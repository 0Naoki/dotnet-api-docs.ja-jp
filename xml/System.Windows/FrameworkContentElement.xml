<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FrameworkContentElement.xml" source-language="en-US" target-language="ja-JP">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac51c90a9ddef163b0e59dd29a8a1fb7b48cd8dbb6c.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1c90a9ddef163b0e59dd29a8a1fb7b48cd8dbb6c</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> is the WPF framework-level implementation and expansion of the <ph id="ph2">&lt;see cref="T:System.Windows.ContentElement" /&gt;</ph> base class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> は、<ph id="ph2">&lt;see cref="T:System.Windows.ContentElement" /&gt;</ph> 基底クラスの WPF フレームワーク レベルの実装および拡張です。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> adds support for additional input APIs (including tooltips and context menus), storyboards, data context for data binding, styles support, and logical tree helper APIs.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> は、補足の入力 API (ツールヒントやコンテキスト メニューなど)、ストーリーボード、データ バインディング用のデータ コンテキスト、スタイルのサポート、および論理ツリーのヘルパー API に関するサポートを追加します。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> does not yet define its own rendering behavior; instantiating an actual <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> class instance in code or markup is possible but displays nothing in a <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> application <ph id="ph4">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 独自のレンダリング動作です。 定義されていません実際のインスタンス化<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>コードまたはマークアップ内のクラス インスタンスは可能ですで何も表示、<ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>アプリケーション<ph id="ph4">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>です。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Rendering logic must be provided by classes that take <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> child elements as part of their content model, or in <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes.</source>
          <target state="translated">受け取るクラスによって提供される必要がありますレンダリング ロジック<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>子要素、または、コンテンツ モデルの一部として<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>クラスを派生します。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> deliberately parallels many of the same <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> as <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> 意図的に同一の多くは対応している<ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph>として<ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Note that certain <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> found on <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> will not have a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> equivalent.</source>
          <target state="translated">特定の注<ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph>で見つかった<ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>必要はありません、<ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>と等価です。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Several of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> are for functionality such as geometry representation or layout, which are not relevant for a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</source>
          <target state="translated">いくつかの<ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph><ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph>は geometry 形式またはレイアウトなどの機能では無関係な<ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>The majority of existing <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes will be found in the <ph id="ph2">&lt;xref:System.Windows.Documents&gt;</ph> namespace.</source>
          <target state="translated">既存のマジョリティ<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>派生クラスが含まれて、<ph id="ph2">&lt;xref:System.Windows.Documents&gt;</ph>名前空間。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Many of these derived classes implement elements for the flow document model.</source>
          <target state="translated">これらの派生クラスの多くは、フロー ドキュメント モデルの要素を実装します。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Certain derived classes such as <ph id="ph1">&lt;xref:System.Windows.Documents.Hyperlink&gt;</ph> have some control-like functionality, but are derived from <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> such that the control-like elements can still participate in the flow document model.</source>
          <target state="translated">などの特定の派生クラス<ph id="ph1">&lt;xref:System.Windows.Documents.Hyperlink&gt;</ph>をいくつかのコントロールのような機能がありますから派生した<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>コントロールのような要素が、フロー ドキュメント モデルに参加できるまだようにします。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> クラスの新しいインスタンスを初期化します。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>The child element to be added.</source>
          <target state="translated">追加される子要素。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>Adds the provided element as a child of this element.</source>
          <target state="translated">指定した要素をこの要素の子として追加します。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>This method can throw an exception if called at a time when the logical tree is being iterated by another process.</source>
          <target state="translated">別のプロセスによって、論理ツリーが反復処理されているときに呼び出された場合、このメソッドは例外をスローできます。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>Most <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes expose dedicated collections that are responsible for containment (for example, <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> on the <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> class; <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> on the <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> class).</source>
          <target state="translated">ほとんど<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>派生クラスの包含を担当する専用のコレクションを公開する (たとえば、<ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph>上、<ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph>クラスです。<ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph>上、<ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph>クラス)。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>You can typically avoid any need to manipulate the logical tree directly if you derive from these classes instead.</source>
          <target state="translated">通常、代わりにこれらのクラスから派生した場合に、論理ツリーを直接操作する必要をしないようにすることができます。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>Working with the logical tree for content elements is an advanced scenario that may require a specialized parser or a specialized <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that acts as the parent rendering element (content host).</source>
          <target state="translated">コンテンツの要素の論理ツリーの操作は必要がある特殊なパーサーや、特殊な高度なシナリオ<ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>親の表示要素 (コンテンツ ホスト) として機能します。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>For more information about how to use <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">使用する方法の詳細についての<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>を参照してください<bpt id="p1">[</bpt>wpf ツリー<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>Called before an element is initialized.</source>
          <target state="translated">要素が初期化される前に呼び出されます。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>Override this method to provide special handling that should occur before your element is initialized during the element loading process.</source>
          <target state="translated">要素の読み込みプロセス中に、要素が初期化される前に発生する特別な処理を提供するには、このメソッドをオーバーライドします。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</source>
          <target state="translated">(既定値) の基本実装では、初期化を追跡するためのいくつかの内部フラグを設定するため、実装には基底の実装を呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>The base implementation will throw an exception if <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.BeginInit" /&gt;</ph> is called more than one time on the same element prior to reaching <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph>.</source>
          <target state="translated">基底の実装は例外をスロー<ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.BeginInit" /&gt;</ph>に到達する前に同じ要素に対して 1 つ以上の時間と呼びます<ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source>Begins the sequence of actions that are contained in the provided storyboard.</source>
          <target state="translated">指定したストーリーボードに含まれるアクションのシーケンスを開始します。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>The storyboard to begin.</source>
          <target state="translated">開始するストーリーボード。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Begins the sequence of actions that are contained in the provided storyboard.</source>
          <target state="translated">指定したストーリーボードに含まれるアクションのシーケンスを開始します。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</source>
          <target state="translated">署名を使用しない、 <ph id="ph1">`isControllable`</ph>、パラメーター、そのパラメーターが指定されている場合または<ph id="ph2">`false`</ph>、「保留」の期間に達するとすぐに、アニメーションに関連付けられているタイムライン クロックは削除されます。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Therefore the animation cannot be restarted after being run once.</source>
          <target state="translated">したがって、アニメーションは、1 回実行されている後に再起動することはできません。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</source>
          <target state="translated">アニメーションを制御するも必要であるストーリー ボードを名前付きまたはコード内のインスタンスとしてアクセスできるようにすることに注意してください。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>The storyboard to begin.</source>
          <target state="translated">開始するストーリーボード。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</source>
          <target state="translated">ストーリーボードに記述されたプロパティが既にアニメーション化されている場合に使用する動作を表す列挙値。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Begins the sequence of actions that are contained in the provided storyboard, with options specified for what should occur if the property is already animated.</source>
          <target state="translated">プロパティが既にアニメーション化されていた場合に行う処理を指定するオプションを使用して、指定したストーリーボードに含まれるアクションのシーケンスを開始します。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</source>
          <target state="translated">署名を使用しない、 <ph id="ph1">`isControllable`</ph>、パラメーター、そのパラメーターが指定されている場合または<ph id="ph2">`false`</ph>、「保留」の期間に達するとすぐに、アニメーションに関連付けられているタイムライン クロックは削除されます。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Therefore the animation cannot be restarted after being run once.</source>
          <target state="translated">したがって、アニメーションは、1 回実行されている後に再起動することはできません。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</source>
          <target state="translated">アニメーションを制御するも必要であるストーリー ボードを名前付きまたはコード内のインスタンスとしてアクセスできるようにすることに注意してください。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Using the Compose HandoffBehavior</source>
          <target state="translated">使用して、HandoffBehavior の作成</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>When you apply a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to a property by using the <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, any <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> objects previously associated with that property continue to consume system resources; the timing system does not remove the clocks automatically.</source>
          <target state="translated">適用すると、 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>、 <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>、または<ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph>を使用してプロパティを<ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>、any<ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph>以前そのプロパティに関連付けられているオブジェクトがシステム リソースを消費引き続き; タイミング システムは、時計を自動的に削除されません。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To avoid performance issues when you apply a large number of clocks by using <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, you should remove composing clocks from the animated property after they complete.</source>
          <target state="translated">使用して多数の時計を適用するときに、パフォーマンスの問題を回避する<ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>、完了した後、アニメーションのプロパティから作成クロックを削除する必要があります。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>There are several ways to remove a clock:</source>
          <target state="translated">クロックを削除するいくつかの方法があります。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To remove all clocks from a property, use the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> method of the animated object.</source>
          <target state="translated">プロパティからすべてのクロックを削除するには、使用、<ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph>または<ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph>アニメーション オブジェクトのメソッドです。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Specify the property being animated as the first parameter, and <ph id="ph1">`null`</ph> as the second.</source>
          <target state="translated">最初のパラメーターとしてアニメーション化されているプロパティを指定し、 <ph id="ph1">`null`</ph> 2 つ目として。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This removes all animation clocks from the property.</source>
          <target state="translated">これにより、すべてのアニメーション クロックが、プロパティから削除します。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To remove a specific <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> from a list of clocks, use the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of the <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to retrieve a <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, then call the <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> method of the <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</source>
          <target state="translated">固有の仕様を削除する<ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph>にクロックのリストを使用して、<ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph>のプロパティ、<ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph>を取得する、<ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>を呼び出す、<ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>のメソッド、<ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This is typically done in the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event handler for a clock.</source>
          <target state="translated">これは、通常、<ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph>クロックのイベント ハンドラー。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Note that only root clocks can be controlled by a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of a child clock returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">唯一のルート クロックできますで制御されることに注意してください、 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>;<ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph>子クロックのプロパティを返します<ph id="ph3">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Note also that the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event is not raised if the effective duration of the clock is forever.</source>
          <target state="translated">なお、<ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph>クロックの有効期間が forever の場合、イベントは発生しません。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>In that case, the user must determine when to call <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</source>
          <target state="translated">その場合は、ユーザーを決定する必要がありますを呼び出すときに<ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This is primarily an issue for animations on objects that have a long lifetime.</source>
          <target state="translated">これは主に、有効期間が長いオブジェクトでのアニメーションの問題です。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>When an object is garbage collected, its clocks are also disconnected and garbage collected.</source>
          <target state="translated">オブジェクトがガベージ コレクションである場合は、そのクロックが切断されても、ガベージ コレクションします。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>For more information about clock objects, see <bpt id="p1">[</bpt>Animation and Timing System Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</source>
          <target state="translated">クロック オブジェクトに関する詳細については、次を参照してください。<bpt id="p1">[</bpt>アニメーションおよびタイミング システムの概要<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>The storyboard to begin.</source>
          <target state="translated">開始するストーリーボード。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>A value of the enumeration that describes behavior to use if a  property described in the storyboard is already animated.</source>
          <target state="translated">ストーリーボードに記述されたプロパティが既にアニメーション化されている場合に使用する、動作を表す列挙型の値。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Declares whether the animation is controllable (can be paused) after it is started.</source>
          <target state="translated">アニメーションを起動した後に、アニメーションを制御できるかどうか (一時停止できるかどうか) を宣言します。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Begins the sequence of actions that are contained in the provided storyboard, with specified state for control of the animation after it is started.</source>
          <target state="translated">開始後のアニメーションの制御の状態を指定して、指定したストーリーボードに含まれるアクションのシーケンスを開始します。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</source>
          <target state="translated">署名を使用しない、 <ph id="ph1">`isControllable`</ph>、パラメーター、そのパラメーターが指定されている場合または<ph id="ph2">`false`</ph>、「保留」の期間に達するとすぐに、アニメーションに関連付けられているタイムライン クロックは削除されます。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Therefore the animation cannot be restarted after being run once.</source>
          <target state="translated">したがって、アニメーションは、1 回実行されている後に再起動することはできません。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</source>
          <target state="translated">アニメーションを制御するも必要であるストーリー ボードを名前付きまたはコード内のインスタンスとしてアクセスできるようにすることに注意してください。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Using the Compose HandoffBehavior</source>
          <target state="translated">使用して、HandoffBehavior の作成</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>When you apply a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to a property by using the <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, any <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> objects previously associated with that property continue to consume system resources; the timing system does not remove these clocks automatically.</source>
          <target state="translated">適用すると、 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>、 <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>、または<ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph>を使用してプロパティを<ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>、any<ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph>以前そのプロパティに関連付けられているオブジェクトがシステム リソースを消費引き続き; タイミング システムがこれらの時計を自動的に削除されません。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To avoid performance issues when you apply a large number of clocks by using <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, you should remove composing clocks from the animated property after they complete.</source>
          <target state="translated">使用して多数の時計を適用するときに、パフォーマンスの問題を回避する<ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>、完了した後、アニメーションのプロパティから作成クロックを削除する必要があります。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>There are several ways to remove a clock:</source>
          <target state="translated">クロックを削除するいくつかの方法があります。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To remove all clocks from a property, use the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> method of the animated object.</source>
          <target state="translated">プロパティからすべてのクロックを削除するには、使用、<ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph>または<ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph>アニメーション オブジェクトのメソッドです。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Specify the property being animated as the first parameter, and <ph id="ph1">`null`</ph> as the second.</source>
          <target state="translated">最初のパラメーターとしてアニメーション化されているプロパティを指定し、 <ph id="ph1">`null`</ph> 2 つ目として。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This removes all animation clocks from the property.</source>
          <target state="translated">これにより、すべてのアニメーション クロックが、プロパティから削除します。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To remove a specific <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> from a list of clocks, use the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of the <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to retrieve a <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, then call the <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> method of the <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</source>
          <target state="translated">固有の仕様を削除する<ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph>にクロックのリストを使用して、<ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph>のプロパティ、<ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph>を取得する、<ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>を呼び出す、<ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>のメソッド、<ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This is typically done in the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event handler for a clock.</source>
          <target state="translated">これは、通常、<ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph>クロックのイベント ハンドラー。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Note that only root clocks can be controlled by a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of a child clock returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">唯一のルート クロックできますで制御されることに注意してください、 <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>;<ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph>子クロックのプロパティを返します<ph id="ph3">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Note also that the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event is not raised if the effective duration of the clock is forever.</source>
          <target state="translated">なお、<ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph>クロックの有効期間が forever の場合、イベントは発生しません。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>In that case, the user must determine when to call <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</source>
          <target state="translated">その場合は、ユーザーを決定する必要がありますを呼び出すときに<ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This is primarily an issue for animations on objects that have a long lifetime.</source>
          <target state="translated">これは主に、有効期間が長いオブジェクトでのアニメーションの問題です。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>When an object is garbage collected, its clocks are also disconnected and garbage collected.</source>
          <target state="translated">オブジェクトがガベージ コレクションである場合は、そのクロックが切断されても、ガベージ コレクションします。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>For more information about clock objects, see <bpt id="p1">[</bpt>Animation and Timing System Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</source>
          <target state="translated">クロック オブジェクトに関する詳細については、次を参照してください。<bpt id="p1">[</bpt>アニメーションおよびタイミング システムの概要<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Gets or sets the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> that is used for the element.</source>
          <target state="translated">要素に使用される <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> を取得または設定します。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> that is used for the element.</source>
          <target state="translated">要素に使用される <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> can be used to validate the values of multiple properties of an object.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph>オブジェクトの複数のプロパティの値を検証するために使用できます。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>For example, suppose that an application prompts the user to enter an address and then populates an object of type <ph id="ph1">`Address`</ph>, which has the properties <ph id="ph2">`Street`</ph>, <ph id="ph3">`City`</ph>, <ph id="ph4">`ZipCode`</ph>, and <ph id="ph5">`Country`</ph>, with the values that the user provided.</source>
          <target state="translated">たとえば、アプリケーションがアドレスを入力するように求めるし、その型のオブジェクトが設定されます<ph id="ph1">`Address`</ph>、プロパティを持つ<ph id="ph2">`Street`</ph>、 <ph id="ph3">`City`</ph>、 <ph id="ph4">`ZipCode`</ph>、および<ph id="ph5">`Country`</ph>ユーザーが指定した値を持つ。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>The application has a panel that contains four <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> controls, each of which is bound to one of the object’s properties.</source>
          <target state="translated">アプリケーションが 4 つを含むパネル<ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph>コントロール、それぞれは、オブジェクトのプロパティのいずれかにバインドします。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>You can use a <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> in a <ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> to validate the <ph id="ph3">`Address`</ph> object.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph>で、<ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph>を検証する、<ph id="ph3">`Address`</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>For example, the <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> can ensure that the zip code is valid for the country of the address.</source>
          <target state="translated">たとえば、<ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph>郵便番号が有効、住所の国であることを確認できます。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Child elements inherit the <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> from their parent elements, just as with any other inheritable property.</source>
          <target state="translated">子要素を継承、<ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph>だけで、他の継承可能なプロパティと同様に、親要素からです。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Dependency Property Information</source>
          <target state="translated">依存プロパティ情報</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Metadata properties set to <bpt id="p1">**</bpt>true<ept id="p1">**</ept></source>
          <target state="translated">メタデータ プロパティに設定<bpt id="p1">**</bpt>は true。<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.BindingGroupProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /&gt;</ph> 依存関係プロパティを識別します。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BringIntoView">
          <source>Attempts to bring this element into view, within any scrollable regions it is contained within.</source>
          <target state="translated">この要素が含まれているスクロール可能な領域内に、この要素を表示することを試みます。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BringIntoView">
          <source>By calling this method, you effectively will call <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A&gt;</ph> on any parent scrollable area that contains the element (the parent may very well be a <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, not a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>).</source>
          <target state="translated">このメソッドを呼び出して、実質的には呼び出す<ph id="ph1">&lt;xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A&gt;</ph>要素を含む親スクロール可能な領域を (親があります明確、<ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>ではなく、 <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BringIntoView">
          <source>If this element is not contained in a scrollable area, the event is still raised, but there will be no effect.</source>
          <target state="translated">スクロール可能領域には、この要素が含まれていない場合、は、イベントは引き続きがなければ効果。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Gets or sets the context menu element that should appear whenever the context menu is requested via <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> from within this element.</source>
          <target state="translated">この要素内から<ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> によってコンテキスト メニューが要求された場合に常に表示されるコンテキスト メニュー要素を取得または設定します。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>The context menu that this element uses.</source>
          <target state="translated">この要素が使用するコンテキスト メニュー。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Dependency Property Information</source>
          <target state="translated">依存プロパティ情報</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">メタデータ プロパティに設定します。 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>None</source>
          <target state="translated">なし</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>The following example places a <ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> on a <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>.</source>
          <target state="translated">次の例の場所、<ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>上、<ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Occurs just before any context menu on the element is closed.</source>
          <target state="translated">要素のコンテキスト メニューが閉じる直前に発生します。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>To suppress closing context menus, handlers of the event should mark it as handled.</source>
          <target state="translated">閉じないようにするには、コンテキスト メニュー、イベントのハンドラーは、処理済みとしてマークします。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>To use this event as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style, you must reference the underlying service event identifier:</source>
          <target state="translated">このイベントを使用する、<ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph>スタイルでは、基になるサービスのイベントの識別子を参照する必要があります。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>(This usage is required because the event implementation on <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> that exposes the underlying service event does not correctly map the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuClosing&gt;</ph> identifier for use in triggers).</source>
          <target state="translated">(ために、この使用法が必要でイベントの実装<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>こと公開サービス イベントの基になる正しくマップされない、<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuClosing&gt;</ph>トリガーで使用するための識別子)。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Routed Event Information</source>
          <target state="translated">ルーティングされたイベント情報</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Routing strategy</source>
          <target state="translated">ルーティング方法</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Bubbling</source>
          <target state="translated">バブル</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Delegate</source>
          <target state="translated">Delegate</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>The following example implements a handler that changes the cursor over a named region <ph id="ph1">`DisplayArea`</ph> (not shown).</source>
          <target state="translated">次の例は、名前付き領域にカーソルを変更するハンドラーを実装<ph id="ph1">`DisplayArea`</ph>(表示されません)。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>The comment hints at a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> usage, but in fact this sample would be identical if <ph id="ph2">`DisplayArea`</ph> were a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</source>
          <target state="translated">コメントのヒントに、<ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>使用状況、実際にこのサンプルは同じですが、場合<ph id="ph2">`DisplayArea`</ph>された、<ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> (<bpt id="p1">[</bpt>Routed Events Overview (ルーティング イベントの概要)<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>) を識別します。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">ルーティング イベントが登録されているときに、イベントの識別子のオブジェクトは作成されます (を参照してください<ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) クラス ハンドラーを追加するために使用する (を参照してください<ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">識別子のオブジェクトには、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれています。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Occurs when any context menu on the element is opened.</source>
          <target state="translated">要素のコンテキスト メニューが開くときに発生します。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>To manually open context menus, handlers of the events should mark the relevant event as handled.</source>
          <target state="translated">コンテキスト メニューを手動で開く、処理済みとして、イベントのハンドラーは、関連するイベントをマークする必要があります。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Otherwise, the existing value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> property will be used to automatically open a context menu.</source>
          <target state="translated">それ以外の場合の既存の値、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph>プロパティが自動的にコンテキスト メニューを開き、使用されます。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> property and then open the new <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</source>
          <target state="translated">既定のアクションを効果的に取り消し処理イベントをマークすることとの値にリセットすることにより、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph>プロパティを開き、新しい<ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>However, there is a timing issue you should be aware of.</source>
          <target state="translated">ただしはタイミングの問題を認識する必要があります。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>In order to completely replace the context menu through a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> handler, the initial context menu must not be null / empty.</source>
          <target state="translated">コンテキスト メニューを完全に置き換えるために、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph>ハンドラー、初期のコンテキスト メニューにはできません null/空です。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Alternatively, you might need to handle the event and then manually open a new context menu.</source>
          <target state="translated">また、イベントを処理し、新しいコンテキスト メニューを手動で開く必要があります。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>For details, see <bpt id="p1">[</bpt>How to: Handle the ContextMenuOpening Event<ept id="p1">](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)</ept>.</source>
          <target state="translated">詳細については、「<bpt id="p1">[</bpt>する方法: ContextMenuOpening イベントを処理<ept id="p1">](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>To use this event as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style, you must reference the underlying service event identifier:</source>
          <target state="translated">このイベントを使用する、<ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph>スタイルでは、基になるサービスのイベントの識別子を参照する必要があります。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>(This usage is required because the event implementation on <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> that exposes the underlying service event does not correctly map the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> identifier for use in triggers).</source>
          <target state="translated">(ために、この使用法が必要でイベントの実装<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>こと公開サービス イベントの基になる正しくマップされない、<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph>トリガーで使用するための識別子)。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Routed Event Information</source>
          <target state="translated">ルーティングされたイベント情報</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Routing strategy</source>
          <target state="translated">ルーティング方法</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Bubbling</source>
          <target state="translated">バブル</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Delegate</source>
          <target state="translated">Delegate</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> (<bpt id="p1">[</bpt>Routed Events Overview (ルーティング イベントの概要)<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>) を識別します。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">ルーティング イベントが登録されているときに、イベントの識別子のオブジェクトは作成されます (を参照してください<ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) クラス ハンドラーを追加するために使用する (を参照してください<ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">識別子のオブジェクトには、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれています。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ContextMenuProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /&gt;</ph> 依存関係プロパティを識別します。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Gets or sets the cursor that displays when the mouse pointer is over this element.</source>
          <target state="translated">この要素上にマウス ポインターが置かれたときに表示されるカーソルを取得または設定します。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The cursor to display.</source>
          <target state="translated">表示対象のカーソル。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The default value is defined as <ph id="ph1">&lt;see langword="null" /&gt;</ph> per this dependency property.</source>
          <target state="translated">この依存関係プロパティによって、既定値が <ph id="ph1">&lt;see langword="null" /&gt;</ph> として定義されます。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>However, the practical default at run time will come from a variety of factors.</source>
          <target state="translated">ただし、実行時における実用的な既定値は、さまざまな要因から取得されます。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>When setting this property in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, the <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> processor relies on type conversion for the <ph id="ph3">&lt;xref:System.Windows.Input.Cursor&gt;</ph> class to evaluate the string.</source>
          <target state="translated">このプロパティを設定すると<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>、<ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>プロセッサがの型の変換に依存しています、<ph id="ph3">&lt;xref:System.Windows.Input.Cursor&gt;</ph>クラス文字列を評価します。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The provided string should evaluate to a <ph id="ph1">&lt;xref:System.Windows.Input.CursorType&gt;</ph> value.</source>
          <target state="translated">指定された文字列に評価される必要があります、<ph id="ph1">&lt;xref:System.Windows.Input.CursorType&gt;</ph>値。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> for details.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Whether the cursor as established by this property will or will not display when the mouse pointer is over this element is also dependent on the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> property.</source>
          <target state="translated">このプロパティによって設定されるカーソルは、マウス ポインターがこの要素上に表示されないかどうかの値に依存しても、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Also, event-related considerations such as an active drag, mouse capture, text editing modes within controls, and so on, will also affect the cursor with higher priority than the value you specify in this property.</source>
          <target state="translated">また、アクティブなドラッグ、マウスのキャプチャ、テキスト コントロール、および、内のモードの編集など、イベント関連の考慮事項も影響を与えますカーソル、このプロパティで指定した値よりも優先順位の高い。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>To revert the behavior of setting this property to the eventual default, set it to <ph id="ph1">`null`</ph> again.</source>
          <target state="translated">最終的な既定値にこのプロパティの設定の動作を戻すには、設定<ph id="ph1">`null`</ph>もう一度です。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The <ph id="ph1">`null`</ph> default really means that determination of the practical cursor value is deferred here and should be obtained from elsewhere.</source>
          <target state="translated"><ph id="ph1">`null`</ph>既定を意味実際的なカーソルの値の決定がここでは遅延し、別の場所から入手してください。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>If presented with no programmatic values from any source, the default cursor over a <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> application will be an arrow.</source>
          <target state="translated">経由でプログラムによる値のない既定のカーソルの任意のソースから提示された場合、<ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph>アプリケーションは矢印になります。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Each movement of the mouse over a <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> application raises a <ph id="ph2">&lt;xref:System.Windows.ContentElement.QueryCursor&gt;</ph> event.</source>
          <target state="translated">上にあるマウスが移動するたび、<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>アプリケーションが発生し、<ph id="ph2">&lt;xref:System.Windows.ContentElement.QueryCursor&gt;</ph>イベント。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The event bubbles, and any element along the route has the opportunity to handle the event and to set the value of the cursor via the arguments of this event.</source>
          <target state="translated">イベント バブルと経路上の任意の要素、イベントを処理し、このイベントの引数を使用して、カーソルの値を設定する機会があります。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>If that happens, the fact that the event is handled and has a changed value in the arguments takes precedence over the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Cursor%2A&gt;</ph> property at any level, unless <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> is set.</source>
          <target state="translated">その場合は、イベントが処理され、引数に変更された値を持つファクトよりも優先の値、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Cursor%2A&gt;</ph>任意のレベルでは、プロパティしない限り、<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph>設定されています。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>If not creating a custom cursor, typically you set this property to a static property value of the <ph id="ph1">&lt;xref:System.Windows.Input.Cursors&gt;</ph> class.</source>
          <target state="translated">場合は、カスタムのカーソルを作成しないこと、通常このプロパティを設定するの静的プロパティの値、<ph id="ph1">&lt;xref:System.Windows.Input.Cursors&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Setting the <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> to a custom value is not enabled in partial trust.</source>
          <target state="translated">設定、<ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph>にカスタム値が有効でない部分的に信頼します。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>For more information on custom cursors, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">カスタム カーソルの詳細については、次を参照してください。<bpt id="p1">[</bpt>入力概要<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Dependency Property Information</source>
          <target state="translated">依存プロパティ情報</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">メタデータ プロパティに設定します。 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>None</source>
          <target state="translated">なし</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The following example sets the cursor to a custom value.</source>
          <target state="translated">次の例では、カスタム値をカーソルを設定します。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.CursorProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph> 依存関係プロパティを識別します。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Gets or sets the data context for an element when it participates in data binding.</source>
          <target state="translated">要素がデータ バインディングに含まれている場合に、その要素のデータ コンテキストを取得または設定します。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>The object to use as data context.</source>
          <target state="translated">データ コンテキストとして使用するオブジェクト。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>Data context<ept id="p1">*</ept> is a concept that allows elements to inherit information from their parent elements about the binding source that is used for binding, as well as other characteristics of the binding such as the path.</source>
          <target state="translated"><bpt id="p1">*</bpt>データ コンテキスト<ept id="p1">*</ept>概念により、バインディング、だけでなく、バインド パスなどの他の特性のために使用されるバインド ソースは、親要素から情報を継承する要素です。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Data context can be set directly to a <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> object, with the bindings evaluating to properties of that object.</source>
          <target state="translated">直接データ コンテキストを設定することができます、<ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph>オブジェクト、そのオブジェクトのプロパティを評価する、バインディングを使用します。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Alternatively, you can set the data context to a <ph id="ph1">&lt;xref:System.Windows.Data.DataSourceProvider&gt;</ph> object.</source>
          <target state="translated">または、データ コンテキストを設定、<ph id="ph1">&lt;xref:System.Windows.Data.DataSourceProvider&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>This dependency property inherits property values.</source>
          <target state="translated">この依存関係プロパティでは、プロパティの値を継承します。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>If there are child elements with no other value for <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> established through local values or styles, the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> value of the nearest parent element with this value assigned.</source>
          <target state="translated">その他の値を持たない子要素があるかどうかは<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>ローカル値またはスタイルを介して確立されると、プロパティのシステム値が設定されますを<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>割り当てられているこの値を持つ最も近い親要素の値。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Alternatively, you can use one of the following properties of the <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> class to specify the binding source explicitly: <ph id="ph2">&lt;xref:System.Windows.Data.Binding.ElementName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.Binding.Source%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Windows.Data.Binding.RelativeSource%2A&gt;</ph>.</source>
          <target state="translated">次のプロパティのいずれかを使用する代わりに、<ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph>クラスをバインディング ソースを明示的に指定する: <ph id="ph2">&lt;xref:System.Windows.Data.Binding.ElementName%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Windows.Data.Binding.Source%2A&gt;</ph>、または<ph id="ph4">&lt;xref:System.Windows.Data.Binding.RelativeSource%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Specify the Binding Source<ept id="p1">](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。<bpt id="p1">[</bpt>する方法: バインド ソースを指定して<ept id="p1">](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> is most commonly set to as a <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> declaration.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>、<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>として最も一般的に設定されて、<ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph>宣言します。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>You can use either property element syntax or attribute syntax.</source>
          <target state="translated">プロパティ要素構文または属性の構文のいずれかを使用することができます。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Attribute syntax is shown in the example on this page.</source>
          <target state="translated">属性構文は、このページの例に示しています。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>You can also set <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> in code.</source>
          <target state="translated">設定することも<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>のコードにします。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>XAML Property Element Usage</source>
          <target state="translated">XAML プロパティ要素の使用</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>XAML Attribute Usage</source>
          <target state="translated">XAML 属性の使用方法</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>XAML Values</source>
          <target state="translated">XAML 値</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>dataContextObject<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>dataContextObject<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>A directly embedded object that serves as data context for any bindings within the parent element.</source>
          <target state="translated">親要素内のすべてのバインディングのデータ コンテキストとして機能する直接埋め込まれたオブジェクト。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Typically, this object is a <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> or another <ph id="ph2">&lt;xref:System.Windows.Data.BindingBase&gt;</ph> subclass.</source>
          <target state="translated">通常、このオブジェクトは、<ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph>別または<ph id="ph2">&lt;xref:System.Windows.Data.BindingBase&gt;</ph>サブクラスです。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Alternatively, raw data of any <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> object type intended for binding may be placed here, with the actual bindings defined later.</source>
          <target state="translated">または、いずれかの生データ<ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph>オブジェクトの種類のバインディングは、後で定義されている実際のバインディングをここでは、配置することも対象としています。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>bindingUsage<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>bindingUsage<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>A binding usage that evaluates to an appropriate data context.</source>
          <target state="translated">適切なデータ コンテキストに評価されるバインディングの使用方法です。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>For details, see <bpt id="p1">[</bpt>Binding Markup Extension<ept id="p1">](~/docs/framework/wpf/advanced/binding-markup-extension.md)</ept>.</source>
          <target state="translated">詳細については、「<bpt id="p1">[</bpt>バインディングのマークアップ拡張機能<ept id="p1">](~/docs/framework/wpf/advanced/binding-markup-extension.md)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>One of the following: <ph id="ph1">`StaticResource`</ph>, or <ph id="ph2">`DynamicResource`</ph>.</source>
          <target state="translated">次のいずれかの: <ph id="ph1">`StaticResource`</ph>、または<ph id="ph2">`DynamicResource`</ph>です。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>This usage is used when referring to raw data defined as an object in resources.</source>
          <target state="translated">この使用法は、リソース内のオブジェクトとして定義されている、生データを参照するときに使用されます。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">参照してください<bpt id="p1">[</bpt>XAML リソース<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>contextResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>contextResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>The key identifier for the object being requested from within a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">内から要求されたオブジェクトのキー識別子、<ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Dependency Property Information</source>
          <target state="translated">依存プロパティ情報</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">メタデータ プロパティに設定します。 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>The following example sets a binding on a <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> element, by creating a new custom data object, establishing that object as <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>, and setting the binding path to a property within it.</source>
          <target state="translated">次の例は、上のバインディングを設定、<ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>としては、そのオブジェクトを確立する、新しいカスタム データ オブジェクトを作成することで、要素<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>、およびその中のプロパティをバインド パスを設定します。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>Occurs when this element's data context changes.</source>
          <target state="translated">この要素のデータ コンテキストが変更されたときに発生します。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>For an explanation of data contexts and data binding, see <bpt id="p1">[</bpt>Data Binding Overview<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>.</source>
          <target state="translated">データ コンテキストおよびデータ バインディングの詳細については、次を参照してください。<bpt id="p1">[</bpt>データ バインディングの概要<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>When an element's <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> changes, all data-bound properties on this element are potentially affected.</source>
          <target state="translated">要素のときに<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>この要素上のすべてのデータ バインドされたプロパティの変更が影響を受ける可能性があります。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>This applies to any elements that are descendant elements of the current element, which inherit the data context, and also the current element itself.</source>
          <target state="translated">これは、データ コンテキストを継承するには、現在の要素の子孫の要素である任意の要素も、現在の要素自体に適用されます。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>All such bindings re-interpret the new <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> to reflect the new value in bindings.</source>
          <target state="translated">このようなすべてのバインドを再解釈新しい<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>のバインディングで新しい値を反映するようにします。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>There is no guarantee made about the order of these changes relative to the raising of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContextChanged&gt;</ph> event.</source>
          <target state="translated">これらの変更の発生に対して相対的順序に関する保証はありません、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContextChanged&gt;</ph>イベント。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>The changes can occur before the event, after the event, or in any mixture.</source>
          <target state="translated">イベントの後、または任意の組み合わせで、変更は、イベントの前に発生します。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.DataContextProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DataContext" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DataContext" /&gt;</ph> 依存関係プロパティを識別します。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Gets or sets the key to use to find the style template for this control in themes.</source>
          <target state="translated">このコントロールのスタイル テンプレートをテーマ内で検索するために使用するキーを取得または設定します。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>The style key.</source>
          <target state="translated">スタイルのキー。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>To work correctly as part of theme style lookup, this value is expected to be the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the element being styled.</source>
          <target state="translated">スタイルを設定する要素の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> になっていないと、テーマ スタイルの参照の一部として正しく機能しません。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> is an accepted value for a certain case.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> 特定のケースの許容される値です。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>This property is typically not set through any of its direct setters.</source>
          <target state="translated">このプロパティは、通常は、直接の setter のを通じて設定されません。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Instead, you override the type-specific metadata of this dependency property every time you create a new subclass.</source>
          <target state="translated">代わりに、新しいサブクラスを作成するたびに、この依存関係プロパティの型に固有のメタデータをオーバーライドします。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>When you subclass, call the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> method against the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty&gt;</ph> identifier, within the static constructor of the control subclass.</source>
          <target state="translated">ときにサブクラス化する、呼び出し、<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>メソッドに対して、<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty&gt;</ph>コントロールのサブクラスの静的コンス トラクター内の識別子。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>For instance, an inline class such as <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> actually has very little implementation beyond overriding the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> metadata in its static constructor, and exposing several instance constructors.</source>
          <target state="translated">など、インライン クラスのインスタンス、<ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph>実際には、ほとんどの実装をオーバーライドする以外、<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph>で静的コンス トラクターといくつかのインスタンス コンス トラクターを公開するメタデータ。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>The fact that elements surrounded by the <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> tag gain a <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement.FontWeight%2A&gt;</ph> property of <ph id="ph3">&lt;xref:System.Windows.FontWeights.Bold%2A&gt;</ph> is implemented within the theme style that was referenced by setting the default value of <ph id="ph4">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> to <ph id="ph5">`typeof(Bold)`</ph>.</source>
          <target state="translated">囲まれている要素のファクト、<ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph>ゲインをタグ付け、<ph id="ph2">&lt;xref:System.Windows.Documents.TextElement.FontWeight%2A&gt;</ph>プロパティの<ph id="ph3">&lt;xref:System.Windows.FontWeights.Bold%2A&gt;</ph>の既定値の設定によって参照されているテーマ スタイル内で実装された<ph id="ph4">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph>に<ph id="ph5">`typeof(Bold)`</ph>です。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>If you want your element or control to deliberately not use theme styles, set the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">要素またはコントロールは意図的にテーマのスタイルを使用する場合は、設定、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A&gt;</ph>プロパティを<ph id="ph2">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Dependency Property Information</source>
          <target state="translated">依存プロパティ情報</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">メタデータ プロパティに設定します。 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /&gt;</ph> 依存関係プロパティを識別します。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Called immediately after an element is initialized.</source>
          <target state="translated">要素が初期化された直後に呼び出されます。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Implement this method to provide special handling that should occur when your element is initialized during the element loading process.</source>
          <target state="translated">要素の読み込みプロセス中に、要素が初期化されたときに発生する特別な処理を提供するには、このメソッドを実装します。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</source>
          <target state="translated">(既定値) の基本実装では、初期化を追跡するためのいくつかの内部フラグを設定するため、実装には基底の実装を呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>If <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> was previously called, the base implementation will raise the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Initialized&gt;</ph> event.</source>
          <target state="translated">場合<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph>が既に呼び出されて、基本実装を発生させる、<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Initialized&gt;</ph>イベント。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Otherwise, if <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> was not called or it could not be determined whether <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> was called, the event is not raised.</source>
          <target state="translated">それ以外の場合<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph>も呼び出されなかったかではない可能性があるかどうかを特定<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph>が呼び出されると、イベントは発生しません。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>Name of the element to search for.</source>
          <target state="translated">検索対象の要素の名前。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>Finds an element that has the provided identifier name.</source>
          <target state="translated">指定した識別名を持つ要素を検索します。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>The requested element.</source>
          <target state="translated">要求された要素。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>May be <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no matching element was found.</source>
          <target state="translated">一致する要素が見つからなかった場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph> になります。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>If this element has child elements, these child elements are all searched recursively for the requested named element.</source>
          <target state="translated">この要素に子要素がある場合は、要求された名前を持つ要素を再帰的には、すべて検索は、これらの子要素です。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>The following example sets a property on an element found by name within a referenced <ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> on a page.</source>
          <target state="translated">次の例では、参照内で名前によって検出された要素のプロパティを設定<ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph>ページにします。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>Key identifier of the resource to be found.</source>
          <target state="translated">検索するリソースのキー識別子。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>Searches for a resource with the specified key, and will throw an exception if the requested resource is not found.</source>
          <target state="translated">指定されたキーを使用してリソースを検索し、要求されたリソースが見つからない場合は例外をスローします。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>The found resource, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no matching resource was found (but will also throw an exception if <ph id="ph2">&lt;see langword="null" /&gt;</ph>).</source>
          <target state="translated">見つかったリソース。一致するリソースが見つからなかった場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph> (ただし、<ph id="ph2">&lt;see langword="null" /&gt;</ph> の場合は例外もスローされます)。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>If you call this method for a key that cannot be found, an exception is thrown.</source>
          <target state="translated">見つからないキーのこのメソッドを呼び出すと、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>If you do not want to handle exceptions for this case, you should instead call <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph>.</source>
          <target state="translated">この場合の例外を処理しない場合は、呼び出す必要は代わりに<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph> returns <ph id="ph2">`null`</ph> when no resource is found, and does not throw an exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph> 返します<ph id="ph2">`null`</ph>と該当するリソースが検出され、例外をスローしません。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a resource were requested by key at run-time.</source>
          <target state="translated">呼び出し元の要素で、リソースが見つからない場合は、論理ツリーを使用して、親のツリーを検索、ツリーになる同じ方法で検索すると、リソースが実行時に、キーにより要求されました。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</source>
          <target state="translated">通常返されたリソース値に設定しようとしているプロパティの型を戻り値をキャストするとすぐにします。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</source>
          <target state="translated">次の例では、マークアップで定義されているリソースを検索し、ルーティングされたイベントに応答内の要素の特定のプロパティに適用されます。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>The requested resource key was not found.</source>
          <target state="translated">要求されたリソース キーは見つかりませんでした。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source><ph id="ph1">&lt;paramref name="resourceKey" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceKey" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Gets or sets an object that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.</source>
          <target state="translated">この要素がキーボード フォーカスを受け取ったときに適用される外観、効果、またはその他のスタイル特性のカスタマイズを可能にするオブジェクトを取得または設定します。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The desired style to apply on focus.</source>
          <target state="translated">フォーカスに適用する目的のスタイル。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The default value as declared in the dependency property is an empty static <ph id="ph1">&lt;see cref="T:System.Windows.Style" /&gt;</ph>.</source>
          <target state="translated">依存関係プロパティ内で宣言された既定値は空の静的 <ph id="ph1">&lt;see cref="T:System.Windows.Style" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>However, the effective value at run time is often (but not always) a style as supplied by theme support for controls.</source>
          <target state="translated">ただし、実行時の有効値は、多くの場合、コントロールのテーマ サポートによって提供されたスタイルです (ただし、常にそうであるとは限りません)。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>When setting this property in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, styles are almost always defined as a resource, rather than inline as an element, and that resource is usually referenced as a <ph id="ph2">&lt;xref:System.Windows.StaticResourceExtension&gt;</ph>.</source>
          <target state="translated">このプロパティを設定すると<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>スタイルは要素としてインラインではなく、リソースとして定義ほとんどの場合、およびとして参照されているリソースは、通常、<ph id="ph2">&lt;xref:System.Windows.StaticResourceExtension&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Note that this property affects visual appearance but does not report so in metadata.</source>
          <target state="translated">このプロパティは外観に影響がメタデータにように報告されないことに注意してください。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>This is because the visual appearance change is event-driven and may not apply at all times, and thus should not generally report any visual or layout information in metadata.</source>
          <target state="translated">これは、視覚的な外観の変更イベント ドリブンなすべての時刻に適用されるおよびしたがっては限らないメタデータに、visual またはレイアウトの情報です。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Conceptually, the visual behavior of focus applied to a control should be coherent from element to element.</source>
          <target state="translated">概念的には、コントロールに適用されたフォーカスの視覚的な動作は、要素間で一貫している必要があります。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The most sensible way to enforce coherence is to only change the focus visual style if you are composing an entire theme.</source>
          <target state="translated">一貫性を実現するための最もわかりやすい方法では、全体のテーマを作成している場合にのみフォーカス visual スタイルを変更します。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Setting this property on individual styles and not as part of a theme is not the intended usage of this property, because it may lead to a confusing user experience regarding keyboard focus.</source>
          <target state="translated">個々 のスタイルとテーマの一部ではなくこのプロパティを設定キーボード フォーカスに関するユーザー エクスペリエンスに混乱をこれは、このプロパティの使用目的はありません。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>If you are intending element-specific behavior that is deliberately not coherent across a theme, a much better approach is to use triggers in styles for individual input state properties, such as <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph>, and to do so in a way that does not visually interfere with any existing focus visual style.</source>
          <target state="translated">要素に固有の動作は意図的に一貫したテーマにする場合は、はるかに優れた方法を使用してトリガーのスタイルでの個々 の入力状態プロパティなど<ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph>が既存のフォーカス visual スタイルに視覚的に干渉しないようにするためです。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>For more information on the design intention of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A&gt;</ph> and alternative focus properties, see <bpt id="p1">[</bpt>Styling for Focus in Controls, and FocusVisualStyle<ept id="p1">](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)</ept>.</source>
          <target state="translated">目的で設計の詳細については<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A&gt;</ph>と代替プロパティの焦点は、「<bpt id="p1">[</bpt>コントロール、および FocusVisualStyle でフォーカスのスタイルは<ept id="p1">](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)</ept>します。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>XAML Attribute Usage</source>
          <target state="translated">XAML 属性の使用方法</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>XAML Property Element Usage</source>
          <target state="translated">XAML プロパティ要素の使用</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>XAML Values</source>
          <target state="translated">XAML 値</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>One of the following: , or .</source>
          <target state="translated">次のいずれかの: または。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">参照してください<bpt id="p1">[</bpt>XAML リソース<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The key that identifies the style being requested.</source>
          <target state="translated">要求されているスタイルを識別するキー。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The key refers to an existing resource in a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">このキーは既存のリソースを<ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Property element syntax is technically possible, but not recommended.</source>
          <target state="translated">プロパティ要素構文は、技術的に可能ですが、推奨されません。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>See <bpt id="p1">[</bpt>Inline Styles and Templates<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</source>
          <target state="translated">参照してください<bpt id="p1">[</bpt>インライン スタイルとテンプレート<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>A binding reference using  or <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> is also possible, but uncommon.</source>
          <target state="translated">バインドの参照を使用して、または<ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph>も可能ですが、一般的ではないです。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Dependency Property Information</source>
          <target state="translated">依存プロパティ情報</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">メタデータ プロパティに設定します。 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>None</source>
          <target state="translated">なし</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /&gt;</ph> 依存関係プロパティを識別します。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Gets or sets a value indicating whether this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> should force the <ph id="ph2">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> to render the cursor as declared by this instance's <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph> property.</source>
          <target state="translated">このインスタンスの <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> プロパティの宣言に従って<ph id="ph2">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> がカーソルを描画するように、この <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph> で強制するかどうかを示す値を取得または設定します。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to force cursor presentation while over this element to use this instance's setting for the cursor (including on all child elements); otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">この要素の上にあるときのカーソルの表示に、このインスタンスのカーソル設定を強制的に使用する場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph> (すべての子要素も対象となります)。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>The default value is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">既定値は <ph id="ph1">&lt;see langword="false" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Setting this property to <ph id="ph1">`true`</ph> will override the cursor preferences established by child elements.</source>
          <target state="translated">このプロパティを設定<ph id="ph1">`true`</ph>子要素で設定されているカーソルの設定が上書きされます。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Doing so in general application <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> might be confusing for the user, particularly if child elements are attempting to specify cursors.</source>
          <target state="translated">そのため、一般にアプリケーション<ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>子要素は、カーソルを指定しようとしている場合は特に、ユーザーの混乱する可能性があります。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Setting <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ForceCursor%2A&gt;</ph> is more appropriate in control subclassing or compositing scenarios.</source>
          <target state="translated">設定<ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ForceCursor%2A&gt;</ph>の方がコントロールのサブクラス化または複合のシナリオに適しています。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Dependency Property Information</source>
          <target state="translated">依存プロパティ情報</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">メタデータ プロパティに設定します。 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>None</source>
          <target state="translated">なし</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>The following example forces the cursor while over the element.</source>
          <target state="translated">次の例は、要素上でカーソルを強制します。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ForceCursorProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /&gt;</ph> 依存関係プロパティを識別します。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>The target <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> from which to get the binding.</source>
          <target state="translated">バインディングの取得元のターゲット <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> for the specified property's binding.</source>
          <target state="translated">指定したプロパティのバインディングに関する <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> を取得します。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> if the target is data bound; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">ターゲットがデータ バインドされている場合は <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> を返します。それ以外の場合は <ph id="ph2">&lt;see langword="null" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>The following example retrieves a binding by querying a property.</source>
          <target state="translated">次の例では、プロパティを照会して、バインディングを取得します。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>Returns an alternative logical parent for this element if there is no visual parent.</source>
          <target state="translated">ビジュアル親が存在しない場合に、この要素に対する代替の論理上の親を返します。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>In this case, a <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> parent is always the same value as the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Parent" /&gt;</ph> property.</source>
          <target state="translated">この場合、<ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> の親の値は常に <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Parent" /&gt;</ph> プロパティの値と同じになります。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>Returns something other than <ph id="ph1">&lt;see langword="null" /&gt;</ph> whenever a WPF framework-level implementation of this method has a non-visual parent connection.</source>
          <target state="translated">このメソッドの WPF フレームワーク レベルの実装が非ビジュアルの親接続を持つ場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph> 以外の値を返します。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>The default implementation returns the expected single visual parent.</source>
          <target state="translated">既定の実装では、予想される 1 つのビジュアル親を返します。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>Custom implementations might return alternate parent relationships.</source>
          <target state="translated">カスタム実装は、別の親リレーションシップを返す場合があります。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>Occurs when this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> is initialized.</source>
          <target state="translated">この <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> が初期化されるときに発生します。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>This coincides with cases where the value of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> property changes from <ph id="ph2">&lt;see langword="false" /&gt;</ph> (or undefined) to <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">これと同時に、<ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> プロパティの値が <ph id="ph2">&lt;see langword="false" /&gt;</ph> (未定義) から <ph id="ph3">&lt;see langword="true" /&gt;</ph> に変更されます。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>This event will be raised whenever the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.EndInit%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.OnInitialized%2A&gt;</ph> methods are called.</source>
          <target state="translated">このイベントになります発生するたびに、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.EndInit%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.OnInitialized%2A&gt;</ph>メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>Calls to these methods could have been made by deliberate code, or by the <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> loading process.</source>
          <target state="translated">これらのメソッドへの呼び出しが行われた意図的なコード、または、<ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>読み込みプロセスです。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Gets or sets the context for input used by this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</source>
          <target state="translated">この <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> によって使用される入力のコンテキストを取得または設定します。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>The input scope, which modifies how input from alternative input methods is interpreted.</source>
          <target state="translated">代替の入力メソッドからの入力を解釈する方法を変更する入力スコープ。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>The default value is <ph id="ph1">&lt;see langword="null" /&gt;</ph> (which results in a default handling of commands).</source>
          <target state="translated">既定値は <ph id="ph1">&lt;see langword="null" /&gt;</ph> です (既定のコマンド処理を行います)。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>This dependency property inherits property values.</source>
          <target state="translated">この依存関係プロパティでは、プロパティの値を継承します。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>If there are child elements with no other value for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> established through local values or styles, the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> value of the nearest parent element with this value assigned.</source>
          <target state="translated">その他の値を持たない子要素があるかどうかは<ph id="ph1">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph>ローカル値またはスタイルを介して確立されると、プロパティのシステム値が設定されますを<ph id="ph2">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph>割り当てられているこの値を持つ最も近い親要素の値。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Although a <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax usage is listed and is syntactically allowed, setting this property in <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> is not common.</source>
          <target state="translated">ただし、<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>構文の使用状況が表示されているし、は構文的に許可されているのこのプロパティを設定<ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>一般的ではありません。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Dependency Property Information</source>
          <target state="translated">依存プロパティ情報</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">メタデータ プロパティに設定します。 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.InputScopeProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.InputScope" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.InputScope" /&gt;</ph> 依存関係プロパティを識別します。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.IsInitialized">
          <source>Gets a value indicating whether this element has been initialized, either by being loaded as <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>, or by explicitly having its <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph> method called.</source>
          <target state="translated">この要素が初期化されているかどうかを示す値を取得します。要素の初期化は、<ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> として読み込むことによって行われる場合と、<ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph> メソッドを明示的に呼び出すことによって行われる場合があります。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsInitialized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the element is initialized per the aforementioned loading or method calls; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">上で挙げた読み込みまたはメソッド呼び出しを通じて要素が初期化される場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsInitialized">
          <source>This property may also be <ph id="ph1">`true`</ph> if this element has been moved within the element tree such that it has a new parent element, and therefore becomes reloaded again.</source>
          <target state="translated">このプロパティがありますも<ph id="ph1">`true`</ph>新しい親要素を持つし、そのために再読み込みされたことになるように、この要素が、要素ツリー内で移動されたかどうか。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>Gets a value indicating whether this element has been loaded for presentation.</source>
          <target state="translated">この要素が表示のために読み込まれているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current element is attached to an element tree and has been rendered; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the element has never been attached to a loaded element tree.</source>
          <target state="translated">現在の要素が要素ツリーにアタッチされ、描画されている場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。読み込まれた要素ツリーに要素がアタッチされていない場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>From a newly constructed instance, this property starts off <ph id="ph1">`false`</ph>, and remains <ph id="ph2">`true`</ph> once it is set to <ph id="ph3">`true`</ph>, even if subsequently removed by  code.</source>
          <target state="translated">新しく構築されたインスタンスからこのプロパティは、まず<ph id="ph1">`false`</ph>、開いたまま<ph id="ph2">`true`</ph>に設定されていると<ph id="ph3">`true`</ph>コードによって、後で削除された場合でも、します。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>The following example code uses <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsLoaded%2A&gt;</ph> as a conditional check to assure that a function <ph id="ph2">`displayData`</ph> (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler.</source>
          <target state="translated">次のコード例を使用して<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsLoaded%2A&gt;</ph>関数を確保するための条件の確認として<ph id="ph2">`displayData`</ph>(非表示) が有効な要素読み込んだページのオンデマンドでハンドラーの一部として、に対して機能します。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>That same logic is run as an event handler for <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph>.</source>
          <target state="translated">イベント ハンドラーとして同じロジックが実行される<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Gets or sets localization/globalization language information that applies to an individual element.</source>
          <target state="translated">個々の要素に適用されるローカリゼーション/グローバリゼーション言語情報を取得または設定します。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>The culture information for this element.</source>
          <target state="translated">この要素のカルチャ情報。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>The default value is an <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XmlLanguage" /&gt;</ph> instance with its <ph id="ph2">&lt;see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /&gt;</ph> value set to the string "en-US".</source>
          <target state="translated">既定値は、<ph id="ph1">&lt;see cref="T:System.Windows.Markup.XmlLanguage" /&gt;</ph> の値が文字列 "en-US" に設定された <ph id="ph2">&lt;see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /&gt;</ph> インスタンスです。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>The string formats follow the RFC 3066 standard.</source>
          <target state="translated">文字列の形式では、RFC 3066 標準に従います。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>For example, U.S. English is "en-US".</source>
          <target state="translated">たとえば、米国"EN-US"は英語です。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Markup.XmlLanguage&gt;</ph> for more information on the values and format.</source>
          <target state="translated">参照してください<ph id="ph1">&lt;xref:System.Windows.Markup.XmlLanguage&gt;</ph>詳細については、値と形式です。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>This dependency property inherits property values.</source>
          <target state="translated">この依存関係プロパティでは、プロパティの値を継承します。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>If there are child elements with no other value for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> established through local values or styles, the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> value of the nearest parent element with this value assigned.</source>
          <target state="translated">その他の値を持たない子要素があるかどうかは<ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph>ローカル値またはスタイルを介して確立されると、プロパティのシステム値が設定されますを<ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph>割り当てられているこの値を持つ最も近い親要素の値。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Dependency Property Information</source>
          <target state="translated">依存プロパティ情報</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">メタデータ プロパティに設定します。 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.LanguageProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Language" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Language" /&gt;</ph> 依存関係プロパティを識別します。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Occurs when the element is laid out, rendered, and ready for interaction.</source>
          <target state="translated">要素のレイアウトやレンダリングが完了し、操作を受け入れる準備が整ったときに発生します。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</source>
          <target state="translated">ルーティング イベントを直接ルートに従っていない、発生したが、同じ要素内でのみ処理されます。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">ルーティング イベントがその他のルーティング イベントの動作をサポートして直接: アクセスできるハンドラーのコレクションをサポートし、として使用できる、<ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph>スタイルでします。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Routed Event Information</source>
          <target state="translated">ルーティングされたイベント情報</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Routing strategy</source>
          <target state="translated">ルーティング方法</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Direct</source>
          <target state="translated">直接</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Delegate</source>
          <target state="translated">Delegate</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.LoadedEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Loaded" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Loaded" /&gt;</ph> (<bpt id="p1">[</bpt>Routed Events Overview (ルーティング イベントの概要)<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>) を識別します。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.LoadedEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">ルーティング イベントが登録されているときに、イベントの識別子のオブジェクトは作成されます (を参照してください<ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) クラス ハンドラーを追加するために使用する (を参照してください<ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.LoadedEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">識別子のオブジェクトには、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれています。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.LogicalChildren">
          <source>Gets an enumerator for the logical child elements of this element.</source>
          <target state="translated">この要素の論理上の子要素に対する列挙子を取得します。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.LogicalChildren">
          <source>An enumerator for logical child elements of this element.</source>
          <target state="translated">この要素の論理上の子要素に対する列挙子。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.LogicalChildren">
          <source>For more information on how to use <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">使用する方法の詳細についての<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>を参照してください<bpt id="p1">[</bpt>wpf ツリー<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>The direction that focus is to be moved, as a value of the enumeration.</source>
          <target state="translated">フォーカスの移動方向を表す列挙値。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>Moves the keyboard focus from this element to another element.</source>
          <target state="translated">この要素から別の要素にキーボード フォーカスを移動します。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if focus is moved successfully; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the target element in direction as specified does not exist.</source>
          <target state="translated">フォーカスの移動が成功した場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph> が返されます。指定した方向にターゲット要素が存在しない場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph> が返されます。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Gets or sets the identifying name of the element.</source>
          <target state="translated">要素の識別名を取得または設定します。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The name provides an instance reference so that programmatic code-behind, such as event handler code, can refer to an element once it is constructed during parsing of <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">この名前は、<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> の解析時に構築された要素を、プログラムの分離コード (イベント ハンドラーのコードなど) から参照できるようにするためのインスタンス参照を提供します。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The name of the element.</source>
          <target state="translated">要素の名前。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The most common usage of this property is when specifying a <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> element name in markup.</source>
          <target state="translated">このプロパティの最も一般的な使用法は指定するときに、<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>マークアップ内の要素名。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>This property essentially provides a WPF framework-level convenience property to set the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> <bpt id="p1">[</bpt>x:Name Directive<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept>.</source>
          <target state="translated">このプロパティでは、WPF フレームワーク レベルの便利なプロパティを設定する基本的にでは、 <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> <bpt id="p1">[</bpt>X:name ディレクティブ<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Getting a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from code is not common, because if you have the appropriate reference in code already, you can just call methods and properties on the element reference and do not generally need the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>.</source>
          <target state="translated">取得する、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>コードからは一般的では、既に適切な参照をコードにある場合だけメソッドを呼び出すことができます、要素のプロパティを参照しないようにして通常必要、<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>An exception is if the string has some overloaded meaning, for instance if it is useful to display that name in <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</source>
          <target state="translated">例外は、オーバー ロードされたに意味があるかどうかは文字列内でその名前を表示すると便利である場合<ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>です。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Setting a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from code if the original <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> was set from markup is also not recommended, and changing the property will not change the object reference.</source>
          <target state="translated">設定、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>コードから場合、元の<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>がマークアップから設定が推奨もされません。 また、プロパティを変更しても、オブジェクト参照は変更されません。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Such object references are created only when the underlying namescopes are explicitly created during <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> loading.</source>
          <target state="translated">基になる名前スコープは、中に明示的に作成された場合にのみ、このようなオブジェクト参照が作成された<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>読み込みします。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>You must specifically call <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> to make an effective change on the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> property of an already loaded element.</source>
          <target state="translated">具体的に呼び出す必要があります<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph>効果的な変更を行うには<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>既に読み込まれた要素のプロパティです。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>One notable case where setting <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from  code is important is for naming elements that storyboards will run against.</source>
          <target state="translated">1 つの重要な場合は設定、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>コードから重要では ストーリー ボードは名前付けの要素の実行に対しては、します。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Before you can register a name, might also need to instantiate and assign a <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> instance.</source>
          <target state="translated">名前を登録することができます、前にも必要になるをインスタンス化し、割り当てます、<ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph>インスタンス。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>See the Example section, or <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</source>
          <target state="translated">使用例」を参照してください。 または<bpt id="p1">[</bpt>ストーリー ボードの概要<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Setting <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from code has limited applications, but looking up an element by name is more common, particularly if you are employing a navigation model where pages reload into the application and the run-time code is not necessarily the code-behind of that respective page.</source>
          <target state="translated">設定<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>からコードには、アプリケーションが制限されていますが、ここで、アプリケーションにページが再読み込みされ、必ずしもその対応するページの分離コードが実行時コードではありませんは、ナビゲーション モデルを採用している場合に特により一般的には名前で要素を検索します。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The utility method <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindName%2A&gt;</ph>, which is available from any <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>, can find any element by <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> in that element's logical tree recursively.</source>
          <target state="translated">ユーティリティ メソッド<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindName%2A&gt;</ph>、これは、<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>で要素を検索できます<ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>その要素の論理ツリーを再帰的にします。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Or you can use the <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> static method of <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, which also takes the <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> string as an argument.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph>の静的メソッド<ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>もを取り、<ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>文字列を引数として。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Commonly used root elements (<ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.Page&gt;</ph> for example) implement the interface <ph id="ph3">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</source>
          <target state="translated">よく使用されるルート要素 (<ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>、<ph id="ph2">&lt;xref:System.Windows.Controls.Page&gt;</ph>たとえば) インターフェイスを実装して<ph id="ph3">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Implementations of this interface are expected to enforce that names be unambiguous within their scope.</source>
          <target state="translated">名前をそのスコープ内で明確にすることを強制するには、このインターフェイスの実装が予想されます。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Dependency Property Information</source>
          <target state="translated">依存プロパティ情報</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">メタデータ プロパティに設定します。 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.NameProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Name" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Name" /&gt;</ph> 依存関係プロパティを識別します。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">イベントに関するデータを提供します。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> ルーティング イベントが、その経路上でこのクラスに到達するたびに呼び出されます。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">このメソッドには、既定の実装ではありません。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">継承の中間クラスがこのメソッドを実装している場合は、基本実装を呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">このメソッドの目的は、類似した<ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph>でのイベント パターン * メソッド: インスタンス ハンドラーではなく、クラス ハンドラーを持つ派生クラスから一致するイベントを処理するための手段を提供します。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">ここでは、照合イベントは、ルーティングされたイベントです。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers.</source>
          <target state="translated">On のメソッドの実装パターンではルーティング イベントの異なるルーティング イベントを子要素、必ずしも要素でハンドラーを呼び出すことによって発生する可能性があります。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">そのため、実装、イベント引数のソースのプロパティを考慮に入れる必要が (および再ほとんどの場合、イベントを発生させる必要がありますいないを再試行してください)。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">サブクラス<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>経路イベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すにこともできます。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">イベントの引数を受け取り、経路を短縮する処理済みとして意図的にイベントをマークする 1 つの潜在的なシナリオです。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Event data for the event.</source>
          <target state="translated">イベントのイベント データ。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> ルーティング イベントが、その経路上でこのクラスに到達するたびに呼び出されます。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">このメソッドには、既定の実装ではありません。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>You should still call base() in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">継承の中間クラスがこのメソッドを実装している場合は、base() を呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">このメソッドの目的は、類似した<ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph>でのイベント パターン * メソッド: インスタンス ハンドラーではなく、クラス ハンドラーを持つ派生クラスから一致するイベントを処理するための手段を提供します。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">ここでは、照合イベントは、ルーティングされたイベントです。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">On のメソッドの実装パターンではルーティング イベントの異なるルーティング イベントを子要素、必ずしも要素であるため、実装は、イベント引数のソースのプロパティを考慮に入れる必要があるハンドラーを呼び出す (ほとんどの場合にイベントを再生成する必要がありますいないを再試行してください) で発生する可能性があります。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">サブクラス<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>経路イベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すにこともできます。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">イベントの引数を受け取り、経路を短縮する処理済みとして意図的にイベントをマークする 1 つの潜在的なシナリオです。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Event data for the event.</source>
          <target state="translated">イベントのイベント データ。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Class handler for the <ph id="ph1">&lt;see cref="E:System.Windows.ContentElement.GotFocus" /&gt;</ph> event.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.ContentElement.GotFocus" /&gt;</ph> イベントのクラス ハンドラー。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>This class handler sets appropriate focus behavior on this element if the event originated from this element.</source>
          <target state="translated">このクラスのハンドラーは、イベントがこの要素から作成された場合は、この要素の適切なフォーカスの動作を設定します。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>If the event's source was another element in the tree, the handler does nothing.</source>
          <target state="translated">イベントのソースが、ツリー内の別の要素の場合は、ハンドラーは、何も実行します。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Override this method in order to change these default focusing behavior on your element.</source>
          <target state="translated">これらの既定の動作を要素にフォーカスを変更するのには、このメソッドをオーバーライドします。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Event data for the event.</source>
          <target state="translated">イベントのイベント データ。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Initialized" /&gt;</ph> event.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Initialized" /&gt;</ph> イベントを発生させます。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>This method is invoked whenever <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> is set to <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">このメソッドは、<ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> に設定されるたびに呼び出されます。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>The default implementation of this virtual method raises the event as described earlier in this topic.</source>
          <target state="translated">この仮想メソッドの既定の実装は、このトピックで前述したように、イベントを発生させます。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Overrides should call base() to preserve this behavior.</source>
          <target state="translated">上書きは、この動作を保持する base() を呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsInitialized%2A&gt;</ph> property is read-only.</source>
          <target state="translated">なお、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsInitialized%2A&gt;</ph>プロパティは読み取り専用です。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Therefore, you cannot set it to force initialization behavior that way.</source>
          <target state="translated">したがって、その動作を強制的に初期化する方法を設定することはできません。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Initialization setting is intended to be done only by the <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> framework.</source>
          <target state="translated">初期化 設定でのみ実行するためのもので、<ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph>フレームワークです。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The event data that describes the property that changed, including the old and new values.</source>
          <target state="translated">変更されたプロパティ (古い値と新しい値を含む) を示すイベント データ。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Invoked whenever the effective value of any dependency property on this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> has been updated.</source>
          <target state="translated">この <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> の依存関係プロパティの有効値が更新されると、そのたびに呼び出されます。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The specific dependency property that changed is reported in the arguments parameter.</source>
          <target state="translated">変更が発生した特定の依存関係プロパティが引数パラメーターで報告されます。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Overrides <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /&gt;</ph> をオーバーライドします。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method is not intended to generally detect property changes or invalidations.</source>
          <target state="translated">このメソッドは、通常、プロパティの変更または無効化を検出するものではありません。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>It is instead intended for modifications of the general invalidation pattern if certain information is known about wide classifications of properties.</source>
          <target state="translated">代わりに目的が、一般的な無効化パターンの変更があったプロパティの広範な分類に関する特定の情報がわかっている場合。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method is potentially invoked many times during the life of an object.</source>
          <target state="translated">このメソッドでは、オブジェクトの有効期間中に何度もを呼び出す可能性があります。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Therefore, you can achieve better performance if you override the metadata of specific properties and then attach <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> functions for individual properties.</source>
          <target state="translated">したがって、特定のプロパティのメタデータをオーバーライドし、適用するを使用するパフォーマンスが向上を実現できます<ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>または<ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>個々 のプロパティです。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>However, you would use this method if a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> includes a significant number of value-interrelated dependency properties, or if it includes logic such as rendering behavior that must be rerun for several related cases of property invalidations.</source>
          <target state="translated">場合にこのメソッドを使用すると、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>多数の値と相互に依存関係プロパティを含む動作をレンダリングする必要がありますを再実行関連のプロパティの無効化のケースのいくつかのようにロジックが含まれている場合またはします。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Note that there is an identically named <ph id="ph1">`OnPropertyChanged`</ph> method with a different signature (the parameter type is <ph id="ph2">&lt;xref:System.ComponentModel.PropertyChangedEventArgs&gt;</ph>) that can appear on a number of classes.</source>
          <target state="translated">ある同じ名前に注意してください<ph id="ph1">`OnPropertyChanged`</ph>異なるシグネチャを持つメソッド (パラメーターの型が<ph id="ph2">&lt;xref:System.ComponentModel.PropertyChangedEventArgs&gt;</ph>) に多数のクラスに表示されることができます。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>That <ph id="ph1">`OnPropertyChanged`</ph> is used for data object notifications, and is part of the contract for <ph id="ph2">&lt;xref:System.ComponentModel.INotifyPropertyChanged&gt;</ph>.</source>
          <target state="translated">ある<ph id="ph1">`OnPropertyChanged`</ph>のコントラクトの一部であり、データ オブジェクトの通知に使用<ph id="ph2">&lt;xref:System.ComponentModel.INotifyPropertyChanged&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Always call the base implementation, as the first operation in your implementation.</source>
          <target state="translated">常に、実装では、最初の操作として基底の実装を呼び出します。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Failure to do this will significantly disable the entire <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system, which causes incorrect values to be reported.</source>
          <target state="translated">これを行うにはエラーには、全体が無効になりますが大幅に<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>プロパティ システムは、これにより、正しくない値が報告されます。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>The old style.</source>
          <target state="translated">元のスタイル。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>The new style.</source>
          <target state="translated">新しいスタイル。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Invoked when the style that is in use on this element changes.</source>
          <target state="translated">この要素で使用されているスタイルが変更された場合に呼び出されます。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>This method has a default implementation that sets an internal flag noting the style changed condition.</source>
          <target state="translated">このメソッドには、スタイルが変更された状態を示す内部フラグを設定する既定の実装があります。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Always call the base implementation, otherwise styles cannot be applied.</source>
          <target state="translated">常に基底の実装を呼び出し、それ以外の場合、スタイルを適用することはできません。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Scenarios for overriding this method might include if your derived class has a specialized style selector, or caches style values.</source>
          <target state="translated">このメソッドをオーバーライドするためのシナリオは、派生クラスは、専用のスタイル セレクターまたはスタイルの値をキャッシュする場合などがあります。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Theme changes will potentially invoke this method.</source>
          <target state="translated">テーマの変更はこのメソッドを呼び出す可能性があります。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">イベントに関するデータを提供します。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> ルーティング イベントが、その経路上でこのクラスに到達するたびに呼び出されます。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">このメソッドには、既定の実装ではありません。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>You should still call base() in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">継承の中間クラスがこのメソッドを実装している場合は、base() を呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">このメソッドの目的は、類似した<ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph>でのイベント パターン * メソッド: インスタンス ハンドラーではなく、クラス ハンドラーを持つ派生クラスから一致するイベントを処理するための手段を提供します。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">ここでは、照合イベントは、ルーティングされたイベントです。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">On のメソッドの実装パターンではルーティング イベントの異なるルーティング イベントを子要素、必ずしも要素であるため、実装は、イベント引数のソースのプロパティを考慮に入れる必要があるハンドラーを呼び出す (ほとんどの場合にイベントを再生成する必要がありますいないを再試行してください) で発生する可能性があります。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">サブクラス<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>経路イベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すにこともできます。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">イベントの引数を受け取り、経路を短縮する処理済みとして意図的にイベントをマークする 1 つの潜在的なシナリオです。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">イベントに関するデータを提供します。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> ルーティング イベントが、その経路上でこのクラスに到達するたびに呼び出されます。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">このメソッドには、既定の実装ではありません。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>You should still call base() in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">継承の中間クラスがこのメソッドを実装している場合は、base() を呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">このメソッドの目的は、類似した<ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph>でのイベント パターン * メソッド: インスタンス ハンドラーではなく、クラス ハンドラーを持つ派生クラスから一致するイベントを処理するための手段を提供します。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">ここでは、照合イベントは、ルーティングされたイベントです。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">On のメソッドの実装パターンではルーティング イベントの異なるルーティング イベントを子要素、必ずしも要素であるハンドラーを呼び出す (ほとんどの場合にイベントを再生成する必要がありますいないを再試行してください) で発生する可能性があります。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">サブクラス<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>経路イベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すにこともできます。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">イベントの引数を受け取り、経路を短縮する処理済みとして意図的にイベントをマークする 1 つの潜在的なシナリオです。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Gets or sets a value indicating whether this element incorporates style properties from theme styles.</source>
          <target state="translated">この要素にテーマ スタイルのスタイル プロパティを組み込むかどうかを示す値を取得または設定します。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this element does not use theme style properties; all style-originating properties come from local application styles, and theme style properties do not apply.</source>
          <target state="translated">この要素がテーマ スタイル プロパティを使用しない場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph> (スタイルが生成するすべてのプロパティは、ローカルのアプリケーション スタイルに起因するため、テーマ スタイル プロパティは適用されません)。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if application styles apply first, and then theme styles apply for properties that were not specifically set in application styles.</source>
          <target state="translated">まずアプリケーション スタイルを適用してから、アプリケーション スタイルで明確に設定されなかったプロパティに対してテーマ スタイルを適用する場合は <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>The most common usage of this property is an indirect usage within the setter of a style that is supplying a themed style.</source>
          <target state="translated">このプロパティの最も一般的な使用法は、テーマとスタイルを提供しているスタイルのセッター内の間接的な使用率です。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Dependency Property Information</source>
          <target state="translated">依存プロパティ情報</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">メタデータ プロパティに設定します。 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /&gt;</ph> 依存関係プロパティを識別します。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>Gets the parent in the logical tree for this element.</source>
          <target state="translated">この要素の論理ツリー内での親を取得します。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The logical parent for this element.</source>
          <target state="translated">この要素の論理上の親。</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>Note that the logical parent of an element can potentially change depending on your application functionality, and keeping the value of this property will not reflect that change.</source>
          <target state="translated">要素の論理上の親が、アプリケーションの機能に応じて変わることが可能性のある、このプロパティの値を維持するその変更は反映されないことに注意してください。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>You typically should get the value immediately before you need it.</source>
          <target state="translated">通常必要があります値を取得する必要がある直前です。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>See <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept> for more information about traversing logical trees, and the scenarios where taking this approach towards element discovery is appropriate.</source>
          <target state="translated">参照してください<bpt id="p1">[</bpt>wpf ツリー<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>詳細については、要素を検索には、この方法は適切な論理ツリー、およびシナリオを走査します。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The property system will potentially recalculate all property values of an element when it is reparented, because some properties inherit values through the logical tree.</source>
          <target state="translated">プロパティのシステムは可能性があると再計算要素のすべてのプロパティ値が親を再指定、いくつかのプロパティは、論理ツリーを使用して値を継承するため。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> that applies for bindings can also change when elements are reparented.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>にバインドできますも変更を適用します。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>Changing an element's parent is typically only done through manipulation of collections, by using dedicated add or remove methods, or through setting content properties of elements.</source>
          <target state="translated">要素の親の変更は通常によってのみ行われますコレクションの操作、dedicated を使用して追加または削除メソッド、または、要素のコンテンツのプロパティを設定します。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The most typical scenario for using the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> property is to obtain a reference and then get various <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> property values from the parent.</source>
          <target state="translated">使用するための最も一般的なシナリオ、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph>プロパティ、参照を取得し、さまざまな<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>親からのプロパティ値。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>For templates, the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> of the template eventually will be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">テンプレートの場合、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph>テンプレートの最終的になります<ph id="ph2">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>To get past this point and extend into the logical tree where the template is actually applied, use <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph>.</source>
          <target state="translated">この時点以降をテンプレートが実際に適用されている論理ツリーに拡張を使用して<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The following example checks to see whether the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> of a <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is of a particular type.</source>
          <target state="translated">次の例の確認を表示するかどうか、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph>の<ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>は、特定の型。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>The direction for which a prospective focus change should be determined.</source>
          <target state="translated">予想されるフォーカスの変更を決定する方向。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.</source>
          <target state="translated">この要素を基準に、指定したフォーカスの移動方向で次にフォーカスを受け取る要素を特定します。ただし、実際のフォーカスの移動は行われません。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>This method is sealed and cannot be overridden.</source>
          <target state="translated">このメソッドはシールされているため、オーバーライドできません。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>The next element that focus would move to if focus were actually traversed.</source>
          <target state="translated">フォーカスが実際にスキャンされた場合にフォーカスの移動先となる、次の要素。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>May return <ph id="ph1">&lt;see langword="null" /&gt;</ph> if focus cannot be moved relative to this element for the provided direction.</source>
          <target state="translated">この要素を基準に、指定した方向へフォーカスを移動できない場合は、<ph id="ph1">&lt;see langword="null" /&gt;</ph> が返されます。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.MoveFocus%2A&gt;</ph> is the related method that actually does move focus.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.MoveFocus%2A&gt;</ph> 実際には、フォーカスを移動するが関連する方法です。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>Specified one of the following directions in the <ph id="ph1">&lt;see cref="T:System.Windows.Input.TraversalRequest" /&gt;</ph>: <ph id="ph2">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Next" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" /&gt;</ph>, <ph id="ph4">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.First" /&gt;</ph>, <ph id="ph5">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Last" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Input.TraversalRequest" /&gt;</ph> に、<ph id="ph2">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Next" /&gt;</ph>、<ph id="ph3">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" /&gt;</ph>、<ph id="ph4">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.First" /&gt;</ph>、<ph id="ph5">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Last" /&gt;</ph> のいずれかの方向が指定されました。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>These directions are not legal for <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /&gt;</ph> (but they are legal for <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /&gt;</ph>).</source>
          <target state="translated">これらの方向は、<ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /&gt;</ph> に対しては有効ではありません (<ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /&gt;</ph> に対しては有効です)。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Name to use for the specified name-object mapping.</source>
          <target state="translated">指定した名前オブジェクトの割り当てに使用する名前。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Object for the mapping.</source>
          <target state="translated">割り当て対象のオブジェクト。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Provides an accessor that simplifies access to the <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph> registration method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph> の登録メソッドへのアクセスを簡略化するアクセサーを提供します。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.NameScope.RegisterName%2A&gt;</ph>.</source>
          <target state="translated">このメソッドは、便利なメソッドを呼び出す<ph id="ph1">&lt;xref:System.Windows.NameScope.RegisterName%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>The implementation will check successive parent elements until it finds the applicable <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> implementation, which is found by finding an element that implements <ph id="ph2">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</source>
          <target state="translated">実装は、該当するが見つかるまで、連続する親要素は確認<ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph>実装を実装する要素の検索で見つかった<ph id="ph2">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>For more information about namescopes, see <bpt id="p1">[</bpt>WPF XAML Namescopes<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</source>
          <target state="translated">名前スコープの詳細については、次を参照してください。 <bpt id="p1">[</bpt>WPF XAML 名前スコープ<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Calling <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> is necessary in order to correctly hook up animation storyboards for applications when created in code.</source>
          <target state="translated">呼び出す<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph>が正しくコードで作成されたときに、アプリケーションのアニメーションのストーリー ボードをフックするために必要です。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>This is because one of the key storyboard properties, <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard.TargetName%2A&gt;</ph>, uses a run-time name lookup instead of being able to take a reference to a target element.</source>
          <target state="translated">これは、プロパティ、キーのいずれかのストーリー ボード作成ため<ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard.TargetName%2A&gt;</ph>、ターゲット要素への参照を実行することではなく実行時の名前検索を使用します。</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>This is true even if that element is accessible by reference from the code.</source>
          <target state="translated">これは、その要素が、コードから参照渡しでアクセス可能な場合でも当てはまります。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>For more information on why you need to register names for storyboard targets, see <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</source>
          <target state="translated">ストーリー ボードのターゲットの名前を登録する必要がある理由の詳細については、次を参照してください。<bpt id="p1">[</bpt>ストーリー ボードの概要<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Animations for content elements are less common than animations on controls, the <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept> concentrates on control scenarios.</source>
          <target state="translated">コンテンツ要素のアニメーションは、コントロールのアニメーションよりもあまり一般的で、<bpt id="p1">[</bpt>ストーリー ボードの概要<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>制御シナリオに重点を置いています。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>The element to remove.</source>
          <target state="translated">削除する要素。</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>Removes the specified element from the logical tree for this element.</source>
          <target state="translated">この要素の論理ツリーから、指定した要素を削除します。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>This <ph id="ph1">[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]</ph> is mainly relevant for class deriving scenarios, when adding support for child collections.</source>
          <target state="translated">これは、<ph id="ph1">[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]</ph>が子コレクション サポートを追加するときに、シナリオを派生するクラスを主に関連します。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>Most <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes expose dedicated collections that are responsible for containment (for example, <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> on the <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> class; <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> on the <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> class).</source>
          <target state="translated">ほとんど<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>派生クラスの包含を担当する専用のコレクションを公開する (たとえば、<ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph>上、<ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph>クラスです。<ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph>上、<ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph>クラス)。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>Deriving from such classes typically can avoid any need to manipulate the logical tree directly.</source>
          <target state="translated">通常、このようなクラスから派生すると、論理ツリーを直接操作する必要を回避できます。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Gets or sets the current locally-defined resource dictionary.</source>
          <target state="translated">ローカルで定義された現在のリソース ディクショナリを取得または設定します。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The current locally-defined resources.</source>
          <target state="translated">ローカルで定義された現在のリソース。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>This is a dictionary of resources, where resources within the dictionary are accessed by key.</source>
          <target state="translated">これはリソース ディクショナリです。ディクショナリ内のリソースにはキーでアクセスします。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Resource dictionaries that can be defined completely or partially in <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> are typically created as a property element, and are typically on the root element for any individual page or for the application.</source>
          <target state="translated">完全または部分的に定義できるリソース ディクショナリ<ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>は、通常、プロパティ要素として作成し、個々 のページまたはアプリケーションのルート要素には、通常します。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Placing the resource dictionary at this level makes it easier to find from individual child elements in the page (or from any page, in the application case).</source>
          <target state="translated">このレベルでリソース ディクショナリを配置すると、ページ内の個々 の子要素 (または任意のページでは、アプリケーションの場合に、) を検索しやすきます。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>In most application scenarios, we recommend that styles be defined as object elements within a resource dictionary, or be defined as external resources so that the entire style resource can be self-contained (this approach helps separate designer responsibilities from developer responsibilities by separating the physical files that need to be edited).</source>
          <target state="translated">ほとんどのアプリケーション シナリオでは、ことをお勧めスタイルが、リソース ディクショナリ内のオブジェクト要素として定義されているスタイル リソース全体を自己完結型できるように、外部リソースとして定義するか (このアプローチは、分担デザイナーと開発者の責任を編集することが必要な物理ファイルを分離することにより、役立ちます)。</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Note that this property returns only the resource dictionary declared directly within that element.</source>
          <target state="translated">このプロパティをリソース ディクショナリだけがその要素内で直接宣言を返すことに注意してください。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>This is different than the actual resource lookup process, where a child element can access any of the resources defined in each parent element, searching recursively upwards.</source>
          <target state="translated">これは、実際のリソース ルックアップ プロセスの子要素がアクセスできる場所の検索方向を再帰的に、各親要素で定義されているリソースとは異なるです。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Resources can also be referenced by code from within the collection, but be aware that resources created in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> will definitely not be accessible until after <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> is raised by the element that declares the dictionary.</source>
          <target state="translated">リソースは、コレクション内からコードで参照することもできますでリソースが作成されたことに注意してください<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>確実アクセスできなくなりますまで後<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph>ディクショナリを宣言する要素で発生します。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>In fact, resources are parsed asynchronously, and not even the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> event is an assurance that you can reference a <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> defined resource.</source>
          <target state="translated">実際には、リソースは、非同期的に解析され、であっても、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph>イベントが参照できるように保証、<ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>リソースを定義します。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>For this reason you should generally only access <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> defined resources as part of run-time code, or through other <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> techniques such as styles or resource extension references for attribute values.</source>
          <target state="translated">このため、通常のみにアクセスする<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>またはその他の実行時のコードの一部としてリソースを定義<ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>スタイルや属性の値をリソース拡張機能の参照などの手法です。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>When you access resources through code, it is essentially equivalent to a  reference made from <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">コードによって、リソースにアクセスするときに基本的と等価であるから行われます。 参照に<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>です。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The underlying <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> supports the methods required to add, remove, or query resources from within the collection by using code.</source>
          <target state="translated">基になる<ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>を追加、削除、またはコードを使用してから、コレクション内のリソースを照会するために必要なメソッドをサポートします。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> property is settable to support the scenario of completely replacing the resources collection of an element to be a new or different <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph>プロパティは、要素を新規または別のリソースのコレクションを完全に置き換えるのシナリオをサポートする設定<ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Notice that the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax shown does not include an element for the <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">注意して、<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>に示す構文の要素を含まない、<ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>This is an example of implicit collection syntax; a tag representing the collection element can be omitted.</source>
          <target state="translated">これは、暗黙の型のコレクション構文の例コレクションの要素を表すタグを省略できます。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The elements that are added as items to the collection are specified instead.</source>
          <target state="translated">代わりに、コレクションに項目として追加される要素を指定します。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>For more information about implicit collections and <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, see <bpt id="p1">[</bpt>XAML Syntax In Detail<ept id="p1">](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>.</source>
          <target state="translated">暗黙の型のコレクションの詳細については、<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>を参照してください<bpt id="p1">[</bpt>XAML 構文の詳細<ept id="p1">](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>One case where a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> is still specified explicitly as an element is if you are introducing a merged dictionary, in which case there are typically no child elements for that <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">1 つのケースで、<ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>要素がマージされたディクショナリを導入する場合ではありません通常その子要素として明示的に指定がまだ<ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>For details, see <bpt id="p1">[</bpt>Merged Resource Dictionaries<ept id="p1">](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)</ept>.</source>
          <target state="translated">詳細については、「<bpt id="p1">[</bpt>リソース ディクショナリのトピックとマージ<ept id="p1">](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>XAML Property Element Usage</source>
          <target state="translated">XAML プロパティ要素の使用</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>XAML Values</source>
          <target state="translated">XAML 値</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source><bpt id="p1">*</bpt>oneOrMoreResourceElements<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>oneOrMoreResourceElements<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>One or more object elements, each of which defines a resource.</source>
          <target state="translated">1 つまたは複数のオブジェクト要素定義されているリソース。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Each resource property element within each <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> must have a unique value for the <bpt id="p1">[</bpt>x:Key Directive<ept id="p1">](~/docs/framework/xaml-services/x-key-directive.md)</ept>, which serves as the unique key when values are retrieved from the <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">各リソースのプロパティ要素内で各<ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>に一意の値を持つ必要があります、 <bpt id="p1">[</bpt>X:key ディレクティブ<ept id="p1">](~/docs/framework/xaml-services/x-key-directive.md)</ept>、値がから取得されたときに、一意のキーとして機能する、<ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The following example establishes a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> collection on a <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> root element.</source>
          <target state="translated">次の例では確立、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph>コレクションに、<ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph>ルート要素です。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source><ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> is a typical choice because it is one of the few <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> 一般的な選択肢は、いくつかのいずれかであるため<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>ページのルート、またはアプリケーションのようにこのようなさらに高いレベルでは、ルート要素では、およびリソースとして意味のあるクラスが一般的に格納します。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source>Attaches a binding to this element for the specified dependency property.</source>
          <target state="translated">指定した依存関係プロパティのためのバインディングをこの要素に添付します。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Identifies the bound property.</source>
          <target state="translated">バインドされているプロパティを識別します。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>The source property name or the path to the property used for the binding.</source>
          <target state="translated">ソース プロパティ名、またはバインドに使用されているプロパティへのパス。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.</source>
          <target state="translated">指定したソース プロパティ名をデータ ソースへのパスの修飾として使用して、この要素にバインディングを添付します。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Records the conditions of the binding.</source>
          <target state="translated">バインドの条件を記録します。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This return value can be useful for error checking.</source>
          <target state="translated">この戻り値は、エラーをチェックするために役立ちます。</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, which passes the current instance as the <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>, and creates a new <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> based on the provided <ph id="ph4">`path`</ph> parameter.</source>
          <target state="translated">このメソッドは、便利なメソッドを呼び出す<ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>、として現在のインスタンスを渡しますが、 <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>、新たに作成および<ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph>に基づいて、指定した<ph id="ph4">`path`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This signature is more convenient if you are establishing a simple default binding.</source>
          <target state="translated">この署名は、単純な既定のバインディングを確立する場合に便利です。</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>If you need to specify any binding properties to non-default conditions, or want to use a <ph id="ph1">&lt;xref:System.Windows.Data.MultiBinding&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Data.PriorityBinding&gt;</ph>,you should use the <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29&gt;</ph> signature.</source>
          <target state="translated">既定以外の条件へのバインディング プロパティを指定するか、使用する必要がある場合、<ph id="ph1">&lt;xref:System.Windows.Data.MultiBinding&gt;</ph>または<ph id="ph2">&lt;xref:System.Windows.Data.PriorityBinding&gt;</ph>、使用する必要があります、<ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29&gt;</ph>署名します。</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>The following example sets a binding on a <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> element, by creating a new custom data object, establishing that object as <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>, and setting the binding path to a property within it.</source>
          <target state="translated">次の例は、上のバインディングを設定、<ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>としては、そのオブジェクトを確立する、新しいカスタム データ オブジェクトを作成することで、要素<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>、およびその中のプロパティをバインド パスを設定します。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Identifies the bound property.</source>
          <target state="translated">バインドされているプロパティを識別します。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Represents a data binding.</source>
          <target state="translated">データ バインディングを表します。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Attaches a binding to this element, based on the provided binding object.</source>
          <target state="translated">指定したバインディング オブジェクトに基づいて、この要素にバインドをアタッチします。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Records the conditions of the binding.</source>
          <target state="translated">バインドの条件を記録します。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>This return value can be useful for error checking.</source>
          <target state="translated">この戻り値は、エラーをチェックするために役立ちます。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, which passes the current instance as the <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>.</source>
          <target state="translated">このメソッドは、便利なメソッドを呼び出す<ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>、現在のインスタンスに渡されます<ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>The following example sets a binding on a <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> element, by creating a new <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> and setting the source to a newly built <ph id="ph3">`DateTime`</ph> object.</source>
          <target state="translated">次の例は、上のバインディングを設定、<ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>要素を新たに作成する<ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph>新たに構築するソースの設定と<ph id="ph3">`DateTime`</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The property to which the resource is bound.</source>
          <target state="translated">リソースのバインド先のプロパティ。</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The name of the resource.</source>
          <target state="translated">リソースの名前。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>Searches for a resource with the specified name and sets up a resource reference to it for the specified property.</source>
          <target state="translated">指定した名前のリソースを検索し、指定したプロパティにそのリソースへのリソース参照を設定します。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>A resource reference is similar to the use of a <bpt id="p1">[</bpt>DynamicResource Markup Extension<ept id="p1">](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)</ept> in markup.</source>
          <target state="translated">リソースの参照の使用に似ていますが、 <bpt id="p1">[</bpt>DynamicResource マークアップ拡張機能<ept id="p1">](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)</ept>マークアップでします。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The resource reference creates an internal expression that supplies the value of the specified property on a run-time deferred basis.</source>
          <target state="translated">リソース参照では、実行時の遅延単位で指定したプロパティの値を提供する内部式を作成します。</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The expression will be re-evaluated whenever the resource dictionary indicates a changed value through internal events, or whenever the current element is reparented (a parent change would change the dictionary lookup path).</source>
          <target state="translated">式は、現在の要素が親を再指定する場合や、リソース ディクショナリが内部のイベントによって変更された値が示すされるたびに再評価されます (親の変更は、ディクショナリの検索パスを変更は)。</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeResources">
          <source>Returns whether serialization processes should serialize the contents of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph> property on instances of this class.</source>
          <target state="translated">シリアル化プロセスが、このクラスのインスタンスに関する <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeResources">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph> property value should be serialized; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> プロパティ値をシリアル化する必要がある場合は <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeResources">
          <source>This will return <ph id="ph1">`true`</ph> so long as there is at least one keyed resource in the local <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph>.</source>
          <target state="translated">これは、戻り値は<ph id="ph1">`true`</ph>、ローカルの少なくとも 1 つのキーを持つリソースがある限り、<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle">
          <source>Returns whether serialization processes should serialize the contents of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> property on instances of this class.</source>
          <target state="translated">シリアル化プロセスが、このクラスのインスタンスに関する <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> property value should be serialized; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> プロパティ値をシリアル化する必要がある場合は <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle">
          <source>This will return <ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> is locally set.</source>
          <target state="translated">返されます<ph id="ph1">`true`</ph>場合、<ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph>ローカルに設定します。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.SourceUpdated">
          <source>Occurs when any associated data source participating in a binding on this element changes.</source>
          <target state="translated">この要素のバインディングに参加しているデータ ソースが変更されたときに発生します。</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.SourceUpdated">
          <source>This event surfaces the <ph id="ph1">&lt;xref:System.Windows.Data.Binding.SourceUpdated&gt;</ph> event that is raised by any <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> associated with this element.</source>
          <target state="translated">このイベントの画面、<ph id="ph1">&lt;xref:System.Windows.Data.Binding.SourceUpdated&gt;</ph>いずれかが発生するイベントを<ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph>この要素に関連付けられています。</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.SourceUpdated">
          <source>XAML Attribute Usage</source>
          <target state="translated">XAML 属性の使用方法</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Gets or sets the style to be used by this element.</source>
          <target state="translated">この要素が使用するスタイルを取得または設定します。</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The applied, nondefault style for the element, if present.</source>
          <target state="translated">要素に適用される既定以外のスタイル (存在する場合)。</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The default for a default-constructed <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">既定で構築された <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> の既定値は <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The current style is often provided by a default style from theming, or from styles generally applied to objects of that type by resources at page or application level (an implicit style).</source>
          <target state="translated">現在のスタイルは、テーマとは通常ページまたはアプリケーション レベル (暗黙的なスタイル) リソースによって、その型のオブジェクトに適用するスタイルから既定のスタイルによって提供される多くの場合。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>This property does not set or return default (theme) styles, but it does return the implicit style or an explicit style.</source>
          <target state="translated">このプロパティは既定の設定したり返したり (テーマ) のスタイルが、暗黙的なスタイルまたは明示的なスタイルを返します。</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>In the case of implicit or explicit styles, it does not matter whether the style is accessed as a resource or defined locally.</source>
          <target state="translated">暗黙的または明示的なスタイルの場合、スタイルをリソースとしてアクセスまたはローカルに定義されているかどうかは関係ありません。</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Setting the styles has some restrictions.</source>
          <target state="translated">スタイルの設定の制限があります。</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>You can reset the entire <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> property to a new <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> at any time, which will force a layout recomposition.</source>
          <target state="translated">全体をリセットする<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph>プロパティを新しい<ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph>、いつでもレイアウト再構成を強制します。</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>However, as soon as that style is placed in use by a loaded element, the <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph> should be considered sealed.</source>
          <target state="translated">ただし、そのスタイルが使用中で読み込まれた要素で配置されるとすぐとして、<ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph>と見なすべきシールします。</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Attempting to make a change to any individual property of an in-use style (such as anything within the collection of <ph id="ph1">&lt;xref:System.Windows.Style.Setters%2A&gt;</ph>) causes an exception to be thrown.</source>
          <target state="translated">使用するスタイルの個々 のプロパティを変更しようとしています (などのコレクション内のすべて<ph id="ph1">&lt;xref:System.Windows.Style.Setters%2A&gt;</ph>) 例外がスローされます。</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>A style that is defined in markup is considered to be in use as soon as it is loaded from a resource dictionary (for resources), or the page it is contained within is loaded (for inline styles).</source>
          <target state="translated">マークアップで定義されているスタイルは、(リソース) のリソース ディクショナリから読み込まれるか (インライン スタイル) に含まれているページが読み込まれるとすぐに使用すると見なされます。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> is a dependency property with special precedence.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> 特殊な優先順位を持つ依存関係プロパティです。</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The locally set style generally operates at the highest precedence in the property system.</source>
          <target state="translated">ローカルに設定スタイルが通常プロパティ システムに最高の優先順位で動作します。</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> is null at this point, during loading the property system checks for implicit styles as defined resources that specify that type.</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph>プロパティ システムがそのタイプが指定された定義済みのリソースとしての暗黙的なスタイルのチェックの読み込み中にこの時点では、null がします。</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>If the style is still null after this step, then the style comes from the default (theme) style, but the default style is not returned in the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> property value.</source>
          <target state="translated">この手順の後にスタイルがも null し、スタイルは、既定の (テーマ) スタイルをから取得します、に既定のスタイルが返されない場合、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph>プロパティの値。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>See <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</source>
          <target state="translated">参照してください<bpt id="p1">[</bpt>依存関係プロパティの値の優先順位<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>XAML Attribute Usage</source>
          <target state="translated">XAML 属性の使用方法</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>XAML Values</source>
          <target state="translated">XAML 値</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>One of the following: , or .</source>
          <target state="translated">次のいずれかの: または。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">参照してください<bpt id="p1">[</bpt>XAML リソース<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The key that identifies the style being requested.</source>
          <target state="translated">要求されているスタイルを識別するキー。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The key refers to an existing resource in a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">このキーは既存のリソースを<ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Property element syntax is technically possible, but not recommended.</source>
          <target state="translated">プロパティ要素構文は、技術的に可能ですが、推奨されません。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>See <bpt id="p1">[</bpt>Inline Styles and Templates<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</source>
          <target state="translated">参照してください<bpt id="p1">[</bpt>インライン スタイルとテンプレート<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>A binding reference using  or <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> is also possible, but uncommon.</source>
          <target state="translated">バインドの参照を使用して、または<ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph>も可能ですが、一般的ではないです。</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Dependency Property Information</source>
          <target state="translated">依存プロパティ情報</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">メタデータ プロパティに設定します。 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The following example establishes a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> collection on a <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> root element and then references it as a resource as a specific style for a <ph id="ph3">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>.</source>
          <target state="translated">次の例では確立、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph>コレクションに、<ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph>ルート要素として特定のスタイルをリソースとして参照し、<ph id="ph3">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.StyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> 依存関係プロパティを識別します。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>The name of the requested ambient property.</source>
          <target state="translated">要求されたアンビエント プロパティの名前。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>For a description of this member, see the <ph id="ph1">&lt;see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /&gt;</ph> method.</source>
          <target state="translated">このメンバーの説明については、<ph id="ph1">&lt;see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /&gt;</ph> メソッドのトピックを参照してください。</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="propertyName" /&gt;</ph> is available; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="propertyName" /&gt;</ph> を使用できる場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">このメンバーは、明示的なインターフェイス メンバーの実装です。</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Windows.Markup.IQueryAmbient&gt;</ph> interface.</source>
          <target state="translated">これは、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> のインスタンスが <ph id="ph2">&lt;xref:System.Windows.Markup.IQueryAmbient&gt;</ph> インターフェイスにキャストされる場合のみ、使用できます。</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Gets or sets an arbitrary object value that can be used to store custom information about this element.</source>
          <target state="translated">この要素に関するユーザー定義情報の格納に使用できる任意のオブジェクト値を取得または設定します。</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>The intended value.</source>
          <target state="translated">任意の値。</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>This property has no default value.</source>
          <target state="translated">このプロパティには既定値はありません。</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>This property is analogous to Tag properties in other <ph id="ph1">[!INCLUDE[TLA#tla_ms](~/includes/tlasharptla-ms-md.md)]</ph> programming models, such as <ph id="ph2">[!INCLUDE[TLA#tla_vba](~/includes/tlasharptla-vba-md.md)]</ph> or <ph id="ph3">[!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)]</ph>.</source>
          <target state="translated">このプロパティは、他のタグのプロパティに似た<ph id="ph1">[!INCLUDE[TLA#tla_ms](~/includes/tlasharptla-ms-md.md)]</ph>などのプログラミング モデル<ph id="ph2">[!INCLUDE[TLA#tla_vba](~/includes/tlasharptla-vba-md.md)]</ph>または<ph id="ph3">[!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)]</ph>です。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>It is intended to provide a pre-existing place to store some basic custom information about any element without forcing application developers to subclass.</source>
          <target state="translated">アプリケーション開発者にサブクラス化を強制することがなく任意の要素に関する基本的なカスタム情報を格納する既存の場所を提供しています。</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>XAML Values</source>
          <target state="translated">XAML 値</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Because this property takes an object, you would need to use the property element usage in order to set the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Tag%2A&gt;</ph> property in <ph id="ph2">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> to anything other than an object with a known and built-in type converter, such as a string.</source>
          <target state="translated">このプロパティは、オブジェクトを受け取り、ためには、プロパティ要素の使用を設定するために使用する必要があります、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Tag%2A&gt;</ph>プロパティに<ph id="ph2">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>文字列などの組み込みの既知の型コンバーターを使用したオブジェクト以外のすべてにします。</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Objects used in this way are typically not within the standard <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> namespaces and therefore may require namespace mapping to the external namespace in order to be introduced as <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> elements.</source>
          <target state="translated">この方法で使用されるオブジェクトが、通常、標準<ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph>名前空間として導入するためを外部の名前空間を名前空間のマッピングに要する場合がありますので<ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>要素。</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Dependency Property Information</source>
          <target state="translated">依存プロパティ情報</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">メタデータ プロパティに設定します。 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>None</source>
          <target state="translated">なし</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.TagProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Tag" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Tag" /&gt;</ph> 依存関係プロパティを識別します。</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>Occurs when any associated target property participating in a binding on this element changes.</source>
          <target state="translated">この要素のバインドに関連する対象プロパティが変更されたときに発生します。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>This event surfaces the <ph id="ph1">&lt;xref:System.Windows.Data.Binding.TargetUpdated&gt;</ph> event that is raised by any <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> associated with this element.</source>
          <target state="translated">このイベントの画面、<ph id="ph1">&lt;xref:System.Windows.Data.Binding.TargetUpdated&gt;</ph>いずれかが発生するイベントを<ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph>この要素に関連付けられています。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>This usually means that the binding in question is a two-way binding, and that the bound  dependency property affirms an invalidation of the previous property value per any validation or caching scheme that the property supports.</source>
          <target state="translated">これは通常、問題のバインドが双方向のバインドであること、およびバインドされた依存関係プロパティに前のプロパティ値の検証またはプロパティをサポートするキャッシュのスキームあたりの無効が確認されたことに意味します。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>The event arguments of this event will inform you which bound property was changed.</source>
          <target state="translated">このイベントのイベントの引数が変更されたプロパティをバインドするお手伝いします。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>XAML Attribute Usage</source>
          <target state="translated">XAML 属性の使用方法</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Gets a reference to the template parent of this element.</source>
          <target state="translated">この要素の親テンプレートへの参照を取得します。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>This property is not relevant if the element was not created through a template.</source>
          <target state="translated">このプロパティは、要素がテンプレートによって作成されていない場合は無効です。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>The element whose <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkTemplate" /&gt;</ph><ph id="ph2">&lt;see cref="P:System.Windows.FrameworkTemplate.VisualTree" /&gt;</ph> caused this element to be created.</source>
          <target state="translated">要素が<ph id="ph1">&lt;see cref="T:System.Windows.FrameworkTemplate" /&gt;</ph><ph id="ph2">&lt;see cref="P:System.Windows.FrameworkTemplate.VisualTree" /&gt;</ph>を作成するには、この要素を発生します。</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>This value is frequently <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">この値は、頻繁に<ph id="ph1">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Templates are actually shared objects, where the contents of the template are created only once.</source>
          <target state="translated">テンプレートは、実際には共有オブジェクト、テンプレートの内容が 1 回だけ作成される場所です。</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Therefore, if you obtain an object reference to an element that came from a template, you may find that the apparent logical tree does not reach to the page root.</source>
          <target state="translated">そのため、テンプレートから得られた要素へのオブジェクト参照を取得する場合があります、見かけ上の論理ツリーは、ページのルートには到達できません。</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>In order to connect such a template reference to the page's logical tree, you should get the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> value and continue to navigate that element tree as desired.</source>
          <target state="translated">このようなテンプレートへの参照をページの論理ツリーを接続するために取得する必要があります、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph>値し、必要に応じて、その要素ツリーのナビゲーションを続行します。</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> will frequently be <ph id="ph2">`null`</ph> for common objects, because if you have obtained an object reference from out of a page in your application through typical means, that element probably was not created from a template.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> 一般に<ph id="ph2">`null`</ph>、共通オブジェクト用の一般的な手段を使用してアプリケーションのページからのオブジェクト参照を取得した場合は、その要素可能性がありますが作成されなかったため、テンプレートからです。</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Cases where <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> might not be <ph id="ph2">`null`</ph> would include operations such as hit-testing, event handling for certain low-level input events, or working with enumerators, which may have returned elements that came from templates.</source>
          <target state="translated">あるケース<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph>できない可能性があります<ph id="ph2">`null`</ph>特定低レベルの入力イベントの処理やテンプレートから得られた要素から返された列挙子は、扱うヒット テスト、イベントなどの操作が含まれます。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Gets or sets the tool-tip object that is displayed for this element in the <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> でこの要素に対して表示されるツールヒント オブジェクトを取得または設定します。</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>The tooltip object.</source>
          <target state="translated">ツールヒント オブジェクト。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>If the value of this property is of type <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>, then that is the tool-tip that will be used in the <ph id="ph2">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</source>
          <target state="translated">このプロパティの値が型の場合<ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>で使用されるツール ヒントをそれが、<ph id="ph2">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>です。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>If the value is of any other type, then that value will be used as the <bpt id="p1">*</bpt>content<ept id="p1">*</ept> for a <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> provided (constructed) by the system.</source>
          <target state="translated">値は、他の任意の型のかどうかは、その値として使用されます、<bpt id="p1">*</bpt>コンテンツ<ept id="p1">*</ept>の<ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>提供システムによって (作成) します。</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>For more information see <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTipService&gt;</ph>.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Windows.Controls.ToolTipService&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>The service class provides attached properties that can be used to further customize a tool-tip.</source>
          <target state="translated">サービス クラスでは、ツール ヒントをさらにカスタマイズするために使用する添付プロパティを提供します。</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>XAML Attribute Usage</source>
          <target state="translated">XAML 属性の使用方法</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>XAML Property Element Usage</source>
          <target state="translated">XAML プロパティ要素の使用</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>XAML Values</source>
          <target state="translated">XAML 値</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source><bpt id="p1">*</bpt>toolTipContent<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>toolTipContent<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>A string that becomes the display text for the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>.</source>
          <target state="translated">文字列の表示テキストになる、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source><bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Some object, provided in object element form, that should be used as the content for the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> .</source>
          <target state="translated">コンテンツとして使用されるオブジェクト要素の形式で提供される一部のオブジェクト、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Typically this would be a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or some other element that creates layout compositing for the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>, eventually containing text content within the compositing.</source>
          <target state="translated">通常、<ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>またはその他の要素のレイアウトの合成を作成する、 <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>、最終的に、合成内のテキスト コンテンツを格納します。</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>In this usage, the <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> element is created implicitly from the parsed <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, and the <bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept> content is set as its <ph id="ph3">&lt;xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">この使用率、<ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>要素が作成、解析されたから暗黙的に<ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>、および<bpt id="p1">*</bpt>方法<ept id="p1">*</ept>としてコンテンツを設定その<ph id="ph3">&lt;xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source><ph id="ph1">&lt;</ph><ph id="ph2">`ToolTip`</ph> .../&gt;</source>
          <target state="translated"><ph id="ph1">&lt;</ph><ph id="ph2">`ToolTip`</ph> .../&gt;</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>.</source>
          <target state="translated">「<ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Dependency Property Information</source>
          <target state="translated">依存プロパティ情報</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">メタデータ プロパティに設定します。 <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>None</source>
          <target state="translated">なし</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>The following example sets the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> property directly to a string.</source>
          <target state="translated">次の例の値の設定、<ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph>プロパティ文字列を直接です。</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Occurs just before any tooltip on the element is closed.</source>
          <target state="translated">要素のツールヒントが閉じる直前に発生します。</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>To suppress closing the tooltip, handlers of the event should mark it as handled.</source>
          <target state="translated">ツールヒントが閉じないように、イベントのハンドラー必要があります、処理済みとしてマークします。</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>This event cannot be an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">このイベントをすることはできません、<ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph>スタイルでします。</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</source>
          <target state="translated">これは、このイベントの識別子フィールドが、サービスからのイベントを追加/削除メソッドを公開しない実装を再使用するためです。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Routed Event Information</source>
          <target state="translated">ルーティングされたイベント情報</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Routing strategy</source>
          <target state="translated">ルーティング方法</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Direct</source>
          <target state="translated">直接</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Delegate</source>
          <target state="translated">Delegate</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> (<bpt id="p1">[</bpt>Routed Events Overview (ルーティング イベントの概要)<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>) を識別します。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">ルーティング イベントが登録されているときに、イベントの識別子のオブジェクトは作成されます (を参照してください<ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) クラス ハンドラーを追加するために使用する (を参照してください<ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">識別子のオブジェクトには、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれています。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Occurs when any tooltip on the element is opened.</source>
          <target state="translated">要素のツールヒントが開かれたときに発生します。</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>To manually open tooltips, handlers of the events should mark the relevant event as handled.</source>
          <target state="translated">ツール ヒントを手動で開く、処理済みとして、イベントのハンドラーは、関連するイベントをマークする必要があります。</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Otherwise, the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> property will be used to automatically open a context menu.</source>
          <target state="translated">それ以外の場合の値、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>プロパティが自動的にコンテキスト メニューを開き、使用されます。</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> property and then open the new <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</source>
          <target state="translated">既定のアクションを効果的に取り消し処理イベントをマークすることとの値にリセットすることにより、<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>プロパティを開き、新しい<ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Note that this event will not be raised if <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> is a null reference or otherwise unset.</source>
          <target state="translated">このイベントは発生しません。 場合に注意してください<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>null 参照またはそれ以外の場合設定を解除します。</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>This event cannot be an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">このイベントをすることはできません、<ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph>スタイルでします。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</source>
          <target state="translated">これは、このイベントの識別子フィールドが、サービスからのイベントを追加/削除メソッドを公開しない実装を再使用するためです。</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Routed Event Information</source>
          <target state="translated">ルーティングされたイベント情報</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Routing strategy</source>
          <target state="translated">ルーティング方法</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Direct</source>
          <target state="translated">直接</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Delegate</source>
          <target state="translated">Delegate</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> (<bpt id="p1">[</bpt>Routed Events Overview (ルーティング イベントの概要)<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>) を識別します。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">ルーティング イベントが登録されているときに、イベントの識別子のオブジェクトは作成されます (を参照してください<ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) クラス ハンドラーを追加するために使用する (を参照してください<ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">識別子のオブジェクトには、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれています。</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ToolTipProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ToolTip" /&gt;</ph> dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ToolTip" /&gt;</ph> 依存関係プロパティを識別します。</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>Key identifier of the resource to be found.</source>
          <target state="translated">検索するリソースのキー識別子。</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>Searches for a resource with the specified key, and returns that resource if found.</source>
          <target state="translated">指定されたキーを使用してリソースを検索し、見つかった場合はそのリソースを返します。</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>The found resource.</source>
          <target state="translated">見つかったリソース。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>If no resource was found, <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">リソースが見つからなかった場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph> が返されます。</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a dynamic resource reference were requested by key at run-time.</source>
          <target state="translated">ツリーになると同様に、論理ツリーを使用して親ツリーを検索する場合は、リソースが呼び出し元の要素で見つからなかった、動的なリソースの参照は、実行時にキーによって要求された場合を検索します。</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</source>
          <target state="translated">通常返されたリソース値に設定しようとしているプロパティの型を戻り値をキャストするとすぐにします。</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindResource%2A&gt;</ph> method has similar behavior, except that it will throw an exception in the case of not finding a resource with the provided key.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindResource%2A&gt;</ph>ことを除き、指定されたキーを使用してリソースを検出していない場合は例外がスローされますが、メソッドは同様の動作です。</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</source>
          <target state="translated">次の例では、マークアップで定義されているリソースを検索し、ルーティングされたイベントに応答内の要素の特定のプロパティに適用されます。</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Occurs when the element is removed from an element tree of loaded elements.</source>
          <target state="translated">読み込まれた要素の要素ツリーから要素が削除されたときに発生します。</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</source>
          <target state="translated">ルーティング イベントを直接ルートに従っていない、発生したが、同じ要素内でのみ処理されます。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">ルーティング イベントがその他のルーティング イベントの動作をサポートして直接: アクセスできるハンドラーのコレクションをサポートし、として使用できる、<ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph>スタイルでします。</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Routed Event Information</source>
          <target state="translated">ルーティングされたイベント情報</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Identifier field</source>
          <target state="translated">識別子のフィールド</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Routing strategy</source>
          <target state="translated">ルーティング方法</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Direct</source>
          <target state="translated">直接</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Delegate</source>
          <target state="translated">Delegate</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.UnloadedEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Unloaded" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Unloaded" /&gt;</ph> (<bpt id="p1">[</bpt>Routed Events Overview (ルーティング イベントの概要)<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>) を識別します。</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.UnloadedEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">ルーティング イベントが登録されているときに、イベントの識別子のオブジェクトは作成されます (を参照してください<ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) クラス ハンドラーを追加するために使用する (を参照してください<ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.UnloadedEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">識別子のオブジェクトには、識別名、所有者型、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれています。</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)">
          <source>Name of the name-object pair to remove from the current scope.</source>
          <target state="translated">現在のスコープから削除する名前とオブジェクトのペアの名前。</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)">
          <source>Simplifies access to the <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph> de-registration method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph> の登録解除メソッドへのアクセスを簡略化します。</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)">
          <source>You only need to un-register names if you intend to re-register another element with that same name.</source>
          <target state="translated">だけで済みます名の登録解除に同じ名前の別の要素を再登録する場合。</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle">
          <source>Reapplies the default style to the current <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> に既定のスタイルを再度適用します。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>