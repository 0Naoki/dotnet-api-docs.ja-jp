<Type Name="Window" FullName="System.Windows.Window">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="18b8587f980d0acb728aa15391718e914c03a226" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37490040" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <TypeSignature Language="F#" Value="type Window = class&#xA;    inherit ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides the ability to create, configure, show, and manage the lifetime of windows and dialog boxes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーとスタンドアロン アプリケーションの間の対話ポイントは、ウィンドウです。 A[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]ウィンドウは 2 つの領域で構成されます。  
  
-   非クライアント領域で、アイコン、タイトル、システムのメニューなど、windows の表示要素をホストするボタンを最小化し、ボタン、[復元] ボタン、閉じるボタン、および罫線を最大化します。  
  
-   アプリケーション固有のコンテンツをホストするクライアント領域。  
  
 標準のウィンドウは、次の図に示されます。  
  
 ![ウィンドウ要素](~/add/media/windowoverviewfigure1.PNG "ウィンドウ要素")  
  
 <xref:System.Windows.Window> 作成、構成、表示、および windows とダイアログ ボックスの両方の有効期間を管理する機能をカプセル化し、次の主要サービスを提供します。  
  
 **有効期間管理**: <xref:System.Windows.Window.Activate%2A>、 <xref:System.Windows.Window.Activated>、 <xref:System.Windows.Window.Close%2A>、 <xref:System.Windows.Window.Closed>、 <xref:System.Windows.Window.Closing>、 <xref:System.Windows.Window.Deactivated>、 <xref:System.Windows.Window.Hide%2A>、 <xref:System.Windows.Window.IsActive%2A>、 <xref:System.Windows.Window.Show%2A>、<xref:System.Windows.Window.SourceInitialized>します。  
  
 **ウィンドウ管理**: <xref:System.Windows.Window.GetWindow%2A>、 <xref:System.Windows.Window.OwnedWindows%2A>、<xref:System.Windows.Window.Owner%2A>します。  
  
 **外観と動作**: <xref:System.Windows.Window.AllowsTransparency%2A>、 <xref:System.Windows.Window.ContentRendered>、 <xref:System.Windows.Window.DragMove%2A>、 <xref:System.Windows.Window.Icon%2A>、 <xref:System.Windows.Window.Left%2A>、 <xref:System.Windows.Window.LocationChanged>、 <xref:System.Windows.Window.ResizeMode%2A>、 <xref:System.Windows.Window.RestoreBounds%2A>、 <xref:System.Windows.Window.ShowActivated%2A>、 <xref:System.Windows.Window.ShowInTaskbar%2A>、 <xref:System.Windows.Window.SizeToContent%2A>、<xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A>  
  
 **ダイアログ ボックス**: <xref:System.Windows.Window.DialogResult%2A>、<xref:System.Windows.Window.ShowDialog%2A>します。  
  
 さらに、<xref:System.Windows.Application>のすべてのアプリケーションでウィンドウを管理するための特別なサポートが公開されます。  
  
-   アプリケーションでは、現在、アプリケーションでインスタンス化されているすべてのウィンドウの一覧を保持します。 この一覧がによって公開されている、<xref:System.Windows.Application.Windows%2A>プロパティ。  
  
-   既定では、<xref:System.Windows.Application.MainWindow%2A>最初への参照を自動的に設定されて<xref:System.Windows.Window>でアプリケーションをインスタンス化されます。 そのため、このウィンドウ アプリケーションのメイン ウィンドウ。  
  
 A<xref:System.Windows.Window>マークアップ、マークアップと分離コード、またはコードを使用して実装することができます。  
  
 <xref:System.Windows.Window> windows とスタンドアロン アプリケーションのダイアログ ボックスを表示する主に使用します。 ただし、ウィザードなど、ウィンドウ レベルのナビゲーションを必要とするアプリケーションを使用できます<xref:System.Windows.Navigation.NavigationWindow>代わりにします。<xref:System.Windows.Navigation.NavigationWindow>から派生した<xref:System.Windows.Window>ブラウザー スタイルのナビゲーションのサポートで拡張されています。  
  
> [!NOTE]
>  ナビゲート可能なコンテンツの諸島を使用して他のコンテンツとコンテンツのコンテナーに組み込める<xref:System.Windows.Controls.Frame>します。  
  
 <xref:System.Windows.Window> 必要がある`UnmanagedCode`インスタンス化するためのセキュリティ アクセス許可。 これは、次の結果があります。  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]-展開済みのスタンドアロン アプリケーションは、インターネットまたはローカル イントラネット ゾーンから起動すると、アクセス許可の昇格を要求します。  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] 何も要求未満の完全なアクセス許可では、ウィンドウやダイアログ ボックスをインスタンス化できません。  
  
 スタンドアロン アプリケーションの配置とセキュリティに関する考慮事項については、次を参照してください。 [WPF のセキュリティ方針 - プラットフォーム セキュリティ](~/docs/framework/wpf/wpf-security-strategy-platform-security.md)します。  
  
 A<xref:System.Windows.Window>は、 <xref:System.Windows.Controls.ContentControl>、つまり、ある任意の型 (文字列、イメージ、パネルなど) の 1 つのオブジェクトを含めることができます。 詳細については、<xref:System.Windows.Controls.ContentControl> クラスを参照してください。 また、<xref:System.Windows.Window>はルート要素であり、そのため、もう 1 つの要素のコンテンツの一部をすることはできません。  
  
> [!NOTE]
>  <xref:System.Windows.FrameworkElement.Height%2A>、 <xref:System.Windows.FrameworkElement.Width%2A>、 <xref:System.Windows.Window.Top%2A>、および<xref:System.Windows.Window.Left%2A>に設定されたプロパティ、<xref:System.Windows.Window>スタイルでは適用されません実行時にします。  
  
## <a name="customizing-the-window-control"></a>ウィンドウ コントロールのカスタマイズ  
 複数に同じプロパティの設定を適用する<xref:System.Windows.Window>コントロールを使用して、<xref:System.Windows.FrameworkElement.Style%2A>プロパティ。 既定値を変更する<xref:System.Windows.Controls.ControlTemplate>固有の外観を制御します。 作成の詳細については、<xref:System.Windows.Controls.ControlTemplate>を参照してください[ControlTemplate の作成による既存のコントロールの外観のカスタマイズ](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md)します。  パーツとに固有の状態を表示する、<xref:System.Windows.Window>を参照してください[ウィンドウのスタイルとテンプレート](~/docs/framework/wpf/controls/window-styles-and-templates.md)します。  
  
 コントロールの既定のスタイルでは、このコントロールの依存関係プロパティを設定する可能性があります。  プロパティが既定のスタイルによって設定されている場合は、アプリケーションでコントロールが表示されたら、既定値から、プロパティが変更可能性があります。 デスクトップ テーマでは、アプリケーションが実行されている場合は、使用、既定のスタイルが決定されます。  詳細については、次を参照してください。[既定の WPF テーマ](http://go.microsoft.com/fwlink/?LinkID=158252)します。  
  
> [!NOTE]
>  ビジュアルのプロパティの設定はのみ、効果がそのプロパティが両方に存在する場合は<xref:System.Windows.Window>コントロールの既定のテンプレートとを使用して設定をします。 "を変更するビジュアル構造体のコントロールのセクションではビジュアルのプロパティの一覧を検索できます[ControlTemplate の作成による既存のコントロールの外観のカスタマイズ](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md)します。  
  
   
  
## Examples  
 次の例は、ウィンドウの標準的なのマークアップのみを使用して定義します。  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 コードのみを使用して標準的なウィンドウを定義する方法を例を次に示します。  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 次の例は、標準的なウィンドウのマークアップと分離コードの組み合わせを使用して定義します。  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Window" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンス トラクターによって初期化、 <xref:System.Windows.FrameworkElement.Width%2A>、 <xref:System.Windows.FrameworkElement.Height%2A>、 <xref:System.Windows.Window.Top%2A>、および<xref:System.Windows.Window.Left%2A>プロパティの既定値に<xref:System.Windows.Window>値。  
  
 内で、ウィンドウが作成された場合、<xref:System.AppDomain>を持つ、<xref:System.Windows.Application>オブジェクトのコンス トラクターを追加、<xref:System.Windows.Window>オブジェクトのセットを<xref:System.Windows.Application>-を使用して windows の管理、<xref:System.Windows.Application.Windows%2A>のプロパティ、<xref:System.Windows.Application>オブジェクト。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">安全でないネイティブ メソッドを呼び出すには、このオブジェクトで許可します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberSignature Language="F#" Value="member this.Activate : unit -&gt; bool" Usage="window.Activate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attempts to bring the window to the foreground and activates it.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:System.Windows.Window" /> was successfully activated; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ウィンドウがアクティブになっているかどうかを決定するルールで使用されるものと同じ、 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow`関数 (User32.dll)。  
  
 ユーザーのフォア グラウンドのアプリケーションではない Windows Presentation Foundation アプリケーションで、ウィンドウがアクティブの場合<xref:System.Windows.Application.Activated>イベントが発生します。  
  
> [!NOTE]
>  ウィンドウが、ブラウザーでホストされている場合、このメソッドを呼び出すことはできません。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">ウィンドウをアクティブ化する権限。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a window becomes the foreground window.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ウィンドウがアクティブ化 (前面のウィンドウになります) と。  
  
-   ウィンドウを最初に開きます。  
  
-   ユーザーは、ALT + TAB キーを押す、マウスまたはタスク マネージャーから選択して、ウィンドウに切り替わります。  
  
-   ユーザーは、ウィンドウのタスク バー ボタンをクリックします。  
  
 アクティブ化になるタイミングを検出する必要がある Windows が処理できる、<xref:System.Windows.Window.Activated>イベント。  
  
 ウィンドウが最初に有効化後に非アクティブ化し、その有効期間中に何度も再アクティブ化することがあります。 アプリケーションの動作や状態は、そのアクティブ化の状態に依存する場合は調査できます<xref:System.Windows.Window.IsActive%2A>内にあるどのライセンス認証状態を確認します。  
  
 アプリケーションがあることができますも<xref:System.Windows.Application.Activated>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowsTransparency : bool with get, set" Usage="System.Windows.Window.AllowsTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a window's client area supports transparency.</summary>
        <value>
          <see langword="true" /> ウィンドウは、透過性をサポートしている場合それ以外の場合、<see langword="false" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Windows.Controls.Control.Background%2A>ウィンドウのプロパティを透明に設定されてを使用したカラー<xref:System.Windows.Media.Brushes.Transparent%2A>など、ウィンドウは非透過的なままです。 つまり、デスクトップと"ウィンドウの下に"に、実行中のアプリケーションを表示できません。 この種類の透明度を有効にする<xref:System.Windows.Window.AllowsTransparency%2A>に設定する必要があります`true`します。  
  
 <xref:System.Windows.Window.AllowsTransparency%2A> 四角形以外の windows の作成を使用して、その結果、ときに<xref:System.Windows.Window.AllowsTransparency%2A>に設定されている`true`、ウィンドウの<xref:System.Windows.Window.WindowStyle%2A>にプロパティを設定する必要があります<xref:System.Windows.WindowStyle.None>します。  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A window that has a <see cref="P:System.Windows.Window.WindowStyle" /> value of anything other than <see cref="F:System.Windows.WindowStyle.None" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowsTransparencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.AllowsTransparencyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.AllowsTransparency" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">A <see cref="T:System.Windows.Size" /> that reflects the final size that the window should use to arrange itself and its children.</param>
        <summary>Override this method to arrange and size a window and its child elements.</summary>
        <returns>A <see cref="T:System.Windows.Size" /> that reflects the actual size that was used.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A> ときに呼び出されません、<xref:System.Windows.UIElement.Visibility%2A>プロパティの値を持つ<xref:System.Windows.Visibility.Collapsed>します。 場合の値、<xref:System.Windows.UIElement.Visibility%2A>プロパティが<xref:System.Windows.Visibility.Hidden>または<xref:System.Windows.Visibility.Visible>、<xref:System.Windows.Window.ArrangeOverride%2A>が呼び出されます。  
  
> [!NOTE]
>  ときにいずれか<xref:System.Windows.Window.Show%2A>または<xref:System.Windows.Window.ShowDialog%2A>が呼び出される、<xref:System.Windows.UIElement.Visibility%2A>のプロパティを<xref:System.Windows.Window>に設定されている<xref:System.Windows.Visibility.Visible>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="window.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Manually closes a <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Window> 、いくつかのいずれかを使用して閉じることがよく知られている、システム指定のメカニズムにあるタイトル バーを含みます。  
  
-   ALT キーを押しながら F4 キー。  
  
-   システム メニュー &#124; **閉じる**します。  
  
-   **閉じる**ボタンをクリックします。  
  
 A<xref:System.Windows.Window>など、開発者によって提供されるクライアント領域内のいくつかのよく知られているメカニズムのいずれかを使用して終了することもできます。  
  
-   **ファイル** &#124; **終了**メイン ウィンドウにします。  
  
-   **ファイル** &#124; **閉じる**または**閉じる**子ウィンドウにボタンをクリックします。  
  
> [!NOTE]
>  **Ok**と**キャンセル** ダイアログ ボックスのボタンのでは、開発者が提供もが可能性は<xref:System.Windows.Window.DialogResult%2A>、呼び出すことによって開かれたウィンドウを自動的に終了する<xref:System.Windows.Window.ShowDialog%2A>します。  
  
 これらのメカニズムを必要とすると、明示的に呼び出す<xref:System.Windows.Window.Close%2A>ウィンドウを閉じます。  
  
> [!NOTE]
>  呼び出すことによって、ウィンドウが開かれている場合<xref:System.Windows.Window.ShowDialog%2A>を使用して、<xref:System.Windows.Controls.Button>でその<xref:System.Windows.Controls.Button.IsCancel%2A>プロパティを true に設定をボタンがクリックされたか、または esc キーが押されたときに自動的に閉じます。 使用して、ウィンドウが開かれた場合<xref:System.Windows.Window.Show%2A>、ただし、<xref:System.Windows.Window.Close%2A>からこのような明示的に呼び出す必要があります<xref:System.Windows.Controls.Primitives.ButtonBase.Click>のイベント ハンドラー、<xref:System.Windows.Controls.Button>します。  
  
 ウィンドウを閉じると、<xref:System.Windows.Window.Closing>イベントが発生します。 場合、<xref:System.Windows.Window.Closing>イベントがキャンセルされていない、次に発生します。  
  
-   <xref:System.Windows.Window>から削除されます<xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType>(場合、<xref:System.Windows.Application>オブジェクトが存在します)。  
  
-   <xref:System.Windows.Window>所有者から削除されます<xref:System.Windows.Window>所有者と所有関係が確立されている場合、所有する前に<xref:System.Windows.Window>が表示されたと所有者後<xref:System.Windows.Window>が開かれました。  
  
-   <xref:System.Windows.Window.Closed> イベントが発生します。  
  
-   アンマネージ リソースによって作成された、<xref:System.Windows.Window>破棄されます。  
  
-   場合<xref:System.Windows.Window.ShowDialog%2A>を表示すると呼ばれますが、 <xref:System.Windows.Window>、<xref:System.Windows.Window.ShowDialog%2A>を返します。  
  
 閉じる、<xref:System.Windows.Window>が原因で終了する、所有する任意の windows。 さらに、終了、<xref:System.Windows.Window>方法に応じて実行を停止するアプリケーションが生じる<xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType>プロパティを設定します。  
  
> [!NOTE]
>  ウィンドウが、ブラウザーでホストされている場合、このメソッドを呼び出すことはできません。  
  
   
  
## Examples  
 次の例は、**ファイル** &#124; **終了**を明示的に呼び出す処理されているメニュー<xref:System.Windows.Window.Close%2A>します。  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">使用することができますをアプリケーションの起動時に UI リソースを自動的に読み込みます。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : EventHandler " Usage="member this.Closed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the window is about to close.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントが発生すると、ウィンドウが閉じるを防ぐことはできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.UIElement.Visibility" /> is set, or <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" />, or <see cref="M:System.Windows.Window.Hide" /> is called while a window is closing.</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberSignature Language="F#" Value="member this.Closing : System.ComponentModel.CancelEventHandler " Usage="member this.Closing : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs directly after <see cref="M:System.Windows.Window.Close" /> is called, and can be handled to cancel window closure.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing> ウィンドウが閉じるときに検出するために処理することができます (ときなど、<xref:System.Windows.Window.Close%2A>と呼びます)。 さらに、<xref:System.Windows.Window.Closing>ウィンドウが終了されないようにするために使用できます。 ウィンドウを閉じるを防ぐために、設定することができます、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>のプロパティ、<xref:System.ComponentModel.CancelEventArgs>引数`true`します。  
  
 <xref:System.Windows.Window.Closing>イベントが発生したときに<xref:System.Windows.Window.Close%2A>と呼ばれる場合は、ウィンドウの閉じるボタンがクリックされた場合、またはユーザーが alt キーを押しながら f4 キーを押した場合。  
  
 その所有者ウィンドウを使用して、所有されているウィンドウを開いたかどうか<xref:System.Windows.Window.Show%2A>、および所有者は、ウィンドウが閉じ、所有しているウィンドウの<xref:System.Windows.Window.Closing>イベントは発生しません。 ウィンドウの所有者が閉じている場合 (を参照してください<xref:System.Windows.Window.Owner%2A>)、<xref:System.Windows.Window.Closing>所有されるウィンドウでは発生しません。  
  
 場合<xref:System.Windows.Application.Shutdown%2A>が呼び出される、<xref:System.Windows.Window.Closing>各ウィンドウのイベントが発生します。 ただし場合、<xref:System.Windows.Window.Closing>が取り消されると、キャンセルが無視されます。  
  
 ユーザーのログオフまたはシャット ダウンするため、セッションが終了する場合<xref:System.Windows.Window.Closing>は発生しません。 処理<xref:System.Windows.Application.SessionEnding>アプリケーション クロージャをキャンセルするコードを実装します。  
  
 複数回、アプリケーションの有効期間中にウィンドウを非表示にしたりして、ウィンドウを毎回再インスタンス化したくない場合は、これを表示する、処理することができます、<xref:System.Windows.Window.Closing>イベント、キャンセルするか、および呼び出し、<xref:System.Windows.Window.Hide%2A>メソッド。 呼び出すことができますし、<xref:System.Windows.Window.Show%2A>で、同じインスタンスをもう一度開いてください。  
  
   
  
## Examples  
 次の例で、<xref:System.Windows.Window>ユーザーの介入を閉じる必要があるかどうかを決定します。  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.UIElement.Visibility" /> is set, or <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" />, or <see cref="M:System.Windows.Window.Close" /> is called while a window is closing.</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" />
      <MemberSignature Language="F#" Value="member this.ContentRendered : EventHandler " Usage="member this.ContentRendered : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after a window's content has been rendered.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンテンツ ウィンドウがない場合は、このイベントは発生しません。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a window becomes a background window.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ウィンドウが非アクティブ化 (バック グラウンド ウィンドウになった) とき。  
  
-   ユーザーは、現在のアプリケーションの別のウィンドウに切り替わります。  
  
-   ユーザーは、ALT キーを押しながら TAB キーを使用して、またはタスク マネージャーを使用して、別のアプリケーション ウィンドウに切り替わります。  
  
-   ユーザーが別のアプリケーションのウィンドウのタスク バー ボタンをクリックします。  
  
 処理することによって、非アクティブになるタイミングを検出する必要がある Windows、<xref:System.Windows.Window.Deactivated>イベント。  
  
 ウィンドウが最初に非アクティブ化後に再アクティブ化し、その有効期間中に何度も非アクティブ化する可能性があります。 アプリケーションの動作や状態は、そのアクティブ化の状態に依存する場合は調査できます<xref:System.Windows.Window.IsActive%2A>内にあるどのライセンス認証状態を確認します。  
  
 アプリケーションがあることができますも<xref:System.Windows.Application.Deactivated>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.DialogResult : Nullable&lt;bool&gt; with get, set" Usage="System.Windows.Window.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the dialog result value, which is the value that is returned from the <see cref="M:System.Windows.Window.ShowDialog" /> method.</summary>
        <value>A<see cref="T:System.Nullable`1" />型の値<see cref="T:System.Boolean" />します。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A> ユーザーが受け入れるかどうかを確認するダイアログ ボックスが映っているコードから使用することができます (`true`) またはキャンセル (`false`) ダイアログ ボックス。 ダイアログ ボックスが承認された場合、ユーザーによって収集されたデータを取得し、それを処理するには、ダイアログ ボックスを開いたコードにこのことを示します。 ダイアログ ボックスが取り消された場合、このことを示しますコードの呼び出しを停止する追加の処理します。  
  
 既定では、ユーザーが、次のいずれかと、ダイアログ ボックスが取り消されました。  
  
-   PressesALT + f4 キー。  
  
-   クリックする、**閉じる**ボタンをクリックします。  
  
-   選択**閉じる**システム メニュー。  
  
 このような場合は、のすべての<xref:System.Windows.Window.DialogResult%2A>は`false`既定。  
  
 ダイアログ ボックスは、通常、ボタンは、ダイアログ ボックスをキャンセルする特殊なボタンを提供します。 ある<xref:System.Windows.Controls.Button.IsCancel%2A>プロパティに設定されて`true`します。 このように構成されているボタンが押されたか、または ESC キーが押されたときに、ウィンドウは自動的に閉じます。 このような場合は、のいずれかで<xref:System.Windows.Window.DialogResult%2A>まま`false`します。  
  
 ダイアログ ボックスも通常は、承認ボタンを提供します。 ある<xref:System.Windows.Controls.Button.IsDefault%2A>プロパティに設定されて`true`します。 このように構成されているボタンを発生させる、<xref:System.Windows.Controls.Primitives.ButtonBase.Click>か、ENTER キーが押されたときにイベント。 ただし、ダイアログ ボックスで、自動的に閉じますも設定は<xref:System.Windows.Window.DialogResult%2A>に`true`します。 このコードをから通常は手動で作成する必要がある、<xref:System.Windows.Controls.Primitives.ButtonBase.Click>既定のボタンのイベント ハンドラー。  
  
 <xref:System.Windows.Window.DialogResult%2A> `null`  ダイアログ ボックスが表示されている場合、許容されるも取り消されました。  
  
 ダイアログ ボックスを閉じた後は、によって返される値からダイアログの結果を取得できます<xref:System.Windows.Window.ShowDialog%2A>メソッド、またはを調べることによって、<xref:System.Windows.Window.DialogResult%2A>プロパティ。  
  
 <xref:System.Windows.Window.DialogResult%2A> のみ設定できる場合に、<xref:System.Windows.Window>が呼び出すことによって開かれたその<xref:System.Windows.Window.ShowDialog%2A>メソッド。  
  
> [!NOTE]
>  設定またはウィンドウが、ブラウザーでホストされている場合は、このプロパティを取得することはできません。  
  
   
  
## Examples  
 次の例は、[ok] ボタンと [キャンセル] ボタンを返す適切なを構成する方法を示します<xref:System.Windows.Window.DialogResult%2A>します。  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Window.DialogResult" /> is set before a window is opened by calling <see cref="M:System.Windows.Window.ShowDialog" />.  -or-  <see cref="P:System.Windows.Window.DialogResult" /> is set on a window that is opened by calling <see cref="M:System.Windows.Window.Show" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberSignature Language="F#" Value="member this.DpiChanged : System.Windows.DpiChangedEventHandler " Usage="member this.DpiChanged : System.Windows.DpiChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after the DPI of the screen on which the Window is displayed changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DpiChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Window.DpiChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A <see cref="T:System.Windows.RoutedEvent" /> for when the DPI of the screen the Window is on changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberSignature Language="F#" Value="member this.DragMove : unit -&gt; unit" Usage="window.DragMove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Allows a window to be dragged by a mouse with its left button down over an exposed area of the window's client area.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウスの左ボタンがダウンする必要があります<xref:System.Windows.Window.DragMove%2A>が呼び出されます。 マウスの左ボタンが押されたときを検出する方法の 1 つが処理するためには、<xref:System.Windows.UIElement.MouseLeftButtonDown>イベント。  
  
 ときに<xref:System.Windows.Window.DragMove%2A>を呼び出すと、左側のウィンドウのクライアント領域の表示部分にマウス ボタンを押されている必要があります。  
  
> [!NOTE]
>  ウィンドウが、ブラウザーでホストされている場合、このメソッドを呼び出すことはできません。  
  
   
  
## Examples  
 次の例は、オーバーライドする方法を示します<xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>を呼び出す<xref:System.Windows.Window.DragMove%2A>します。  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The left mouse button is not down.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">ウィンドウをドラッグするアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetWindow : System.Windows.DependencyObject -&gt; System.Windows.Window" Usage="System.Windows.Window.GetWindow dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">The dependency object.</param>
        <summary>Returns a reference to the <see cref="T:System.Windows.Window" /> object that hosts the content tree within which the dependency object is located.</summary>
        <returns>A <see cref="T:System.Windows.Window" /> reference to the host window.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencyObject" /> is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="window.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Makes a window invisible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非表示になって、ときに、ウィンドウが閉じられていませんし、どちらも、<xref:System.Windows.Window.Closing>も<xref:System.Windows.Window.Closed>イベントが発生します。 代わりに、ウィンドウの<xref:System.Windows.UIElement.Visibility%2A>プロパティに設定されて<xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>します。  
  
 ウィンドウが、アプリケーションの場合は<xref:System.Windows.Application.MainWindow%2A>とアプリケーションの<xref:System.Windows.Application.ShutdownMode%2A>は<xref:System.Windows.ShutdownMode.OnMainWindowClose>アプリケーションがシャット ダウンしません。 同様に、アプリケーションはシャット ダウンされず、ウィンドウのみのウィンドウでは、アプリケーションのシャット ダウン モード場合<xref:System.Windows.ShutdownMode.OnLastWindowClose>します。  
  
 複数回、アプリケーションの有効期間中にウィンドウを非表示にしたりするたびに、ウィンドウを再インスタンス化したくない場合を表示する、処理できる、<xref:System.Windows.Window.Closing>イベント、キャンセルするか、および呼び出し、<xref:System.Windows.Window.Hide%2A>メソッド。 呼び出すことができますし、<xref:System.Windows.Window.Show%2A>を再び開くには、同一のインスタンスにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Hide" /> is called on a window that is closing (<see cref="E:System.Windows.Window.Closing" />) or has been closed (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Icon : System.Windows.Media.ImageSource with get, set" Usage="System.Windows.Window.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a window's icon.</summary>
        <value>
          <see cref="T:System.Windows.Media.ImageSource" />アイコンを表すオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows Presentation Foundation (WPF) スタンドアロン アプリケーションでは、2 種類のアイコンがあります。  
  
-   1 つのアセンブリのアイコンを使用して指定されている、`<ApplicationIcon>`アプリケーションのプロジェクトのプロパティは、ファイルをビルドします。 このアイコンは、アセンブリのデスクトップのアイコンとして使用されます。  
  
    > [!NOTE]
    >  Visual Studio で、デバッグ時に、ホスティング プロセスにより、アイコンが表示されません。 実行可能ファイルを実行する場合、アイコンが表示されます。 詳細については、「[ホスト プロセス (vshost.exe)](http://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b)」を参照してください。  
  
-   1 つのアイコンを設定して指定されているウィンドウあたり<xref:System.Windows.Window.Icon%2A>します。 各ウィンドウのタイトル バー、タスク バー ボタン、およびその ALT TAB アプリケーション選択リストのエントリにこのアイコンが使用されます。  
  
 常に、WPF ウィンドウには、アイコンが表示されます。 設定して指定されていないときに<xref:System.Windows.Window.Icon%2A>WPF は、次の規則に基づいて表示するアイコンを選択します。  
  
1.  指定した場合は、アセンブリのアイコンを使用します。  
  
2.  アセンブリのアイコンが指定されていない場合は、Microsoft Windows の既定のアイコンを使用します。  
  
 使用する場合<xref:System.Windows.Window.Icon%2A>カスタム ウィンドウ アイコンを指定するには、設定して既定のアプリケーション アイコンを戻すことができます<xref:System.Windows.Window.Icon%2A>に`null`します。  
  
 1 つのアイコンは、さまざまなウィンドウ、ウィンドウ、ALT キーを押しながら TAB キー ファイルの選択リストのタスク バーのタイトル バーに表示されているなど、Windows での方法で使用できます。 これらの異なるサイズを使用してアイコンが表示されます。ALT キーを押しながら TAB キー ファイルの選択リストのサイズは 32 x 32 ピクセルのアイコンが表示されますが、ウィンドウのタイトル バーでは、タスク バーで、16 x 16 ピクセルのアイコンが表示されます。 などの一部のアプリケーションでは、 [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)]、提供、**ビュー**メニューを表示するアイコンのサイズを選択することができます。  
  
 さまざまな画面サイズに対応する、アイコン ファイルは 1 つまたは複数の実際アイコンを使用して、それぞれが特定のサイズと色深度を対象とするアイコンのバージョンを表すので構成されます。 たとえば、16 x 16 ピクセルと 16 色のカラーと 256 色の両方でのサイズは 32 x 32 ピクセルのアイコンには別、1 つのアイコンは 16 色が、1 つの 16 x 16 ピクセル アイコンを必要のみがあります。  
  
 アイコン ファイル内のすべての可能なサイズと色深度を示すアイコンが存在する場合<xref:System.Windows.Window>該当するアイコンを使用します。 アイコン ファイルには、すべての可能なアイコンのサブセットのみが含まれている場合<xref:System.Windows.Window>サイズと色の解像度が高い順に次の最も適切なアイコンが使用されます。  
  
 結果はアイコンが常に使用されます<xref:System.Windows.Window>、表示されるアイコンは、必要なサイズと色の深度を対象可能性があります。 たとえば、16 色の 16 x 16 ピクセルのアイコンは、256 色のサイズは 32 x 32 ピクセルのアイコンとして表示に使用可能性があります。 これにより、保たれますなどの望ましくない視覚効果が発生することができますが、すべてのサイズと色深度のアイコンを作成することによって回避できます。  
  
> [!NOTE]
>  設定またはウィンドウが、ブラウザーでホストされている場合は、このプロパティを取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.Window.IconProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次の例では、[ウィンドウ] アイコンを設定する方法を示します。  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">アイコンの設定にアクセスを許可します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IconProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IconProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.Icon" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsActive : bool" Usage="System.Windows.Window.IsActive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the window is active.</summary>
        <value>
          <see langword="true" /> ウィンドウがアクティブである場合それ以外の場合、<see langword="false" />します。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アクティブなウィンドウは、ユーザーの現在の前面のウィンドウであり、フォーカスは、アクティブなタイトル バーの外観では表されます。 アクティブなウィンドウは明示的に設定されていないすべてのトップレベル ウィンドウの最上位にもなります、<xref:System.Windows.Window.Topmost%2A>プロパティ。  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.Window.IsActiveProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsActiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IsActiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.IsActive" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Left : double with get, set" Usage="System.Windows.Window.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the position of the window's left edge, in relation to the desktop.</summary>
        <value>ウィンドウの位置の左端の論理単位 (1/96 インチ)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Windows.Window>最大化または最小化、復元の左端のポイントをこの値は、<xref:System.Windows.Window>します。  
  
 このプロパティは、スタイルを設定できません。  
  
 値を指定しない場合<xref:System.Windows.Window.Left%2A>システムの既定値に設定されます。 設定して、システムの既定値を指定することも<xref:System.Windows.Window.Left%2A>に<xref:System.Double.NaN>します。 どちらも<xref:System.Double.NegativeInfinity>も<xref:System.Double.PositiveInfinity>の有効な値は、<xref:System.Windows.Window.Left%2A>します。  
  
> [!NOTE]
>  設定またはウィンドウが、ブラウザーでホストされている場合は、このプロパティを取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.Window.LeftProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LeftProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.Left" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the window's location changes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ウィンドウの場所は、ときに変更します。  
  
-   ユーザーは、ウィンドウのタイトル バーをドラッグして、ウィンドウを移動します。  
  
-   後に、ウィンドウが移動<xref:System.Windows.Window.DragMove%2A>が呼び出されます。  
  
-   いずれか、<xref:System.Windows.Window.Left%2A>または<xref:System.Windows.Window.Top%2A>プロパティをプログラムで設定します。  
  
-   **移動**ウィンドウのシステム メニューのメニュー項目を選択します。  
  
-   <xref:System.Windows.Window.WindowState%2A>プロパティを変更します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Window.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an enumerator for a window's logical child elements.</summary>
        <value>
          <see cref="T:System.Collections.IEnumerator" />ウィンドウの論理上の子要素。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">A <see cref="T:System.Windows.Size" /> that reflects the available size that this window can give to the child. Infinity can be given as a value to indicate that the window will size to whatever content is available.</param>
        <summary>Override this method to measure the size of a window.</summary>
        <returns>A <see cref="T:System.Windows.Size" /> that reflects the size that this window determines it needs during layout, based on its calculations of children's sizes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A> ときに呼び出されません、<xref:System.Windows.UIElement.Visibility%2A>プロパティの値を持つ<xref:System.Windows.Visibility.Collapsed>します。 場合の値、<xref:System.Windows.UIElement.Visibility%2A>プロパティが<xref:System.Windows.Visibility.Hidden>または<xref:System.Windows.Visibility.Visible>、<xref:System.Windows.Window.MeasureOverride%2A>が呼び出されます。  
  
> [!NOTE]
>  ときにいずれか<xref:System.Windows.Window.Show%2A>または<xref:System.Windows.Window.ShowDialog%2A>が呼び出される、<xref:System.Windows.UIElement.Visibility%2A>のプロパティを<xref:System.Windows.Window>に設定されている<xref:System.Windows.Visibility.Visible>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="window.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.Activated" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnActivated%2A> は、<xref:System.Windows.Window.Activated> イベントを発生させます。  
  
 派生した型<xref:System.Windows.Window>よりも優先<xref:System.Windows.Window.OnActivated%2A>します。 オーバーライドされたメソッドを呼び出す必要があります<xref:System.Windows.Window.OnActivated%2A>基本クラスの場合は<xref:System.Windows.Window.Activated>を発生させる必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : EventArgs -&gt; unit&#xA;override this.OnClosed : EventArgs -&gt; unit" Usage="window.OnClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.Closed" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosed%2A> は、<xref:System.Windows.Window.Closed> イベントを発生させます。  
  
 派生した型<xref:System.Windows.Window>よりも優先<xref:System.Windows.Window.OnClosed%2A>します。 オーバーライドされたメソッドを呼び出す必要があります<xref:System.Windows.Window.OnClosed%2A>基本クラスの場合は<xref:System.Windows.Window.Closed>を発生させる必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="window.OnClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.ComponentModel.CancelEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.Closing" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosing%2A> は、<xref:System.Windows.Window.Closing> イベントを発生させます。  
  
 派生した型<xref:System.Windows.Window>よりも優先<xref:System.Windows.Window.OnClosing%2A>します。 オーバーライドされたメソッドを呼び出す必要があります<xref:System.Windows.Window.OnClosing%2A>基本クラスの場合は<xref:System.Windows.Window.Closing>を発生させる必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberSignature Language="F#" Value="override this.OnContentChanged : obj * obj -&gt; unit" Usage="window.OnContentChanged (oldContent, newContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">A reference to the root of the old content tree.</param>
        <param name="newContent">A reference to the root of the new content tree.</param>
        <summary>Called when the <see cref="P:System.Windows.Controls.ContentControl.Content" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentRendered : EventArgs -&gt; unit&#xA;override this.OnContentRendered : EventArgs -&gt; unit" Usage="window.OnContentRendered e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.ContentRendered" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnContentRendered%2A> は、<xref:System.Windows.Window.ContentRendered> イベントを発生させます。  
  
 派生した型<xref:System.Windows.Window>よりも優先<xref:System.Windows.Window.OnContentRendered%2A>します。 オーバーライドされたメソッドを呼び出す必要があります<xref:System.Windows.Window.OnContentRendered%2A>基本クラスの場合は<xref:System.Windows.Window.ContentRendered>を発生させる必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="window.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates and returns a <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> object for this <see cref="T:System.Windows.Window" />.</summary>
        <returns>A <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> object for this <see cref="T:System.Windows.Window" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="window.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.Deactivated" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnDeactivated%2A> は、<xref:System.Windows.Window.Deactivated> イベントを発生させます。  
  
 派生した型<xref:System.Windows.Window>よりも優先<xref:System.Windows.Window.OnDeactivated%2A>します。 オーバーライドされたメソッドを呼び出す必要があります<xref:System.Windows.Window.OnDeactivated%2A>基本クラスの場合は<xref:System.Windows.Window.Deactivated>を発生させる必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit&#xA;override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="window.OnDpiChanged (oldDpi, newDpi)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">The previous DPI scale setting.</param>
        <param name="newDpi">The new DPI scale setting.</param>
        <summary>Called when the DPI at which this window is rendered changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="window.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.LocationChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnLocationChanged%2A> は、<xref:System.Windows.Window.LocationChanged> イベントを発生させます。  
  
 派生した型<xref:System.Windows.Window>よりも優先<xref:System.Windows.Window.OnLocationChanged%2A>します。 オーバーライドされたメソッドを呼び出す必要があります<xref:System.Windows.Window.OnLocationChanged%2A>基本クラスの場合は<xref:System.Windows.Window.LocationChanged>を発生させる必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit" Usage="window.OnManipulationBoundaryFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The data for the event.</param>
        <summary>Called when the <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> event occurs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この実装では、処理済みの状態は変更されません (、<xref:System.Windows.RoutedEventArgs.Handled%2A>プロパティ) の<xref:System.Windows.UIElement.ManipulationBoundaryFeedback>イベント データ。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />、常基本実装を呼び出して、<see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />実装します。基本の実装の呼び出しに失敗すると、基底クラスが、最後のクラスの実行時の動作が変わる可能性のあるイベントを処理できなくなります。要件に応じて前に、または後、特別な処理の基本実装を呼び出すことができます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSourceInitialized : EventArgs -&gt; unit&#xA;override this.OnSourceInitialized : EventArgs -&gt; unit" Usage="window.OnSourceInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.SourceInitialized" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnSourceInitialized%2A> は、<xref:System.Windows.Window.SourceInitialized> イベントを発生させます。  
  
 派生した型<xref:System.Windows.Window>よりも優先<xref:System.Windows.Window.OnSourceInitialized%2A>します。 オーバーライドされたメソッドを呼び出す必要があります<xref:System.Windows.Window.OnSourceInitialized%2A>基本クラスの場合は<xref:System.Windows.Window.SourceInitialized>を発生させる必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStateChanged : EventArgs -&gt; unit&#xA;override this.OnStateChanged : EventArgs -&gt; unit" Usage="window.OnStateChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.StateChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnStateChanged%2A> は、<xref:System.Windows.Window.StateChanged> イベントを発生させます。  
  
 派生した型<xref:System.Windows.Window>よりも優先<xref:System.Windows.Window.OnStateChanged%2A>します。 オーバーライドされたメソッドを呼び出す必要があります<xref:System.Windows.Window.OnStateChanged%2A>基本クラスの場合は<xref:System.Windows.Window.StateChanged>を発生させる必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">The previous parent. Set to null if the <see cref="T:System.Windows.DependencyObject" /> did not have a previous parent.</param>
        <summary>Called when the parent of the window is changed.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnedWindows : System.Windows.WindowCollection" Usage="System.Windows.Window.OwnedWindows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a collection of windows for which this window is the owner.</summary>
        <value>A<see cref="T:System.Windows.WindowCollection" />このウィンドウは、所有者、windows への参照を格納しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所有されるウィンドウは、1 つ持つ<xref:System.Windows.Window.Owner%2A>プロパティは、オーナー ウィンドウと呼ばれる別のウィンドウへの参照。 列挙することができます、オーナー ウィンドウを所有するすべての windows を検索する<xref:System.Windows.WindowCollection>によって返される、<xref:System.Windows.Window.OwnedWindows%2A>プロパティ。  
  
   
  
## Examples  
 次の例は、列挙する方法を示しています。<xref:System.Windows.Window.OwnedWindows%2A>します。  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.Window with get, set" Usage="System.Windows.Window.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Windows.Window" /> that owns this <see cref="T:System.Windows.Window" />.</summary>
        <value>A<see cref="T:System.Windows.Window" />これの所有者を表すオブジェクトを<see cref="T:System.Windows.Window" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことによって、親ウィンドウから子ウィンドウが開かれたときに<xref:System.Windows.Window.ShowDialog%2A>親と子の両方のウィンドウ間の暗黙的なリレーションシップが確立します。 この関係を最小限に抑え、最大化、および復元に関してなど、特定の動作が適用されます。  
  
 呼び出すことによって、親ウィンドウによって子ウィンドウが作成されたときに<xref:System.Windows.Window.Show%2A>、ただし、子ウィンドウには、親ウィンドウとの関係はありません。 これによって、次のことが起こります。  
  
-   子ウィンドウには、親ウィンドウへの参照はありません。  
  
-   子ウィンドウの動作は、親ウィンドウの動作に依存しません。いずれかのウィンドウは、最大化し、個別に復元されたは、最小化したり、その他を覆うことができます。  
  
 子ウィンドウと、親ウィンドウの間のリレーションシップを作成できるように<xref:System.Windows.Window>所有権の概念をサポートしています。 所有権が確立されているときに、<xref:System.Windows.Window.Owner%2A>ウィンドウ (所有するウィンドウ) のプロパティが別のウィンドウ (オーナー ウィンドウ) への参照を設定します。  
  
 この関係が確立されると、次の動作が発生します。  
  
-   オーナー ウィンドウを最小化されている場合、所有しているすべての windows も最小化します。  
  
-   所有されるウィンドウを最小化すると、その所有者は最小化されません。  
  
-   オーナー ウィンドウが最大化されている場合は、オーナー ウィンドウとその所有されている windows の両方が復元されます。  
  
-   オーナー ウィンドウでは、所有されるウィンドウをカバーできることはありません。  
  
-   使用していない開いているウィンドウを所有している<xref:System.Windows.Window.ShowDialog%2A>モーダルではありません。 引き続き、ユーザーは、オーナー ウィンドウと対話できます。  
  
-   オーナー ウィンドウを閉じると、所有されるウィンドウも閉じます。  
  
-   その所有者ウィンドウを使用して、所有されているウィンドウを開いたかどうか<xref:System.Windows.Window.Show%2A>、および所有者は、ウィンドウが閉じ、所有しているウィンドウの<xref:System.Windows.Window.Closing>イベントは発生しません。  
  
 呼び出して子ウィンドウを開くと<xref:System.Windows.Window.ShowDialog%2A>も設定する必要があります、<xref:System.Windows.Window.Owner%2A>子ウィンドウのプロパティ。 ない場合は、ユーザーはタスク バー ボタンを押して、ウィンドウの子と親ウィンドウの両方を復元することができません。 代わりに、タスク バー ボタンを押すと生成に選択; の子と親の両方のウィンドウを含む、windows の一覧選択したウィンドウのみが復元されます。  
  
> [!IMPORTANT]
>  設定する必要があります、<xref:System.Windows.Window.Owner%2A>プロパティを呼び出すことで開いているウィンドウを<xref:System.Windows.Window.ShowDialog%2A>で正しい動作を確保します。  
  
> [!NOTE]
>  設定またはウィンドウが、ブラウザーでホストされている場合は、このプロパティを取得することはできません。  
  
   
  
## Examples  
 次の例では、所有者と所有関係を確立する方法を示します。  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A window tries to own itself  -or-  Two windows try to own each other.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Windows.Window.Owner" /> property is set on a visible window shown using <see cref="M:System.Windows.Window.ShowDialog" />  -or-  The <see cref="P:System.Windows.Window.Owner" /> property is set with a window that has not been previously shown.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">使用することができますをアプリケーションの起動時に UI リソースを自動的に読み込みます。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeMode : System.Windows.ResizeMode with get, set" Usage="System.Windows.Window.ResizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the resize mode.</summary>
        <value>A<see cref="T:System.Windows.ResizeMode" />サイズ変更モードを指定する値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の 4 つのオプションがあります。  
  
-   **NoResize**します。 ユーザー、ウィンドウ サイズを変更することはできません。 最大および最小化ボックスは表示されません。  
  
-   **CanMinimize**します。 ユーザーは、のみ、ウィンドウを最小化し、タスク バーから復元できます。 最小化、最大化ボタンは表示されますが最小化ボックスのみが有効にします。  
  
-   **CanResize**します。 ユーザーは、あるボックスに最小化、最大化、およびドラッグ可能なアウトラインをウィンドウの周囲を使用して、ウィンドウのサイズを変更する完全な権限を持ちます。 最小化、最大化ボックスが表示され、有効になっています。 (既定値)。  
  
-   **CanResizeWithGrip**します。 このオプションと同じ機能には<xref:System.Windows.ResizeMode.CanResize>がウィンドウの右下隅に「サイズ変更グリップ」を追加します。  
  
> [!NOTE]
>  設定またはウィンドウが、ブラウザーでホストされている場合は、このプロパティを取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.Window.ResizeModeProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ResizeModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ResizeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.ResizeMode" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.RestoreBounds : System.Windows.Rect" Usage="System.Windows.Window.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the size and location of a window before being either minimized or maximized.</summary>
        <value>A<see cref="T:System.Windows.Rect" />を指定するサイズとウィンドウの位置に最小化または最大化します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 復元の四角形が最小化または最大化する前に、ウィンドウによって占有される領域です。 使用することができます<xref:System.Windows.Window.RestoreBounds%2A>をアプリケーションが閉じられる前に、最後のサイズとウィンドウの位置を保存し、次回のアプリケーションの起動時にユーザー状態の方法は、ウィンドウを復元するこれらの値を取得します。  
  
 照会する場合は<xref:System.Windows.Window.RestoreBounds%2A>ウィンドウが表示される前に、または閉じられた後<xref:System.Windows.Rect.Empty%2A>が返されます。  
  
> [!NOTE]
>  ウィンドウが、ブラウザーでホストされている場合は、このプロパティを取得することはできません。  
  
   
  
## Examples  
 次の例では<xref:System.Windows.Window.RestoreBounds%2A>とストレージ サイズとウィンドウの位置が同じで、ウィンドウが表示される前の時間を分離します。  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">ウィンドウの位置とサイズを照会するためのアクセス許可の外接する四角形。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="window.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opens a window and returns without waiting for the newly opened window to close.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Windows.Window>クラスがインスタンス化は既定では表示されません。 <xref:System.Windows.Window.Show%2A> ウィンドウが表示され、ウィンドウを閉じるを待たず、すぐに返します。 その結果、開いているウィンドウは、アプリケーションの他のウィンドウと対話するからユーザーを妨げません。 ウィンドウのこの型が呼び出される、*モードレス*ウィンドウ。 モードレス ウィンドウの一般的な例は、[プロパティ] ウィンドウ、ツールボックス、およびパレットです。 特定のウィンドウと対話するユーザーを制限する、呼び出すことによって、ウィンドウを開く必要がある<xref:System.Windows.Window.ShowDialog%2A>します。  
  
 呼び出すことによって開かれたウィンドウ<xref:System.Windows.Window.Show%2A>は自動的に開いているウィンドウの関係があります。 具体的には、開かれたウィンドウがわからないどのウィンドウを開いたとき。 使用してこの関係を確立することができます、<xref:System.Windows.Window.Owner%2A>プロパティと管理を使用して、<xref:System.Windows.Window.OwnedWindows%2A>プロパティ。  
  
 呼び出す<xref:System.Windows.Window.Show%2A>の設定と同じ結果を達成<xref:System.Windows.UIElement.Visibility%2A>のプロパティ、<xref:System.Windows.Window>オブジェクトを<xref:System.Windows.Visibility.Visible>します。 ただし、タイミングの観点から 2 つの違いがあります。  
  
 呼び出す<xref:System.Windows.Window.Show%2A>にした場合のみを返す同期操作には、<xref:System.Windows.FrameworkElement.Loaded>子ウィンドウにイベントが発生しました。  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 設定<xref:System.Windows.UIElement.Visibility%2A>、ただし、非同期操作をすぐに返すには。  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 設定するときに<xref:System.Windows.UIElement.Visibility%2A>を設定する前に登録して、ウィンドウ イベント<xref:System.Windows.UIElement.Visibility%2A>設定するメソッドが終了するまでは発生しない可能性があります<xref:System.Windows.UIElement.Visibility%2A>の実行が完了します。  
  
   
  
## Examples  
 次の例では、モードレス ウィンドウを開く方法を示します。  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Show" /> is called on a window that is closing (<see cref="E:System.Windows.Window.Closing" />) or has been closed (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowActivated : bool with get, set" Usage="System.Windows.Window.ShowActivated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a window is activated when first shown.</summary>
        <value>
          <see langword="true" /> ウィンドウがアクティブ化されます。 最初に表示される場合それ以外の場合、<see langword="false" />します。 既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに使用してウィンドウをその<xref:System.Windows.Window.ShowActivated%2A>プロパティに設定`false`が開かれると、ウィンドウはアクティブいないし、その<xref:System.Windows.Window.Activated>ユーザーが手動で選択して、ウィンドウを起動するまで、イベントは発生しません。 ウィンドウを選択すると、アクティブにし、通常を非アクティブ化します。  
  
 ウィンドウが開くときにアクティブ化されないようにする、<xref:System.Windows.Window.ShowActivated%2A>にプロパティを設定する必要があります`false`ウィンドウが表示される前に (呼び出して<xref:System.Windows.Window.Show%2A>) を設定<xref:System.Windows.Window.ShowActivated%2A>に`false`後、ウィンドウが表示される場合は、影響を与えません。  
  
 設定<xref:System.Windows.Window.ShowActivated%2A>に`false`で呼び出すことによって、モーダルで開かれるウィンドウ<xref:System.Windows.Window.ShowDialog%2A>、実際の影響を与えません。 モーダル ウィンドウをアクティブにできませんが、モーダル ウィンドウは、他のアプリケーションの開いているウィンドウをアクティブ化をユーザーをできなくなります。  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.Window.ShowActivatedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次の例では、マークアップを使用してアクティブ化することがなく開かれているウィンドウを構成する方法を示します。  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 次の例では、コードを使用して、ウィンドウを開くことがなくアクティブ化されていることを構成する方法を示します。  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowActivatedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowActivatedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.ShowActivated" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberSignature Language="F#" Value="member this.ShowDialog : unit -&gt; Nullable&lt;bool&gt;" Usage="window.ShowDialog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opens a window and returns only when the newly opened window is closed.</summary>
        <returns>A <see cref="T:System.Nullable`1" /> value of type <see cref="T:System.Boolean" /> that specifies whether the activity was accepted (<see langword="true" />) or canceled (<see langword="false" />). The return value is the value of the <see cref="P:System.Windows.Window.DialogResult" /> property before a window closes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Windows.Window>クラスがインスタンス化は既定では表示されません。 <xref:System.Windows.Window.ShowDialog%2A> ウィンドウを示しています、アプリケーションでは、その他のすべての windows を無効にし、ウィンドウが閉じられたときにのみを返します。 この種類のウィンドウと呼ばれる、*モーダル*ウィンドウ。  
  
 モーダル ウィンドウは、ダイアログ ボックスとして主に使用されます。 ダイアログ ボックスは特殊なファイルを開くまたはドキュメントの印刷などのタスクを実行するユーザーと対話するアプリケーションで使用されるウィンドウです。 ダイアログ ボックスには、よくを受け入れるか、ダイアログ ボックスを閉じる前に、表示されているタスクを取り消すユーザーができるようにします。 <xref:System.Windows.Window.ShowDialog%2A> 返します、 <xref:System.Nullable%601> <xref:System.Boolean>アクティビティが受け入れられるか、取り消されたかどうかを指定する値。 戻り値は、の値、<xref:System.Windows.Window.DialogResult%2A>プロパティ ウィンドウが閉じる前にします。 詳細については、「<xref:System.Windows.Window.DialogResult%2A>」を参照してください。  
  
 呼び出すことによって開かれたウィンドウ、<xref:System.Windows.Window.ShowDialog%2A>メソッドに自動的に開いているウィンドウとの関係がありません。 具体的には、開かれたウィンドウがわからないどのウィンドウを開いたとき。 使用してこの関係を確立することができます、<xref:System.Windows.Window.Owner%2A>プロパティと管理を使用して、<xref:System.Windows.Window.OwnedWindows%2A>プロパティ。 サポートするために[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]オートメーション (を参照してください[UI オートメーションの概要](~/docs/framework/ui-automation/ui-automation-overview.md))、<xref:System.Windows.Window.Owner%2A>呼び出しによって開いたウィンドウを設定する必要があります<xref:System.Windows.Window.ShowDialog%2A>します。  
  
 ときに、モーダル[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]ウィンドウ (呼び出しによって開いたウィンドウ<xref:System.Windows.Window.ShowDialog%2A>) を閉じると、以前にアクティブなウィンドウが再アクティブ化します。 場合、モーダル[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]ウィンドウがオーナー ウィンドウ (を参照してください<xref:System.Windows.Window.Owner%2A>)、オーナー ウィンドウがない場合に再アクティブ化、モーダル[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]にアクティブだったウィンドウがなければ、ウィンドウが閉じられます。  
  
> [!NOTE]
>  ウィンドウが、ブラウザーでホストされている場合、このメソッドを呼び出すことはできません。  
  
   
  
## Examples  
 次の例では、モーダル ウィンドウを開く方法を示します。  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.ShowDialog" /> is called on a window that is closing (<see cref="E:System.Windows.Window.Closing" />) or has been closed (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">ウィンドウをアクティブ化する権限。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowInTaskbar : bool with get, set" Usage="System.Windows.Window.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the window has a task bar button.</summary>
        <value>
          <see langword="true" /> ウィンドウに、タスク バー ボタンがある場合それ以外の場合、<see langword="false" />します。 ウィンドウが、ブラウザーでホストされている場合に適用されません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合<xref:System.Windows.Window.ShowInTaskbar%2A>に設定されている`true`ウィンドウは、alt キーを押しながら TAB アプリケーションの選択リストにも表示されます。  
  
 タスク バー ボタンと alt キーを押しながら TAB アプリケーションの選択リストの両方に使用されるアイコンの値である、<xref:System.Windows.Window.Icon%2A>プロパティ。  
  
> [!NOTE]
>  設定またはウィンドウが、ブラウザーでホストされている場合は、このプロパティを取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowInTaskbarProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowInTaskbarProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.ShowInTaskbar" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberSignature Language="F#" Value="member this.SizeToContent : System.Windows.SizeToContent with get, set" Usage="System.Windows.Window.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a window will automatically size itself to fit the size of its content.</summary>
        <value>
          <see cref="T:System.Windows.SizeToContent" /> 値。 既定値は <see cref="F:System.Windows.SizeToContent.Manual" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに<xref:System.Windows.Window.SizeToContent%2A>に設定されている<xref:System.Windows.SizeToContent.WidthAndHeight>、いずれかを設定<xref:System.Windows.FrameworkElement.Height%2A>または<xref:System.Windows.FrameworkElement.Width%2A>も何も起こりません。 両方のプロパティを設定することができますが、設定された値は、ウィンドウには適用されません。  
  
 ときに<xref:System.Windows.Window.SizeToContent%2A>に設定されている<xref:System.Windows.SizeToContent.Height>設定<xref:System.Windows.FrameworkElement.Height%2A>ウィンドウの高さを変更することはできません。  
  
 ときに<xref:System.Windows.Window.SizeToContent%2A>に設定されている<xref:System.Windows.SizeToContent.Width>設定<xref:System.Windows.FrameworkElement.Width%2A>ウィンドウの幅を変更することはできません。  
  
 場合<xref:System.Windows.Window.SizeToContent%2A>以外の値を持つ<xref:System.Windows.SizeToContent.Manual>:  
  
-   <xref:System.Windows.Window.SizeToContent%2A> 自動的に設定されている<xref:System.Windows.SizeToContent.Manual>ユーザー ウィンドウのサイズ変更グリップを使用してまたは境界線をドラッグしてサイズ変更する場合。  
  
-   により、ウィンドウ自体のサイズを変更する方法でコンテンツのサイズが変更された場合<xref:System.Windows.FrameworkElement.SizeChanged>が発生します。  
  
 ウィンドウが透明な場合 (を参照してください<xref:System.Windows.Window.AllowsTransparency%2A>)、設定を考慮する必要があります<xref:System.Windows.Window.SizeToContent%2A>に<xref:System.Windows.SizeToContent.WidthAndHeight>ウィンドウが表示されるそのコンテンツを超えることを確認します。  
  
> [!NOTE]
>  設定またはウィンドウが、ブラウザーでホストされている場合は、このプロパティを取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.Window.SizeToContentProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次の例は、設定する方法を示します、<xref:System.Windows.Window.SizeToContent%2A>コード ウィンドウのコンテンツに合わせてサイズ変更する方法を指定するプロパティ。  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeToContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.SizeToContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.SizeToContent" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberSignature Language="F#" Value="member this.SourceInitialized : EventHandler " Usage="member this.SourceInitialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This event is raised to support interoperation with [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]. See <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberSignature Language="F#" Value="member this.StateChanged : EventHandler " Usage="member this.StateChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the window's <see cref="P:System.Windows.Window.WindowState" /> property changes.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TaskbarItemInfo : System.Windows.Shell.TaskbarItemInfo with get, set" Usage="System.Windows.Window.TaskbarItemInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the [!INCLUDE[win7](~/includes/win7-md.md)] taskbar thumbnail for the <see cref="T:System.Windows.Window" />.</summary>
        <value>[!タスク バーの縮小表示を INCLUDE[win7](~/includes/win7-md.md)]、<see cref="T:System.Windows.Window" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用する方法についての詳細、[!INCLUDE[win7](~/includes/win7-md.md)]タスク バーのサムネイルを参照してください、<xref:System.Windows.Shell.TaskbarItemInfo>クラス。  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TaskbarItemInfoProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.TaskbarItemInfo" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Window.Title" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a window's title.</summary>
        <value>A<see cref="T:System.String" />ウィンドウのタイトルを格納しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タイトル、 <xref:System.Windows.Window>、 <xref:System.Windows.Navigation.NavigationWindow>、または[!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]を使用して設定することも<xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>します。  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.Window.TitleProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TitleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.Title" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Top : double with get, set" Usage="System.Windows.Window.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the position of the window's top edge, in relation to the desktop.</summary>
        <value>ウィンドウの最上位の論理単位 (1/96 インチ) での位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Windows.Window>最大化または最小化、復元の上端のポイントをこの値は、<xref:System.Windows.Window>します。  
  
 このプロパティは、スタイルを設定できません。  
  
 値を指定しない場合<xref:System.Windows.Window.Top%2A>システムの既定値に設定されます。 設定して、システムの既定値を指定することも<xref:System.Windows.Window.Top%2A>に<xref:System.Double.NaN>します。 どちらも<xref:System.Double.NegativeInfinity>も<xref:System.Double.PositiveInfinity>の有効な値は、<xref:System.Windows.Window.Top%2A>します。  
  
> [!NOTE]
>  設定またはウィンドウが、ブラウザーでホストされている場合は、このプロパティを取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.Window.TopProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Topmost : bool with get, set" Usage="System.Windows.Window.Topmost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a window appears in the topmost z-order.</summary>
        <value>
          <see langword="true" /> ウィンドウが最前面以外の場合それ以外の場合、<see langword="false" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ウィンドウを持つ<xref:System.Windows.Window.Topmost%2A>プロパティに設定されて`true`すべてのウィンドウの上に表示が<xref:System.Windows.Window.Topmost%2A>プロパティに設定されます`false`します。  
  
 グループが windows の<xref:System.Windows.Window.Topmost%2A>プロパティに設定されて`true`、現在アクティブになっているウィンドウが最上位ウィンドウです。 同様にする必要があるのグループ、<xref:System.Windows.Window.Topmost%2A>プロパティに設定されて`false`します。  
  
> [!NOTE]
>  設定またはウィンドウが、ブラウザーでホストされている場合は、このプロパティを取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.Window.TopmostProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopmostProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopmostProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.Topmost" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.Top" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStartupLocation : System.Windows.WindowStartupLocation with get, set" Usage="System.Windows.Window.WindowStartupLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the position of the window when first shown.</summary>
        <value>A<see cref="T:System.Windows.WindowStartupLocation" />最初に表示されるときに、ウィンドウの上/左の位置を指定する値。 既定値は <see cref="F:System.Windows.WindowStartupLocation.Manual" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定<xref:System.Windows.WindowStartupLocation>に<xref:System.Windows.WindowStartupLocation.Manual>に従って配置されるウィンドウと、その<xref:System.Windows.Window.Left%2A>と<xref:System.Windows.Window.Top%2A>プロパティの値。 どちらの場合、<xref:System.Windows.Window.Left%2A>または<xref:System.Windows.Window.Top%2A>プロパティが指定されていない、その値は Windows によって決まります。  
  
 設定<xref:System.Windows.WindowStartupLocation.CenterScreen>ウィンドウがマウス カーソルを含む画面の中央に配置します。  
  
 設定<xref:System.Windows.WindowStartupLocation>に<xref:System.Windows.WindowStartupLocation.CenterOwner>ウィンドウが、オーナー ウィンドウの中央に配置される (を参照してください<xref:System.Windows.Window.Owner%2A>)、指定しました。 オーナー ウィンドウには、別の WPF ウィンドウまたは非 WPF ウィンドウのいずれかを指定できます。  
  
> [!NOTE]
>  非 WPF windows での WPF ウィンドウの詳細については、次を参照してください。 [WPF と Win32 の相互運用性](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)と<xref:System.Windows.Interop.WindowInteropHelper>します。  
  
 ウィンドウの位置が同じ方法で決定されます、オーナー ウィンドウが指定されていない場合、<xref:System.Windows.WindowStartupLocation>に設定されている<xref:System.Windows.WindowStartupLocation.Manual>します。  
  
> [!NOTE]
>  設定またはウィンドウが、ブラウザーでホストされている場合は、このプロパティの値を取得することはできません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberSignature Language="F#" Value="member this.WindowState : System.Windows.WindowState with get, set" Usage="System.Windows.Window.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a window is restored, minimized, or maximized.</summary>
        <value>A<see cref="T:System.Windows.WindowState" />ウィンドウを復元、最小化、または最大化されているかどうかを決定します。 既定値は<see cref="F:System.Windows.WindowState.Normal" />(復元)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サイズと場所が格納されているウィンドウが最小化または最大化する前に<xref:System.Windows.Window.RestoreBounds%2A>します。 値をそのサイズと位置の値を復元後、ウィンドウが復元されると、<xref:System.Windows.Window.RestoreBounds%2A>します。  
  
 ときに、<xref:System.Windows.Window.WindowState%2A>プロパティを変更すると、<xref:System.Windows.Window.StateChanged>が発生します。  
  
> [!NOTE]
>  設定またはウィンドウが、ブラウザーでホストされている場合は、このプロパティを取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.Window.WindowStateProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.WindowState" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStyle : System.Windows.WindowStyle with get, set" Usage="System.Windows.Window.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a window's border style.</summary>
        <value>A<see cref="T:System.Windows.WindowStyle" />ウィンドウの境界線スタイルを指定します。 既定値は <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A> いずれか、<xref:System.Windows.WindowStyle>列挙値を含む<xref:System.Windows.WindowStyle.None>、 <xref:System.Windows.WindowStyle.ToolWindow>、 <xref:System.Windows.WindowStyle.SingleBorderWindow> (既定)、および<xref:System.Windows.WindowStyle.ThreeDBorderWindow>します。  
  
 次の図では、ウィンドウ スタイルを示します[!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)](Windows Vista Aero テーマ、透明グラスの有効化)。  
  
 ![ウィンドウ スタイル](~/add/media/windowoverviewfigure6.PNG "ウィンドウ スタイル")  
  
> [!NOTE]
>  設定またはウィンドウが、ブラウザーでホストされている場合は、このプロパティを取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.Window.WindowStyleProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.WindowStyle" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>