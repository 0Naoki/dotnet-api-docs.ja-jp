<Type Name="Window" FullName="System.Windows.Window">
  <Metadata><Meta Name="ms.openlocfilehash" Value="eae82f38da2db6642d1be7c07faa5b5a64322578" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69443621" /></Metadata><TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <TypeSignature Language="F#" Value="type Window = class&#xA;    inherit ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>ウィンドウおよびダイアログ ボックスの作成、構成、表示、および有効期間の管理を可能にします。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーとスタンドアロンアプリケーションの間の相互作用のポイントは、ウィンドウです。 ウィンドウ[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]は、次の2つの領域で構成されます。  
  
-   非クライアント領域。アイコン、タイトル、システムメニュー、最小化ボタン、最大化ボタン、復元ボタン、閉じるボタン、および境界線を含む、windows の修飾をホストします。  
  
-   クライアント領域。アプリケーション固有のコンテンツをホストします。  
  
 標準ウィンドウを次の図に示します。  
  
 ![ウィンドウ要素](~/add/media/windowoverviewfigure1.PNG "ウィンドウ要素")  
  
 <xref:System.Windows.Window>は、ウィンドウとダイアログボックスの両方の有効期間を作成、構成、表示、および管理する機能をカプセル化し、次の主要なサービスを提供します。  
  
 **有効期間** <xref:System.Windows.Window.Activate%2A> <xref:System.Windows.Window.Closed>の管理<xref:System.Windows.Window.Hide%2A>: <xref:System.Windows.Window.Close%2A> <xref:System.Windows.Window.Activated>、、、 、、<xref:System.Windows.Window.Deactivated>、、、、 。<xref:System.Windows.Window.SourceInitialized> <xref:System.Windows.Window.Closing> <xref:System.Windows.Window.IsActive%2A> <xref:System.Windows.Window.Show%2A>  
  
 **ウィンドウ**の管理<xref:System.Windows.Window.GetWindow%2A>: <xref:System.Windows.Window.OwnedWindows%2A>、 <xref:System.Windows.Window.Owner%2A>、。  
  
 **外観と動作**: <xref:System.Windows.Window.AllowsTransparency%2A> <xref:System.Windows.Window.ContentRendered> <xref:System.Windows.Window.DragMove%2A> 、、<xref:System.Windows.Window.LocationChanged>、 、、、、<xref:System.Windows.Window.Icon%2A>、、、 、<xref:System.Windows.Window.StateChanged> <xref:System.Windows.Window.Left%2A> <xref:System.Windows.Window.ResizeMode%2A> <xref:System.Windows.Window.RestoreBounds%2A> <xref:System.Windows.Window.ShowActivated%2A> <xref:System.Windows.Window.ShowInTaskbar%2A> <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>,<xref:System.Windows.Window.WindowStyle%2A>  
  
 **ダイアログボックス**: <xref:System.Windows.Window.DialogResult%2A>、 <xref:System.Windows.Window.ShowDialog%2A>。  
  
 また、 <xref:System.Windows.Application>は、アプリケーション内のすべてのウィンドウを管理するための特別なサポートを公開しています。  
  
-   アプリケーションでは、現在アプリケーションでインスタンス化されているすべてのウィンドウの一覧を保持します。 このリストは、 <xref:System.Windows.Application.Windows%2A>プロパティによって公開されます。  
  
-   既定では<xref:System.Windows.Application.MainWindow%2A> 、は、アプリケーションでインスタンス化され<xref:System.Windows.Window>ている最初のへの参照を使用して自動的に設定されます。 これにより、ウィンドウがメインアプリケーションウィンドウになります。  
  
 は<xref:System.Windows.Window> 、マークアップ、マークアップと分離コード、またはコードを使用して実装できます。  
  
 <xref:System.Windows.Window>は、主にスタンドアロンアプリケーションのウィンドウとダイアログボックスを表示するために使用されます。 ただし、ウィザードなどのウィンドウレベルでのナビゲーションを必要とするアプリケーションでは、代わりに<xref:System.Windows.Navigation.NavigationWindow>を使用できます。は、 <xref:System.Windows.Window>から派生し、ブラウザースタイルのナビゲーションサポートを使用して拡張します。 <xref:System.Windows.Navigation.NavigationWindow>  
  
> [!NOTE]
>  誘導可能なコンテンツの孤島は、を使用して<xref:System.Windows.Controls.Frame>他のコンテンツコンテナーやコンテンツコンテナーに組み込むことができます。  
  
 <xref:System.Windows.Window>セキュリティ`UnmanagedCode`権限をインスタンス化する必要があります。 これには、次のような影響があります。  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]-展開されたスタンドアロンアプリケーションは、インターネットゾーンまたはローカルイントラネットゾーンから起動するときに、アクセス許可の昇格を要求します。  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)]この要求を行うと、完全なアクセス許可よりも小さいと、ウィンドウまたはダイアログボックスをインスタンス化できなくなります。  
  
 スタンドアロンアプリケーションの配置とセキュリティに関する考慮事項については、「 [WPF のセキュリティ方針-プラットフォームのセキュリティ](~/docs/framework/wpf/wpf-security-strategy-platform-security.md)」を参照してください。  
  
 <xref:System.Windows.Window> は<xref:System.Windows.Controls.ContentControl>です。つまり、任意の型 (文字列、イメージ、パネルなど) の1つのオブジェクトを含めることができます。 詳細については、<xref:System.Windows.Controls.ContentControl> クラスを参照してください。 また、 <xref:System.Windows.Window>はルート要素であるため、別の要素のコンテンツの一部にすることはできません。  
  
> [!NOTE]
>  <xref:System.Windows.FrameworkElement.Width%2A> <xref:System.Windows.Window.Top%2A> <xref:System.Windows.Window.Left%2A>スタイルによっ<xref:System.Windows.Window>てに設定された、、、およびの各プロパティは、実行時には適用されません。<xref:System.Windows.FrameworkElement.Height%2A>  
  
## <a name="customizing-the-window-control"></a>ウィンドウコントロールのカスタマイズ  
 複数の<xref:System.Windows.Window>コントロールに同じプロパティの設定を適用するには、<xref:System.Windows.FrameworkElement.Style%2A>プロパティを使用します。 <xref:System.Windows.Controls.ControlTemplate>の既定値を変更して外観を制御します。 <xref:System.Windows.Controls.ControlTemplate>作成の詳細については、「 [ControlTemplate の作成による既存コントロールの外観カスタマイズ](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md)」を参照してください。  に<xref:System.Windows.Window>固有のパーツと状態を確認するには、「[ウィンドウのスタイルとテンプレート](~/docs/framework/wpf/controls/window-styles-and-templates.md)」を参照してください。  
  
 このコントロールの依存関係のプロパティは、コントロールの既定のスタイルによって設定される可能性があります。  プロパティが既定のスタイルによって設定されている場合、アプリケーションにコントロールが表示されると、プロパティが既定値から変更されることがあります。 既定のスタイルは、アプリケーションの実行時に使用するデスクトップテーマによって決定されます。  詳しくは、「[既定の WPF テーマ](https://go.microsoft.com/fwlink/?LinkID=158252)」をご覧ください。  
  
[!INCLUDE[setting-a-visual-property](~/includes/visual-property-note.md)]  
  
## Examples  
 次の例は、マークアップのみを使用して標準ウィンドウを定義する方法を示しています。  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 次の例は、コードのみを使用して標準ウィンドウを定義する方法を示しています。  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 次の例は、マークアップと分離コードの組み合わせを使用して、標準ウィンドウを定義する方法を示しています。  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Window" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Width%2A>コンストラクターは<xref:System.Windows.FrameworkElement.Height%2A> <xref:System.Windows.Window> 、、、 <xref:System.Windows.Window.Left%2A> 、およびの各プロパティを既定値に初期化します。 <xref:System.Windows.Window.Top%2A>  
  
 <xref:System.AppDomain> <xref:System.Windows.Application> <xref:System.Windows.Application.Windows%2A> <xref:System.Windows.Application> <xref:System.Windows.Window>オブジェクトを持つ内にウィンドウが作成されると、オブジェクトのプロパティを使用して、によって管理される windows のセットにオブジェクトが追加されます。 <xref:System.Windows.Application>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">このオブジェクトが unsafe ネイティブメソッドを呼び出すためのアクセス許可。 関連付けられた列挙型:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberSignature Language="F#" Value="member this.Activate : unit -&gt; bool" Usage="window.Activate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ウィンドウを前面にしてアクティブ化することを試みます。</summary>
        <returns><see cref="T:System.Windows.Window" /> が正常にアクティブにされた場合は <see langword="true" /> を返します。それ以外の場合は <see langword="false" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ウィンドウがアクティブ化されているかどうかを判断する規則は、 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow`関数 (user32.dll) で使用されているものと同じです。  
  
 ユーザーのフォアグラウンドアプリケーションではない Windows Presentation Foundation アプリケーションでウィンドウがアクティブになっている場合<xref:System.Windows.Application.Activated>は、イベントが発生します。  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このメソッドを呼び出すことはできません。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">ウィンドウをアクティブにするアクセス許可の場合は。 関連付けられた列挙型:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウがフォアグラウンド ウィンドウになったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の場合、ウィンドウがアクティブになります (前のウィンドウになります)。  
  
-   ウィンドウが最初に開かれます。  
  
-   ユーザーは、マウスを使用して選択するか、ALT + TAB キーを押すか、またはタスクマネージャーを使用して、ウィンドウに切り替えます。  
  
-   ユーザーがウィンドウのタスクバーボタンをクリックします。  
  
 アクティブになったときに検出する必要があるウィンドウ<xref:System.Windows.Window.Activated>は、イベントを処理できます。  
  
 ウィンドウが最初にアクティブになった後は、有効期間中に何度も非アクティブ化および再アクティブ化される可能性があります。 アプリケーションの動作または状態がアクティブ化状態に依存している場合<xref:System.Windows.Window.IsActive%2A>は、そのアプリケーションがどのアクティブ化状態にあるかを調べることができます。  
  
 アプリケーションもにする<xref:System.Windows.Application.Activated>ことができます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowsTransparency : bool with get, set" Usage="System.Windows.Window.AllowsTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウのクライアント領域が透過性をサポートするかどうかを示す値を取得または設定します。</summary>
        <value>ウィンドウで透過性がサポートされる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ウィンドウの<xref:System.Windows.Media.Brushes.Transparent%2A>プロパティが透明色に設定されている場合、たとえば、ウィンドウは不透明なままになります。 <xref:System.Windows.Controls.Control.Background%2A> これは、デスクトップと、ウィンドウの下にあるすべての実行中のアプリケーションを表示できないことを意味します。 この種類の透明度を有効<xref:System.Windows.Window.AllowsTransparency%2A>にするには`true`、をに設定する必要があります。  
  
 <xref:System.Windows.Window.AllowsTransparency%2A>四角形以外のウィンドウの作成を容易にするために存在します。 <xref:System.Windows.Window.AllowsTransparency%2A>したがって、 `true`がに設定さ<xref:System.Windows.Window.WindowStyle%2A>れている場合は<xref:System.Windows.WindowStyle.None>、ウィンドウのプロパティをに設定する必要があります。  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|メタデータプロパティがに設定される`true`|None|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Window.WindowStyle" /> 値が <see cref="F:System.Windows.WindowStyle.None" /> 以外に設定されたウィンドウ。</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowsTransparencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.AllowsTransparencyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.AllowsTransparency" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">ウィンドウがウィンドウ自体とその子を配置するために使用する、最終的なサイズを反映する <see cref="T:System.Windows.Size" />。</param>
        <summary>ウィンドウとその子要素を配置したり、サイズを設定したりするには、このメソッドをオーバーライドします。</summary>
        <returns>使用された実際のサイズを反映する <see cref="T:System.Windows.Size" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A>プロパティの値がの<xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Visibility.Collapsed>場合、は呼び出されません。 <xref:System.Windows.UIElement.Visibility%2A>プロパティの値がまたは<xref:System.Windows.Visibility.Visible>のいずれ<xref:System.Windows.Visibility.Hidden>かで<xref:System.Windows.Window.ArrangeOverride%2A>ある場合は、が呼び出されます。  
  
> [!NOTE]
>  または<xref:System.Windows.Window.Show%2A> <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Window> <xref:System.Windows.Visibility.Visible>のいずれかが呼び出されると、のプロパティはに設定されます。 <xref:System.Windows.Window.ShowDialog%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="window.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Window" /> を手動で閉じます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 は<xref:System.Windows.Window> 、次のように、タイトルバーにある、よく知られているいくつかのシステム指定のメカニズムのいずれかを使用して閉じることができます。  
  
-   ALT + F4  
  
-   システムメニュー &#124;を**閉じる**。  
  
-   **[閉じる]** ボタン。  
  
 は<xref:System.Windows.Window> 、次のような、開発者によって提供されるクライアント領域内の既知のメカニズムのいずれかを使用して閉じることもできます。  
  
-   **ファイル**&#124;メインウィンドウで**終了**します。  
  
-   **ファイル**&#124;子ウィンドウの**閉じる**ボタンまたは**閉じる**ボタン。  
  
> [!NOTE]
>  また、ダイアログボックスの [ **OK]** ボタンと **[キャンセル**] ボタンも開発者向け<xref:System.Windows.Window.DialogResult%2A>に用意されていますが、はを<xref:System.Windows.Window.ShowDialog%2A>呼び出すことによって開かれたウィンドウを自動的に閉じるように設定される可能性があります。  
  
 これらのメカニズムでは、ウィンドウ<xref:System.Windows.Window.Close%2A>を閉じるためにを明示的に呼び出す必要があります。  
  
> [!NOTE]
>  を呼び出し<xref:System.Windows.Window.ShowDialog%2A>てウィンドウを開き、 <xref:System.Windows.Controls.Button.IsCancel%2A>プロパティが true に<xref:System.Windows.Controls.Button>設定されたを使用すると、ボタンがクリックされるか、ESC キーが押されると、が自動的に閉じます。 ただし、を使用して<xref:System.Windows.Window.Show%2A>ウィンドウを開い<xref:System.Windows.Window.Close%2A>た場合は、の<xref:System.Windows.Controls.Primitives.ButtonBase.Click>イベントハンドラー <xref:System.Windows.Controls.Button>など、を明示的に呼び出す必要があります。  
  
 ウィンドウを閉じると、 <xref:System.Windows.Window.Closing>イベントが発生します。 イベントが<xref:System.Windows.Window.Closing>取り消されない場合は、次の処理が行われます。  
  
-   が ( <xref:System.Windows.Application>オブジェクトが<xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType>存在する場合は) から削除されます。 <xref:System.Windows.Window>  
  
-   所有者が表示される<xref:System.Windows.Window>前と所有者<xref:System.Windows.Window>が開かれた後に<xref:System.Windows.Window>所有者/所有関係が確立された場合、は所有者から削除されます。 <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Window.Closed> イベントが発生します。  
  
-   によって<xref:System.Windows.Window>作成されたアンマネージリソースは破棄されます。  
  
-   を<xref:System.Windows.Window.ShowDialog%2A>呼び出すために<xref:System.Windows.Window>が呼び出さ<xref:System.Windows.Window.ShowDialog%2A>れた場合、はを返します。  
  
 を<xref:System.Windows.Window>閉じると、それが所有するすべてのウィンドウが閉じられます。 さらに、を<xref:System.Windows.Window>閉じると、プロパティの<xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType>設定方法に応じて、アプリケーションの実行が停止する可能性があります。  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このメソッドを呼び出すことはできません。  
  
   
  
## Examples  
 次の例は、を明示的に呼び出す<xref:System.Windows.Window.Close%2A>ために処理される**ファイル** &#124;の**終了**メニューを示しています。  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">すべての windows およびユーザー入力イベントを制限なしで使用するためのアクセス許可。 関連付けられた列挙型:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : EventHandler " Usage="member this.Closed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウが閉じるときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントが発生すると、ウィンドウを閉じることができなくなります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.UIElement.Visibility" /> が設定されているか、ウィンドウを閉じている間に <see cref="M:System.Windows.Window.Show" />、<see cref="M:System.Windows.Window.ShowDialog" />、または <see cref="M:System.Windows.Window.Hide" /> が呼び出されました。</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberSignature Language="F#" Value="member this.Closing : System.ComponentModel.CancelEventHandler " Usage="member this.Closing : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Windows.Window.Close" /> が呼び出された直後に発生します。これを処理して、ウィンドウが閉じるのをキャンセルすることができます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing>は、ウィンドウがいつ閉じられたかを検出するために処理<xref:System.Windows.Window.Close%2A>できます (たとえば、が呼び出された場合)。 さらに<xref:System.Windows.Window.Closing> 、を使用して、ウィンドウが閉じないようにすることもできます。 ウィンドウが閉じないようにするには、 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> <xref:System.ComponentModel.CancelEventArgs>引数のプロパティをに`true`設定します。  
  
 イベント<xref:System.Windows.Window.Closing>は、が呼び出さ<xref:System.Windows.Window.Close%2A>れたとき、ウィンドウの [閉じる] ボタンがクリックされたとき、またはユーザーが ALT + F4 キーを押したときに発生します。  
  
 所有ウィンドウがを使用し<xref:System.Windows.Window.Show%2A>て所有者ウィンドウによって開かれ、オーナーウィンドウが閉じている場合、所有ウィンドウの<xref:System.Windows.Window.Closing>イベントは発生しません。 ウィンドウの所有者が閉じている場合 ( <xref:System.Windows.Window.Owner%2A>「」 <xref:System.Windows.Window.Closing>を参照)、所有しているウィンドウでは発生しません。  
  
 が呼び出されると<xref:System.Windows.Window.Closing> 、各ウィンドウのイベントが発生します。 <xref:System.Windows.Application.Shutdown%2A> ただし、が<xref:System.Windows.Window.Closing>取り消された場合、キャンセルは無視されます。  
  
 ユーザーがログオフまたはシャットダウンすることによってセッションが<xref:System.Windows.Window.Closing>終了した場合、 <xref:System.Windows.Application.SessionEnding>は発生しません。アプリケーションのクロージャをキャンセルするコードを実装するためのハンドル。  
  
 アプリケーションの有効期間中にウィンドウを何度も表示したり非表示にしたりする場合に、ウィンドウを表示するたびに再インスタンス化したくない場合は<xref:System.Windows.Window.Closing> 、イベントを処理し、キャンセルし<xref:System.Windows.Window.Hide%2A>て、メソッドを呼び出すことができます。 次に、同じインスタンス<xref:System.Windows.Window.Show%2A>でを呼び出して再度開くことができます。  
  
   
  
## Examples  
 次の例は、 <xref:System.Windows.Window>ユーザーの介入を閉じる必要があるかどうかを判断するを示しています。  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.UIElement.Visibility" /> が設定されているか、ウィンドウを閉じている間に <see cref="M:System.Windows.Window.Show" />、<see cref="M:System.Windows.Window.ShowDialog" />、または <see cref="M:System.Windows.Window.Close" /> が呼び出されました。</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" />
      <MemberSignature Language="F#" Value="member this.ContentRendered : EventHandler " Usage="member this.ContentRendered : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウのコンテンツがレンダリングされた後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ウィンドウにコンテンツがない場合、このイベントは発生しません。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウが背景ウィンドウになったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の場合、ウィンドウは非アクティブ化されます (バックグラウンドウィンドウになります)。  
  
-   ユーザーは、現在のアプリケーションの別のウィンドウに切り替えます。  
  
-   ユーザーは、ALT + TAB キーを使用するか、タスクマネージャーを使用して、別のアプリケーションのウィンドウに切り替えます。  
  
-   ユーザーは、別のアプリケーションのウィンドウのタスクバーボタンをクリックします。  
  
 <xref:System.Windows.Window.Deactivated>イベントを処理することによって非アクティブになったことを検出する必要があるウィンドウ。  
  
 ウィンドウが最初に非アクティブになった後は、有効期間中に何度も再アクティブ化および非アクティブ化される可能性があります。 アプリケーションの動作または状態がアクティブ化状態に依存している場合<xref:System.Windows.Window.IsActive%2A>は、そのアプリケーションがどのアクティブ化状態にあるかを調べることができます。  
  
 アプリケーションもにする<xref:System.Windows.Application.Deactivated>ことができます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.DialogResult : Nullable&lt;bool&gt; with get, set" Usage="System.Windows.Window.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ダイアログ ボックスの結果値を取得または設定します。この値は、<see cref="M:System.Windows.Window.ShowDialog" /> メソッドから返される値です。</summary>
        <value><see cref="T:System.Nullable`1" /> 型の <see cref="T:System.Boolean" /> 値。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A>ダイアログボックスを見たコードから使用して、ダイアログボックスでユーザーが同意`true`したか ()、キャンセルしたか (`false`) を確認できます。 ダイアログボックスが受け入れられた場合、ユーザーによって収集されたデータを取得して処理するために、ダイアログボックスを開いたコードを示します。 ただし、ダイアログボックスがキャンセルされた場合は、呼び出し元のコードが後続の処理を停止する必要があることを意味します。  
  
 既定では、ユーザーが次のいずれかを実行すると、ダイアログボックスはキャンセルされます。  
  
-   Preson Alt + F4。  
  
-   **[閉じる]** ボタンをクリックします。  
  
-   システム メニューの **閉じる** を選択します。  
  
 これらのすべての場合、 <xref:System.Windows.Window.DialogResult%2A>は`false`既定でになります。  
  
 ダイアログボックスには、通常、ダイアログをキャンセルするための特別なボタンが用意<xref:System.Windows.Controls.Button.IsCancel%2A>されてい`true`ます。このボタンは、プロパティがに設定されているボタンです。 この方法で構成されたボタンを押すと、ウィンドウが押されたとき、または ESC キーが押されたときに、ウィンドウが自動的に閉じられます。 どちらの場合も、 <xref:System.Windows.Window.DialogResult%2A>は残り`false`ます。  
  
 また、ダイアログボックスには、通常、[accept] ボタンがあり<xref:System.Windows.Controls.Button.IsDefault%2A>ます。このボタン`true`は、プロパティがに設定されているボタンです。 この方法で構成されたボタン<xref:System.Windows.Controls.Primitives.ButtonBase.Click>を押すと、そのボタンまたは ENTER キーが押されたときにイベントが発生します。 ただし、ダイアログボックスが自動的に閉じられることはなく、 <xref:System.Windows.Window.DialogResult%2A>に`true`も設定されません。 このコードは、通常、既定のボタンの<xref:System.Windows.Controls.Primitives.ButtonBase.Click>イベントハンドラーから手動で書き込む必要があります。  
  
 <xref:System.Windows.Window.DialogResult%2A>ダイアログ`null`ボックスが表示されても、受け入れもキャンセルでもない場合はです。  
  
 ダイアログボックスを閉じると、メソッドによって<xref:System.Windows.Window.ShowDialog%2A>返された値からダイアログの結果を取得したり、 <xref:System.Windows.Window.DialogResult%2A>プロパティを調べたりすることができます。  
  
 <xref:System.Windows.Window.DialogResult%2A>は、 <xref:System.Windows.Window> <xref:System.Windows.Window.ShowDialog%2A>メソッドを呼び出すことによってが開かれている場合にのみ設定できます。  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このプロパティを設定または取得することはできません。  
  
   
  
## Examples  
 次の例は、[OK] ボタンと [キャンセル] ボタンを構成して<xref:System.Windows.Window.DialogResult%2A>適切なを返す方法を示しています。  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Window.DialogResult" /> を呼び出すことによってウィンドウが開かれる前に <see cref="M:System.Windows.Window.ShowDialog" /> が設定されます。  
  
または 
 <see cref="P:System.Windows.Window.DialogResult" /> を呼び出すことによって開かれたウィンドウに <see cref="M:System.Windows.Window.Show" /> が設定されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberSignature Language="F#" Value="member this.DpiChanged : System.Windows.DpiChangedEventHandler " Usage="member this.DpiChanged : System.Windows.DpiChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Window が表示されている画面の DPI が変更されたあとに発生します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DpiChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Window.DpiChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>画面 Window の DPI が変更中であるときの <see cref="T:System.Windows.RoutedEvent" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberSignature Language="F#" Value="member this.DragMove : unit -&gt; unit" Usage="window.DragMove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ウィンドウのクライアント領域の表示部分でマウスの左ボタンを押したままにすることにより、ウィンドウをドラッグできるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 が呼び出されると<xref:System.Windows.Window.DragMove%2A> 、マウスの左ボタンが押されている必要があります。 マウスの左ボタンが押されたことを検出する1つの<xref:System.Windows.UIElement.MouseLeftButtonDown>方法は、イベントを処理することです。  
  
 が<xref:System.Windows.Window.DragMove%2A>呼び出されたときに、マウスの左ボタンをウィンドウのクライアント領域の公開された領域の上に押す必要があります。  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このメソッドを呼び出すことはできません。  
  
   
  
## Examples  
 をオーバーライド<xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>してを呼び出す<xref:System.Windows.Window.DragMove%2A>方法を次の例に示します。  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">マウスの左ボタンが押されていません。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">ウィンドウをドラッグするアクセス許可の場合は。 関連付けられた列挙型:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetWindow : System.Windows.DependencyObject -&gt; System.Windows.Window" Usage="System.Windows.Window.GetWindow dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">依存関係オブジェクト。</param>
        <summary>依存関係オブジェクトが存在するコンテンツ ツリーをホストする <see cref="T:System.Windows.Window" /> オブジェクトへの参照を返します。</summary>
        <returns>ホスト ウィンドウへの <see cref="T:System.Windows.Window" /> 参照。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dependencyObject" /> が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="window.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ウィンドウを非表示にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ウィンドウは非表示<xref:System.Windows.Window.Closing>のときは閉じられず、イベントも<xref:System.Windows.Window.Closed>イベントも発生しません。 代わりに、ウィンドウの<xref:System.Windows.UIElement.Visibility%2A>プロパティはに<xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>設定されます。  
  
 ウィンドウがアプリケーション<xref:System.Windows.Application.MainWindow%2A>であり、アプリケーションの<xref:System.Windows.Application.ShutdownMode%2A>が<xref:System.Windows.ShutdownMode.OnMainWindowClose>の場合、アプリケーションはシャットダウンされません。 同様に、ウィンドウが唯一のウィンドウであり、アプリケーションのシャットダウンモードが<xref:System.Windows.ShutdownMode.OnLastWindowClose>の場合、アプリケーションはシャットダウンされません。  
  
 アプリケーションの有効期間中にウィンドウを何度も表示したり非表示にしたりする必要があり、表示するたびにウィンドウを再インスタンス化したくない場合は<xref:System.Windows.Window.Closing> 、イベントを処理し、キャンセルし<xref:System.Windows.Window.Hide%2A>て、メソッドを呼び出すことができます。 次に、同じインスタンス<xref:System.Windows.Window.Show%2A>でを呼び出して、再度開くことができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">閉じている途中 (<see cref="M:System.Windows.Window.Hide" />) または閉じた (<see cref="E:System.Windows.Window.Closing" />) ウィンドウに対して <see cref="E:System.Windows.Window.Closed" /> が呼び出されている。</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Icon : System.Windows.Media.ImageSource with get, set" Usage="System.Windows.Window.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウのアイコンを取得または設定します。</summary>
        <value>アイコンを表す <see cref="T:System.Windows.Media.ImageSource" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows Presentation Foundation (WPF) スタンドアロンアプリケーションには、次の2種類のアイコンがあります。  
  
-   1つのアセンブリアイコン。これは、アプリケーション`<ApplicationIcon>`のプロジェクトビルドファイルのプロパティを使用して指定されます。 このアイコンは、アセンブリのデスクトップアイコンとして使用されます。  
  
    > [!NOTE]
    >  Visual Studio でデバッグする場合、ホストプロセスによってアイコンが表示されないことがあります。 実行可能ファイルを実行すると、アイコンが表示されます。 詳細については、「[ホスト プロセス (vshost.exe)](https://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b)」を参照してください。  
  
-   設定<xref:System.Windows.Window.Icon%2A>によって指定されたウィンドウごとに1つのアイコン。 このアイコンは、各ウィンドウについて、タイトルバー、タスクバーボタン、および ALT タブアプリケーション選択リストのエントリで使用されます。  
  
 WPF ウィンドウには常にアイコンが表示されます。 設定<xref:System.Windows.Window.Icon%2A>によって指定されていない場合、WPF は次の規則に基づいて表示するアイコンを選択します。  
  
1.  アセンブリアイコン (指定されている場合) を使用します。  
  
2.  アセンブリアイコンが指定されていない場合は、既定の Microsoft Windows アイコンを使用します。  
  
 を使用<xref:System.Windows.Window.Icon%2A>してカスタムウィンドウアイコンを指定した場合は、をに`null`設定<xref:System.Windows.Window.Icon%2A>することによって、既定のアプリケーションアイコンを復元できます。  
  
 1つのアイコンは、ウィンドウのタイトルバーに表示される、ウィンドウのタスクバー、ALT + TAB ファイル選択リストなど、Windows のさまざまな方法で使用できます。 これらはそれぞれ異なるサイズを使用するアイコンを示しています。16×16ピクセルのアイコンがウィンドウのタイトルバーとタスクバーに表示されますが、ALT + TAB ファイル選択リストに32×32ピクセルのアイコンが表示されます。 などの一部の[!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)]アプリケーションでは、表示するアイコンのサイズを選択できる **[表示]** メニューが用意されています。  
  
 さまざまな表示サイズに対応するために、アイコンファイルは1つ以上の実際のアイコンで構成されます。各アイコンは、特定のサイズと色深度を対象とするアイコンのバージョンを表します。 たとえば、1つのアイコンには16色の 16 x 16 ピクセルのアイコンがありますが、別のアイコンには16色と256色の 16 x 16 ピクセルと32x32 ピクセルのアイコンが含まれている場合があります。  
  
 すべての可能なサイズと色深度のアイコンがアイコンファイル内に<xref:System.Windows.Window>存在する場合、は適切なアイコンを使用します。 アイコンファイルに、可能なすべてのアイコンのサブセットのみが<xref:System.Windows.Window>含まれている場合、では、サイズと色の深さを小さくするために、次に最も適切なアイコンが使用されます。  
  
 結果として、アイコンは常にによっ<xref:System.Windows.Window>て使用されます。ただし、使用されるアイコンは、必要なサイズと色深度をターゲットにすることはできません。 たとえば、16色の16x16 ピクセルのアイコンは、256色の32x32 ピクセルのアイコンとして表示されることがあります。 これにより、pixilation などの望ましくない視覚効果が発生する可能性がありますが、対象となるすべてのサイズと色深度のアイコンを作成することによって回避できます。  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このプロパティを設定または取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Window.IconProperty>|  
|メタデータプロパティがに設定される`true`|None|  
  
   
  
## Examples  
 次の例は、ウィンドウアイコンを設定する方法を示しています。  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">アイコンを設定するためのアクセス許可。 関連付けられた列挙型:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IconProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IconProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.Icon" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsActive : bool" Usage="System.Windows.Window.IsActive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウがアクティブかどうかを示す値を取得します。</summary>
        <value>ウィンドウがアクティブの場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アクティブウィンドウはユーザーの現在の前景ウィンドウであり、フォーカスがあります。これは、タイトルバーのアクティブな外観によって表されます。 アクティブウィンドウは、プロパティを<xref:System.Windows.Window.Topmost%2A>明示的に設定しないすべてのトップレベルウィンドウの最上位にもなります。  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Window.IsActiveProperty>|  
|メタデータプロパティがに設定される`true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsActiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IsActiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.IsActive" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Left : double with get, set" Usage="System.Windows.Window.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウの左端の位置を、デスクトップとの関係で取得または設定します。</summary>
        <value>ウィンドウの左端の位置。単位は論理単位 (1/96 インチ)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 が最大化または最小化されると、この値はの復元ポイント<xref:System.Windows.Window>の左端を表します。 <xref:System.Windows.Window>  
  
 このプロパティは、スタイルを使用して設定することはできません。  
  
 値を指定しない場合、 <xref:System.Windows.Window.Left%2A>はシステムの既定値に設定されます。 をに<xref:System.Windows.Window.Left%2A> <xref:System.Double.NaN>設定することによって、システムの既定値を指定することもできます。 とのどちらも<xref:System.Double.NegativeInfinity> 、の<xref:System.Windows.Window.Left%2A>有効な値ではありません。 <xref:System.Double.PositiveInfinity>  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このプロパティを設定または取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Window.LeftProperty>|  
|メタデータプロパティがに設定される`true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LeftProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.Left" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウの場所が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ウィンドウの位置は、次の場合に変更されることがあります。  
  
-   ウィンドウをウィンドウのタイトルバーと一緒にドラッグすることで、ユーザーがウィンドウを移動します。  
  
-   が呼び出された後<xref:System.Windows.Window.DragMove%2A>にウィンドウが移動されます。  
  
-   プロパティまた<xref:System.Windows.Window.Left%2A>は<xref:System.Windows.Window.Top%2A>プロパティは、プログラムによって設定されます。  
  
-   ウィンドウの システム メニューの **移動** メニュー項目が選択されます。  
  
-   プロパティ<xref:System.Windows.Window.WindowState%2A>が変更されています。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Window.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウの論理上の子要素に対する列挙子を取得します。</summary>
        <value>ウィンドウの論理上の子要素に対する <see cref="T:System.Collections.IEnumerator" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">このウィンドウが子に提供できる有効なサイズを反映する <see cref="T:System.Windows.Size" />。 値として無限大を指定すると、ウィンドウのサイズをあらゆるコンテンツに合わせることができます。</param>
        <summary>ウィンドウのサイズを測定するには、このメソッドをオーバーライドします。</summary>
        <returns>このウィンドウが、子のサイズの計算に基づいて、レイアウト時に必要だと判断するサイズを反映する <see cref="T:System.Windows.Size" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A>プロパティの値がの<xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Visibility.Collapsed>場合、は呼び出されません。 <xref:System.Windows.UIElement.Visibility%2A>プロパティの値がまたは<xref:System.Windows.Visibility.Visible>のいずれ<xref:System.Windows.Visibility.Hidden>かで<xref:System.Windows.Window.MeasureOverride%2A>ある場合は、が呼び出されます。  
  
> [!NOTE]
>  または<xref:System.Windows.Window.Show%2A> <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Window> <xref:System.Windows.Visibility.Visible>のいずれかが呼び出されると、のプロパティはに設定されます。 <xref:System.Windows.Window.ShowDialog%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="window.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Window.Activated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnActivated%2A> は、<xref:System.Windows.Window.Activated> イベントを発生させます。  
  
 から<xref:System.Windows.Window>派生する型がオーバーライド<xref:System.Windows.Window.OnActivated%2A>される可能性があります。 必要に応じ<xref:System.Windows.Window.Activated>て、 <xref:System.Windows.Window.OnActivated%2A>オーバーライドされたメソッドは基底クラスでを呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : EventArgs -&gt; unit&#xA;override this.OnClosed : EventArgs -&gt; unit" Usage="window.OnClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Window.Closed" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosed%2A> は、<xref:System.Windows.Window.Closed> イベントを発生させます。  
  
 から<xref:System.Windows.Window>派生する型がオーバーライド<xref:System.Windows.Window.OnClosed%2A>される可能性があります。 必要に応じ<xref:System.Windows.Window.Closed>て、 <xref:System.Windows.Window.OnClosed%2A>オーバーライドされたメソッドは基底クラスでを呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="window.OnClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.ComponentModel.CancelEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Window.Closing" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosing%2A> は、<xref:System.Windows.Window.Closing> イベントを発生させます。  
  
 から<xref:System.Windows.Window>派生する型がオーバーライド<xref:System.Windows.Window.OnClosing%2A>される可能性があります。 必要に応じ<xref:System.Windows.Window.Closing>て、 <xref:System.Windows.Window.OnClosing%2A>オーバーライドされたメソッドは基底クラスでを呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberSignature Language="F#" Value="override this.OnContentChanged : obj * obj -&gt; unit" Usage="window.OnContentChanged (oldContent, newContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">古いコンテンツ ツリーのルートへの参照。</param>
        <param name="newContent">新しいコンテンツ ツリーのルートへの参照。</param>
        <summary><see cref="P:System.Windows.Controls.ContentControl.Content" /> プロパティが変更されたときに呼び出されます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentRendered : EventArgs -&gt; unit&#xA;override this.OnContentRendered : EventArgs -&gt; unit" Usage="window.OnContentRendered e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Window.ContentRendered" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnContentRendered%2A> は、<xref:System.Windows.Window.ContentRendered> イベントを発生させます。  
  
 から<xref:System.Windows.Window>派生する型がオーバーライド<xref:System.Windows.Window.OnContentRendered%2A>される可能性があります。 必要に応じ<xref:System.Windows.Window.ContentRendered>て、 <xref:System.Windows.Window.OnContentRendered%2A>オーバーライドされたメソッドは基底クラスでを呼び出す必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="window.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> に対応する <see cref="T:System.Windows.Window" /> オブジェクトを作成して返します。</summary>
        <returns>この <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> に対応する <see cref="T:System.Windows.Window" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A> をオーバーライドします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="window.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Window.Deactivated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnDeactivated%2A> は、<xref:System.Windows.Window.Deactivated> イベントを発生させます。  
  
 から<xref:System.Windows.Window>派生する型がオーバーライド<xref:System.Windows.Window.OnDeactivated%2A>される可能性があります。 必要に応じ<xref:System.Windows.Window.Deactivated>て、 <xref:System.Windows.Window.OnDeactivated%2A>オーバーライドされたメソッドは基底クラスでを呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberSignature Language="F#" Value="override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="window.OnDpiChanged (oldDpi, newDpi)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="oldDpi">以前の DPI スケール設定。</param>
        <param name="newDpi">新規の DPI スケール設定。</param>
        <summary>このウィンドウが表示される DPI が変更するときに呼び出されます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="window.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Window.LocationChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnLocationChanged%2A> は、<xref:System.Windows.Window.LocationChanged> イベントを発生させます。  
  
 から<xref:System.Windows.Window>派生する型がオーバーライド<xref:System.Windows.Window.OnLocationChanged%2A>される可能性があります。 必要に応じ<xref:System.Windows.Window.LocationChanged>て、 <xref:System.Windows.Window.OnLocationChanged%2A>オーバーライドされたメソッドは基底クラスでを呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit" Usage="window.OnManipulationBoundaryFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベントのデータ。</param>
        <summary><see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> イベントが発生すると呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この実装では、 <xref:System.Windows.RoutedEventArgs.Handled%2A> <xref:System.Windows.UIElement.ManipulationBoundaryFeedback>イベントデータの処理済みの状態 (プロパティ) は変更されません。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>をオーバーライド<see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />する場合は、常に<see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />実装で基本実装を呼び出します。 基本実装を呼び出さないと、基底クラスでイベントを処理できなくなり、最終的なクラスの実行時の動作が変わる可能性があります。 基本実装は、要件に応じて、特別な処理の前または後に呼び出すことができます。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSourceInitialized : EventArgs -&gt; unit&#xA;override this.OnSourceInitialized : EventArgs -&gt; unit" Usage="window.OnSourceInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Window.SourceInitialized" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnSourceInitialized%2A> は、<xref:System.Windows.Window.SourceInitialized> イベントを発生させます。  
  
 から<xref:System.Windows.Window>派生する型がオーバーライド<xref:System.Windows.Window.OnSourceInitialized%2A>される可能性があります。 必要に応じ<xref:System.Windows.Window.SourceInitialized>て、 <xref:System.Windows.Window.OnSourceInitialized%2A>オーバーライドされたメソッドは基底クラスでを呼び出す必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStateChanged : EventArgs -&gt; unit&#xA;override this.OnStateChanged : EventArgs -&gt; unit" Usage="window.OnStateChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Window.StateChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnStateChanged%2A> は、<xref:System.Windows.Window.StateChanged> イベントを発生させます。  
  
 から<xref:System.Windows.Window>派生する型がオーバーライド<xref:System.Windows.Window.OnStateChanged%2A>される可能性があります。 必要に応じ<xref:System.Windows.Window.StateChanged>て、 <xref:System.Windows.Window.OnStateChanged%2A>オーバーライドされたメソッドは基底クラスでを呼び出す必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualChildrenChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualChildrenChanged (System.Windows.DependencyObject visualAdded, System.Windows.DependencyObject visualRemoved);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualChildrenChanged(class System.Windows.DependencyObject visualAdded, class System.Windows.DependencyObject visualRemoved) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualChildrenChanged (visualAdded As DependencyObject, visualRemoved As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualChildrenChanged(System::Windows::DependencyObject ^ visualAdded, System::Windows::DependencyObject ^ visualRemoved);" />
      <MemberSignature Language="F#" Value="override this.OnVisualChildrenChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualChildrenChanged (visualAdded, visualRemoved)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visualAdded" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.8" />
        <Parameter Name="visualRemoved" Type="System.Windows.DependencyObject" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="visualAdded">コレクションに追加された <see cref="T:System.Windows.Media.Visual" />。</param>
        <param name="visualRemoved">コレクションから削除された <see cref="T:System.Windows.Media.Visual" />。</param>
        <summary>この <see cref="T:System.Windows.Window" /> オブジェクトの <see cref="T:System.Windows.Media.VisualCollection" /> が変更されると呼び出されます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">直前の親。 <see cref="T:System.Windows.DependencyObject" /> の直前の親が存在しない場合は null に設定されます。</param>
        <summary>ウィンドウの親が変更されると呼び出されます。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnedWindows : System.Windows.WindowCollection" Usage="System.Windows.Window.OwnedWindows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このウィンドウがオーナー ウィンドウとなっているウィンドウのコレクションを取得します。</summary>
        <value>このウィンドウがオーナー ウィンドウとなっているウィンドウへの参照を含む <see cref="T:System.Windows.WindowCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所有ウィンドウとは、オーナー <xref:System.Windows.Window.Owner%2A>ウィンドウと呼ばれる別のウィンドウへの参照を持つプロパティが設定されているウィンドウのことです。 所有者ウィンドウに<xref:System.Windows.WindowCollection> <xref:System.Windows.Window.OwnedWindows%2A>よって所有されているすべてのウィンドウを検索するには、プロパティによって返されるを列挙します。  
  
   
  
## Examples  
 次の例は、を列挙<xref:System.Windows.Window.OwnedWindows%2A>する方法を示しています。  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.Window with get, set" Usage="System.Windows.Window.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Windows.Window" /> を所有する <see cref="T:System.Windows.Window" /> を取得または設定します。</summary>
        <value>この <see cref="T:System.Windows.Window" /> のオーナー ウィンドウを表す <see cref="T:System.Windows.Window" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 を呼び出し<xref:System.Windows.Window.ShowDialog%2A>て親ウィンドウで子ウィンドウを開くと、親ウィンドウと子ウィンドウの間に暗黙的なリレーションシップが確立されます。 この関係により、最小化、最大化、および復元に関するなどの特定の動作が適用されます。  
  
 ただし<xref:System.Windows.Window.Show%2A>、子ウィンドウが親ウィンドウによって作成されている場合、子ウィンドウは親ウィンドウとのリレーションシップを持ちません。 これによって、次のことが起こります。  
  
-   子ウィンドウに親ウィンドウへの参照がありません。  
  
-   子ウィンドウの動作は、親ウィンドウの動作に依存しません。どちらのウィンドウも、他のウィンドウとは別にカバーするか、最小化、最大化、および復元することができます。  
  
 子ウィンドウと親ウィンドウの間にリレーションシップを作成できるようにするため<xref:System.Windows.Window>に、では所有権の概念がサポートされています。 所有権は、ウィンドウ<xref:System.Windows.Window.Owner%2A> (所有ウィンドウ) のプロパティが別のウィンドウ (オーナーウィンドウ) への参照で設定されている場合に確立されます。  
  
 このリレーションシップが確立されると、次の動作が発生します。  
  
-   所有者ウィンドウが最小化されている場合は、所有しているすべてのウィンドウも最小化されます。  
  
-   所有しているウィンドウが最小化されている場合、その所有者は最小化されていません。  
  
-   オーナーウィンドウが最大化されている場合は、所有者ウィンドウと所有ウィンドウの両方が復元されます。  
  
-   オーナーウィンドウは、所有しているウィンドウをカバーすることはできません。  
  
-   を使用して<xref:System.Windows.Window.ShowDialog%2A>開かれていない所有ウィンドウはモーダルではありません。 ユーザーは、引き続き [所有者] ウィンドウと対話できます。  
  
-   オーナーウィンドウを閉じると、所有しているウィンドウも閉じられます。  
  
-   所有ウィンドウがを使用し<xref:System.Windows.Window.Show%2A>て所有者ウィンドウによって開かれ、オーナーウィンドウが閉じている場合、所有ウィンドウの<xref:System.Windows.Window.Closing>イベントは発生しません。  
  
 を呼び出し<xref:System.Windows.Window.ShowDialog%2A>て子ウィンドウを開いた場合は、子ウィンドウの<xref:System.Windows.Window.Owner%2A>プロパティも設定する必要があります。 そうしないと、ユーザーはタスクバーボタンを押して子ウィンドウと親ウィンドウの両方を復元できなくなります。 代わりに、[タスクバー] ボタンを押すと、子ウィンドウと親ウィンドウの両方を含むウィンドウの一覧が表示され、選択できるようになります。選択したウィンドウのみが復元されます。  
  
> [!IMPORTANT]
>  また、を呼び出し<xref:System.Windows.Window.Owner%2A> <xref:System.Windows.Window.ShowDialog%2A>て、を正しく動作させるために開いたウィンドウにプロパティを設定する必要があります。  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このプロパティを設定または取得することはできません。  
  
   
  
## Examples  
 次の例では、所有者/所有関係を確立する方法を示します。  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ウィンドウがそのウィンドウ自体を所有しようとしています。  
  
 - または -  
  
 2 つのウィンドウが相互に所有しようとしています。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Window.Owner" /> プロパティが、表示されているウィンドウで <see cref="M:System.Windows.Window.ShowDialog" /> を使用して設定されています。  
  
- または - 
<see cref="P:System.Windows.Window.Owner" /> プロパティが、まだ表示されていないウィンドウに設定されています。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">すべての windows およびユーザー入力イベントを制限なしで使用するためのアクセス許可。 関連付けられた列挙型:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeMode : System.Windows.ResizeMode with get, set" Usage="System.Windows.Window.ResizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サイズ変更モードを取得または設定します。</summary>
        <value>サイズ変更モードを指定する <see cref="T:System.Windows.ResizeMode" /> 値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の4つのオプションがあります。  
  
-   **Noresize**。 ユーザーはウィンドウのサイズを変更できません。 [最大化] と [最小化] の各ボックスは表示されません。  
  
-   **Canminimize**。 ユーザーは、ウィンドウを最小化して、タスクバーから復元することしかできません。 [最小化] と [最大化] の両方のボックスが表示されますが、[最小化] ボックスのみが有効になっています。  
  
-   **Canresize**。 ユーザーは、最小化ボタンと最大化ボックスを使用してウィンドウのサイズを変更できるだけでなく、ウィンドウの周りにドラッグしたアウトラインも表示されます。 [最小化] ボックスと [最大化] ボックスが表示され、有効になります。 (既定値)。  
  
-   **CanResizeWithGrip**。 このオプションの機能はと<xref:System.Windows.ResizeMode.CanResize>同じですが、ウィンドウの右下隅に "サイズ変更グリップ" を追加します。  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このプロパティを設定または取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Window.ResizeModeProperty>|  
|メタデータプロパティがに設定される`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ResizeModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ResizeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.ResizeMode" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.RestoreBounds : System.Windows.Rect" Usage="System.Windows.Window.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最小化または最大化される前のウィンドウのサイズと位置を取得します。</summary>
        <value>最小化または最大化される前のウィンドウのサイズと位置を指定する <see cref="T:System.Windows.Rect" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 復元用の四角形は、最小化または最大化される前にウィンドウによって占有される領域です。 を使用<xref:System.Windows.Window.RestoreBounds%2A>すると、アプリケーションを閉じる前にウィンドウの最後のサイズと位置を保存し、次にアプリケーションが起動してからユーザーがウィンドウを左に移動したときにそれらの値を取得できます。  
  
 ウィンドウが表示<xref:System.Windows.Window.RestoreBounds%2A>される前、または閉じられた後にクエリ<xref:System.Windows.Rect.Empty%2A>を実行すると、が返されます。  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このプロパティを取得することはできません。  
  
   
  
## Examples  
 次の例で<xref:System.Windows.Window.RestoreBounds%2A>は、および分離ストレージを使用して、ウィンドウのサイズと位置が、ウィンドウが以前に表示されたときと同じであることを確認します。  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">ウィンドウの外接する四角形のサイズと位置を照会するアクセス許可。 関連付けられた列挙型:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="window.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ウィンドウを開き、開いたウィンドウが閉じるのを待機せずに制御を戻します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window>クラスがインスタンス化されると、既定では表示されません。 <xref:System.Windows.Window.Show%2A>ウィンドウを表示し、ウィンドウが閉じられるのを待たずにすぐに制御を戻します。 そのため、開いているウィンドウでは、ユーザーがアプリケーション内の他のウィンドウと対話できないようにすることはできません。 この種類のウィンドウは、*モードレス*ウィンドウと呼ばれます。 モードレスウィンドウの一般的な例として、ウィンドウ、ツールボックス、およびパレットがあります。 特定のウィンドウとの対話をユーザーに制限するには、を呼び出し<xref:System.Windows.Window.ShowDialog%2A>てウィンドウを開く必要があります。  
  
 を呼び出す<xref:System.Windows.Window.Show%2A>ことによって開かれたウィンドウは、そのウィンドウを開いたウィンドウと自動的に関係がありません。特に、開いているウィンドウは、開いているウィンドウを認識しません。 このリレーションシップは、 <xref:System.Windows.Window.Owner%2A>プロパティを使用して確立し、 <xref:System.Windows.Window.OwnedWindows%2A>プロパティを使用して管理できます。  
  
 を<xref:System.Windows.Window.Show%2A>呼び出すと、 <xref:System.Windows.Window>オブジェクトのプロパティ<xref:System.Windows.UIElement.Visibility%2A>をに設定するの<xref:System.Windows.Visibility.Visible>と同じ結果が得られます。 ただし、タイミングの観点からは2つの違いがあります。  
  
 の<xref:System.Windows.Window.Show%2A>呼び出しは、子ウィンドウの<xref:System.Windows.FrameworkElement.Loaded>イベントが発生した後にのみを返す同期操作です。  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 ただし<xref:System.Windows.UIElement.Visibility%2A>、を設定するのは、すぐにを返す非同期操作です。  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 設定すると<xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.UIElement.Visibility%2A> 、を設定する前に登録したウィンドウイベントは、を設定したメソッドが実行を完了するまで発生しない可能性があります。 <xref:System.Windows.UIElement.Visibility%2A>  
  
   
  
## Examples  
 次のサンプルは、モードレスウィンドウを開く方法を示しています。  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">閉じている途中 (<see cref="M:System.Windows.Window.Show" />) または閉じた (<see cref="E:System.Windows.Window.Closing" />) ウィンドウに対して <see cref="E:System.Windows.Window.Closed" /> が呼び出されている。</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowActivated : bool with get, set" Usage="System.Windows.Window.ShowActivated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウをアクティブ状態で初期表示するかどうかを示す値を取得または設定します。</summary>
        <value>ウィンドウを初期表示するときにアクティブ化する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ShowActivated%2A>プロパティがに`false`設定されたウィンドウを開くと、ウィンドウはアクティブ化され<xref:System.Windows.Window.Activated>ず、ユーザーが手動でウィンドウを選択してアクティブにするまで、そのイベントは発生しません。 ウィンドウが選択されると、正常にアクティブ化され、非アクティブになります。  
  
 <xref:System.Windows.Window.ShowActivated%2A>ウィンドウが開いたときにアクティブにならないようにするには、を`false`呼び出し<xref:System.Windows.Window.Show%2A>て、ウィンドウを表示する前にプロパティを<xref:System.Windows.Window.ShowActivated%2A>に`false`設定する必要があります。ウィンドウを表示した後にを設定しても効果はありません。  
  
 を<xref:System.Windows.Window.ShowActivated%2A>呼び`false` 出す<xref:System.Windows.Window.ShowDialog%2A>ことによって、モーダルで開かれたウィンドウでをに設定しても、実際の影響はありません。 モーダルウィンドウはアクティブ化されませんが、モーダルウィンドウを使用すると、ユーザーは開いている他のアプリケーションウィンドウをアクティブにできなくなります。  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Window.ShowActivatedProperty>|  
|メタデータプロパティがに設定される`true`|None|  
  
   
  
## Examples  
 次の例は、マークアップを使用して、アクティブ化せずにウィンドウを開くように構成する方法を示しています。  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 次の例は、コードを使用して、ウィンドウをアクティブ化せずに開くように構成する方法を示しています。  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowActivatedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowActivatedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.ShowActivated" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberSignature Language="F#" Value="member this.ShowDialog : unit -&gt; Nullable&lt;bool&gt;" Usage="window.ShowDialog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ウィンドウを開き、開いたウィンドウが閉じた場合にのみ制御を戻します。</summary>
        <returns>アクティビティが受け入れられた (<see langword="true" />) か、取り消された (<see langword="false" />) かを示す <see cref="T:System.Nullable`1" /> 型の <see cref="T:System.Boolean" /> 値。 この戻り値は、ウィンドウが閉じる前の <see cref="P:System.Windows.Window.DialogResult" /> プロパティの値です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window>クラスがインスタンス化されると、既定では表示されません。 <xref:System.Windows.Window.ShowDialog%2A>ウィンドウを表示し、アプリケーション内の他のウィンドウをすべて無効にして、ウィンドウが閉じている場合にのみを返します。 この種類のウィンドウを*モーダル*ウィンドウと呼びます。  
  
 モーダルウィンドウは、主にダイアログボックスとして使用されます。 ダイアログボックスは、アプリケーションがユーザーとやり取りして、ファイルのオープンやドキュメントの印刷などのタスクを実行するために使用する、特別な種類のウィンドウです。 ダイアログボックスを使用すると、通常、ダイアログボックスが閉じられる前に表示されていたタスクをユーザーが受け入れたり取り消したりできます。 <xref:System.Windows.Window.ShowDialog%2A>アクティビティが受け入れられたか取り消されたかを示す値を返します。<xref:System.Boolean> <xref:System.Nullable%601> この戻り値は、ウィンドウが閉じる前の <xref:System.Windows.Window.DialogResult%2A> プロパティの値です。 詳細については、「<xref:System.Windows.Window.DialogResult%2A>」を参照してください。  
  
 <xref:System.Windows.Window.ShowDialog%2A>メソッドを呼び出すことによって開かれたウィンドウには、そのウィンドウを開いたウィンドウとの関係は自動的にはありません。つまり、開いているウィンドウでは、どのウィンドウが開いているかがわかりません。 このリレーションシップは、 <xref:System.Windows.Window.Owner%2A>プロパティを使用して確立し、 <xref:System.Windows.Window.OwnedWindows%2A>プロパティを使用して管理できます。 オートメーションを[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]サポートするには (「 [UI オートメーションの概要](~/docs/framework/ui-automation/ui-automation-overview.md)」を参照)、を<xref:System.Windows.Window.Owner%2A>呼び出し<xref:System.Windows.Window.ShowDialog%2A>て開いたウィンドウに対してを設定する必要があります。  
  
 モーダル[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]ウィンドウ (を呼び出し<xref:System.Windows.Window.ShowDialog%2A>て開いたウィンドウ) を閉じると、アクティブになっていたウィンドウが再アクティブ化されます。 モーダル[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]ウィンドウにオーナーウィンドウがある場合 (「 <xref:System.Windows.Window.Owner%2A>」を参照)、モーダル[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]ウィンドウが閉じているときに、前にアクティブ化されたウィンドウでない限り、オーナーウィンドウは再アクティブ化されません。  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このメソッドを呼び出すことはできません。  
  
   
  
## Examples  
 モーダルウィンドウを開く方法を次の例に示します。  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">閉じている途中 (<see cref="M:System.Windows.Window.ShowDialog" />) または閉じた (<see cref="E:System.Windows.Window.Closing" />) ウィンドウに対して <see cref="E:System.Windows.Window.Closed" /> が呼び出されている。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">ウィンドウをアクティブにするアクセス許可の場合は。 関連付けられた列挙型:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowInTaskbar : bool with get, set" Usage="System.Windows.Window.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウにタスク バー ボタンがあるかどうかを示す値を取得または設定します。</summary>
        <value>ウィンドウにタスク バー ボタンがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 ブラウザー内でウィンドウがホストされている場合は適用されません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 が<xref:System.Windows.Window.ShowInTaskbar%2A> に`true`設定されている場合、ウィンドウは ALT + TAB アプリケーションの選択リストにも表示されます。  
  
 タスクバーボタンと ALT + TAB アプリケーション選択リストの両方に使用されるアイコンは、 <xref:System.Windows.Window.Icon%2A>プロパティの値です。  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このプロパティを設定または取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|メタデータプロパティがに設定される`true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowInTaskbarProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowInTaskbarProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.ShowInTaskbar" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberSignature Language="F#" Value="member this.SizeToContent : System.Windows.SizeToContent with get, set" Usage="System.Windows.Window.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウのサイズがコンテンツのサイズに合わせて自動的に調整されるかどうかを示す値を取得または設定します。</summary>
        <value><see cref="T:System.Windows.SizeToContent" /> 値。 既定値は、<see cref="F:System.Windows.SizeToContent.Manual" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 が<xref:System.Windows.Window.SizeToContent%2A>に<xref:System.Windows.SizeToContent.WidthAndHeight>設定されている<xref:System.Windows.FrameworkElement.Height%2A>場合<xref:System.Windows.FrameworkElement.Width%2A> 、またはのいずれかを設定しても効果はありません。両方のプロパティを設定できますが、設定されている値はウィンドウに適用されません。  
  
 が<xref:System.Windows.Window.SizeToContent%2A>に<xref:System.Windows.SizeToContent.Height>設定されて<xref:System.Windows.FrameworkElement.Height%2A>いる場合、を設定してもウィンドウの高さは変わりません。  
  
 が<xref:System.Windows.Window.SizeToContent%2A>に<xref:System.Windows.SizeToContent.Width>設定されて<xref:System.Windows.FrameworkElement.Width%2A>いる場合、を設定してもウィンドウの幅は変わりません。  
  
 の値が<xref:System.Windows.Window.SizeToContent%2A> 次の値以外の場合:<xref:System.Windows.SizeToContent.Manual>  
  
-   <xref:System.Windows.Window.SizeToContent%2A>ユーザーがサイズ変更<xref:System.Windows.SizeToContent.Manual>グリップを使用してウィンドウのサイズを変更した場合、または境界線をドラッグした場合、は自動的にに設定されます。  
  
-   コンテンツのサイズが変更され、ウィンドウのサイズが変更されるようになっ<xref:System.Windows.FrameworkElement.SizeChanged>た場合は、が発生します。  
  
 ウィンドウが透明になっている<xref:System.Windows.Window.AllowsTransparency%2A>場合は (「」を<xref:System.Windows.Window.SizeToContent%2A>参照<xref:System.Windows.SizeToContent.WidthAndHeight> )、ウィンドウが表示されるコンテンツよりも大きくないことを確認するには、をに設定することを検討してください。  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このプロパティを設定または取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Window.SizeToContentProperty>|  
|メタデータプロパティがに設定される`true`|None|  
  
   
  
## Examples  
 次の例では、コンテンツに<xref:System.Windows.Window.SizeToContent%2A>合わせてウィンドウのサイズを変更する方法を指定するために、コードでプロパティを設定する方法を示します。  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeToContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.SizeToContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.SizeToContent" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberSignature Language="F#" Value="member this.SourceInitialized : EventHandler " Usage="member this.SourceInitialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このイベントは、[!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] との相互運用をサポートするために発生します。 以下を参照してください。<see cref="T:System.Windows.Interop.HwndSource" /></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberSignature Language="F#" Value="member this.StateChanged : EventHandler " Usage="member this.StateChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウの <see cref="P:System.Windows.Window.WindowState" /> プロパティが変更されたときに発生します。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TaskbarItemInfo : System.Windows.Shell.TaskbarItemInfo with get, set" Usage="System.Windows.Window.TaskbarItemInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Window" /> の [!INCLUDE[win7](~/includes/win7-md.md)] タスク バーのサムネイルを取得または設定します。</summary>
        <value><see cref="T:System.Windows.Window" /> の [!INCLUDE[win7](~/includes/win7-md.md)] タスク バーのサムネイル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスクバーのサムネイルの[!INCLUDE[win7](~/includes/win7-md.md)]使用方法の詳細については、 <xref:System.Windows.Shell.TaskbarItemInfo>クラスを参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TaskbarItemInfoProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.TaskbarItemInfo" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Window.Title" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウのタイトルを取得または設定します。</summary>
        <value>ウィンドウのタイトルを格納する <see cref="T:System.String" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window>、 <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>、または[!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]のタイトルは、を使用して設定することもできます。 <xref:System.Windows.Navigation.NavigationWindow>  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Window.TitleProperty>|  
|メタデータプロパティがに設定される`true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TitleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.Title" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Top : double with get, set" Usage="System.Windows.Window.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウの上端の位置を、デスクトップとの関係で取得または設定します。</summary>
        <value>ウィンドウの上端の位置。単位は論理単位 (1/96 インチ)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 が最大化または最小化されると、この値はの復元ポイント<xref:System.Windows.Window>の上端を表します。 <xref:System.Windows.Window>  
  
 このプロパティは、スタイルを使用して設定することはできません。  
  
 値を指定しない場合、 <xref:System.Windows.Window.Top%2A>はシステムの既定値に設定されます。 をに<xref:System.Windows.Window.Top%2A> <xref:System.Double.NaN>設定することによって、システムの既定値を指定することもできます。 とのどちらも<xref:System.Double.NegativeInfinity> 、の<xref:System.Windows.Window.Top%2A>有効な値ではありません。 <xref:System.Double.PositiveInfinity>  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このプロパティを設定または取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Window.TopProperty>|  
|メタデータプロパティがに設定される`true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Topmost : bool with get, set" Usage="System.Windows.Window.Topmost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウが最上位 z オーダーで表示されるかどうかを示す値を取得または設定します。</summary>
        <value>ウィンドウが最上位の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティがに<xref:System.Windows.Window.Topmost%2A>設定されて`true`いる`false`すべてのウィンドウ<xref:System.Windows.Window.Topmost%2A>の上にプロパティが設定されているウィンドウ。  
  
 <xref:System.Windows.Window.Topmost%2A>プロパティがに`true`設定されているウィンドウのグループでは、現在アクティブになっているウィンドウが最上位のウィンドウになります。 また、プロパティがに<xref:System.Windows.Window.Topmost%2A> `false`設定されているウィンドウのグループについても同様です。  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このプロパティを設定または取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Window.TopmostProperty>|  
|メタデータプロパティがに設定される`true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopmostProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopmostProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.Topmost" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.Top" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStartupLocation : System.Windows.WindowStartupLocation with get, set" Usage="System.Windows.Window.WindowStartupLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初に表示するときのウィンドウの位置を取得または設定します。</summary>
        <value>ウィンドウが最初に表示されたときの左上の位置を指定する <see cref="T:System.Windows.WindowStartupLocation" /> 値。 既定値は、<see cref="F:System.Windows.WindowStartupLocation.Manual" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティをに設定<xref:System.Windows.WindowStartupLocation.Manual>する<xref:System.Windows.Window.Left%2A>と、ウィンドウがプロパティ値および<xref:System.Windows.Window.Top%2A>プロパティ値に従って配置されます。 `WindowStartupLocation` または<xref:System.Windows.Window.Left%2A> <xref:System.Windows.Window.Top%2A>のいずれかのプロパティが指定されていない場合、これらの値は Windows によって決定されます。  
  
 プロパティをに設定<xref:System.Windows.WindowStartupLocation.CenterScreen>すると、ウィンドウがマウスカーソルを含む画面の中央に配置されます。 `WindowStartupLocation`  
  
 プロパティをに設定<xref:System.Windows.WindowStartupLocation.CenterOwner>すると、ウィンドウがオーナーウィンドウの中央に配置されます ( <xref:System.Windows.Window.Owner%2A?displayProperty=nameWithType>を参照)。 `WindowStartupLocation` [所有者] ウィンドウには、別の WPF ウィンドウまたは非 WPF ウィンドウを指定できます。

> [!NOTE]   
>  Wpf 以外のウィンドウを使用した WPF ウィンドウの詳細については、「 <xref:System.Windows.Interop.WindowInteropHelper> [Wpf と Win32 の相互運用](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)」と「」を参照してください。 

 オーナーウィンドウが指定されていない場合、ウィンドウの位置は、 `WindowStartupLocation`プロパティがに<xref:System.Windows.WindowStartupLocation.Manual>設定されている場合と同じ方法で決定されます。

> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このプロパティの値を設定または取得することはできません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberSignature Language="F#" Value="member this.WindowState : System.Windows.WindowState with get, set" Usage="System.Windows.Window.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウが元のサイズに戻されているか、最小化されているか、最大化されているかを示す値を取得または設定します。</summary>
        <value>ウィンドウが元のサイズに戻されているか、最小化されているか、最大化されているかを判断する <see cref="T:System.Windows.WindowState" />。 既定値は、<see cref="F:System.Windows.WindowState.Normal" /> (元のサイズに戻されている) です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ウィンドウが最小化または最大化される前に、そのサイズと<xref:System.Windows.Window.RestoreBounds%2A>位置がに格納されます。 その後、ウィンドウが復元されると、サイズと位置の値がからの<xref:System.Windows.Window.RestoreBounds%2A>値で復元されます。  
  
 プロパティが変更されると<xref:System.Windows.Window.StateChanged> 、が発生します。 <xref:System.Windows.Window.WindowState%2A>  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このプロパティを設定または取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Window.WindowStateProperty>|  
|メタデータプロパティがに設定される`true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.WindowState" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStyle : System.Windows.WindowStyle with get, set" Usage="System.Windows.Window.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウィンドウの枠線のスタイルを取得または設定します。</summary>
        <value>ウィンドウの境界線スタイルを指定する <see cref="T:System.Windows.WindowStyle" />。 既定値は、<see cref="F:System.Windows.WindowStyle.SingleBorderWindow" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A><xref:System.Windows.WindowStyle> <xref:System.Windows.WindowStyle.None>には、、<xref:System.Windows.WindowStyle.ThreeDBorderWindow>、 (既定値)、およびなどの列挙値のいずれかを指定できます。<xref:System.Windows.WindowStyle.SingleBorderWindow> <xref:System.Windows.WindowStyle.ToolWindow>  
  
 次の図は、の[!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)]ウィンドウスタイルを示しています (透明なグラスが有効になっている Windows Vista Aero テーマ)。  
  
 ![ウィンドウスタイル](~/add/media/windowoverviewfigure6.PNG "ウィンドウスタイル")  
  
> [!NOTE]
>  ウィンドウがブラウザーでホストされている場合、このプロパティを設定または取得することはできません。  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Window.WindowStyleProperty>|  
|メタデータプロパティがに設定される`true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.WindowStyle" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
