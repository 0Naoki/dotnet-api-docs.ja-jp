<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="423f853a60d99a5767f47d8a9e4d3ef0dce3cb15" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39845059" /></Metadata><TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>登録時の条件など、特定の種類に適用されるときの依存関係プロパティの動作を定義します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティのメタデータを定義し、呼び出すときに、依存関係プロパティの登録時に使用、<xref:System.Windows.DependencyProperty.Register%2A>メソッド (または添付プロパティまたは読み取り専用の依存関係プロパティの変化形)、または、を呼び出すときに、元の所有者登録した後<xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>メソッド。 <xref:System.Windows.DependencyProperty.AddOwner%2A> プロパティのメタデータも受け取ります。  
  
 このクラスは、それらの各呼び出しで使用できる具象基底クラスです。 ただし、メタデータなどを使用して、派生クラスのいずれかを指定する非常に一般的なは<xref:System.Windows.FrameworkPropertyMetadata>します。 これらの派生クラスでのみ実装されているプロパティ システムとレイアウト動作を有効にするかを検出する場合に便利ですが、ブール型プロパティ値として実行される詳細なメタデータをサポートする、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]フレームワーク レベル。  
  
 このクラスのいくつかのプロパティは、オブジェクト モデルを読み取り/書き込みがなどのプロパティのシステム操作で使用されているインスタンスの前に記述できますのみ<xref:System.Windows.DependencyProperty.Register%2A>または<xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>します。 これらの各プロパティ、コンス トラクターによって設定されてもでしたが公開されるように<xref:System.Windows.PropertyMetadata.Merge%2A>メソッドの実装が設定できます。  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用状況  
 この種類、および、この型のメンバーは、通常は使用されません[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティに指定する既定値。通常、特定の型の値として指定されます。</param>
        <summary>メタデータが適用される依存関係プロパティの指定した既定値を使用して、<see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定された値の型`defaultValue`一致であるか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 メタデータの既定値の型に適用される依存関係プロパティの型の間の不一致 (不一致を実行時例外が発生させる) コンパイル時に、不一致が検出できないため、デバッグが困難ことはできます。  
  
 既定のパラメーターなしのコンス トラクターごと、`defaultValue`の<xref:System.Windows.DependencyProperty.UnsetValue>は指定できません。 しようとすると、例外が発生します。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> は値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照です。</param>
        <summary>指定した <see cref="T:System.Windows.PropertyMetadata" /> 実装参照を使用して、<see cref="T:System.Windows.PropertyChangedCallback" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型の値として指定されます。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照です。</param>
        <summary>指定した既定値と <see cref="T:System.Windows.PropertyMetadata" /> 実装参照を使用して、<see cref="T:System.Windows.PropertyChangedCallback" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定された値の型`defaultValue`一致であるか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 メタデータの既定値の型に適用される依存関係プロパティの型の間の不一致 (不一致を実行時例外が発生させる) コンパイル時に、不一致が検出できないため、デバッグが困難ことはできます。  
  
 既定のパラメーターなしのコンス トラクターごと、`defaultValue`の<xref:System.Windows.DependencyProperty.UnsetValue>は指定できません。 しようとすると、例外が発生します。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> は値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型の値として指定されます。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照です。</param>
        <param name="coerceValueCallback">プロパティ システムがこのプロパティに対して <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> を呼び出すときに必ず呼び出されるハンドラー実装への参照です。</param>
        <summary>指定した既定値とコールバックを使用して、<see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定する場合、<xref:System.Windows.CoerceValueCallback>ではなく、<xref:System.Windows.PropertyChangedCallback>を渡すことができます`null`の`propertyChangedCallback`パラメーター。  
  
 指定された値の型`defaultValue`一致であるか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 メタデータの既定値の型に適用される依存関係プロパティの型の間の不一致 (不一致を実行時例外が発生させる) コンパイル時に、不一致が検出できないため、デバッグが困難ことはできます。  
  
 既定のパラメーターなしのコンス トラクターごと、`defaultValue`の<xref:System.Windows.DependencyProperty.UnsetValue>は指定できません。 しようとすると、例外が発生します。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> は値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメタデータに指定されている <see cref="T:System.Windows.CoerceValueCallback" /> 実装への参照を取得または設定します。</summary>
        <value><see cref="T:System.Windows.CoerceValueCallback" /> 実装参照。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティのメタデータでのコールバックは、このプロパティの値は単に既存の依存関係プロパティのメタデータを使用するほとんどのシナリオの重要ではありませんので、型は、通常のパブリック メンバーではありません。 このプロパティが公開されている理由の 1 つは、メタデータのサブクラスは基本メタデータとメタデータをオーバーライドする追加の両方を指定する場合、必要なマージ ロジックを実行できるように、<xref:System.Windows.CoerceValueCallback>します。 ただし、既定値はマージ ロジックを<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>に 1 つ前を置き換えるものです。  
  
 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 読み取り/書き込みとしてオブジェクト モデルで定義されます。 これは、<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>の初期化後に調整することができます、<xref:System.Windows.PropertyMetadata>オブジェクト自体です。 ただし、呼び出しの一部として使用されるメタデータと<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、プロパティ システムはそのメタデータ インスタンスを封印およびプロパティを変更できないと見なされますようになりました。 設定しようとしています。<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>したら<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`でこのメタデータ インスタンスで例外が発生します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">依存関係プロパティの操作にいったん適用した後は、メタデータのプロパティを設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの既定値を取得または設定します。</summary>
        <value>プロパティの既定値。 既定値、<see cref="T:System.Windows.PropertyMetadata" />パラメーターなしのコンス トラクターで作成されたインスタンスになります<see cref="F:System.Windows.DependencyProperty.UnsetValue" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 読み取り/書き込みとしてオブジェクト モデルで定義されます。 これは、<xref:System.Windows.PropertyMetadata.DefaultValue%2A>の初期化後に調整することができます、<xref:System.Windows.PropertyMetadata>オブジェクト自体です。 ただし、呼び出しの一部として使用されるメタデータと<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、プロパティ システムはそのメタデータ インスタンスを封印およびプロパティを変更できないと見なされますようになりました。 設定しようとしています。<xref:System.Windows.PropertyMetadata.DefaultValue%2A>したら<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`でこのメタデータ インスタンスで例外が発生します。  
  
 既定のパラメーターなしのコンス トラクターごと、`defaultValue`の<xref:System.Windows.DependencyProperty.UnsetValue>いずれかを使用して設定することはできません<xref:System.Windows.PropertyMetadata.DefaultValue%2A>またはコンス トラクター。 しようとすると、例外が発生します。  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用状況  
 この型のメンバーは、通常では使用しない[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">いったん作成した後は、値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定できません。</exception>
        <exception cref="T:System.InvalidOperationException">依存関係プロパティの操作にいったん適用した後は、メタデータのプロパティを設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータが何らかの方法でプロパティに適用されていて、該当のメタデータ インスタンスが不変の状態にあるかどうかを判断する値を取得します。</summary>
        <value>メタデータ インスタンスが不変の状態の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 さまざまなプロパティ<xref:System.Windows.PropertyMetadata>など<xref:System.Windows.PropertyMetadata.DefaultValue%2A>読み取り/書き込みとしてオブジェクト モデルで定義されています。 これはの初期化後に、これらのプロパティを調整することができますので、<xref:System.Windows.PropertyMetadata>オブジェクト自体です。 ただし、呼び出しの一部として、メタデータが依存関係プロパティに適用されると<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、プロパティ システムはそのメタデータ インスタンスを封印およびプロパティを変更できないと見なされますようになりました。 これらの呼び出しのいずれかの時点で<xref:System.Windows.PropertyMetadata.OnApply%2A>が呼び出されると、このプロパティの値に設定されます`true`します。  
  
   
  
## Examples  
 次の例のチェック<xref:System.Windows.PropertyMetadata.IsSealed%2A>カスタム メタデータ プロパティの設定操作の前にします。  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">このインスタンスの値とマージする基本メタデータ。</param>
        <param name="dp">このメタデータが適用される依存関係プロパティ。</param>
        <summary>このメタデータと基本メタデータをマージします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メタデータが上書きされているときに、このメソッドが内部的に使用されます (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>メソッド)。  
  
   
  
## Examples  
 次の例では、プロパティのメタデータに追加のプロパティを追加するカスタム メタデータの種類のマージを実装します。  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>クラスから派生する実装<see cref="T:System.Windows.PropertyMetadata" />実装に追加したすべてのメタデータ プロパティに対応するには、このメソッドをオーバーライドする必要があります。たとえば、実装追加可能性が新しいフラグ列挙値、および<see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />実装できる必要がありますし、それらのフラグを正しく結合します。常に、基本実装を呼び出す前、実装コードを既に定義されているすべてのプロパティをマージした基本の実装が自動的に処理、<see cref="T:System.Windows.PropertyMetadata" />型。マージの正確な動作は自由です。値を結合、派生メタデータの既定値、または、特定のメタデータ クラスとその意味に追加したプロパティの型に基づくその他の多くの動作のままにした場合、基本値に戻すことができます。</para></block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">メタデータが適用された依存関係プロパティ。</param>
        <param name="targetType">該当するメタデータが型固有のメタデータの場合、このメタデータに関連付けられている型。 これが既定のメタデータの場合、この値は null 参照です。</param>
        <summary>このメタデータがプロパティに適用されたときに呼び出され、メタデータがシールされることを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サブクラスを確認するためのデータ構造のすべての変更可能性を<xref:System.Windows.PropertyMetadata>サブクラスに設定されなければなりません変更不可として 1 回<xref:System.Windows.PropertyMetadata.OnApply%2A>が呼び出されます。 メタデータがプロパティ システムの操作に適用されると呼び出されます (登録、所有者の追加、メタデータをオーバーライドする)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメタデータに指定されている <see cref="T:System.Windows.PropertyChangedCallback" /> 実装への参照を取得または設定します。</summary>
        <value><see cref="T:System.Windows.PropertyChangedCallback" /> 実装参照。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティのメタデータでコールバックは、このプロパティの値は単に既存の依存関係プロパティのメタデータを使用するほとんどのシナリオの重要ではありませんので、型の定義に通常のパブリック メンバーではありません。 このプロパティが公開されている理由の 1 つは、基本のメタデータとメタデータをオーバーライドする追加の両方を指定する場合、メタデータ クラスは、必要なマージ ロジックを実行できるように、<xref:System.Windows.PropertyChangedCallback>します。 既定のマージ ロジックはすべて維持するために、<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>テーブルとは、最初を実行している階層の最下位のクラスによって確立されたコールバックの呼び出しごとに実装します。  
  
 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 読み取り/書き込みとしてオブジェクト モデルで定義されます。 これは、<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>の初期化後に調整することができます、<xref:System.Windows.PropertyMetadata>オブジェクト自体です。 ただし、呼び出しの一部として使用されるメタデータと<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、プロパティ システムはそのメタデータ インスタンスを封印およびプロパティを変更できないと見なされますようになりました。 設定しようとしています。<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>したら<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`でこのメタデータ インスタンスで例外が発生します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">依存関係プロパティの操作にいったん適用した後は、メタデータのプロパティを設定できません。</exception>
      </Docs>
    </Member>
  </Members>
</Type>