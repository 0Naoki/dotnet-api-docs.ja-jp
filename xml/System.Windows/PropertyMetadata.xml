<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5c5dfef7a02e9b858a22854c1ef79b198ef1d9bc" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30680016" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>登録時の条件など、特定の種類に適用されるときの依存関係プロパティの動作を定義します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティのメタデータを定義しを呼び出すときに、依存関係プロパティの登録中に使用される、<xref:System.Windows.DependencyProperty.Register%2A>メソッド (または、アタッチされるプロパティまたは読み取り専用の依存関係プロパティのバリエーション) 以降の呼び出し時に元の所有者の登録、<xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>メソッドです。 <xref:System.Windows.DependencyProperty.AddOwner%2A> プロパティのメタデータを受け取ります。  
  
 このクラスは、それらの各呼び出しで使用できる具象基底クラスです。 ただし、メタデータなどを使用して、派生クラスのいずれかを指定する非常に一般的なは<xref:System.Windows.FrameworkPropertyMetadata>します。 これらの派生クラスを検出するか、いくつか、プロパティに動作でのみ実装されているシステムとレイアウトを有効にするのに便利ですが、ブール型プロパティ値として実行されます。 詳細なメタデータをサポートする、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]フレームワーク レベル。  
  
 このクラスのいくつかのプロパティは、オブジェクト モデルへの読み取り/書き込みがなどのプロパティのシステム操作で使用されているインスタンスの前にのみ書き込むこと<xref:System.Windows.DependencyProperty.Register%2A>または<xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>です。 これらの各プロパティ コンス トラクターによって設定されてもでしたが、公開されるように<xref:System.Windows.PropertyMetadata.Merge%2A>メソッドの実装が設定できます。  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用方法  
 この型、および、この型のメンバーは、通常は使用されません[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]です。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティに指定する既定値。通常、特定の型の値として指定されます。</param>
        <summary>メタデータが適用される依存関係プロパティの指定した既定値を使用して、<see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定された値の型`defaultValue`一致する必要がありますか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 (この不一致は実行時の例外が発生) コンパイル時に、不一致が検出できないために、既定値の型のメタデータと適用される依存関係プロパティの型の間の不一致は、デバッグが困難できます。  
  
 パラメーターなしのコンス トラクターごとの既定値は、`defaultValue`の<xref:System.Windows.DependencyProperty.UnsetValue>は指定できません。 しようとすると、例外が発生します。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> は値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照です。</param>
        <summary>指定した <see cref="T:System.Windows.PropertyMetadata" /> 実装参照を使用して、<see cref="T:System.Windows.PropertyChangedCallback" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型の値として指定されます。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照です。</param>
        <summary>指定した既定値と <see cref="T:System.Windows.PropertyMetadata" /> 実装参照を使用して、<see cref="T:System.Windows.PropertyChangedCallback" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定された値の型`defaultValue`一致する必要がありますか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 (この不一致は実行時の例外が発生) コンパイル時に、不一致が検出できないために、既定値の型のメタデータと適用される依存関係プロパティの型の間の不一致は、デバッグが困難できます。  
  
 パラメーターなしのコンス トラクターごとの既定値は、`defaultValue`の<xref:System.Windows.DependencyProperty.UnsetValue>は指定できません。 しようとすると、例外が発生します。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> は値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型の値として指定されます。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照です。</param>
        <param name="coerceValueCallback">プロパティ システムがこのプロパティに対して <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> を呼び出すときに必ず呼び出されるハンドラー実装への参照です。</param>
        <summary>指定した既定値とコールバックを使用して、<see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定する場合、<xref:System.Windows.CoerceValueCallback>ではなく、<xref:System.Windows.PropertyChangedCallback>を渡すことができます`null`の`propertyChangedCallback`パラメーター。  
  
 指定された値の型`defaultValue`一致する必要がありますか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 (この不一致は実行時の例外が発生) コンパイル時に、不一致が検出できないために、既定値の型のメタデータと適用される依存関係プロパティの型の間の不一致は、デバッグが困難できます。  
  
 パラメーターなしのコンス トラクターごとの既定値は、`defaultValue`の<xref:System.Windows.DependencyProperty.UnsetValue>は指定できません。 しようとすると、例外が発生します。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> は値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメタデータに指定されている <see cref="T:System.Windows.CoerceValueCallback" /> 実装への参照を取得または設定します。</summary>
        <value>
          <see cref="T:System.Windows.CoerceValueCallback" /> 実装参照。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティのメタデータでコールバックは、このプロパティの値が同じ既存の依存関係プロパティのメタデータを使用するほとんどのシナリオの重要ではありませんので、型は、通常のパブリック メンバーではありません。 このプロパティが公開されている理由の 1 つはメタデータ サブクラスは基本のメタデータとメタデータをオーバーライドする追加の両方を指定する場合、マージが必要なロジックを実行できるように、<xref:System.Windows.CoerceValueCallback>です。 ただし、既定値はマージのロジックを<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>前を置換するとします。  
  
 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 読み取り/書き込みとしてオブジェクト モデルで定義されます。 これは、<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>の初期化後に調整することができます、<xref:System.Windows.PropertyMetadata>オブジェクト自体です。 ただし、メタデータがへの呼び出しの一部として使用された後<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>プロパティ システムはそのメタデータ インスタンスをシール、およびプロパティを変更できないと見なされますようになりました。 設定しようとしています。<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>したら<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`このメタデータをインスタンスで例外が発生します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">依存関係プロパティの操作にいったん適用した後は、メタデータのプロパティを設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの既定値を取得または設定します。</summary>
        <value>プロパティの既定値。 既定値、<see cref="T:System.Windows.PropertyMetadata" />パラメーターなしのコンス トラクターで作成されたインスタンスになります<see cref="F:System.Windows.DependencyProperty.UnsetValue" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 読み取り/書き込みとしてオブジェクト モデルで定義されます。 これは、<xref:System.Windows.PropertyMetadata.DefaultValue%2A>の初期化後に調整することができます、<xref:System.Windows.PropertyMetadata>オブジェクト自体です。 ただし、メタデータがへの呼び出しの一部として使用された後<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>プロパティ システムはそのメタデータ インスタンスをシール、およびプロパティを変更できないと見なされますようになりました。 設定しようとしています。<xref:System.Windows.PropertyMetadata.DefaultValue%2A>したら<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`このメタデータをインスタンスで例外が発生します。  
  
 パラメーターなしのコンス トラクターごとの既定値は、`defaultValue`の<xref:System.Windows.DependencyProperty.UnsetValue>いずれかを使用して設定することはできません<xref:System.Windows.PropertyMetadata.DefaultValue%2A>またはコンス トラクターです。 しようとすると、例外が発生します。  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用方法  
 この型のメンバーは、通常では使用されない[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">いったん作成した後は、値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定できません。</exception>
        <exception cref="T:System.InvalidOperationException">依存関係プロパティの操作にいったん適用した後は、メタデータのプロパティを設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータが何らかの方法でプロパティに適用されていて、該当のメタデータ インスタンスが不変の状態にあるかどうかを判断する値を取得します。</summary>
        <value>
          メタデータ インスタンスが不変の状態の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 さまざまなプロパティ<xref:System.Windows.PropertyMetadata>など<xref:System.Windows.PropertyMetadata.DefaultValue%2A>読み取り/書き込みとしてオブジェクト モデルで定義されます。 これは、これらのプロパティの初期化後に調整できるように、<xref:System.Windows.PropertyMetadata>オブジェクト自体です。 ただしへの呼び出しの一部として、依存関係プロパティに適用するメタデータ<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>プロパティ システムはそのメタデータ インスタンスをシール、およびプロパティを変更できないと見なされますようになりました。 これらの呼び出しのいずれかの時点で<xref:System.Windows.PropertyMetadata.OnApply%2A>が呼び出されるにこのプロパティの値を設定および`true`です。  
  
   
  
## Examples  
 次の例のチェック<xref:System.Windows.PropertyMetadata.IsSealed%2A>カスタム メタデータ プロパティの設定操作の前にします。  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">このインスタンスの値とマージする基本メタデータ。</param>
        <param name="dp">このメタデータが適用される依存関係プロパティ。</param>
        <summary>このメタデータと基本メタデータをマージします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メタデータが上書きされているときに、このメソッドは内部的に使用 (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>メソッド)。  
  
   
  
## Examples  
 次の例では、プロパティのメタデータに追加のプロパティを追加するカスタム メタデータの種類のマージを実装します。  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>クラスから派生する実装<see cref="T:System.Windows.PropertyMetadata" />の実装では、追加のメタデータ プロパティに対応するには、このメソッドをオーバーライドする必要があります。 たとえば、実装に追加可能性があります新しいフラグ列挙値では、および<see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />実装はこれらのフラグを正しく組み合わせることができるしする必要があります。  
  
 常に、基本実装を呼び出す、実装コードの前に既に定義されているすべてのプロパティのマージの基底の実装が行われますので、<see cref="T:System.Windows.PropertyMetadata" />型です。  
  
 マージの正確な動作は、ユーザーの責任です。 結合の値を持つ、派生のメタデータは、既定値、または、特定のメタデータ クラスとその意味を追加したプロパティの型に基づくその他の多くの動作に残されている場合、ベース値に戻すを選択する可能性があります。</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">メタデータが適用された依存関係プロパティ。</param>
        <param name="targetType">該当するメタデータが型固有のメタデータの場合、このメタデータに関連付けられている型。 これが既定のメタデータの場合、この値は null 参照です。</param>
        <summary>このメタデータがプロパティに適用されたときに呼び出され、メタデータがシールされることを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サブクラスはことを保証のデータ構造のすべての変更可能性、<xref:System.Windows.PropertyMetadata>サブクラスとマークするか変更不可として 1 回<xref:System.Windows.PropertyMetadata.OnApply%2A>と呼びます。 プロパティのシステム操作にメタデータが適用されると呼び出されます (登録、所有者を追加、メタデータをオーバーライドする)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメタデータに指定されている <see cref="T:System.Windows.PropertyChangedCallback" /> 実装への参照を取得または設定します。</summary>
        <value>
          <see cref="T:System.Windows.PropertyChangedCallback" /> 実装参照。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティのメタデータでコールバックは、このプロパティの値が同じ既存の依存関係プロパティのメタデータを使用するほとんどのシナリオの重要ではありませんので、型の定義、通常のパブリック メンバーではありません。 このプロパティが公開されている理由の 1 つは基本のメタデータとメタデータをオーバーライドする追加の両方を指定する場合、メタデータ クラスは、マージが必要なロジックを実行できるように、<xref:System.Windows.PropertyChangedCallback>です。 既定のマージのロジックはすべて維持するために、<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>テーブルとは、最初を実行している階層の最下位のクラスによって確立されたコールバックの呼び出しごとに実装します。  
  
 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 読み取り/書き込みとしてオブジェクト モデルで定義されます。 これは、<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>の初期化後に調整することができます、<xref:System.Windows.PropertyMetadata>オブジェクト自体です。 ただし、メタデータがへの呼び出しの一部として使用された後<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>プロパティ システムはそのメタデータ インスタンスをシール、およびプロパティを変更できないと見なされますようになりました。 設定しようとしています。<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>したら<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`このメタデータをインスタンスで例外が発生します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">依存関係プロパティの操作にいったん適用した後は、メタデータのプロパティを設定できません。</exception>
      </Docs>
    </Member>
  </Members>
</Type>