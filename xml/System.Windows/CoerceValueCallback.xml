<Type Name="CoerceValueCallback" FullName="System.Windows.CoerceValueCallback">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bc1a383fe21e6b9b549e0ccda7aa8c21c6f92d9f" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37493664" />
  </Metadata>
  <TypeSignature Language="C#" Value="public delegate object CoerceValueCallback(DependencyObject d, object baseValue);" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed CoerceValueCallback extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Windows.CoerceValueCallback" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Function CoerceValueCallback(d As DependencyObject, baseValue As Object) As Object " />
  <TypeSignature Language="C++ CLI" Value="public delegate System::Object ^ CoerceValueCallback(DependencyObject ^ d, System::Object ^ baseValue);" />
  <TypeSignature Language="F#" Value="type CoerceValueCallback = delegate of DependencyObject * obj -&gt; obj" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Parameters>
    <Parameter Name="d" Type="System.Windows.DependencyObject" />
    <Parameter Name="baseValue" Type="System.Object" />
  </Parameters>
  <ReturnValue>
    <ReturnType>System.Object</ReturnType>
  </ReturnValue>
  <Docs>
    <param name="d">
      <span data-ttu-id="cee76-101">プロパティが存在するオブジェクト。</span>
      <span class="sxs-lookup">
        <span data-stu-id="cee76-101">The object that the property exists on.</span>
      </span>
      <span data-ttu-id="cee76-102">コールバックが呼び出されると、プロパティ システムがこの値を渡します。</span>
      <span class="sxs-lookup">
        <span data-stu-id="cee76-102">When the callback is invoked, the property system will pass this value.</span>
      </span>
    </param>
    <param name="baseValue">
      <span data-ttu-id="cee76-103">強制が試行される前のプロパティの新しい値。</span>
      <span class="sxs-lookup">
        <span data-stu-id="cee76-103">The new value of the property, prior to any coercion attempt.</span>
      </span>
    </param>
    <summary>
      <span data-ttu-id="cee76-104">依存関係プロパティの値が再評価されたり強制が明示的に要求されたりした場合に必ず呼び出されるメソッドのテンプレートを提供します。</span>
      <span class="sxs-lookup">
        <span data-stu-id="cee76-104">Provides a template for a method that is called whenever a dependency property value is being re-evaluated, or coercion is specifically requested.</span>
      </span>
    </summary>
    <returns>
      <span data-ttu-id="cee76-105">強制された (適切な型の) 値。</span>
      <span class="sxs-lookup">
        <span data-stu-id="cee76-105">The coerced value (with appropriate type).</span>
      </span>
    </returns>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cee76-106">コールバックがに基づいて<xref:System.Windows.CoerceValueCallback>いくつかの異なる手法を使用して依存関係プロパティに割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="cee76-106">Callbacks based on <xref:System.Windows.CoerceValueCallback> can be assigned to a dependency property through several different techniques.</span></span> <span data-ttu-id="cee76-107">これらの手法のそれぞれは、最初に新しいプロパティ メタデータ オブジェクトを作成することが必要です。 (<xref:System.Windows.PropertyMetadata>、などの派生クラスまたは<xref:System.Windows.FrameworkPropertyMetadata>)。</span><span class="sxs-lookup"><span data-stu-id="cee76-107">Each of these techniques requires that you first create a new property metadata object (<xref:System.Windows.PropertyMetadata>, or a derived class such as <xref:System.Windows.FrameworkPropertyMetadata>).</span></span> <span data-ttu-id="cee76-108">受け取るコンス トラクター シグネチャを使用してメタデータ オブジェクトを作成、`coerceValueCallback`パラメーター、コールバック ハンドラーにそのパラメーターを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="cee76-108">Create the metadata object using a constructor signature that takes the `coerceValueCallback` parameter, and assign that parameter to your callback handler.</span></span> <span data-ttu-id="cee76-109">署名とセットのメタデータを作成したり、<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>プロパティを使用して、メタデータを配置する前にします。</span><span class="sxs-lookup"><span data-stu-id="cee76-109">Or construct the metadata by any signature and set the <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> property prior to putting the metadata in use.</span></span>  
  
 <span data-ttu-id="cee76-110">このメタデータがある場合は、次のことができます。</span><span class="sxs-lookup"><span data-stu-id="cee76-110">When you have this metadata, you can:</span></span>  
  
-   <span data-ttu-id="cee76-111">新しい依存関係プロパティのいずれかのシグネチャを使用して、新しいクラスを定義<xref:System.Windows.DependencyProperty.Register%2A>、としてのメタデータを提供、`typeMetadata`値。</span><span class="sxs-lookup"><span data-stu-id="cee76-111">Define a new dependency property on a new class, using either signature of  <xref:System.Windows.DependencyProperty.Register%2A>, giving the metadata as the `typeMetadata` value.</span></span>  
  
-   <span data-ttu-id="cee76-112">メタデータのオーバーライド (呼び出し<xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>) の既存の依存関係プロパティを依存関係プロパティを所有するクラスから派生するとき。</span><span class="sxs-lookup"><span data-stu-id="cee76-112">Override the metadata (call <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>) for an existing dependency property, when you derive from the class that owns the dependency property.</span></span>  
  
-   <span data-ttu-id="cee76-113">新しいの既存の依存関係プロパティの追加<xref:System.Windows.DependencyObject>クラスを呼び出すことによって、新しいメタデータを使用して<xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>します。</span><span class="sxs-lookup"><span data-stu-id="cee76-113">Add an existing dependency property to a new <xref:System.Windows.DependencyObject> class, using new metadata, by calling <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</span></span>  
  
 <span data-ttu-id="cee76-114">このコールバックの実装値を確認する必要があります`baseValue`確認とこれは、さらに強制的に変換する必要がある値か、値または型のいずれかに基づき、します。</span><span class="sxs-lookup"><span data-stu-id="cee76-114">Implementations of this callback should check the value in `baseValue` and determine based on either the value or the type whether this is a value that needs to be further coerced.</span></span>  
  
 <span data-ttu-id="cee76-115"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>プロパティには依存関係の呼び出し、プロパティ システムまたはその他のすべての呼び出し元をいつが呼び出された<xref:System.Windows.DependencyObject.CoerceValue%2A>上、<xref:System.Windows.DependencyObject>とそのプロパティの識別子を指定する、インスタンス、 `dp`。</span><span class="sxs-lookup"><span data-stu-id="cee76-115">The <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> for a dependency property is invoked any time that the property system or any other caller calls <xref:System.Windows.DependencyObject.CoerceValue%2A> on a <xref:System.Windows.DependencyObject> instance, specifying that property's identifier as the `dp`.</span></span>  
  
 <span data-ttu-id="cee76-116">プロパティ値の変更は、プロパティ システムで可能な任意参加要素から取得されている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="cee76-116">Changes to the property value may have come from any possible participant in the property system.</span></span> <span data-ttu-id="cee76-117">これには、スタイル、ジェネリックの無効化、トリガー、プロパティ値の継承、およびローカルの値の設定が含まれます。</span><span class="sxs-lookup"><span data-stu-id="cee76-117">This includes styles, generic invalidation, triggers, property value inheritance, and local value setting.</span></span>  
  
 <span data-ttu-id="cee76-118">1 つ以上指定することを避ける必要があります通常<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>いずれか、特定の依存関係プロパティ (が既に存在する依存関係プロパティの新しいメタデータを追加またはオーバーライド、 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>)。</span><span class="sxs-lookup"><span data-stu-id="cee76-118">Generally you should avoid specifying more than one <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> for any given dependency property (overriding or adding with new metadata for a dependency property that already had a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>).</span></span> <span data-ttu-id="cee76-119">コールバックの 1 つのみは機能することになります。コールバックと比べて、継承の最派生クラスに適用されているものであるが、<xref:System.Windows.DependencyObject>呼び出し元。</span><span class="sxs-lookup"><span data-stu-id="cee76-119">Only one of the callbacks will be able to act. The acting callback will be the one that was applied to the most derived class in the inheritance as compared to the <xref:System.Windows.DependencyObject> caller.</span></span> <span data-ttu-id="cee76-120">メタデータがオーバーライドされると、所有者階層の高い状態では、依存関係プロパティのメタデータに割り当てられているその他のコールバックが置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="cee76-120">Other callbacks as assigned to metadata for the dependency property as it existed higher in the owner hierarchy are replaced when the metadata is overridden.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cee76-121">次の例には、別のプロパティの値などの他の入力に基づく依存関係プロパティの格納されている値を強制的にこのコールバックの実装が含まれます。</span><span class="sxs-lookup"><span data-stu-id="cee76-121">The following example includes an implementation of this callback to coerce the stored value of a dependency property based on other inputs, such as another property's value.</span></span> <span data-ttu-id="cee76-122">コールバックがここを確認するかどうか、`ShirtType`シャツを持つボタンの種類に対応するプロパティその場合の既定の開始色を確立、 `ButtonColor`、強制的に変換ボタン シャツ型がない場合は、、`ButtonColor`値。これにより、開始値に戻す、 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] (非表示) を有効な選択肢の中からそのドロップダウン リストを削除します。</span><span class="sxs-lookup"><span data-stu-id="cee76-122">In this case, the callback checks to see whether the `ShirtType` property corresponds to a type of shirt that has buttons; if so it establishes a starting default color for the `ButtonColor`, if the shirt type has no buttons, it coerces the `ButtonColor` value back to a starting value, which causes the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] (not shown) to remove that dropdown from the effective choices.</span></span>  
  
 [!code-csharp[DPCustom#CoerceValueCallback](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCustom/CSharp/default.xaml.cs#coercevaluecallback)]
 [!code-vb[DPCustom#CoerceValueCallback](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCustom/visualbasic/default.xaml.vb#coercevaluecallback)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
</Type>