<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CoerceValueCallback.xml" source-language="en-US" target-language="ja-JP">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5edddfb39d197bb5c7d9ebb6e4c366a99eae21935.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">edddfb39d197bb5c7d9ebb6e4c366a99eae21935</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>The object that the property exists on.</source>
          
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>When the callback is invoked, the property system will pass this value.</source>
          
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>The new value of the property, prior to any coercion attempt.</source>
          
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>Provides a template for a method that is called whenever a dependency property value is being re-evaluated, or coercion is specifically requested.</source>
          
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>The coerced value (with appropriate type).</source>
          
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Callbacks based on <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> can be assigned to a dependency property through several different techniques.</source>
          <target state="translated">コールバックがに基づいて<ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>いくつかの方法を使用して依存関係プロパティを割り当てることができます。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Each of these techniques requires that you first create a new property metadata object (<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>, or a derived class such as <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>).</source>
          <target state="translated">これらの手法のそれぞれは、最初に新しいプロパティ メタデータ オブジェクトを作成することが必要です。 (<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>、やなどの派生クラス<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Create the metadata object using a constructor signature that takes the <ph id="ph1">`coerceValueCallback`</ph> parameter, and assign that parameter to your callback handler.</source>
          <target state="translated">受け取るコンス トラクターのシグネチャを使用してメタデータ オブジェクトを作成、<ph id="ph1">`coerceValueCallback`</ph>パラメーター、コールバック ハンドラーにそのパラメーターを割り当てるとします。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Or construct the metadata by any signature and set the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> property prior to putting the metadata in use.</source>
          <target state="translated">署名とセット メタデータを作成したり、<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>使用中でメタデータを配置する前にプロパティです。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>When you have this metadata, you can:</source>
          <target state="translated">このメタデータがある場合は、次のことができます。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Define a new dependency property on a new class, using either signature of  <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, giving the metadata as the <ph id="ph2">`typeMetadata`</ph> value.</source>
          <target state="translated">新しい依存関係プロパティのいずれかの署名を使用して、新しいクラスを定義<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>、としてのメタデータを提供、<ph id="ph2">`typeMetadata`</ph>値。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Override the metadata (call <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>) for an existing dependency property, when you derive from the class that owns the dependency property.</source>
          <target state="translated">メタデータをオーバーライド (呼び出し<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>) 既存の依存関係プロパティを依存関係プロパティを所有するクラスから派生するときにします。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Add an existing dependency property to a new <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> class, using new metadata, by calling <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</source>
          <target state="translated">新しいの既存の依存関係プロパティの追加<ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph>クラスを呼び出すことによって、新しいメタデータを使用して<ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Implementations of this callback should check the value in <ph id="ph1">`baseValue`</ph> and determine based on either the value or the type whether this is a value that needs to be further coerced.</source>
          <target state="translated">このコールバックの実装は、値を確認する必要があります<ph id="ph1">`baseValue`</ph>を決定し、これは、さらに強制的に変換する必要がある値かどうか、値型または型に基づきます。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>The <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> for a dependency property is invoked any time that the property system or any other caller calls <ph id="ph2">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph> on a <ph id="ph3">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance, specifying that property's identifier as the <ph id="ph4">`dp`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>依存関係プロパティが呼び出さプロパティ システムまたはその他の任意の呼び出し元がいつでも<ph id="ph2">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph>上、<ph id="ph3">&lt;xref:System.Windows.DependencyObject&gt;</ph>とそのプロパティの識別子を指定して、インスタンス、<ph id="ph4">`dp`</ph>です。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Changes to the property value may have come from any possible participant in the property system.</source>
          <target state="translated">プロパティの値への変更は、プロパティ システムに考えられる任意参加要素から取得が可能性があります。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>This includes styles, generic invalidation, triggers, property value inheritance, and local value setting.</source>
          <target state="translated">これには、スタイル、ジェネリックの無効化、トリガー、プロパティ値の継承、およびローカル値の設定が含まれます。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Generally you should avoid specifying more than one <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> for any given dependency property (overriding or adding with new metadata for a dependency property that already had a <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>).</source>
          <target state="translated">1 つ以上を指定することを避ける必要があります、通常<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>いずれかの依存関係プロパティを指定します (が既に存在する依存関係プロパティの新しいメタデータを追加またはオーバーライド、 <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Only one of the callbacks will be able to act. The acting callback will be the one that was applied to the most derived class in the inheritance as compared to the <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> caller.</source>
          <target state="translated">コールバックの 1 つだけは、機能することができます。コールバックと比べて、継承の最も派生クラスに適用されている 1 つになります、<ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph>呼び出し元。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Other callbacks as assigned to metadata for the dependency property as it existed higher in the owner hierarchy are replaced when the metadata is overridden.</source>
          <target state="translated">存在していた以上、所有者の階層内の依存関係プロパティのメタデータに割り当てられているその他のコールバックは、メタデータがオーバーライドされるときに置き換えられます。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>The following example includes an implementation of this callback to coerce the stored value of a dependency property based on other inputs, such as another property's value.</source>
          <target state="translated">次の例には、別のプロパティの値など、他の入力に基づく依存関係プロパティの格納されている値を強制するには、このコールバックの実装が含まれています。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>In this case, the callback checks to see whether the <ph id="ph1">`ShirtType`</ph> property corresponds to a type of shirt that has buttons; if so it establishes a starting default color for the <ph id="ph2">`ButtonColor`</ph>, if the shirt type has no buttons, it coerces the <ph id="ph3">`ButtonColor`</ph> value back to a starting value, which causes the <ph id="ph4">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> (not shown) to remove that dropdown from the effective choices.</source>
          <target state="translated">この場合、コールバックかを確認するかどうか、<ph id="ph1">`ShirtType`</ph>プロパティはボタンを持つシャツの種類に対応ですその場合の既定の開始色を確立、 <ph id="ph2">`ButtonColor`</ph>、強制的に変換シャツ型には、ボタンがなければ、、<ph id="ph3">`ButtonColor`</ph>値。開始値にそれが原因で、 <ph id="ph4">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> (非表示) を有効な選択肢の中からそのドロップダウン リストを削除します。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>