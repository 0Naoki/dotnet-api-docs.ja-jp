<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DependencyPropertyKey.xml" source-language="en-US" target-language="ja-JP">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac59a12e407bc5345e416145c390f8fcd6f8262c445.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9a12e407bc5345e416145c390f8fcd6f8262c445</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyPropertyKey">
          <source>Provides a dependency property identifier for limited write access to a read-only dependency property.</source>
          <target state="translated">読み取り専用の依存関係プロパティへの制限された書き込みアクセスに必要な依存関係プロパティ識別子を提供します。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> instances are obtained as the return value of a dependency property registration call using the methods <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> インスタンスがメソッドを使用して、依存関係プロパティの登録呼び出しの戻り値として取得された<ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>The types that register a dependency property can use the <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> in calls to <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> that adjust the property's value as part of class logic.</source>
          <target state="translated">依存関係プロパティを登録する型が使用できる、<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>への呼び出しで<ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph>と<ph id="ph3">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph>クラス ロジックの一部として、プロパティの値を調整します。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>If permitted by the access level of the key, related classes can use the key and the dependency property also.</source>
          <target state="translated">場合は、キーのアクセス レベルで許可されている、関連するクラスも使用できます、キーと依存関係プロパティ。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>For instance, you can declare the key as internal, and other types within the same assembly can also set that dependency property.</source>
          <target state="translated">たとえば、internal としてキーを宣言することができ、同じアセンブリ内の他の型は、その依存関係プロパティを設定できます。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> returned by read-only dependency property registration should not be made public, because exposing the key makes the property settable, thus defeating the point of registering it as a read-only dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>返される読み取り専用の依存関係によってプロパティの登録ができるようにしないパブリック、プロパティを設定可能なしたがって読み取り専用の依存関係プロパティとして登録ポイントを無駄には、キーを公開するためです。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>Also, exposing the key causes a mismatch between the available dependency property behaviors and its <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> property wrapper implementations, which is bad class design.</source>
          <target state="translated">また、キーを公開する不一致が発生間利用可能な依存関係プロパティの動作とその<ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph>は無効なクラス デザインのプロパティのラッパー実装します。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>Instead of exposing the key itself, you should instead expose the <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> value of the <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> as a <ph id="ph3">`public static readonly`</ph><ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> on your class.</source>
          <target state="translated">キー自体を公開すると、代わりに公開すべきで代わりに、<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph>の値、<ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>として、 <ph id="ph3">`public static readonly`</ph> <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph>クラスにします。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>This enables the property to return a valid dependency property identifier for certain property system operations such as enumerating locally set values.</source>
          <target state="translated">これにより、特定のローカル設定値を列挙するなどのシステム操作のプロパティの有効な依存関係プロパティの識別子を取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>However, the identifier thus obtained does not have the full capabilities of a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> for many property system operations.</source>
          <target state="translated">ただし、識別子を取得したためにはのすべての機能はありません、<ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>の多くのプロパティのシステム操作します。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>The following example registers a read-only dependency property, and also uses the key for two purposes in other class members: implementing the get "wrapper", and as the identifier for a protected determination operation that sets the value based on calculations of other property values.</source>
          <target state="translated">次の例は、読み取り専用の依存関係プロパティを登録し、他のクラス メンバーに 2 つの目的のキーを使用しても: get の「ラッパー」を実装して、計算に基づいて、値を設定する保護された特定の操作の識別子としてその他のプロパティ値。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Gets the dependency property identifier associated with this specialized read-only dependency property identifier.</source>
          <target state="translated">この特殊な読み取り専用依存関係プロパティ識別子に関連付けられている依存関係プロパティ識別子を取得します。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The relevant dependency property identifier.</source>
          <target state="translated">関連する依存関係プロパティ識別子。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> value enables a read-only property's identifier to participate in common property system operations using some of the same interfaces as used for read-write dependency properties.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph>値には、同じインターフェイスの一部として使用されるプロパティを使って読み取り/書き込みの依存関係プロパティ システム操作で参加に共通する読み取り専用プロパティの識別子が有効になります。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>In order to implement the get property accessor for a read-only dependency property, you should create and expose a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier on your class.</source>
          <target state="translated">読み取り専用の依存関係プロパティの get プロパティ アクセサーを実装するために作成し、公開する必要があります、<ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>クラスの識別子。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>This serves two purposes:</source>
          <target state="translated">これには 2 つの目的があります。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Your own class needs the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier in order to implement the get accessor for the property wrapper.</source>
          <target state="translated">クラスの独自のニーズ、<ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>プロパティ ラッパーの get アクセサーを実装するために識別子。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>You use the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> as a parameter for the <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> call that implements the get accessor.</source>
          <target state="translated">使用する、<ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>のパラメーターとして、 <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> get アクセサーを実装するための呼び出しです。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifiers expose your dependency property to the property system such that other methods that rely on metadata can access it in a standard form.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> 識別子は、メタデータに依存するその他のメソッドを使用すると標準のフォームにアクセスできるように、プロパティ システムに、依存関係プロパティを公開します。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>For instance, if you called <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> on some <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> and obtained an enumeration of locally set properties (values and identifiers) the identifier returned for a read-only dependency property would be your <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> value rather than the key.</source>
          <target state="translated">インスタンスを呼び出した場合<ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph>の一部で<ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>ローカル プロパティの設定 (値と識別子) の列挙体識別子を取得および返される読み取り専用の依存関係プロパティになります、<ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>キーではなく値します。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Not exposing a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier does not increase the security of your read-only dependency property in any way, it just makes operations that involve your property more awkward both for subsequent derived classes and class instances.</source>
          <target state="translated">公開する、<ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>識別子が任意の方法で、読み取り専用の依存関係プロパティのセキュリティを強化していない、後続の派生クラスとクラスのインスタンスの両方ににくいプロパティに関連する操作で、します。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>To expose the  <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier on your class, you call <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> directly on your key.</source>
          <target state="translated">公開するために、<ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>クラスの識別子を呼び出す<ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph>キーで直接です。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Use this value to create a <ph id="ph1">`public static readonly`</ph><ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier on the class, which parallels the <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>.</source>
          <target state="translated">この値を使用して、作成、 <ph id="ph1">`public static readonly`</ph> <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph>と類似している、クラスの識別子、<ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The following example calls <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> to expose the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier (<ph id="ph3">`AquariumGraphicProperty`</ph>) for the <ph id="ph4">`AquariumGraphic`</ph> read-only dependency property on a class.</source>
          <target state="translated">次の例では<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph>を公開する、<ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph>識別子 (<ph id="ph3">`AquariumGraphicProperty`</ph>) の<ph id="ph4">`AquariumGraphic`</ph>クラスでの読み取り専用の依存関係プロパティです。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The example also shows the <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> creation (as an internal member) and the get accessor for <ph id="ph2">`AquariumGraphic`</ph>.</source>
          <target state="translated">この例も示します、 <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> (として内部のメンバー) の作成と get アクセサーを<ph id="ph2">`AquariumGraphic`</ph>です。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The type on which this dependency property exists and metadata should be overridden.</source>
          <target state="translated">この依存関係プロパティが存在し、メタデータをオーバーライドする必要がある型。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Metadata supplied for this type.</source>
          <target state="translated">この型に対して提供されるメタデータ。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Overrides the metadata of a read-only dependency property that is represented by this dependency property identifier.</source>
          <target state="translated">この依存関係プロパティ識別子によって表される読み取り専用の依存関係プロパティのメタデータをオーバーライドします。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Overriding metadata on a read-only dependency property is done for similar reasons as overriding metadata on a read-write dependency property, and is restricted to access at the key level because behaviors specified in the metadata can change the set behavior (the default value, for instance).</source>
          <target state="translated">読み取り専用の依存関係プロパティのメタデータのオーバーライドは読み取り/書き込みの依存関係プロパティのメタデータをオーバーライドすることと同様の理由で実行され、メタデータに指定された動作は、セットの動作を変更できるので、キーのレベルのアクセスに制限されます (既定値のインスタンス)。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>As with read-write dependency properties, overriding metadata on a read-only dependency property should only be done prior to that property being placed in use by the property system (this equates to the time that specific instances of objects that register the property are instantiated).</source>
          <target state="translated">として読み取り/書き込みの依存関係プロパティを持つ、読み取り専用の依存関係プロパティのメタデータのオーバーライドにのみ行ってください (これは特定のプロパティを登録するオブジェクトのインスタンスがインスタンス化される時間に相当) プロパティのシステムによって使用されるプロパティの前にします。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Calls to <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph> should only be performed within the static constructors of the type that provides itself as the <ph id="ph2">`forType`</ph> parameter of this method, or equivalent initialization for that class.</source>
          <target state="translated">呼び出す<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph>としてそれ自体を提供する型の静的コンス トラクター内でのみ実行する必要があります、<ph id="ph2">`forType`</ph>メソッド、またはそのクラスの初期化を同等のパラメーターです。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>This method effectively forwards to the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> method, passing the <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> instance as the key parameter.</source>
          <target state="translated">このメソッドを効率的に転送、<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>渡して、メソッド、<ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>キー パラメーターとインスタンス。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The following example overrides metadata for an existing read-only dependency property that a class inherits.</source>
          <target state="translated">次の例では、クラスを継承する既存の読み取り専用の依存関係プロパティのメタデータをオーバーライドします。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>In this case, the scenario goal was to add a coerce value callback that the base property metadata did not have.</source>
          <target state="translated">この場合、シナリオの目的は、基本プロパティのメタデータが含まれていない強制値のコールバックを追加するでした。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>You could also override metadata for any of the other reasons that overriding metadata is typically appropriate (changing default value, adding <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> values, etc.)</source>
          <target state="translated">メタデータのオーバーライドは、通常、その他の理由のいずれか適切向けに、メタデータを上書きすることも可能性があります (既定値の変更を追加する<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph>値などです)。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Attempted metadata override on a read-write dependency property (cannot be done using this signature).</source>
          <target state="translated">読み取り/書き込み用の依存関係プロパティでメタデータをオーバーライドしようとしました (このシグネチャを使用してオーバーライドすることはできません)。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Metadata was already established for the property as it exists on the provided type.</source>
          <target state="translated">提供された型に存在するので、プロパティのメタデータは既に確立されています。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>