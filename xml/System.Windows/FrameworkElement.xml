<Type Name="FrameworkElement" FullName="System.Windows.FrameworkElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f9436c4c983e3940bfa7043e2eac92986b636f8f" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56389356" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>WPF フレームワーク レベルのプロパティ、イベント、およびメソッドのセットを Windows Presentation Foundation (WPF) 要素で利用できます。 このクラスは WPF フレームワーク レベルの実装として用意されており、<see cref="T:System.Windows.UIElement" /> によって定義される WPF コア レベル API 上に構築されています。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> WPF フレームワーク レベル要素のクラスと WPF コア レベルのセット間の接続ポイントは、<xref:System.Windows.UIElement>プレゼンテーション サービス。 これらの概念の詳細については、次を参照してください。 [WPF アーキテクチャ](~/docs/framework/wpf/advanced/wpf-architecture.md)します。  
  
 <xref:System.Windows.FrameworkElement> 拡張<xref:System.Windows.UIElement>し、次の機能を追加します。  
  
-   **レイアウト システム定義**:<xref:System.Windows.FrameworkElement>特定の仮想メンバーとして定義されたメソッドの特定の WPF フレームワーク レベルの実装を提供<xref:System.Windows.UIElement>します。 最も注目に値する<xref:System.Windows.FrameworkElement>特定 WPF コア レベルのレイアウトの上書きをシールして、代わりに、WPF フレームワーク レベルと同じ派生クラスを代わりにオーバーライドする必要があります。 たとえば、<xref:System.Windows.FrameworkElement>シール<xref:System.Windows.UIElement.ArrangeCore%2A>を提供しますが、<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>します。 これらの変更は、WPF フレームワーク レベルでは、完全なレイアウト システムでいずれかをレンダリングするという事実を反映<xref:System.Windows.FrameworkElement>クラスを派生します。 WPF で構造化、一般的なは、特定のレベルのメンバーをコア[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]ベースのレイアウトをソリューションは、場所がレイアウト システムの実際のエンジンが定義されていません。 詳細については、「[Layout](~/docs/framework/wpf/advanced/layout.md)」 (レイアウト) を参照してください。  
  
-   **論理ツリー:** 一般的な[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]プログラミング モデルが要素のツリーの中の観点から表されます。 論理ツリーとしての要素のツリーを表現してでの実装は、マークアップでそのツリーを定義するためのサポートに付属するサポート、<xref:System.Windows.FrameworkElement>レベル。 注ただしその<xref:System.Windows.FrameworkElement>意図的に、コンテンツ モデルを一切定義しませんが、そのクラスを派生する必要があります。 詳細については、「[WPF のツリー](~/docs/framework/wpf/advanced/trees-in-wpf.md)」を参照してください。  
  
-   **オブジェクトの有効期間イベント:** 要素が初期化される場合を把握すると便利です (コンス トラクターが呼び出されます) または論理ツリーに要素が最初に読み込まれるときにします。 <xref:System.Windows.FrameworkElement> 子要素の追加などの要素に関連する分離コード操作の便利なフックを提供するオブジェクトの有効期間に関連するいくつかのイベントを定義します。 詳細については、次を参照してください。[オブジェクトの有効期間イベント](~/docs/framework/wpf/advanced/object-lifetime-events.md)します。  
  
-   **データ バインディングと動的リソース参照のサポート:** データ バインディングとリソースのプロパティ レベルのサポートは、<xref:System.Windows.DependencyProperty>クラスし、プロパティ システムとして格納されているメンバー値を解決する機能に組み込まれている、 <xref:System.Windows.Expression> (プログラミング コンストラクト両方を基になります。データ バインディングと動的リソース) によって実装される<xref:System.Windows.FrameworkElement>します。 詳細については、次を参照してください。[データ バインディングの概要](~/docs/framework/wpf/data/data-binding-overview.md)と[XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)します。  
  
-   **スタイル:** <xref:System.Windows.FrameworkElement>定義、<xref:System.Windows.FrameworkElement.Style%2A>プロパティ。 ただし、<xref:System.Windows.FrameworkElement>されていないテンプレートのサポートを定義またはデコレーターをサポートしません。 これらの機能がなどのコントロール クラスで導入された<xref:System.Windows.Controls.Control>と<xref:System.Windows.Controls.ContentControl>します。  
  
-   **その他のアニメーションのサポート:** 一部のアニメーションのサポートは、WPF コア レベルで既に定義されてが<xref:System.Windows.FrameworkElement>これを実装することによって拡張<xref:System.Windows.FrameworkElement.BeginStoryboard%2A>および関連するメンバー。  
  
 クラスの階層構造で表示できるよう多く[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]クラスから派生<xref:System.Windows.FrameworkElement>直接または中間の基底クラスのいずれかなど、<xref:System.Windows.Controls.Panel>または<xref:System.Windows.Controls.Control>します。  
  
 使用する場合<xref:System.Windows.FrameworkElement>基底クラスとしてまず既存の派生クラスを調べてする可能性があります。 <xref:System.Windows.FrameworkElement> 基本的なシナリオは、さまざまなサポートを提供しますも、多くの作成に使用する構成要素の意味で"element"ために必要な機能がありません[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]で[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]します。 たとえば、 <xref:System.Windows.FrameworkElement> ; true コンテンツ モデルが定義されていません<xref:System.Windows.FrameworkElement>基底クラスが作成可能なプロパティを定義していないよう[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]子要素。 確認する具体的には、<xref:System.Windows.Controls.Control>と<xref:System.Windows.Controls.ContentControl>します。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.FrameworkElement" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeight">
      <MemberSignature Language="C#" Value="public double ActualHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualHeight { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualHeight : double" Usage="System.Windows.FrameworkElement.ActualHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の描画時の高さを取得します。</summary>
        <value>要素の高さ ([!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] の値)。 既定値は 0 (ゼロ) です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、他の高さ入力とレイアウト システムに基づいて計算される値です。 値は、実際のレンダリング パスに基づいて、レイアウト システム自体によって設定がためとプロパティの設定値の背後にあるなど<xref:System.Windows.FrameworkElement.Height%2A>入力の変更の基準であります。  
  
 <xref:System.Windows.FrameworkElement.ActualHeight%2A>注意する必要が、計算した値には、複数存在する可能性がありますまたは増分報告が変更をさまざまな操作の結果として、レイアウト システムによる。 レイアウト システムが、子要素に必要な測定スペース、親要素による制約などを計算している場合があります。  
  
 このプロパティを設定することはできません[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、基にすることができます、<xref:System.Windows.Trigger>スタイルでは、その値にします。  
  
<a name="dependencyPropertyInfo_ActualHeight"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次の例では、さまざまな高さのプロパティを表示します。  
  
 [!code-csharp[HeightMinHeightMaxHeight#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HeightMinHeightMaxHeight/CSharp/Window1.xaml.cs#3)]
 [!code-vb[HeightMinHeightMaxHeight#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HeightMinHeightMaxHeight/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.ActualHeight" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidth">
      <MemberSignature Language="C#" Value="public double ActualWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualWidth { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualWidth : double" Usage="System.Windows.FrameworkElement.ActualWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の描画時の幅を取得します。</summary>
        <value>要素の幅 ([!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] の値)。 既定値は 0 (ゼロ) です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、その他の幅の入力とレイアウト システムに基づいて計算される値です。 値は、実際のレンダリング パスに基づいて、レイアウト システム自体によって設定がためとプロパティの設定値の背後にあるなど<xref:System.Windows.FrameworkElement.Width%2A>入力の変更の基準であります。  
  
 <xref:System.Windows.FrameworkElement.ActualWidth%2A>注意する必要が、計算した値には、複数存在する可能性がありますまたは増分報告が変更をさまざまな操作の結果として、レイアウト システムによる。 レイアウト システムが、子要素に必要な測定スペース、親要素による制約などを計算している場合があります。  
  
 このプロパティを設定することはできません[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、基にすることができます、<xref:System.Windows.Trigger>スタイルでは、その値にします。  
  
<a name="dependencyPropertyInfo_ActualWidth"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次の例では、さまざまな幅のプロパティを表示します。  
  
 [!code-csharp[WidthMinWidthMaxWidth#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WidthMinWidthMaxWidth/CSharp/Window1.xaml.cs#3)]
 [!code-vb[WidthMinWidthMaxWidth#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WidthMinWidthMaxWidth/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.ActualWidth" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">追加される子要素。</param>
        <summary>指定したオブジェクトをこの要素の論理ツリーに追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素の論理上の子要素を表すオブジェクトのコレクションの実装には、このメソッドを使用します。 子要素のコレクションのコレクションのメンテナンスは、プロパティ get アクセス操作子または set アクセス操作子のクラス処理のときに Changed イベント、コンス トラクター、またはコレクション型自体内で行われます。  
  
 制御シナリオに適した使用可能な基本コントロール クラスのコンテンツ モデルの場合を除いては、コントロールの作成者がこのレベルでの論理ツリーを操作することはお勧めできません。 サブクラス化のレベルを検討してください。 <xref:System.Windows.Controls.ContentControl>、 <xref:System.Windows.Controls.ItemsControl>、および<xref:System.Windows.Controls.HeaderedItemsControl>します。 これらのクラスを専用の論理ツリーの子要素の特定の強制のコンテンツ モデルを提供する[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]、通常望ましい他の機能のサポートと、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]テンプレートをスタイル設定などのコントロール。 使用する方法の詳細についての<xref:System.Windows.FrameworkElement.LogicalChildren%2A>と<xref:System.Windows.FrameworkElement.AddLogicalChild%2A>を参照してください[WPF のツリー](~/docs/framework/wpf/advanced/trees-in-wpf.md)します。  
  
 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A> 別のプロセスによって、論理ツリーが反復処理されるときに呼び出された場合、例外をスローする可能性があります。  
  
   
  
## Examples  
 次の例では、実装、`Child`カスタム プロパティ<xref:System.Windows.FrameworkElement>独自のビジュアル層の実装を行うことです。 プロパティ set アクセス操作子では、古い値をクラスに固有のビジュアルのコレクションと同様に、論理ツリーから削除、値が変更された場合ように設計されています。 プロパティの値をキャッシュすると、論理ツリーとカスタム ビジュアルのコレクションの両方に新しい値を追加し、.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyTemplate">
      <MemberSignature Language="C#" Value="public bool ApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyTemplate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ApplyTemplate();" />
      <MemberSignature Language="F#" Value="member this.ApplyTemplate : unit -&gt; bool" Usage="frameworkElement.ApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>必要に応じて現在のテンプレートのビジュアル ツリーを構築し、この呼び出しによってビジュアル ツリーが再構築されたかどうかを示す値を返します。</summary>
        <returns>ビジュアルがツリーに追加された場合は <see langword="true" />、それ以外の場合は <see langword="false" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションでは、要素のビジュアル ツリーが完了したことを保証するには、このメソッドを呼び出すことができます。 この保証手順のコードは、ツリー内の子要素をチェックする場合は、必要があります。 一般的な要素のロジックを呼び出すアプリケーション内での<xref:System.Windows.FrameworkElement.ApplyTemplate%2A>テンプレートは適用されるため、適切な位置にある要素をその有効期間で自動的に必要ではありません。  
  
 <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> すべてのメジャーが呼び出される、WPF フレームワーク レベルのレイアウト システムによって渡します。  
  
 <xref:System.Windows.FrameworkElement> 派生クラスで使用できる、<xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>にケースがこのメソッドが明示的に呼び出された場合のまたは、レイアウト システムによる通知を受け取るクラス ハンドラー。 <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> テンプレートが完全に生成し、論理ツリーにアタッチされていると呼びます。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ControlTemplate" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected override sealed void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="override this.ArrangeCore : System.Windows.Rect -&gt; unit" Usage="frameworkElement.ArrangeCore finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">この要素が要素自体と子を配置するために使用する親の末尾の領域。</param>
        <summary><see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> (<see cref="T:System.Windows.UIElement" /> で仮想メソッドとして定義されています) を実装し、その実装をシールします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはシールされています。 要素のレイアウトの配置パスを具体的には、カスタム要素内のロジックをオーバーライドするには、<xref:System.Windows.FrameworkElement>派生クラスでオーバーライドする必要があります<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size finalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ArrangeOverride (finalSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size ArrangeOverride(System::Windows::Size finalSize);" />
      <MemberSignature Language="F#" Value="abstract member ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.ArrangeOverride finalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="finalSize">この要素が要素自体と子を配置するために使用する親の末尾の領域。</param>
        <summary>派生クラスでオーバーライドされると、子要素を配置し、<see cref="T:System.Windows.FrameworkElement" /> 派生クラスのサイズを決定します。</summary>
        <returns>使用する実際のサイズ。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>コントロールの作成者がレイアウト処理の配置パスをカスタマイズするには、このメソッドをオーバーライドする必要があります。 実装のパターンを呼び出す必要があります<see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />各表示されている子要素、およびパスの最終的な目的として各子要素のサイズ、<paramref name="finalRect" />パラメーター。 親要素で呼び出す必要があります<see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />でそれぞれの子では、それ以外の場合、子要素は表示されません。  
  
多くの派生クラスでは、このメソッドの実装を提供します。 著名なものが含まれます: <see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />、<see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" />と<see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />します。</para></block>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素の初期化プロセスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 公開または要素を任意の要素ツリーに接続されていない方法で調整する場合は、個々 の要素でこのメソッドを呼び出すことができます。 たとえば、作成した場合、新しい<xref:System.Windows.FrameworkElement>、まだ接続していないことを論理ツリーですが。 または、要素がその中の子要素を論理ツリーは、ウィンドウや、アプリケーションのページに接続されていない可能性があります。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>要素の読み込みプロセス中に、要素が初期化される前に行う必要がある特別な処理を提供するのには、このメソッドを実装します。  
  
実装は、ベース (既定値) の実装の初期化を追跡するいくつかの内部フラグが設定されるため、基本の実装を呼び出す必要があります。 1 つの考えられる実装では、コンス トラクターによって既に有効でない独自のプライベート クラスの初期化ルーチンをフックとしてこのメソッドを使用します。  
  
場合に基本の実装が例外をスロー<see cref="M:System.Windows.FrameworkElement.BeginInit" />が呼び出された複数の同じ要素の前に<see cref="M:System.Windows.FrameworkElement.EndInit" />が呼び出されます。</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したストーリーボードに含まれるアクションのシーケンスを開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">開始するストーリーボード。</param>
        <summary>指定したストーリーボードに含まれるアクションのシーケンスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アニメーションの最も一般的なシナリオでは、このメソッドは使用しないでください。 通常、作成、<xref:System.Windows.Media.Animation.Storyboard>または<xref:System.Windows.Media.Animation.BeginStoryboard>、マークアップ内の要素を配置として、<xref:System.Windows.EventTrigger>要素のコンテンツ。 イベントによってトリガーされると、アニメーションが実行されます。 ほとんどのコントロールの側面を<xref:System.Windows.Media.Animation.Storyboard>マークアップで公開されているプロパティでアドレス指定することができます。  
  
 署名を使用しない、 `isControllable`、パラメーター、そのパラメーターが指定されている場合または`false`アニメーションに関連付けられているタイムラインのクロックが"Fill"期間に達するとすぐに削除されます。 そのため、アニメーションは、1 回実行した後は再開できません。 ストーリー ボードがある必要がありますもアニメーションを制御する、 [X:name ディレクティブ](~/docs/framework/xaml-services/x-name-directive.md)またはコード内の参照でアクセスできるようにします。  
  
   
  
## Examples  
 次の例では、取得、<xref:System.Windows.Media.Animation.Storyboard>リソースからし実行する<xref:System.Windows.Media.Animation.Storyboard>内部イベントが処理されるクラスの場合。  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">開始するストーリーボード。</param>
        <param name="handoffBehavior">ストーリーボードに記述されたプロパティが既にアニメーション化されている場合に使用する動作を表す列挙値。</param>
        <summary>プロパティが既にアニメーション化されていた場合にどうするかを指定するオプションを使用して、指定したストーリーボードに含まれるアクションのシーケンスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アニメーションの最も一般的なシナリオでは、このメソッドは使用しないでください。 通常、作成、<xref:System.Windows.Media.Animation.Storyboard>または<xref:System.Windows.Media.Animation.BeginStoryboard>、マークアップ内の要素を配置として、<xref:System.Windows.EventTrigger>要素のコンテンツ。 イベントによってトリガーされると、アニメーションが実行されます。 ほとんどのコントロールの側面を<xref:System.Windows.Media.Animation.Storyboard>マークアップで公開されているプロパティでアドレス指定することができます。  
  
 署名を使用しない、 `isControllable`、パラメーター、そのパラメーターが指定されている場合または`false`アニメーションに関連付けられているタイムラインのクロックが"Fill"期間に達するとすぐに削除されます。 そのため、アニメーションは、1 回実行した後は再開できません。 ストーリー ボードがある必要がありますもアニメーションを制御する、 [X:name ディレクティブ](~/docs/framework/xaml-services/x-name-directive.md)またはコード内の参照でアクセスできるようにします。  
  
 ハンドオフ動作の属性として指定できます<xref:System.Windows.Media.Animation.BeginStoryboard>します。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用して、Compose HandoffBehavior  
 適用すると、 <xref:System.Windows.Media.Animation.Storyboard>、 <xref:System.Windows.Media.Animation.AnimationTimeline>、または<xref:System.Windows.Media.Animation.AnimationClock>にプロパティを使用して、 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>、any<xref:System.Windows.Media.Animation.Clock>以前そのプロパティに関連付けられているオブジェクトは引き続きシステム リソースを消費しますタイミング システムは。時計を自動的に削除されません。  
  
 使用して多数のクロックを適用すると、パフォーマンスの問題を回避するために<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>、完了後に、アニメーション化されたプロパティから構成クロックを削除する必要があります。 クロックを削除するいくつかの方法はあります。  
  
-   プロパティからすべてのクロックを削除するには、使用、<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>または<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>アニメーション化されたオブジェクトのメソッド。 最初のパラメーターとしてアニメーション化されているプロパティを指定し、 `null` 2 つ目として。 これにより、すべてのアニメーション クロックがプロパティから削除します。  
  
-   特定を削除する<xref:System.Windows.Media.Animation.AnimationClock>クロックの一覧は、使用して、<xref:System.Windows.Media.Animation.Clock.Controller%2A>のプロパティ、<xref:System.Windows.Media.Animation.AnimationClock>を取得する、 <xref:System.Windows.Media.Animation.ClockController>、呼び出して、<xref:System.Windows.Media.Animation.ClockController.Remove%2A>のメソッド、<xref:System.Windows.Media.Animation.ClockController>します。 これは、通常、<xref:System.Windows.Media.Animation.Clock.Completed>クロックのイベント ハンドラー。 唯一のルート クロックを使用して制御できることに注意してください、 <xref:System.Windows.Media.Animation.ClockController>、<xref:System.Windows.Media.Animation.Clock.Controller%2A>子クロックのプロパティを返します`null`します。 なお、<xref:System.Windows.Media.Animation.Clock.Completed>クロックの有効期間が永久の場合、イベントは発生しません。  その場合は、ユーザーが判断する必要がありますを呼び出すタイミング<xref:System.Windows.Media.Animation.ClockController.Remove%2A>します。  
  
 これは主に、有効期間が長いオブジェクトでのアニメーションの問題です。  オブジェクトがガベージ コレクションの場合は、そのクロックも切断し、ガベージ コレクション。  
  
 クロック オブジェクトの詳細については、次を参照してください。[アニメーションとタイミング システムの概要](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)します。  
  
   
  
## Examples  
 次の例では、取得、<xref:System.Windows.Media.Animation.Storyboard>リソースからし実行する<xref:System.Windows.Media.Animation.Storyboard>内部イベントが処理されるクラスの場合。  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">開始するストーリーボード。</param>
        <param name="handoffBehavior">ストーリーボードに記述されたプロパティが既にアニメーション化されている場合に使用する動作を表す列挙値。</param>
        <param name="isControllable">アニメーションを起動した後に、アニメーションを制御できるかどうか (一時停止できるかどうか) を宣言します。</param>
        <summary>開始後のアニメーションの制御の状態を指定して、指定したストーリーボードに含まれるアクションのシーケンスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アニメーションの最も一般的なシナリオでは、このメソッドは使用しないでください。 通常、作成、<xref:System.Windows.Media.Animation.Storyboard>または<xref:System.Windows.Media.Animation.BeginStoryboard>、マークアップ内の要素を配置として、<xref:System.Windows.EventTrigger>要素のコンテンツ。 イベントによってトリガーされると、アニメーションが実行されます。 ほとんどのコントロールの側面を<xref:System.Windows.Media.Animation.Storyboard>マークアップで公開されているプロパティでアドレス指定することができます。  
  
 署名を使用しない、 `isControllable`、パラメーター、そのパラメーターが指定されている場合または`false`アニメーションに関連付けられているタイムラインのクロックが"Fill"期間に達するとすぐに削除されます。 そのため、アニメーションは、1 回実行した後は再開できません。 ストーリー ボードがある必要がありますもアニメーションを制御する、 [X:name ディレクティブ](~/docs/framework/xaml-services/x-name-directive.md)またはコード内の参照でアクセスできるようにします。  
  
 ハンドオフ動作の属性として指定できます<xref:System.Windows.Media.Animation.BeginStoryboard>します。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用して、Compose HandoffBehavior  
 適用すると、 <xref:System.Windows.Media.Animation.Storyboard>、 <xref:System.Windows.Media.Animation.AnimationTimeline>、または<xref:System.Windows.Media.Animation.AnimationClock>にプロパティを使用して、 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>、any<xref:System.Windows.Media.Animation.Clock>以前そのプロパティに関連付けられているオブジェクトは引き続きシステム リソースを消費しますタイミング システムは。時計を自動的に削除されません。  
  
 使用して多数のクロックを適用すると、パフォーマンスの問題を回避するために<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>、完了後に、アニメーション化されたプロパティから構成クロックを削除する必要があります。 クロックを削除するいくつかの方法はあります。  
  
-   プロパティからすべてのクロックを削除するには、使用、<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>または<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>アニメーション化されたオブジェクトのメソッド。 最初のパラメーターとしてアニメーション化されているプロパティを指定し、 `null` 2 つ目として。 これにより、すべてのアニメーション クロックがプロパティから削除します。  
  
-   特定を削除する<xref:System.Windows.Media.Animation.AnimationClock>クロックの一覧は、使用して、<xref:System.Windows.Media.Animation.Clock.Controller%2A>のプロパティ、<xref:System.Windows.Media.Animation.AnimationClock>を取得する、 <xref:System.Windows.Media.Animation.ClockController>、呼び出して、<xref:System.Windows.Media.Animation.ClockController.Remove%2A>のメソッド、<xref:System.Windows.Media.Animation.ClockController>します。 これは、通常、<xref:System.Windows.Media.Animation.Clock.Completed>クロックのイベント ハンドラー。 唯一のルート クロックを使用して制御できることに注意してください、 <xref:System.Windows.Media.Animation.ClockController>、<xref:System.Windows.Media.Animation.Clock.Controller%2A>子クロックのプロパティを返します`null`します。 なお、<xref:System.Windows.Media.Animation.Clock.Completed>クロックの有効期間が永久の場合、イベントは発生しません。  その場合は、ユーザーが判断する必要がありますを呼び出すタイミング<xref:System.Windows.Media.Animation.ClockController.Remove%2A>します。  
  
 これは主に、有効期間が長いオブジェクトでのアニメーションの問題です。  オブジェクトがガベージ コレクションの場合は、そのクロックも切断し、ガベージ コレクション。  
  
 クロック オブジェクトの詳細については、次を参照してください。[アニメーションとタイミング システムの概要](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素に使用される <see cref="T:System.Windows.Data.BindingGroup" /> を取得または設定します。</summary>
        <value>要素に使用される <see cref="T:System.Windows.Data.BindingGroup" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Data.BindingGroup>オブジェクトの複数のプロパティの値を検証するために使用できます。 たとえば、アプリケーションはアドレスを入力するように求めるし、型のオブジェクトを作成し、 `Address`、プロパティを持つ`Street`、 `City`、`ZipCode`と`Country`値を使用しているユーザー提供されています。 アプリケーションが 4 つを格納しているパネル<xref:System.Windows.Controls.TextBox>オブジェクトのプロパティのいずれかにバインドされているは、コントロール。 使用することができます、<xref:System.Windows.Controls.ValidationRule>で、<xref:System.Windows.Data.BindingGroup>を検証する、`Address`オブジェクト。 たとえば、<xref:System.Windows.Controls.ValidationRule>郵便番号がアドレスの国の有効であることを確認できます。  
  
 子要素の継承、<xref:System.Windows.Data.BindingGroup>だけで、他の継承可能なプロパティと同様に、親要素から。  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 次の例は、ユーザーに同じ値を 2 つのオブジェクトのプロパティを設定するかどうかを確認するアプリケーションの一部です。 最初の例では、2 つ作成されます<xref:System.Windows.Controls.TextBox>コントロール、それぞれが別のデータ ソースにバインドされます。 <xref:System.Windows.Controls.StackPanel>が、<xref:System.Windows.Data.BindingGroup>を格納している、 <xref:System.Windows.Controls.ValidationRule> 2 つの文字列が等しいことを確認します。  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupComplete](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupcomplete)]  
  
 次の例は、<xref:System.Windows.Controls.ValidationRule>前の例を使用します。  <xref:System.Windows.Controls.ValidationRule.Validate%2A>メソッドのオーバーライド例からには、各ソース オブジェクトを取得、<xref:System.Windows.Data.BindingGroup>オブジェクトのプロパティが等しいかどうかを確認します。  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 呼び出す、<xref:System.Windows.Controls.ValidationRule>を呼び出し、<xref:System.Windows.Data.BindingGroup.UpdateSources%2A>メソッド。  次の例では<xref:System.Windows.Data.BindingGroup.UpdateSources%2A>ボタンの click イベントが発生します。  
  
 [!code-csharp[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#updatesourcesclick)]
 [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#updatesourcesclick)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.BindingGroup" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BringIntoView">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素が含まれているスクロール可能な領域内に、この要素を表示することを試みます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素が含まれているスクロール可能な領域内に、この要素を表示することを試みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出すことにより、<xref:System.Windows.FrameworkElement.RequestBringIntoView>を現在の要素から取得されたイベント。 処理できるように、このイベントが発生した、 <xref:System.Windows.Controls.ScrollViewer>、または派生または同様のクラス。 想定される動作は、イベントがイベント データの処理済みとしてマーク、親要素によって処理し、イベントのソースに埋め込まれたロジックを通じてビューに読み込まれること、<xref:System.Windows.Controls.ScrollViewer>コントロール。 どちらも、<xref:System.Windows.FrameworkElement.RequestBringIntoView>イベントも<xref:System.Windows.FrameworkElement.BringIntoView%2A>メソッドについての成功または失敗、もう 1 つよりも、イベントは通常の処理の成功とマーク情報を送信します。 上の理由により障害などで要素の設定を含めることができますの<xref:System.Windows.UIElement.Visibility%2A>以外のいくつかの値をされている<xref:System.Windows.Visibility.Visible>します。  
  
 指定されていない署名を使用する場合、 `targetRectangle`、全体の要素のサイズし (その<xref:System.Windows.UIElement.RenderSize%2A>) が表示されます。  
  
 このメソッドを呼び出す可能性のある呼び出す<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>要素を含む親スクロール可能な領域にします。 スクロール可能な領域では、この要素が含まれていない場合、<xref:System.Windows.FrameworkElement.RequestBringIntoView>も、イベントが発生しますが、ことはありません効果イベント リスナーが存在しないためです。  
  
   
  
## Examples  
 次の例では、実装されるたびに応答するアプリケーションのナビゲーション イベントのハンドラーを[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]フラグメントには移動先が含まれています。 フラグメントの名前は、[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]ハッシュ記号に続く (#)、実装の動作により、スクロールして、フレーム内で表示する要素とします。 <xref:System.Windows.FrameworkElement.BringIntoView%2A> <xref:System.Windows.FrameworkElement.RequestBringIntoView>の例では、そのスクロール動作を要求します。  
  
 [!code-csharp[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/csharp/VS_Snippets_Wpf/FragmentNavigationSample/CSharp/MainWindow.xaml.cs#febringintoview)]
 [!code-vb[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FragmentNavigationSample/VisualBasic/MainWindow.xaml.vb#febringintoview)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView (System.Windows.Rect targetRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView(valuetype System.Windows.Rect targetRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView (targetRectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView(System::Windows::Rect targetRectangle);" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : System.Windows.Rect -&gt; unit" Usage="frameworkElement.BringIntoView targetRectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetRectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="targetRectangle">指定した、表示する必要がある要素のサイズ。</param>
        <summary>この要素が含まれているスクロール可能な領域内で、この要素の指定したサイズの領域が表示されるように試みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出すことにより、<xref:System.Windows.FrameworkElement.RequestBringIntoView>を現在の要素から取得されたイベント。 処理できるように、このイベントが発生した、 <xref:System.Windows.Controls.ScrollViewer>、または派生または同様のクラス。 想定される動作は、イベントがイベント データの処理済みとしてマーク、親要素によって処理し、イベントのソースに埋め込まれたロジックを通じてビューに読み込まれること、<xref:System.Windows.Controls.ScrollViewer>コントロール。 どちらも、<xref:System.Windows.FrameworkElement.RequestBringIntoView>イベントも<xref:System.Windows.FrameworkElement.BringIntoView%2A>メソッドについての成功または失敗、もう 1 つよりも、イベントは通常の処理の成功とマーク情報を送信します。 上の理由により障害などで要素の設定を含めることができますの<xref:System.Windows.UIElement.Visibility%2A>以外のいくつかの値をされている<xref:System.Windows.Visibility.Visible>します。  
  
 指定されていない署名を使用する場合、 `targetRectangle`、全体の要素のサイズし (その<xref:System.Windows.UIElement.RenderSize%2A>) が表示されます。  
  
 このメソッドを呼び出す可能性のある呼び出す<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>要素を含む親スクロール可能な領域にします。 スクロール可能な領域では、この要素が含まれていない場合、<xref:System.Windows.FrameworkElement.RequestBringIntoView>も、イベントが発生しますが、ことはありません効果イベント リスナーが存在しないためです。  
  
   
  
## Examples  
 次の例では、制約付きのスクロール領域で大規模なグラフィックが。 ページ上のボタンには、大きな画像の特定の地域にビューをスクロールするハンドラーがあります。  
  
 [!code-xaml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml#bringintoviewrectmarkup)]  
  
 [!code-csharp[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#bringintoviewrectcode)]
 [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#bringintoviewrectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.FlowDocumentScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素内から [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] によってコンテキスト メニューが要求された場合に常に表示されるコンテキスト メニュー要素を取得または設定します。</summary>
        <value>この要素に割り当てられたコンテキスト メニュー。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ContextMenu> 自体は、<xref:System.Windows.FrameworkElement>クラスを派生し、技術的には可能性があります<xref:System.Windows.Controls.ContextMenu>自体が、<xref:System.Windows.FrameworkElement.ContextMenu%2A>プロパティ。 ただし、これがユーザーの混乱を招くのコンテキスト] メニューの [エクスペリエンスを作成し、この方法は推奨されません。  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素のコンテキスト メニューが閉じる直前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 閉じないようにするには、イベントのハンドラーのコンテキスト メニュー、する必要があります、処理済みとしてマークします。  
  
 このイベントとして使用する、<xref:System.Windows.EventTrigger>スタイルでは、イベントの基になるサービスの定義を参照する必要があります。  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (この使用法が必要なのでイベントの実装<xref:System.Windows.FrameworkElement>、公開、基になるサービスのイベントはマップされません、<xref:System.Windows.FrameworkElement.ContextMenuClosing>識別子をトリガーとして使用することができます)。  
  
 <xref:System.Windows.Controls.ContextMenu> 自体は、<xref:System.Windows.FrameworkElement>派生クラスしますが、<xref:System.Windows.FrameworkElement.ContextMenuClosing>コンテキスト メニューでイベントは直接発生しません。 代わりに、プロパティとして、コンテキスト メニューを"所有"して、ユーザーが UI にコンテキスト メニューを閉じるしようとしたときにだけ発生する要素から、イベントが発生します。 ただしのことができます<xref:System.Windows.Controls.ContextMenu>自体が、<xref:System.Windows.FrameworkElement.ContextMenu%2A>プロパティ (入れ子になったコンテキスト メニュー)。 この場合、 <xref:System.Windows.Controls.ContextMenu> 、入れ子になった実際に所有して<xref:System.Windows.Controls.ContextMenu>と入れ子になったコンテキスト メニューをされているイベントのソースと、イベントを発生させる可能性があります。  
  
 <xref:System.Windows.Controls.ContextMenu>クラス自体にも同様のイベント (<xref:System.Windows.Controls.ContextMenu.Closed>) が、<xref:System.Windows.Controls.ContextMenu.Closed>イベントは、ユーザーの操作をキャンセルする機会が提供されません。  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   オーバーライド<xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素のコンテキスト メニューが開くときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンテキスト メニューを手動で開く、処理済みとして、イベントのハンドラーは、関連するイベントをマークする必要があります。 それ以外の場合、既存の値、<xref:System.Windows.FrameworkElement.ContextMenu%2A>プロパティが自動的にコンテキスト メニューを開き、使用されます。 既定のアクションを効果的に取り消しし、の値にリセットすることにより、イベントを処理済みのマークを付ける、<xref:System.Windows.FrameworkElement.ContextMenu%2A>プロパティを開き、新しい<xref:System.Windows.Controls.ContextMenu>します。 ただし、認識する必要があるタイミングの問題があります。 によりコンテキスト メニューを完全に置換するには、<xref:System.Windows.FrameworkElement.ContextMenuOpening>ハンドラー、初期のコンテキスト メニューがあります null/空です。 また、イベントを処理し、新しいコンテキスト メニューを手動で開く必要があります。 詳細については、「[方法: ContextMenuOpening イベントを処理](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)します。  
  
 としては、このイベントを使用して、<xref:System.Windows.EventTrigger>スタイルでは、基になる添付イベントを参照する必要があります。  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (ために、この使用法が必要でイベントの実装<xref:System.Windows.FrameworkElement>を公開、基になるサービスのイベントがマップされない、<xref:System.Windows.FrameworkElement.ContextMenuOpening>識別子をトリガーで使用することができます)。  
  
 <xref:System.Windows.Controls.ContextMenu> 自体は、<xref:System.Windows.FrameworkElement>派生クラスでは、ソースとして開かれている、コンテキスト メニューからこのイベントは発生しません。 要素をプロパティとして、コンテキスト メニューを「所有」するしようとすると、UI のコンテキスト メニューを開くときにのみ発生するイベントが発生します。 可能性があります<xref:System.Windows.Controls.ContextMenu>自体が、<xref:System.Windows.FrameworkElement.ContextMenu%2A>がプロパティには、このシナリオを回避する必要があります (詳細については、次を参照してください。 <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType>)。  
  
 <xref:System.Windows.Controls.ContextMenu>クラス自体にも同様のイベント (<xref:System.Windows.Controls.ContextMenu.Opened>) が、<xref:System.Windows.Controls.ContextMenu.Opened>ユーザー操作をキャンセルする機会を提供しません。  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   オーバーライド<xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.ContextMenu" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上にマウス ポインターが置かれたときに表示されるカーソルを取得または設定します。</summary>
        <value>表示対象のカーソル。 既定値はこの依存関係プロパティごとに <see langword="null" /> として定義されます。 ただし、実行時における実用的な既定値は、さまざまな要因から取得されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを設定すると[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]プロセッサに依存の型変換を<xref:System.Windows.Input.Cursor>クラス文字列を評価します。 指定された文字列に評価、<xref:System.Windows.Input.CursorType>値。 詳細については、「<xref:System.Windows.Input.Cursor>」を参照してください。  
  
 このプロパティによって確立されると、カーソルは、マウス ポインターがこの要素は表示されないかどうかの値に依存しても、<xref:System.Windows.FrameworkElement.ForceCursor%2A>プロパティ。 また、イベント関連の考慮事項など、アクティブなドラッグ、マウスのキャプチャ、テキスト編集コントロール、および、内のモードでは、このプロパティで指定した値よりも優先順位の高いカーソルは影響はも。  
  
 最終的な既定値にこのプロパティの設定の動作を元に戻すに設定`null`もう一度です。  
  
 `null`実際的なカーソルの値の決定はここでは遅延し、別の場所から取得する必要が本当に既定値を意味します。 任意のソースからプログラムで値を使用せず、提示された場合の既定のカーソルが視覚的にわたって、[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]アプリケーションは矢印になります。 ただし、カーソルの一時的な変更に設定されていない、<xref:System.Windows.FrameworkElement.Cursor%2A>経由で渡されるときに、要素の値。 <xref:System.Windows.FrameworkElement.Cursor%2A>プロパティはのみレポート非 null 値でそれが実際に設定されている場合、インスタンスのコードまたはスタイルによって。 上にマウスが移動するたび、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]が発生する<xref:System.Windows.UIElement.QueryCursor>イベント。 イベント バブルにおよび、経路上の任意の要素は、イベントを処理して、このイベントの引数をカーソルの値を設定する機会を持ちます。 これは、ほとんどの場合、明らかな視覚的にカーソルを生成するメカニズムです。 場合、<xref:System.Windows.UIElement.QueryCursor>ハンドラーは、カーソル結果を返すし、イベントが処理され、変更された値が引数、ファクトの値よりも優先、<xref:System.Windows.FrameworkElement.Cursor%2A>プロパティを任意のレベルでは、しない限り、<xref:System.Windows.FrameworkElement.ForceCursor%2A>設定されます。  
  
 通常の静的プロパティの値にこのプロパティを設定する場合は、カスタムのカーソルを作成しない、<xref:System.Windows.Input.Cursors>クラス。 設定<xref:System.Windows.FrameworkElement.Cursor%2A>コードで、次のいずれかが必要です。  
  
-   呼び出す、<xref:System.Windows.Input.Cursor>を取得するコンス トラクター、<xref:System.Windows.Input.Cursor>インスタンス。 両方の署名、<xref:System.Windows.Input.Cursor>コンス トラクターを使用して、ストリームまたはファイルを作成しているに応じるために、<xref:System.Windows.Input.Cursor>カスタム カーソル オブジェクト。  
  
-   使用して、<xref:System.Windows.Input.CursorConverter>クラスとその<xref:System.Windows.Input.CursorConverter.ConvertFrom%2A>メソッドによって、カーソルを指定<xref:System.Windows.Input.CursorType>、または文字列に評価されることを<xref:System.Windows.Input.CursorType>、キャストに戻ると<xref:System.Windows.Input.Cursor>。  
  
 設定、<xref:System.Windows.Input.Cursor>にカスタム値が有効でない部分信頼でします。 カスタムのカーソルの詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.CursorProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次の例では、カーソルのグラフィックを意図的に設定する方法を示します。  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.Cursor" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素がデータ バインディングに含まれている場合に、その要素のデータ コンテキストを取得または設定します。</summary>
        <value>データ コンテキストとして使用するオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *データ コンテキスト*は情報をバインディング、パスなどの他の特性と、バインディングに使用されるデータ ソースについて、親要素から継承できるようにする概念です。  
  
 データ コンテキストは、そのオブジェクトのプロパティに評価されるバインドで、.NET オブジェクトに直接設定できます。 または、データ コンテキストを設定、<xref:System.Windows.Data.DataSourceProvider>オブジェクト。  
  
 この依存関係プロパティは、プロパティの値を継承します。 その他の値を使用せずに子要素がある場合<xref:System.Windows.FrameworkElement.DataContext%2A>プロパティ システムは値を設定し、ローカルの値またはスタイル、を通じて確立、<xref:System.Windows.FrameworkElement.DataContext%2A>最も近い親要素の値をこの値が割り当てられています。  
  
 次のプロパティのいずれかを使用する代わりに、<xref:System.Windows.Data.Binding>バインディング ソースを明示的に指定するクラス。
  
    - <xref:System.Windows.Data.Binding.ElementName%2A>。
    - <xref:System.Windows.Data.Binding.Source%2A>.
    - <xref:System.Windows.Data.Binding.RelativeSource%2A>。 
  
  詳細については、「[方法 :バインディング ソースを指定](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)します。  
  
 XAML で<xref:System.Windows.FrameworkElement.DataContext%2A>として設定は通常、<xref:System.Windows.Data.Binding>宣言。 プロパティ要素構文または属性の構文を使用することができます。 属性構文は、このページの例に示します。 設定するコードを使用することもできます。<xref:System.Windows.FrameworkElement.DataContext%2A>します。  
  
 <xref:System.Windows.FrameworkElement.DataContext%2A> 別に 1 つのコンテキストをバインドするがあるシナリオを容易にバインド可能なプロパティです。 ただしにバインドする場合<xref:System.Windows.FrameworkElement.DataContext%2A>、循環バインディング参照を作成しないように注意してください (バインドは、<xref:System.Windows.FrameworkElement.DataContext%2A>自体のプロパティ値継承の性質のために実行することはこれを<xref:System.Windows.FrameworkElement.DataContext%2A>プロパティ)。  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>XAML 値  
 *dataContextObject*  
 親要素内のすべてのバインディングのデータ コンテキストとして機能する直接埋め込まれたオブジェクト。 通常、このオブジェクトは、<xref:System.Windows.Data.Binding>別または<xref:System.Windows.Data.BindingBase>クラスを派生します。 または、バインド対象の任意のオブジェクト型の生データは、後で定義されている実際のバインディングをここでは、配置する可能性があります。  
  
 *bindingUsage*  
 バインディングの使用方法、適切なデータ コンテキストに評価されます。 詳細については、「[バインディングのマークアップ拡張機能](~/docs/framework/wpf/advanced/binding-markup-extension.md)」を参照してください。  
  
 *resourceExtension*  
 次のいずれか: [ `StaticResource` ](~/docs/framework/wpf/advanced/staticresource-markup-extension.md)または[ `DynamicResource`](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)します。 この使用法は、リソース内のオブジェクトとして定義されている生データを参照するときに使用されます。 参照してください[XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)します。  
  
 *contextResourceKey*  
 内から要求されているオブジェクトのキー識別子、<xref:System.Windows.ResourceDictionary>します。  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.DataContextProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 次の例では、バインディング上のデータ コンテキストの動作を示していて、特定のバインドされたプロパティの値を定義する情報を提供します。  
  
 [!code-xaml[MasterDetail#DataContextProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty)]  
[!code-xaml[MasterDetail#DataContextProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty2)]  
[!code-xaml[MasterDetail#DataContextProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素のデータ コンテキストが変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 データ コンテキストとデータ バインディングの詳細については、次を参照してください。[データ バインディングの概要](~/docs/framework/wpf/data/data-binding-overview.md)します。  
  
> [!IMPORTANT]
>  ときに、<xref:System.Windows.FrameworkElement.DataContext%2A>要素変更では、この要素のすべてのデータ バインド プロパティに影響は可能性があります。 これは、データ コンテキストを継承するには、論理ツリーの現在の要素の子要素である任意の要素とも、現在の要素自体に適用されます。 このような既存のすべてのバインドは、新しい再解釈する必要があります<xref:System.Windows.FrameworkElement.DataContext%2A>バインディングの結果を再評価するとします。 データ バインディング エンジンが明確では、これらの再評価の順序ではありません、<xref:System.Windows.FrameworkElement.DataContextChanged>イベント。 イベントの後、または任意の組み合わせで、再評価は、イベントの前に発生します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.DataContext" />
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.DataContext" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>テーマ スタイルを使用または定義するときに、このコントロールのスタイルを参照するために使用されるキーを取得または設定します。</summary>
        <value>スタイルのキー。 テーマ スタイル参照の一部として正常に機能するために、この値は、スタイルを設定するコントロールの <see cref="T:System.Type" /> である必要があります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、通常はその直接のプロパティ アクセサーのいずれかを設定されません。 新規に作成するたびにこの依存関係プロパティの種類に固有のメタデータをオーバーライドする代わりに、<xref:System.Windows.FrameworkElement>クラスを派生します。 コントロールを派生するときに呼び出す、<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>メソッドに対して、<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>クラス (または同等のクラスの初期化) 派生したコントロールの静的コンス トラクター内の識別子。  
  
 コントロールは通常、独自の型を指定するには、このプロパティの既定値よりも優先されますが、場合によってはのテーマ ディクショナリでスタイルが存在する基本データ型も同じで使用できます。 これは、基本コントロールのコントロール テンプレートが完全に、その派生コントロールの視覚的表現を定義し、どのような追加のメンバーが派生型を公開、コントロール テンプレートの一部として追加の要素が必要ない場合にのみ実用的です。  
  
 要素または意図的にないテーマ スタイルを使用するコントロールをする場合、設定、<xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>プロパティを`true`します。  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 次の例は、「解説」で説明されている依存関係プロパティ メタデータのオーバーライド使用を示しています。 このコードは、カスタム コントロール クラスを定義します。`NumericUpDown`専用コントロール ライブラリのアセンブリから使用するためのものです。 イラストの静的コンス トラクターがプライベートの初期化関数を参照、クラス ハンドラーを登録します (別の一般的なコントロールをサブクラス化シナリオ[ルーティング イベントの処理済み、およびクラス処理としてのマーキング](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)) と最後に上書き、<xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>で依存関係プロパティ メタデータ、`NumericUpDown`クラス。 <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> テーマ スタイルのシステムを使用していくつか任意が設定されていないコントロールのスタイルを検索する規則は、目的のキーとして常に独自の型を返します。 完全なサンプルは、そのキーによって参照される実際のコントロールのテーマのスタイルも定義されています。参照してください[NumericUpDown カスタム コントロールのテーマと UI Automation Support Sample](https://go.microsoft.com/fwlink/?LinkID=160025)します。  
  
 [!code-csharp[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown2.cs)]
 [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown2.vb)]  

  この例の完全なソース コードは GitHub の両方で使用可能[ C# ](https://github.com/dotnet/samples/tree/master/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary)と[Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary)します。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160025">NumericUpDown Custom Control with Theme and UI Automation Support Sample</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素の初期化プロセスが完了したことを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合<xref:System.Windows.FrameworkElement.BeginInit%2A>以前、呼び出された基本実装を発生させる、<xref:System.Windows.FrameworkElement.Initialized>イベント。 の場合<xref:System.Windows.FrameworkElement.BeginInit%2A>が呼び出されていないかできなかったかどうかを確認<xref:System.Windows.FrameworkElement.BeginInit%2A>が呼び出された<xref:System.Windows.FrameworkElement.Initialized>は発生しません代わりに、例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">以前に <see cref="M:System.Windows.FrameworkElement.EndInit" /> が呼び出されていないこの要素で、<see cref="M:System.Windows.FrameworkElement.BeginInit" /> が呼び出されました。</exception>
        <block subset="none" type="overrides"><para>要素の読み込みプロセス中に、要素の初期化時に行う必要がある特別な処理を提供するのには、このメソッドを実装します。  
  
実装は、ベース (既定値) の実装の初期化を追跡するいくつかの内部フラグが設定されるため、基本の実装を呼び出す必要があります。</para></block>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要求された要素の名前。</param>
        <summary>指定した識別名を持つ要素を検索します。</summary>
        <returns>要求された要素。 一致する要素が見つからなかった場合は <see langword="null" /> になります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素の子要素が、これらの子要素が要求された要素をという名前の再帰的には、すべて検索にします。  
  
 <xref:System.Windows.FrameworkElement.FindName%2A> 現在の要素の名前スコープ内で動作します。 詳細については、次を参照してください。 [WPF XAML 名前スコープ](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
        <related type="Article" href="https://msdn.microsoft.com/library/b7e61222-e8cf-48d2-acd0-6df3b7685d48">X:name 属性</related>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要求したリソースのキー識別子。</param>
        <summary>指定したキーを持つリソースを検索します。要求したリソースが見つからない場合は例外がスローされます。</summary>
        <returns>要求されたリソース。 指定したキーを持つリソースが見つからなかった場合は例外がスローされます。 その場合は <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> 値が返されることもあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  見つからないキーのこのメソッドを呼び出すと、例外がスローされます。 呼び出し元に起因する例外を処理しないかどうかは<xref:System.Windows.FrameworkElement.FindResource%2A>、呼び出す<xref:System.Windows.FrameworkElement.TryFindResource%2A>代わりにします。 <xref:System.Windows.FrameworkElement.TryFindResource%2A> 返します`null`要求されたリソースが見つからないし、例外はスローされません。  
  
 呼び出し元の要素で、リソースが見つからない場合、論理ツリー内の親要素、検索結果の次し、アプリケーション、し、テーマ、最後にシステム リソース。 この参照方法は、リソースがマークアップでの動的リソース参照によって要求された場合に、ツリーを検索する方法と同じです。 リソースのルックアップの詳細については、次を参照してください。 [XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)します。  
  
 通常、即座にキャストする、<xref:System.Windows.FrameworkElement.FindResource%2A>に値を返し、プロパティの型を返されたリソースの値を設定します。  
  
 リソース キーは、必ずしも文字列ではありません。 たとえば、テーマ レベルのコントロールが意図的と適合するをスタイル設定、<xref:System.Type>の管理、およびアプリケーションまたはページのスタイルのコントロールを通常使用してこの同じキー規則。 詳細については、次を参照してください。[スタイルとテンプレート](~/docs/framework/wpf/controls/styling-and-templating.md)または[XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)します。  
  
   
  
## Examples  
 次の例では、名前付きリソースを取得し、プロパティを入力する適切な型にキャストされます。  
  
 [!code-csharp[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page3.xaml.cs#resourceproceduralget)]
 [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page3.xaml.vb#resourceproceduralget)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException"><paramref name="resourceKey" /> が見つからず、<see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> イベントのイベント ハンドラーが存在しません。  
  
または 
 <paramref name="resourceKey" /> が見つからず、<see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" /> イベントで <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> プロパティが <see langword="false" /> です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceKey" /> は <see langword="null" />です。</exception>
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FlowDirection" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowDirection As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FlowDirection FlowDirection { System::Windows::FlowDirection get(); void set(System::Windows::FlowDirection value); };" />
      <MemberSignature Language="F#" Value="member this.FlowDirection : System.Windows.FlowDirection with get, set" Usage="System.Windows.FrameworkElement.FlowDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウトを制御する親要素内でのテキストやその他の [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 要素のフロー方向を取得または設定します。</summary>
        <value>テキストやその他の [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 要素の親要素内でのフロー方向を示す列挙値。 既定値は <see cref="F:System.Windows.FlowDirection.LeftToRight" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係プロパティの使用状況のセット、<xref:System.Windows.FrameworkElement.FlowDirection%2A>この要素にします。 プロパティ値の設定の継承により<xref:System.Windows.FrameworkElement.FlowDirection%2A>要素では設定できます可能性のある<xref:System.Windows.FrameworkElement.FlowDirection%2A>設定しなかったすべての子要素で<xref:System.Windows.FrameworkElement.FlowDirection%2A>ローカルやスタイルなど、他の方法。  
  
 このプロパティがない自動的に設定、アプリケーションのカルチャの情報の一部として要素には、カルチャ情報が含まれる一般的なフローの方向に従うように必ずしもを目的としないコンテンツが含まれます。 グローバリゼーションの考慮事項の詳細については、次を参照してください。 [WPF のグローバリゼーション](~/docs/framework/wpf/advanced/globalization-for-wpf.md)します。  
  
 このプロパティは、定義されている[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]依存関係プロパティとして機能するように、プロパティ アクセサー。 ただし、コンピューターはも登録、接続されているため、添付プロパティとしても機能できます。 接続されている登録が主にプロパティ値の継承がサポートされていますが、プロパティは、実際の添付プロパティとしても使用できます。 添付プロパティの使用のフロー方向を設定するオブジェクトに関連するのみ、<xref:System.Windows.FrameworkElement>し、それに基づいてレイアウトを実行する親要素がそれ自体を<xref:System.Windows.FrameworkElement>がない、直接定義されていると`FlowDirection`プロパティ。 (フローのいくつかのドキュメント クラス<xref:System.Windows.Documents.Block>と<xref:System.Windows.Documents.Inline>が独自に定義`FlowDirection`、このプロパティは、フローの方向を設定もできます。 プロパティの値が、読み取られた最終的なコンテンツ ホスト添付プロパティの使用を必要とせず。)  
  
<a name="xamlAttributeUsage_FlowDirection"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
 \<*object* **FlowDirection**="<xref:System.Windows.FlowDirection>"/>  
  
<a name="xamlTextUsage_FlowDirection"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用状況  
 このプロパティは、れていないクラスにも設定できます<xref:System.Windows.FrameworkElement>、以下の派生クラス、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]添付プロパティの使用法。  
  
 `<` *object* `FrameworkElement.`**FlowDirection**="<xref:System.Windows.FlowDirection>`"/>`  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>、 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 このプロパティは依存関係プロパティと、添付プロパティです。「解説」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlowDirectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FlowDirectionProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FlowDirectionProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がキーボード フォーカスを受け取ったときに適用される外観、効果、またはその他のスタイル特性のカスタマイズを可能にするプロパティを取得または設定します。</summary>
        <value>フォーカスに適用する目的のスタイル。 依存関係プロパティで宣言されている既定値は、空の静的 <see cref="T:System.Windows.Style" /> です。 ただし、実行時の有効値は、多くの場合、コントロールのテーマ サポートによって提供されたスタイルです (ただし、常にそうであるとは限りません)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、視覚的な外観に影響を与えますが、報告しません<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>メタデータ。 視覚的な外観の変更はイベント ドリブンし、常に適用され、したがっては限らないメタデータ内の任意のビジュアルやレイアウト情報があるためにです。  
  
 概念的には、コントロールに適用されたフォーカスの視覚的な動作は、コントロール間で一貫している必要があります。 一貫性を実現する最も実用的な方法は、全体のテーマを作成する場合にのみフォーカス表示スタイルを変更します。 個々 のコントロールのスタイルとテーマの一部ではなく、このプロパティを設定キーボード フォーカスに関するユーザー エクスペリエンスに混乱には、このプロパティの使用目的はありません。 入力状態の個々 のプロパティのスタイルでトリガーをなど、使用するはるかに優れた方法は、コントロール固有の動作は意図的に一貫性のあるテーマである場合、<xref:System.Windows.UIElement.IsFocused%2A>または<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>とにはない方法で実行するには視覚的に既存のフォーカス ビジュアル スタイルに干渉します。 目的で設計の詳細については<xref:System.Windows.FrameworkElement.FocusVisualStyle%2A>と代替プロパティの焦点は、「[コントロール、および FocusVisualStyle フォーカスのスタイル](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)します。  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>XAML 値  
 *resourceExtension*  
 次のいずれか: または。 参照してください[XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)します。  
  
 *styleResourceKey*  
 要求されているスタイルを識別するキー。 このキーは、既存のリソースで、<xref:System.Windows.ResourceDictionary>します。  
  
> [!NOTE]
>  プロパティ要素構文は技術的に可能であれば、推奨されません。 参照してください[インライン スタイルおよびテンプレート](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)します。 使用してバインドの参照または<xref:System.Windows.Data.Binding>も可能ですが、一般的ではありません。  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Windows.FrameworkElement" /> でカーソルを <see cref="P:System.Windows.FrameworkElement.Cursor" /> プロパティの宣言に従って描画するように[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] を強制するかどうかを示す値を取得または設定します。</summary>
        <value>この要素の上にあるときのカーソルの表示に <see cref="P:System.Windows.FrameworkElement.Cursor" /> の現在の設定を強制的に使用する場合は <see langword="true" /> (すべての子要素を含む)。それ以外の場合は <see langword="false" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを設定する場合`true`子要素で設定されているカーソルの設定をオーバーライドします。 これは一般にアプリケーション[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]カーソルを指定しようとしている子要素の場合に特に、ユーザーの混乱する可能性があります。 設定<xref:System.Windows.FrameworkElement.ForceCursor%2A>がコントロールのサブクラス化や合成のシナリオでより適しています。  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次の例では、カーソル値を強制します。  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.ForceCursor" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">バインディングを取得するターゲット <see cref="T:System.Windows.DependencyProperty" />。</param>
        <summary>指定したプロパティでのバインディングを表す <see cref="T:System.Windows.Data.BindingExpression" /> を返します。</summary>
        <returns>ターゲット プロパティにアクティブなバインディングが設定されている場合は <see cref="T:System.Windows.Data.BindingExpression" />。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 戻り値の確認`null`はプロパティがアクティブなバインディングを持つかどうかを判断に使用できる手法です。  
  
 このメソッドは、実際には利便性のためのラッパー、<xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>メソッド。 <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> 現在のインスタンスを渡して、`dp`パラメーターを<xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.BindingOperations" />
      </Docs>
    </Member>
    <Member MemberName="GetFlowDirection">
      <MemberSignature Language="C#" Value="public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FlowDirection GetFlowDirection(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFlowDirection (element As DependencyObject) As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FlowDirection GetFlowDirection(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFlowDirection : System.Windows.DependencyObject -&gt; System.Windows.FlowDirection" Usage="System.Windows.FrameworkElement.GetFlowDirection element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="P:System.Windows.FrameworkElement.FlowDirection" /> を返す要素。</param>
        <summary>指定した <see cref="T:System.Windows.DependencyObject" /> の <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 添付プロパティの値を取得します。</summary>
        <returns>列挙体の値としての要求されたフローの方向。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの主な目的は、添付プロパティの構文をサポートするために、<xref:System.Windows.FrameworkElement.FlowDirection%2A>プロパティ、そのための指定された要素を子に許可<xref:System.Windows.FrameworkElement>それぞれの親要素内の配置のフロー方向を指定します。 現在の値を取得する<xref:System.Windows.FrameworkElement>、ダイレクトを使用して、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]アクセサー<xref:System.Windows.FrameworkElement.FlowDirection%2A>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberSignature Language="F#" Value="override this.GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry" Usage="frameworkElement.GetLayoutClip layoutSlotSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">ビジュアル プレゼンテーションを行う要素の部分のサイズ。</param>
        <summary>クリッピング マスクのジオメトリを返します。 クリッピング マスクは、利用可能な表示領域より大きな要素をレイアウト システムが配置しようとすると適用されます。</summary>
        <returns>クリッピング ジオメトリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 減算する余白、`layoutSlotSize`レイアウト システムの動作の一部として。  
  
 返される null 参照では、クリッピングが発生しないことを示します。 既定の実装を常に返します`null`とき<xref:System.Windows.UIElement.ClipToBounds%2A>は`false`します。 このメソッドは、<xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType> をオーバーライドします。 <xref:System.Windows.FrameworkElement>実装を使用して<xref:System.Windows.FrameworkElement.MaxHeight%2A>と<xref:System.Windows.FrameworkElement.MaxWidth%2A>計算を行います。 いくつかのサブクラスの<xref:System.Windows.FrameworkElement>もう一度このメソッドをオーバーライドします。 <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType>、戻り値を常にオーバーライド`null`装飾は通常の境界の外側多くの場合、意図的に、ためです。 <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType> <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType>返す`null`場合<xref:System.Windows.UIElement.ClipToBounds%2A>は`false`します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>既定の実装を常に返します<see langword="null" />とき<see cref="P:System.Windows.UIElement.ClipToBounds" />は<see langword="false" />します。 上書きをリレーションシップと派生クラスと基底クラスではなく、レイアウト ロジックの目的に応じて、例外もありますが、一般に、この動作を保持する必要があります。</para></block>
        <altmember cref="P:System.Windows.UIElement.Clip" />
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetTemplateChild">
      <MemberSignature Language="C#" Value="protected internal System.Windows.DependencyObject GetTemplateChild (string childName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetTemplateChild(string childName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetTemplateChild (childName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Windows::DependencyObject ^ GetTemplateChild(System::String ^ childName);" />
      <MemberSignature Language="F#" Value="member this.GetTemplateChild : string -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetTemplateChild childName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childName">検索する子の名前。</param>
        <summary>インスタンス化された <see cref="T:System.Windows.Controls.ControlTemplate" /> のビジュアル ツリー内にある名前付き要素を返します。</summary>
        <returns>要求された要素。 要求した名前の要素が存在しない場合は <see langword="null" /> になります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 テンプレートで[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]自己完結型の名前空間があります。 これは、テンプレートは再利用され、各コントロールの複数のインスタンスがそのテンプレートをインスタンス化時にテンプレートで定義されている任意の名前を一意におくことはできません。 呼び出す、<xref:System.Windows.FrameworkElement.GetTemplateChild%2A>をインスタンス化された後、テンプレートに由来するオブジェクトへの参照を返すメソッド。 使用することはできません、<xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType>ために、テンプレートから項目を検索するメソッド<xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType>スコープより一般的な機能し、の間の接続がない、<xref:System.Windows.Controls.ControlTemplate>適用された後、それ自体と、インスタンス化されたテンプレートのクラスします。  
  
 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> このメソッドと同じ機能を提供します。 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> 代わりにパブリックが保護されている、要素およびその中の項目をという名前を見つけ内で、テンプレートにアクセスできるように名前スコープの考慮事項は正しいを使用しています。 使用<xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType>親コントロールの外部で要素を取得する必要がある場合。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkTemplate.FindName(System.String,System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ビジュアル親が存在しない場合に、この要素に対する代替の論理上の親を返します。</summary>
        <returns>このメソッドの WPF フレームワーク レベルの実装が非ビジュアルの親接続を持つ場合は <see langword="null" /> 以外の値を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType> をオーバーライドします。 既定の<xref:System.Windows.FrameworkElement>実装で予想される 1 つのビジュアル親、これを取得すると同じ結果にが返されます、<xref:System.Windows.FrameworkElement.Parent%2A>値。 派生クラスの実装では、代替の親リレーションシップを返す可能性があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="frameworkElement.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">コレクション内の要求された子要素の 0 から始まるインデックス。</param>
        <summary><see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" /> をオーバーライドし、子要素のコレクションから指定したインデックス位置の子を返します。</summary>
        <returns>要求された子要素。 これは <see langword="null" /> を返しません。指定されたインデックスが範囲外の場合、例外がスローされます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement>実装、唯一の有効なインデックスは 0 です。 コンテンツ モデル<xref:System.Windows.FrameworkElement.GetVisualChild%2A>0 個または 1 つ子要素をコレクションではなくをサポートします。  
  
   
  
## Examples  
 次の例は、カスタム装飾で宣言されている値の使用方法を示しています、<xref:System.Windows.Media.VisualCollection>複数のビジュアル子を保持します。 これらの値がの上書きによって報告された<xref:System.Windows.FrameworkElement.VisualChildrenCount%2A>と<xref:System.Windows.FrameworkElement.GetVisualChild%2A>します。  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>この実装は、わかりやすい子ビジュアル要素のコレクションを保持しない要素のみです。 このようなコレクションが任意の要素は、このメソッドをオーバーライドし、その要素でサポートされている子要素のコレクションの同等のインデックスにインデックスをマップする必要があります。 0 の範囲内でインデックス<see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" />(マイナス 1) です。 有効な要素を返す必要があります、その他のインデックスが範囲外の例外をスローする必要があります。 子コレクションをサポートし、オーバーライドする要素型の例<see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />を 1 つ以上の使用可能な子を返すが<see cref="T:System.Windows.Controls.Panel" />します。  
  
既定の実装で<see cref="T:System.Windows.FrameworkElement" />ビジュアル子の 1 つだけを前提としています。 値を渡す<paramref name="index" />以外 0 原因がスローされる例外。 デコレーター、装飾、または特殊なレンダリングでは、要素など、いくつかの一般的な要素をオーバーライド、 <see cref="T:System.Windows.FrameworkElement" /> (中間の基本クラスから実装) の実装。 一部の実装は、コレクションが許可される他のユーザーがまだビジュアル子の 1 つを適用します。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public double Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Height : double with get, set" Usage="System.Windows.FrameworkElement.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の推奨される高さを取得または設定します。</summary>
        <value>要素の高さ ([!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 単位)。 既定値は <see cref="F:System.Double.NaN" /> です。 この値は 0.0 以上にする必要があります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Height%2A> 3 つの書き込み可能なプロパティの 1 つ<xref:System.Windows.FrameworkElement>高さ情報を指定します。 その他の 2 つは<xref:System.Windows.FrameworkElement.MinHeight%2A>と<xref:System.Windows.FrameworkElement.MaxHeight%2A>します。 間の競合がある場合これらの値、実際の高さを決定するためのアプリケーションの順序は最初<xref:System.Windows.FrameworkElement.MinHeight%2A>し、適用する必要があります<xref:System.Windows.FrameworkElement.MaxHeight%2A>、最後に、境界内にある場合<xref:System.Windows.FrameworkElement.Height%2A>します。  
  
 この要素が他の要素内の子要素の場合は、値にこのプロパティを設定し、本当にのみ推奨される値です。 親要素の特定のレイアウト ロジックと同様に、レイアウト システムは、値として使用非バインド入力レイアウト プロセス中にします。 実際を<xref:System.Windows.FrameworkElement>を設定する場合でも、他; の子要素で、ほとんどの場合、<xref:System.Windows.FrameworkElement.Height%2A>で<xref:System.Windows.Window>します。 (の<xref:System.Windows.Window>、基になるアプリケーション モデル、Hwnd を作成する基本的なレンダリングの前提条件を確立するときに、値を使用するアプリケーションをホストします)。  
  
 さらに許容される<xref:System.Double>値、このプロパティにすることができますも<xref:System.Double.NaN?displayProperty=nameWithType>します。 これは、コードの自動サイズ変更動作を指定する方法です。 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] "Auto"(大文字と小文字は区別されません)、自動サイズ変更動作を有効にする、文字列に値を設定します。 自動サイズ変更動作は、要素の高さは高さを使用することを意味します。 ただし、特定のコントロールがサイズ変更動作は具体的には、再度有効にしない限り、自動を無効にするには既定のテーマ スタイルによって既定値を頻繁に提供することに注意してください。  
  
 このプロパティの戻り値は、任意の値に設定されたのと同じでは常にします。 これに対しての値、<xref:System.Windows.FrameworkElement.ActualHeight%2A>異なる場合があります。 いずれかの静的になっていた、レイアウトは、何らかの理由で推奨されるサイズを拒否または一時的にします。 プロパティ システムの一連の基準とした、レイアウト システム自体が非同期的に動作<xref:System.Windows.FrameworkElement.Height%2A>が処理されていない特定のプロパティの変更をまだサイズ変更とします。  
  
 値の制限、<xref:System.Double>によって値が適用されます、<xref:System.Windows.ValidateValueCallback>メカニズム。 無効な値を設定しようとすると、実行時例外がスローされます。  
  
 非決定的の上限値のバインドがあるだけでなく、検証チェック<xref:System.Windows.FrameworkElement.Height%2A>レイアウト システムによって強制適用されるは (これは非常に大きい番号より大きい<xref:System.Single.MaxValue?displayProperty=nameWithType>よりも小さい<xref:System.Double.MaxValue?displayProperty=nameWithType>)。 この上限値を超過した場合、要素は表示されませんし、例外はスローされません。 設定しない<xref:System.Windows.FrameworkElement.Height%2A>の表示可能な最大サイズは、非決定的であるこの上限を超える可能性がありますよりも大幅に大きい値にします。  
  
<a name="xamlAttributeUsage_Height"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object Height="double"/>  
- or -  
<object Height="qualifiedDouble"/>  
- or -  
<object Height="Auto"/>  
```  
  
<a name="xamlValues_Height"></a>   
## <a name="xaml-values"></a>XAML 値  
 *double*  
 <xref:System.Double>  
  
 文字列表現を<xref:System.Double>0.0 以上の値。 上限については、「解説」を参照してください。 この値として解釈されます、[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]測定します。 文字列が必要な 10 進数のポイントを明示的に含まれません。 値のインスタンス`1`は許容されます。  
  
 *qualifiedDouble*  
 A*二重*値、上記と続く単位の次の宣言文字列のいずれか: `px`、 `in`、 `cm`、`pt`します。  
  
 `px` (既定値) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 in 96px = =  
  
 `cm` センチメートル; は、します。1cm==(96/2.54) px  
  
 `pt` ポイントです。1pt==(96/72) px  
  
 **Auto**  
 自動サイズ調整の動作を有効にします。 「解説」を参照してください。  
  
<a name="dependencyPropertyInfo_Height"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.HeightProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.ActualHeight" />
      </Docs>
    </Member>
    <Member MemberName="HeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.Height" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::HorizontalAlignment HorizontalAlignment { System::Windows::HorizontalAlignment get(); void set(System::Windows::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalAlignment : System.Windows.HorizontalAlignment with get, set" Usage="System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が、Panel またはアイテム コントロールのような親要素内に構成されるときに適用される水平方向の配置特性を取得または設定します。</summary>
        <value>列挙体の値としての水平方向の配置設定。 既定値は、<see cref="F:System.Windows.HorizontalAlignment.Stretch" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに<xref:System.Windows.FrameworkElement.Height%2A>と<xref:System.Windows.FrameworkElement.Width%2A>要素にプロパティが明示的に設定されている場合、これらの測定値はレイアウト時に高い優先設定の標準的な効果が取り消されます<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>に<xref:System.Windows.HorizontalAlignment.Stretch>します。  
  
 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]何が実際には、依存関係プロパティのプロパティ アクセサー。 この特定の依存関係プロパティでは、その見かけ上の「既定」値がコントロールでは特に、サブクラス化された要素で設定が異なりますがよくあります。 これは 2 つの方法のいずれかで一般的に発生します依存関係プロパティでは、特定のサブクラスでは、その既定値を設定するためのさまざまなメタデータが再登録。またはが適用されている既定のスタイルを異なる方法でその依存関係プロパティの値を設定します。 たとえば、明らかな「既定」の<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>の<xref:System.Windows.Controls.Label>コントロールである<xref:System.Windows.HorizontalAlignment.Left>場合でも、<xref:System.Windows.Controls.Label>継承<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>から直接<xref:System.Windows.FrameworkElement>。 これは、既定のスタイル内でその値がリセットされたため<xref:System.Windows.Controls.Label>スタイルのコントロール テンプレート内で。  
  
 <xref:System.Windows.Controls.Canvas> 使用しない<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>ため、レイアウトの作成時に<xref:System.Windows.Controls.Canvas>絶対位置に基づきます。  
  
 継承するときに<xref:System.Windows.Controls.Label>派生クラス、または<xref:System.Windows.Controls.Label>にするには、この依存関係プロパティの既定値を再定義<xref:System.Windows.HorizontalAlignment.Left>します。  
  
<a name="dependencyPropertyInfo_HorizontalAlignment"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HorizontalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.InheritanceBehavior InheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property InheritanceBehavior As InheritanceBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::InheritanceBehavior InheritanceBehavior { System::Windows::InheritanceBehavior get(); void set(System::Windows::InheritanceBehavior value); };" />
      <MemberSignature Language="F#" Value="member this.InheritanceBehavior : System.Windows.InheritanceBehavior with get, set" Usage="System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.InheritanceBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロパティ値の継承、リソース キーのルックアップ、および RelativeSource FindAncestor 検索のスコープの制限を取得または設定します。</summary>
        <value>列挙体の値。 既定値は、<see cref="F:System.Windows.InheritanceBehavior.Default" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定の境界で、要素ツリー セット<xref:System.Windows.FrameworkElement.InheritanceBehavior%2A>意図的に、アプリケーションのリソースを確認するか、RelativeSource FindAncestor 検索が現在の要素のクエリを実行するを防ぐために、force リソース参照を継承の動作のスコープを制限するにはまたは、さらにします。 RelativeSource FindAncestor 検索の場合は、バインドを使用して、<xref:System.Windows.Data.RelativeSource>を持つその<xref:System.Windows.Data.RelativeSource.Mode%2A>プロパティに設定、<xref:System.Windows.Data.RelativeSourceMode.FindAncestor?displayProperty=nameWithType>値。  
  
 派生クラスをこのプロパティを設定する場合は、する必要がありますこれを行う静的コンス トラクター内、またはその他の初期化ルーチンでします。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Frame" />
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Windows.FrameworkElement" /> が初期化されるときに発生します。 このイベントと同時に、<see cref="P:System.Windows.FrameworkElement.IsInitialized" /> プロパティの値が <see langword="false" /> (未定義) から <see langword="true" /> に変更されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントがあるときに発生します、<xref:System.Windows.FrameworkElement.EndInit%2A>または<xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A>メソッドが呼び出されます。 アプリケーション コード、またはいずれかのメソッドの呼び出しをものがありますが、[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]プロセッサの動作と、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]ページを処理します。  
  
 処理するために選択するかどうか<xref:System.Windows.FrameworkElement.Loaded>または<xref:System.Windows.FrameworkElement.Initialized>要件によって異なります。 要素のプロパティを読み取る必要がない場合、プロパティをリセットして、すべてのレイアウト情報は必要ありません<xref:System.Windows.FrameworkElement.Initialized>向上イベントの対象となる場合があります。 要素は、使用可能なすべてのプロパティが必要で、レイアウトをリセットする可能性のあるプロパティを設定する場合<xref:System.Windows.FrameworkElement.Loaded>向上イベントの対象となる場合があります。 ハンドラーは、新しいレイアウト パスが必要であることを意味するには、レイアウト システムで解釈される任意のプロパティをリセットした場合、再入に注意します。 (確認する必要があります、<xref:System.Windows.FrameworkPropertyMetadata>プロパティは、新しいレイアウトを要求できますの不明な場合は、プロパティの値が変更された場合に渡します)。  
  
 オブジェクトのイベントのシーケンスの詳細については、<xref:System.Windows.FrameworkElement>もいくつかの関連アプリケーションと要素のクラスは、表示と[オブジェクトの有効期間イベント](~/docs/framework/wpf/advanced/object-lifetime-events.md)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Windows.FrameworkElement" /> で使用される入力のコンテキストを取得または設定します。</summary>
        <value>代替の入力メソッドからの入力を解釈する方法を変更する入力スコープ。 既定値は <see langword="null" /> です (コマンドの既定の処理が行われます)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この依存関係プロパティは、プロパティの値を継承します。 その他の値を使用せずに子要素がある場合<xref:System.Windows.FrameworkElement.InputScope%2A>プロパティ システムは値を設定し、ローカルの値またはスタイル、を通じて確立、<xref:System.Windows.FrameworkElement.InputScope%2A>最も近い先祖の要素の値をこの値が割り当てられています。  
  
 ただし、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]構文の使用方法が表示されており、このプロパティの設定は許可されて構文的に[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]一般的ではありません。  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.InputScopeProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.InputScope" />
        <altmember cref="T:System.Windows.IInputElement" />
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.InputScope" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] プロセッサによって処理されている間、またはこの要素の <see cref="M:System.Windows.FrameworkElement.EndInit" /> メソッドが明示的に呼び出されたときに初期化されたかどうかを示す値を取得します。</summary>
        <value>前述の [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 処理やメソッド呼び出しごとに要素が初期化された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティがありますも`true`新しい親要素を持つし、そのために再読み込みされたことになるように、この要素が論理ツリー内で移動されたかどうか。  
  
 このプロパティにも使用している場合に便利ですが<xref:System.Windows.FrameworkElement.BeginInit%2A>と<xref:System.Windows.FrameworkElement.EndInit%2A>します。 によって読み込まれる論理ツリー内の要素を[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]プロセッサで保証を初期化します。 論理ツリーに存在しない要素が初期化されるときに<xref:System.Windows.FrameworkElement.EndInit%2A>が呼び出されます。 ない場合は、特定の処理の<xref:System.Windows.FrameworkElement.BeginInit%2A>と<xref:System.Windows.FrameworkElement.EndInit%2A>、これは、コンス トラクターが初期化された結果を返し、すぐに、発生します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が表示のために読み込まれているかどうかを示す値を取得します。</summary>
        <value>現在の要素が要素ツリーにアタッチされている場合は <see langword="true" />。読み込まれた要素ツリーに要素がアタッチされていない場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しく構築された<xref:System.Windows.FrameworkElement>、このプロパティは、まず`false`、開いたまま`true`に設定されている後`true`コードによって、接続されている論理ツリーから要素が、その後削除された場合でも、します。 `true` 状態は、要素が、プレゼンテーション エンジンに読み込まれるときに、一般的なプレゼンテーション ロジックによって設定されます。  
  
 通常、読み込まれた要素は、レンダリングされて、すべてではなく<xref:System.Windows.FrameworkElement>派生クラスは、プレゼンテーション、およびなどの他のプロパティがある<xref:System.Windows.UIElement.Visibility%2A>プレゼンテーションに影響を与えることができます。  
  
   
  
## Examples  
 次の例では、2 つのハンドラーの実装: いずれかの処理は、<xref:System.Windows.FrameworkElement.Loaded>が特定のイベントの重要性があるために、ページのルート要素が読み込まれているため、ルート要素のイベント。 ユーザー コントロールを呼び出し、その他のハンドラーがフックされている<xref:System.Windows.FrameworkElement.IsLoaded%2A>ルート要素を確認するためには、読み込まれた完全にします。 両方のハンドラーは、子要素に新しいデータを設定する (非表示) と同じ関数を呼び出します。  
  
 [!code-csharp[GroupBoxExample#FEIsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupBoxExample/CSharp/Page1.xaml.cs#feisloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素に適用されるローカライズ/グローバリゼーション言語情報を取得または設定します。</summary>
        <value>この要素の言語情報。 既定値は、<see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> 値が文字列 "en-US" に設定されている <see cref="T:System.Windows.Markup.XmlLanguage" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文字列の形式では、RFC 3066 標準に従います。 たとえば、米国"EN-US"は英語です。 値と形式の詳細については、次を参照してください。<xref:System.Windows.Markup.XmlLanguage>します。  
  
 この依存関係プロパティは、プロパティの値を継承します。 その他の値を使用せずに子要素がある場合<xref:System.Windows.FrameworkElement.Language%2A>ローカル値またはスタイルを通じて確立されると、プロパティ システムはある値を設定は、<xref:System.Windows.FrameworkElement.Language%2A>最も近い先祖の要素の値をこの値が割り当てられています。  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] 一般的な意味を定義、`xml:lang`属性。 <xref:System.Windows.FrameworkElement.Language%2A> 基本的に、依存関係プロパティとして、この属性の意味を公開します。 <xref:System.Windows.FrameworkElement.Language%2A> プログラムで調整することができ、プロパティに対応する方法でシステム値の継承に参加できますが、どのように`xml:lang`で子要素のスコープに継承される属性[!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]します。 設定した場合<xref:System.Windows.FrameworkElement.Language%2A>、その値が、`xml:lang`し、以前の値を上書きします。 詳細については、次を参照してください。 [xml:lang XAML 処理](~/docs/framework/xaml-services/xml-lang-handling-in-xaml.md)します。  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.LanguageProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.Language" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform LayoutTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform LayoutTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LayoutTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property LayoutTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ LayoutTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LayoutTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.FrameworkElement.LayoutTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウトの実行時にこの要素に適用するグラフィック変換を取得または設定します。</summary>
        <value>この要素で使用する変換。 既定値は、<see cref="P:System.Windows.Media.Transform.Identity" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 対照的に<xref:System.Windows.UIElement.RenderTransform%2A>、<xref:System.Windows.FrameworkElement.LayoutTransform%2A>レイアウトの結果に影響されます。  
  
 拡大縮小および回転の強力な機能を提供する変換を設定します。 ただし、<xref:System.Windows.FrameworkElement.LayoutTransform%2A>無視<xref:System.Windows.Media.TranslateTransform>操作。 これは、ため、レイアウト システムの動作の子要素に対する、<xref:System.Windows.FrameworkElement>任意のオフセットがレイアウトにスケールまたは回転した要素の位置と親要素の座標システムへの自動修正します。  
  
 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> レイアウト システムによるフル パスを必要としないシナリオで起動する場合アプリケーション パフォーマンスの低下につながります。 適用すると、<xref:System.Windows.FrameworkElement.LayoutTransform%2A>を<xref:System.Windows.Controls.Panel.Children%2A>のコレクション、<xref:System.Windows.Controls.Panel>により再配置をすべて画面に表示されるオブジェクトを強制的に、レイアウト システムによる新しいパスをトリガーします。 完全なアプリケーションを更新する場合は[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]、この機能は必要がある正確にすることがあります。 ただし場合は、完全なレイアウト パスを使用する必要はありませんを使用して、<xref:System.Windows.UIElement.RenderTransform%2A>プロパティが、レイアウト システムは呼び出しません。 そのため、このシナリオの方が適切では通常します。  
  
 シナリオ例を<xref:System.Windows.FrameworkElement.LayoutTransform%2A>役に立つが含まれます: フォーカス、編集の動作などを提供することでスケールを要素 (拡大) から水平方向を垂直方向、またはその逆の場合は、メニュー コンポーネントなどの要素を回転します。  
  
<a name="dependencyPropertyInfo_LayoutTransform"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 次の例では、適用する方法を示しています、<xref:System.Windows.FrameworkElement.LayoutTransform%2A>要素にします。 インスタンスを作成する例では、<xref:System.Windows.Controls.Button>し、親ホスト<xref:System.Windows.Controls.Grid>します。 また、使用、<xref:System.Windows.FrameworkElement.LayoutTransform%2A>を適用するプロパティを<xref:System.Windows.Media.RotateTransform>を<xref:System.Windows.Controls.Button>。  
  
 [!code-cpp[LayoutTransform#1](~/samples/snippets/cpp/VS_Snippets_Wpf/LayoutTransform/CPP/LayoutTransform.cpp#1)]
 [!code-csharp[LayoutTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LayoutTransform/CSharp/LayoutTransform.cs#1)]
 [!code-vb[LayoutTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LayoutTransform/VisualBasic/LayoutTransform.vb#1)]
 [!code-xaml[LayoutTransform#1](~/samples/snippets/xaml/VS_Snippets_Wpf/LayoutTransform/XAML/default.xaml#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=158252">2-d 変換のサンプル</related>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LayoutTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LayoutTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LayoutTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LayoutTransformProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LayoutTransformProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.LayoutTransform" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素のレイアウトやレンダリングが完了し、操作を受け入れる準備が整ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Loaded> 通常は最後のイベントで発生します要素の初期化シーケンス。 常に後に発生する<xref:System.Windows.FrameworkElement.Initialized>します。 処理するために選択するかどうか<xref:System.Windows.FrameworkElement.Loaded>または<xref:System.Windows.FrameworkElement.Initialized>要件によって異なります。 要素のプロパティを読み取る必要がない場合、プロパティをリセットして、すべてのレイアウト情報は必要ありません<xref:System.Windows.FrameworkElement.Initialized>向上イベントの対象となる場合があります。 要素は、使用可能なすべてのプロパティが必要で、レイアウトをリセットする可能性のあるプロパティを設定する場合<xref:System.Windows.FrameworkElement.Loaded>向上イベントの対象となる場合があります。 ハンドラーは、新しいレイアウト パスが必要であることを意味するには、レイアウト システムで解釈される任意のプロパティをリセットした場合、再入に注意します。 (確認する必要があります、<xref:System.Windows.FrameworkPropertyMetadata>プロパティは、新しいレイアウトを要求できますの不明な場合は、プロパティの値が変更された場合に渡します)。  
  
 オブジェクトのイベントのシーケンスの詳細については、<xref:System.Windows.FrameworkElement>もいくつかの関連アプリケーションと要素のクラスは、表示と[オブジェクトの有効期間イベント](~/docs/framework/wpf/advanced/object-lifetime-events.md)します。  
  
 直接ルーティング イベントがルートに従っていない、発生しますが、同じ要素内でのみ処理されます。 直接ルーティング イベントは、その他のルーティング イベントの動作をサポートして: アクセスできるハンドラーのコレクションをサポートし、として使用できる、<xref:System.Windows.EventTrigger>スタイル。  
  
 <xref:System.Windows.FrameworkElement.Loaded> <xref:System.Windows.FrameworkElement.Unloaded>両方ユーザーによるシステムのテーマを変更した結果のコントロールで発生する可能性があります。 テーマの変更により、コントロール テンプレートと、コントロール全体をアンロードして再読み込みが含まれているビジュアル ツリーの無効化します。 そのため<xref:System.Windows.FrameworkElement.Loaded>のみページが最初に読み込まれるときに、ページへの移動を発生すると想定することはできません。  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.LoadedEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkElement.Loaded" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の論理上の子要素に対する列挙子を取得します。</summary>
        <value>この要素の論理上の子要素に対する列挙子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> 子要素を反復処理することができます。 これは可能性があります、定義された専用のコレクションはありませんが、まだ特に 1 つ以上の子要素が含まれている要素に役立ちます<xref:System.Windows.FrameworkContentElement>子要素。  
  
 使用する方法の詳細についての<xref:System.Windows.FrameworkElement.LogicalChildren%2A>と<xref:System.Windows.FrameworkElement.AddLogicalChild%2A>を参照してください[WPF のツリー](~/docs/framework/wpf/advanced/trees-in-wpf.md)します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c5358e14-d24c-44c7-b5eb-6062a4fd981c">x:Array のマークアップ拡張機能</related>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Thickness with get, set" Usage="System.Windows.FrameworkElement.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の外側の余白を取得または設定します。</summary>
        <value>要素の余白の値を提供します。 既定値は、すべてのプロパティが 0 (ゼロ) の <see cref="T:System.Windows.Thickness" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 余白は、この要素とレイアウトを作成するときに、隣接するその他の要素間のスペース、[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]します。 共有要素は、ピア要素 (など、他の要素に共通の親コントロールのコレクション) があります。 または、この要素の親の場合もあります。  
  
 <xref:System.Windows.FrameworkElement.Margin%2A> として設定されて、<xref:System.Windows.Thickness>構造ではなく数値としてマージンを非対称的設定できるようにします。 <xref:System.Windows.Thickness>構造体自体には文字列型の変換がサポートされているため、非対称を指定できます<xref:System.Windows.FrameworkElement.Margin%2A>で[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]属性構文もします。  
  
 0 以外の余白は要素のレイアウトの<xref:System.Windows.FrameworkElement.ActualWidth%2A>と<xref:System.Windows.FrameworkElement.ActualHeight%2A>します。  
  
 余白は、レイアウトの兄弟要素の追加たとえば、2 つの隣接する要素が隣接する端に余白 30 をどちらも設定では、60 のユニットの間にスペースがあります。  
  
 余白の設定を持つ要素を通常の指定したサイズ制約しない<xref:System.Windows.FrameworkElement.Margin%2A>割り当てられた四角形領域が十分な大きさの余白と要素のコンテンツ領域でないかどうか。 要素のコンテンツ領域は、レイアウトの計算時に、代わりに制限されます。 コンテンツが既に 0 に制約されていますもは余白が制限される場合だけです。  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object Margin="left,top,right,bottom"/>  
- or -  
<object Margin="left,top"/>  
- or -  
<object Margin="thicknessReference"/>  
```  
  
<a name="xamlPropertyElementUsage_Margin"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
```  
<object>  
  <object.Margin>  
    <Thickness Left="left" Top="top" Right="right" Bottom="bottom"/>  
  </object.Margin>  
</object>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>XAML 値  
 *左、上、右、下*  
 番号を 0 までの値と<xref:System.Double.PositiveInfinity>の 4 つの考えられるディメンション プロパティを指定する、<xref:System.Windows.Thickness>構造体。  
  
 属性の使用法も指定すると、対称的および論理的な順序で適用される省略形の値を受け取ります。 たとえば、`Margin="20"`として解釈する、<xref:System.Windows.Thickness>すべてのプロパティを 20 に設定します。 `Margin="20,50"` として解釈する、<xref:System.Windows.Thickness>で<xref:System.Windows.Thickness.Left%2A>と<xref:System.Windows.Thickness.Right%2A>を 20 に設定し、<xref:System.Windows.Thickness.Top%2A>と<xref:System.Windows.Thickness.Bottom%2A>50 に設定します。  
  
 既定の単位を<xref:System.Windows.Thickness>メジャーが[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]します。 単位の種類の文字列を追加して、他の単位を指定することも`cm`、 `in`、または`pt`測定値にします。  
  
 数値として指定された[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]属性は、10 進数のポイントを指定しない必要があります (0 は、0.0 として指定する必要はありません)。 詳細については[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]使用状況を参照してください<xref:System.Windows.Thickness>します。  
  
 *thicknessReference*  
 既存のオブジェクト参照<xref:System.Windows.Thickness>します。 これは、可能性があります、 `}`、a、または`}`参照。 詳細については[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]使用状況を参照してください<xref:System.Windows.Thickness>します。  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.MarginProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Thickness" />
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MarginProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.Margin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeight">
      <MemberSignature Language="C#" Value="public double MaxHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxHeight : double with get, set" Usage="System.Windows.FrameworkElement.MaxHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の高さの最大値を取得または設定します。</summary>
        <value>要素の最大高 ([!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 単位)。 既定値は <see cref="F:System.Double.PositiveInfinity" /> です。 この値は、0.0 以上の任意の値を指定できます。 <see cref="F:System.Double.PositiveInfinity" /> も有効です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これで 3 つのプロパティの 1 つは<xref:System.Windows.FrameworkElement>高さ情報を指定します。 その他の 2 つは<xref:System.Windows.FrameworkElement.MinHeight%2A>と<xref:System.Windows.FrameworkElement.Height%2A>します。  これらの値の間に競合がある場合は、実際の高さを決定するためのアプリケーションの順序は最初<xref:System.Windows.FrameworkElement.MinHeight%2A>し、適用する必要があります<xref:System.Windows.FrameworkElement.MaxHeight%2A>、最後に、境界内にある場合これらの各<xref:System.Windows.FrameworkElement.Height%2A>します。  
  
 値の制限、<xref:System.Double>によって値が適用されます、<xref:System.Windows.ValidateValueCallback>メカニズム。 無効な値を設定しようとした場合、実行時に例外がスローされます。  
  
<a name="xamlAttributeUsage_MaxHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object MaxHeight="double"/>  
- or -  
<object MaxHeight ="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxHeight"></a>   
## <a name="xaml-values"></a>XAML 値  
 *double*  
 <xref:System.Double>  
  
 文字列表現を<xref:System.Double>0.0 以上の値。 これは、[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]測定します。 文字列が必要な 10 進数のポイントを明示的に含まれません。 値のインスタンス`1`は許容されます。  
  
 同じ<xref:System.Double>プロパティの値のセクションで説明したように範囲の制約を適用する点を除いて、使用する必要があります[X:static マークアップ拡張機能](~/docs/framework/xaml-services/x-static-markup-extension.md)かどうかは、明示的に値を設定する必要があります。<xref:System.Double.PositiveInfinity>します。  
  
 *qualifiedDouble*  
 A*二重*値、上記と続く単位の次の宣言文字列のいずれか: `px`、 `in`、 `cm`、`pt`します。  
  
 `px` (既定値) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 in 96px = =  
  
 `cm` センチメートル; は、します。1cm==(96/2.54) px  
  
 `pt` ポイントです。1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MaxHeight"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.MaxHeight" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidth">
      <MemberSignature Language="C#" Value="public double MaxWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWidth : double with get, set" Usage="System.Windows.FrameworkElement.MaxWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の幅の最大値を取得または設定します。</summary>
        <value>要素の最大の幅 ([!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 単位)。 既定値は <see cref="F:System.Double.PositiveInfinity" /> です。 この値は、0.0 以上の任意の値を指定できます。 <see cref="F:System.Double.PositiveInfinity" /> も有効です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これで 3 つのプロパティの 1 つは<xref:System.Windows.FrameworkElement>幅情報を指定します。 その他の 2 つは<xref:System.Windows.FrameworkElement.MinWidth%2A>と<xref:System.Windows.FrameworkElement.Width%2A>します。 これらの値の間に競合がある場合は、実際の幅を決定するためのアプリケーションの順序は最初<xref:System.Windows.FrameworkElement.MinWidth%2A>し、適用する必要があります<xref:System.Windows.FrameworkElement.MaxWidth%2A>、最後に、境界内にある場合これらの各<xref:System.Windows.FrameworkElement.Width%2A>します。  
  
 値の制限、<xref:System.Double>によって値が適用されます、<xref:System.Windows.ValidateValueCallback>メカニズム。 無効な値を設定しようとすると、実行時例外がスローされます。  
  
<a name="xamlAttributeUsage_MaxWidth"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object MaxWidth="double"/>  
- or -  
<object MaxWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxWidth"></a>   
## <a name="xaml-values"></a>XAML 値  
 *double*  
 <xref:System.Double>  
  
 文字列表現を<xref:System.Double>0.0 以上の値。 これは、[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]測定します。 文字列が必要な 10 進数のポイントを明示的に含まれません。 値のインスタンス`1`は許容されます。  
  
 同じ<xref:System.Double>プロパティの値のセクションで説明したように範囲の制約を適用する点を除いて、使用する必要があります[X:static マークアップ拡張機能](~/docs/framework/xaml-services/x-static-markup-extension.md)値に設定する<xref:System.Double.PositiveInfinity>します。  
  
 *qualifiedDouble*  
 A*二重*値、上記と続く単位の次の宣言文字列のいずれか: `px`、 `in`、 `cm`、`pt`します。  
  
 `px` (既定値) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 in 96px = =  
  
 `cm` センチメートル; は、します。1cm==(96/2.54) px  
  
 `pt` ポイントです。1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MaxWidth"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.MaxWidth" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureCore : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureCore availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">親要素が子要素に与えることが利用可能なサイズ。</param>
        <summary><see cref="T:System.Windows.FrameworkElement" /> の測定パス レイアウト システムの基本動作を実装します。</summary>
        <returns>レイアウト内のこの要素の必要なサイズ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは<xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>WPF コア レベルと WPF フレームワーク レベルのレイアウトの測定の実装に接続します。 <xref:System.Windows.FrameworkElement>封印し、メソッドを実装します。 WPF フレームワーク レベル上に構築される要素の測定パス レイアウト動作を調整するのには、オーバーライド<xref:System.Windows.FrameworkElement.MeasureOverride%2A>代わりにします。 測定パスを意図的に WPF フレームワーク レベル上に構築を使用して、要素のレイアウト動作を調整する<xref:System.Windows.FrameworkElement>、オーバーライド<xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="abstract member MeasureOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">この要素が子要素に提供できる使用可能なサイズ。 あらゆるコンテンツに要素がサイズを合わせることを示す値として、無限大を指定できます。</param>
        <summary>派生クラスでオーバーライドされると、子要素に必要なレイアウトのサイズを測定し、<see cref="T:System.Windows.FrameworkElement" /> 派生クラスのサイズを決定します。</summary>
        <returns>子要素のサイズの計算に基づいて、この要素が判断したレイアウト時に必要なサイズ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オーバーライド<xref:System.Windows.FrameworkElement.MeasureOverride%2A>に含まれているように、要素のカスタム レイアウトのサイズ変更動作を実装するために、[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]レイアウト システム。 実装は、次の操作を行います。  
  
1.  レイアウト、呼び出しの一部である子の要素の特定のコレクションを反復処理<xref:System.Windows.UIElement.Measure%2A>で各子要素。  
  
2.  すぐに<xref:System.Windows.UIElement.DesiredSize%2A>子 (後のプロパティが設定されて<xref:System.Windows.UIElement.Measure%2A>と呼びます)。  
  
3.  子要素の測定に基づいて、親の net 目的のサイズを計算します。  
  
 戻り値<xref:System.Windows.FrameworkElement.MeasureOverride%2A>メジャーの現在の要素の親要素の入力となる要素自体の必要なサイズにする必要があります。 ページのルート要素に到達するまでは、レイアウト システムでこの同じプロセスが続行されます。  
  
 このプロセス中には、子要素をより大きなに返す可能性があります<xref:System.Windows.UIElement.DesiredSize%2A>最初よりもサイズ`availableSize`を子要素がより多くの領域を必要があることを示します。 これは、何らかのスタック順序、または任意の数を測定するか、コンテンツの配置のソリューションの確立することによって、親コントロールのサイズを変更して、スクロール可能なリージョンを導入することで、独自の実装で処理可能性があります。  
  
> [!IMPORTANT]
>  要素で呼び出す必要があります<xref:System.Windows.UIElement.Measure%2A>でこのプロセス中にそれぞれの子では、それ以外の場合、子要素正しくサイズまたはされません配置されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>次のコンパイルされていないコードは、この実装パターンを示しています。  <c>VisualChildren</c>独自の要素を定義する子の列挙可能なコレクションのプロパティを表します。 プロパティは、何かということができます。 <c>VisualChildren</c>目的で、この例のプレース ホルダー名は、 <c>VisualChildren</c>でない、[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]によって提供される[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]または名前付けパターンの一部です。 
  
[!code-csharp[CorePseudocode#FEMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#femeasureoverride)] [!code-vb[CorePseudocode#FEMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#femeasureoverride)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="MinHeight">
      <MemberSignature Language="C#" Value="public double MinHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MinHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinHeight : double with get, set" Usage="System.Windows.FrameworkElement.MinHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の高さの最小値を取得または設定します。</summary>
        <value>要素の高さの最小値 ([!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 単位)。 既定値は 0.0 です。 この値は、0.0 以上の任意の値を指定できます。 ただし、<see cref="F:System.Double.PositiveInfinity" /> は有効でなく、<see cref="F:System.Double.NaN" /> も有効ではありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これで 3 つのプロパティの 1 つは<xref:System.Windows.FrameworkElement>高さ情報を指定します。  その他の 2 つは<xref:System.Windows.FrameworkElement.Height%2A>と<xref:System.Windows.FrameworkElement.MaxHeight%2A>します。 これらの値の間に競合がある場合は、実際の高さを決定するためのアプリケーションの順序は最初<xref:System.Windows.FrameworkElement.MinHeight%2A>し、適用する必要があります<xref:System.Windows.FrameworkElement.MaxHeight%2A>、最後に、境界内にある場合これらの各<xref:System.Windows.FrameworkElement.Height%2A>します。  
  
 値の制限、<xref:System.Double>によって値が適用されます、<xref:System.Windows.ValidateValueCallback>メカニズム。 無効な値を設定しようとすると、実行時例外がスローされます。  
  
<a name="xamlAttributeUsage_MinHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object MinHeight="double"/>  
- or -  
<object MinHeight="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinHeight"></a>   
## <a name="xaml-values"></a>XAML 値  
 *double*  
 <xref:System.Double>  
  
 文字列表現を<xref:System.Double>0.0 以上の値。 これは、[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]測定します。 文字列が必要な 10 進数のポイントを明示的に含まれません。 値のインスタンス`1`は許容されます。  
  
 同じ<xref:System.Double>プロパティの値のセクションで説明したように範囲の制限が適用されます。  
  
 *qualifiedDouble*  
 A*二重*値、上記と続く単位の次の宣言文字列のいずれか: `px`、 `in`、 `cm`、`pt`します。  
  
 `px` (既定値) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 in 96px = =  
  
 `cm` センチメートル; は、します。1cm==(96/2.54) px  
  
 `pt` ポイントです。1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MinHeight"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.MinHeightProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.MinHeight" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidth">
      <MemberSignature Language="C#" Value="public double MinWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinWidth : double with get, set" Usage="System.Windows.FrameworkElement.MinWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の幅の最小値を取得または設定します。</summary>
        <value>要素の幅の最小値 ([!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 単位)。 既定値は 0.0 です。 この値は、0.0 以上の任意の値を指定できます。 ただし、<see cref="F:System.Double.PositiveInfinity" /> と <see cref="F:System.Double.NaN" /> は無効です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これで 3 つのプロパティの 1 つは<xref:System.Windows.FrameworkElement>幅情報を指定します。  その他の 2 つは<xref:System.Windows.FrameworkElement.Width%2A>と<xref:System.Windows.FrameworkElement.MaxWidth%2A>します。  これらの値の間に競合がある場合は、実際の幅を決定するためのアプリケーションの順序は最初<xref:System.Windows.FrameworkElement.MinWidth%2A>し、適用する必要があります<xref:System.Windows.FrameworkElement.MaxWidth%2A>、最後に、境界内にある場合これらの各<xref:System.Windows.FrameworkElement.Width%2A>します。  
  
 値の制限、<xref:System.Double>によって値が適用されます、<xref:System.Windows.ValidateValueCallback>メカニズム。 無効な値を設定しようとすると、実行時例外がスローされます。  
  
<a name="xamlAttributeUsage_MinWidth"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object MinWidth="double"/>  
- or -  
<object MinWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>XAML 値  
 *double*  
 <xref:System.Double>  
  
 文字列表現を<xref:System.Double>0.0 以上の値。 これは、[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]測定します。 文字列が必要な 10 進数のポイントを明示的に含まれません。 値のインスタンス`1`は許容されます。  
  
 同じ<xref:System.Double>プロパティの値のセクションで説明したように範囲の制限が適用されます。  
  
 *qualifiedDouble*  
 A*二重*値、上記と続く単位の次の宣言文字列のいずれか: `px`、 `in`、 `cm`、`pt`します。  
  
 `px` (既定値) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 in 96px = =  
  
 `cm` センチメートル; は、します。1cm==(96/2.54) px  
  
 `pt` ポイントです。1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MinWidth"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.MinWidthProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.MinWidth" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">フォーカスの移動方向を表す列挙値。</param>
        <summary>指定した移動方向の別の要素にこの要素からキーボード フォーカスを移動します。</summary>
        <returns>フォーカスの移動が成功した場合は <see langword="true" /> が返されます。指定した方向にターゲット要素が存在しない場合や、ターゲット要素にキーボード フォーカスを設定できなかった場合は、<see langword="false" /> が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この実装をオーバーライド<xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType>メソッドをシールするとします。  
  
   
  
## Examples  
 次の例では、いくつかのボタン入力を処理するハンドラーを実装します。 各ボタンは、可能な限り<xref:System.Windows.Input.FocusNavigationDirection>します。 ハンドラーは、要素を現在のキーボード フォーカスと呼び出しを追跡<xref:System.Windows.FrameworkElement.MoveFocus%2A>、適切なを指定して、その要素に<xref:System.Windows.Input.FocusNavigationDirection>の初期化として、<xref:System.Windows.Input.TraversalRequest>指定されたパラメーターを入力します。  
  
 [!code-csharp[FocusSample#FocusSampleMoveFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplemovefocus)]
 [!code-vb[FocusSample#FocusSampleMoveFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplemovefocus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions(System.Windows.Markup.DesignerSerializationOptions.SerializeAsAttribute)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の識別名を取得または設定します。 この名前は参照を提供するため、イベント ハンドラー コードなどの分離コードは、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] プロセッサによる処理の際に、構築された後のマークアップ要素を参照できます。</summary>
        <value>要素の名前。 既定値は空の文字列です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの最も一般的な使用方法を指定するは、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]マークアップ内の属性と要素名。  
  
 このプロパティでは、WPF フレームワーク レベルの便利なプロパティを設定する基本的にでは、 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [X:name ディレクティブ](~/docs/framework/xaml-services/x-name-directive.md)します。  
  
 名前は、名前スコープ内で一意である必要があります。 詳細については、次を参照してください。 [WPF XAML 名前スコープ](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)します。  
  
 取得、<xref:System.Windows.FrameworkElement.Name%2A>内の要素を作成する場合のコードは一般的ではありません。 メソッドを呼び出すだけで済みます既に適切な参照をコードである場合と、要素のプロパティを参照し、一般的に必要ではない、<xref:System.Windows.FrameworkElement.Name%2A>します。 この例外は場合、<xref:System.Windows.FrameworkElement.Name%2A>文字列は、オーバー ロードされたに意味を持ちますでその名前を表示すると便利な場合[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]します。 設定、<xref:System.Windows.FrameworkElement.Name%2A>分離コードから場合元<xref:System.Windows.FrameworkElement.Name%2A>マークアップから設定されたがしないでも、読み込み後、プロパティを変更する、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]元のオブジェクト参照は変更されません。 基になる名前スコープが解析中に明示的に作成された場合にのみ、オブジェクト参照が作成されます。 具体的には呼び出す必要がある<xref:System.Windows.FrameworkElement.RegisterName%2A>を効果的に変更する、<xref:System.Windows.FrameworkElement.Name%2A>既に読み込まれた要素のプロパティ。  
  
 1 つの重要な設定がの場合<xref:System.Windows.FrameworkElement.Name%2A>コードからは重要なは、実行時に参照できるように、に対してはストーリー ボード要素の実行に名前を登録する場合。 名前を登録する前にインスタンス化を割り当てる必要がありますも、<xref:System.Windows.NameScope>インスタンス。 例のセクションを参照または[ストーリー ボードの概要](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)します。  
  
 設定<xref:System.Windows.FrameworkElement.Name%2A>コードからは制限されていますが、アプリケーションして要素を取得する<xref:System.Windows.FrameworkElement.Name%2A>方が一般的です。 1 つのシナリオでは、アプリケーションが、アプリケーションにページが再読み込みして、必ずしもそのページに対して定義されている分離コードが実行時のコードではありません場所は、ナビゲーション モデルをサポートするかどうかです。 ユーティリティ メソッド<xref:System.Windows.FrameworkElement.FindName%2A>、いずれかから利用できる<xref:System.Windows.FrameworkElement>で要素を検索できます<xref:System.Windows.FrameworkElement.Name%2A>その要素の論理ツリーで、必要に応じて、ツリーを再帰的を検索します。 使用することができます、<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>の静的メソッド<xref:System.Windows.LogicalTreeHelper>、により、<xref:System.Windows.FrameworkElement.Name%2A>を引数として文字列。  
  
 通常使用されるルート要素 (<xref:System.Windows.Window>、<xref:System.Windows.Controls.Page>など)、インターフェイスを実装して<xref:System.Windows.Markup.INameScope>します。 このインターフェイスの実装は、名は、スコープ内で明確であることを強制する必要があります。 このインターフェイスを定義するルート要素は、すべての名前スコープの動作の境界を定義することも、関連する[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]します。  
  
 <xref:System.Windows.FrameworkElement.Name%2A>プロパティは、他のプロセスの識別子としても機能します。 たとえば、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]オートメーション モデルを使用して<xref:System.Windows.FrameworkElement.Name%2A>クライアントとプロバイダーの AutomationId として。  
  
 使用する文字列値<xref:System.Windows.FrameworkElement.Name%2A>によって、基になるいくつかの制限がある[X:name ディレクティブ](~/docs/framework/xaml-services/x-name-directive.md)によって定義された、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]仕様。 最も注目に値する、<xref:System.Windows.FrameworkElement.Name%2A>文字またはアンダー スコア文字 (_) で始める必要があるあり、文字、数字、またはアンダー スコアのみを含める必要があります。 詳細については、次を参照してください。 [WPF XAML 名前スコープ](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)します。  
  
 <xref:System.Windows.FrameworkElement.Name%2A> アニメーション化することはできません非常にいくつかの依存関係プロパティの 1 つです (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>は`true`メタデータで) 名自体は、アニメーションを対象とするために不可欠であるためです。 データ バインディング、<xref:System.Windows.FrameworkElement.Name%2A>は技術的に可能ですが、ため、非常に一般的ではないシナリオは、データ バインド<xref:System.Windows.FrameworkElement.Name%2A>プロパティの主な目的を提供することはできません。 分離コードの識別子の接続ポイントを提供します。  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.NameProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
   
  
## Examples  
 次の例のセット、<xref:System.Windows.FrameworkElement.Name%2A>プロパティをコードで、名前に、新しく作成し、登録と<xref:System.Windows.NameScope>呼び出して<xref:System.Windows.FrameworkElement.RegisterName%2A>します。 ストーリー ボードは、対象を設定する必要があるために、ここで示した手法は、ストーリー ボードでアニメーション化するための要件、 <xref:System.Windows.FrameworkElement.Name%2A>、し、オブジェクト参照の対象となることはできません。  
  
 [!code-csharp[animateHeight_procedural#FEName](~/samples/snippets/csharp/VS_Snippets_Wpf/animateHeight_procedural/CSharp/AnimatedHeightExample.cs#fename)]
 [!code-vb[animateHeight_procedural#FEName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateHeight_procedural/visualbasic/animatedheightexample.vb#fename)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.Name" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public virtual void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="abstract member OnApplyTemplate : unit -&gt; unit&#xA;override this.OnApplyTemplate : unit -&gt; unit" Usage="frameworkElement.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされると、アプリケーション コードまたは内部プロセスが <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" /> を呼び出すたびに呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。  
  
 テンプレートの Template プロパティから取得された要素の完成したビジュアル ツリーのセクションを<xref:System.Windows.Style>要素に適用されています。 詳しくは、「 [スタイルとテンプレート](~/docs/framework/wpf/controls/styling-and-templating.md)」をご覧ください。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスの<see cref="T:System.Windows.FrameworkElement" />可能性のあるシナリオのさまざまな通知としてこのメソッドを使用できます。 
-要素のビジュアル ツリーの残りの部分をビルドするコードの独自の実装を呼び出すことができます。  
  
-テンプレートのテンプレートの取得元の名前付きの要素への参照を取得するなど、適用されたことから、ビジュアル ツリーに依存するコードを実行できます。  
  
-テンプレートのビジュアル ツリーが完了した後にのみ意味のあるサービスを導入できます。  
  
-は、状態とその他の要因に依存するテンプレート内の要素のプロパティを設定できます。 たとえば、プロパティの値のみがあります探索可能な親要素を理解することでまたはクラスが共通のテンプレートを使用して、特定の派生します。  
  
実装者は、独自の実装前に基本の実装を常に呼び出す必要があります。 <see cref="T:System.Windows.FrameworkElement" /> 既定値を持たない自体の実装が介在するクラスがあります。  
  
 <see cref="T:System.Windows.Controls.Control" /> ようなオーバーライドでは、<see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />します。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理の <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> ルーティング イベントが、その経路上でこのクラスに到達するたびに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスがこのメソッドを実装している場合は、基本実装を呼び出す必要があります。  
  
 このメソッドの目的は、類似した[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: 一致する、インスタンス ハンドラーではなく、クラス ハンドラーで、派生クラスからイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンはルーティング イベントのさまざまなルーティング イベントをハンドラー イベント引数のソースを実行する必要があります、実装を呼び出すは必ずしもの要素の子要素で発生する可能性があります。アカウントにプロパティ (および再ほとんどの場合、イベントを発生しないでください)。 サブクラス<xref:System.Windows.FrameworkElement>にイベントが経路上に受信したときに、プライベート クラス ハンドラー メソッドを呼び出すこともできます。 イベントの引数を受け取り、処理済みとして意図的にイベントをマークする 1 つの潜在的なシナリオです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> ルーティング イベントが、その経路上でこのクラスに到達するたびに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスがこのメソッドを実装している場合は、基本実装を呼び出す必要があります。  
  
 このメソッドの目的は、類似した[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: 一致する、インスタンス ハンドラーではなく、クラス ハンドラーで、派生クラスからイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンはルーティング イベントのさまざまなルーティング イベントをハンドラー イベント引数のソースを実行する必要があります、実装を呼び出すは必ずしもの要素の子要素で発生する可能性があります。アカウントにプロパティ (および再ほとんどの場合、イベントを発生しないでください)。 サブクラス<xref:System.Windows.FrameworkElement>にイベントが経路上に受信したときに、プライベート クラス ハンドラー メソッドを呼び出すこともできます。 イベントの引数を受け取り、処理済みとして意図的にイベントをマークする 1 つの潜在的なシナリオです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.GotFocus" /> イベントが、その経路上でこの要素に到達するたびに呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 その他とは異なり * ベースの要素によって公開されるメソッド<xref:System.Windows.FrameworkElement.OnGotFocus%2A>が既定の実装。 具体的には、ダウンしている基本要素の次のレベルで null の実装をオーバーライドする実装が<xref:System.Windows.UIElement.OnGotFocus%2A>します。 呼び出されると、<xref:System.Windows.FrameworkElement.OnGotFocus%2A>がキーボード フォーカスのため、現在の要素から、イベントが発生した場合は、この要素に適切なフォーカスの動作を設定します。 <xref:System.Windows.FrameworkElement.OnGotFocus%2A>ハンドラーにイベント引数を現在の要素にフォーカスが設定時にも、処理済みとしてマークされません。 イベントのソースで別の要素ツリー (現在の要素ではなく) であった場合、ハンドラーは何も行いません。  
  
 要素のフォーカスの既定の動作の変更が、この方法でフォーカスの動作を変更する向上を実現する要素にすべてのフォーカスを許可しないことによって、このメソッドをオーバーライドすることができます (を参照してください<xref:System.Windows.UIElement.Focusable%2A>)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>引数で処理されるイベントをマークする場合は、要素ツリー内の他の親要素でのイベント処理に与える影響があります。 このハンドラーは、バブル ルーティング イベントに動作するため、現在、フォーカスの設定<paramref name="sender" />イベントあたり引数適さない場合があります。 フォーカスがや特定のコントロールの複合に応じての親要素、複合の子要素のいずれかに移動する必要があります。 イベントがルーティングするビジュアル ツリーの全体が作成したコントロールの複合の一部である場合処理済みとしてそのため、フォーカス イベントをマークすることをお勧めのみです。</para></block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary><see cref="E:System.Windows.FrameworkElement.Initialized" /> イベントを発生させます。 このメソッドは、<see cref="P:System.Windows.FrameworkElement.IsInitialized" /> が内部で <see langword="true" /> に設定されるたびに呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この特定 * メソッドは、ハンドラーのフックをクラスではありません。 正確に従って、確立されたも[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]で * メソッド規則がこのメソッドをオーバーライドし、基本実装を呼び出していない一致するイベントを抑制する可能性があります。  
  
 なお、<xref:System.Windows.FrameworkElement.IsInitialized%2A>プロパティは、読み取り専用で設定することはできませんので<xref:System.Windows.FrameworkElement.IsInitialized%2A>初期化の動作を強制的にします。 のみ実行するためのものが、初期化状態を設定、[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]フレームワーク。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>この仮想メソッドの既定の実装は、上で説明したようにイベントを発生させます。 オーバーライドでは、この動作を保持するために基本実装を呼び出す必要があります。 基本の実装を呼び出しに失敗した場合だけでなくするさせないで、<see cref="E:System.Windows.FrameworkElement.Initialized" />イベントの想定が通常どおり、<see cref="T:System.Windows.FrameworkElement" />派生クラスでは、2 つ重要なスタイルとテーマ スタイルの初期化の操作であるで抑制します。この基本実装によって実装されます。</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnApplyTemplate" />
        <altmember cref="E:System.Windows.FrameworkElement.Initialized" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">変更されたプロパティと、新旧の値を記述するイベント データ。</param>
        <summary>この <see cref="T:System.Windows.FrameworkElement" /> の依存関係プロパティの有効値が更新された場合に必ず呼び出されます。 変更が発生した特定の依存関係プロパティが引数パラメーターで報告されます。 <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> をオーバーライドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、一般的にプロパティの変更または無効化を検出するものではありません。 代わりにものでは、無効化の一般的なパターンを変更するためのプロパティの広範な分類について特定の情報がわかっている場合。  
  
 このメソッドでは、オブジェクトの有効期間中に何度もを呼び出す可能性があります。 固有のプロパティのメタデータをオーバーライドし、適用する場合、パフォーマンスが向上を実現するそのため、<xref:System.Windows.CoerceValueCallback>または<xref:System.Windows.PropertyChangedCallback>個々 のプロパティ。 場合にこのメソッドを使用すると、<xref:System.Windows.FrameworkElement>多数値と相互に依存関係プロパティにはが含まれています動作をレンダリングする必要がありますを再実行するいくつかの関連プロパティの無効化のケースのようにロジックが含まれている場合またはします。  
  
 同じ名前に注意してください。`OnPropertyChanged`異なるシグネチャを持つメソッド (パラメーターの型が<xref:System.ComponentModel.PropertyChangedEventArgs>) クラスの数で表示されることができます。 ある`OnPropertyChanged`のコントラクトの一部であり、データ オブジェクトの通知に使用<xref:System.ComponentModel.INotifyPropertyChanged>します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>常に、実装の最初の操作として基本の実装を呼び出します。 これに失敗には、全体が無効になりますが大幅に[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]プロパティ システムは、不適切な値を報告するために発生します。 特定<see cref="T:System.Windows.FrameworkElement" />実装はさまざまな表示されるユーザー インターフェイスに影響を与えるプロパティの適切な状態を維持することもできます。 適切なタイミングでスタイルを設定する変更に基づいて、ビジュアル ツリーを無効化が含まれます。</para></block>
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberSignature Language="F#" Value="override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="frameworkElement.OnRenderSizeChanged sizeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">変更に関係する、古いサイズと新しいサイズの詳細。</param>
        <summary>指定した情報を最終的なイベント データの一部として使用して、<see cref="E:System.Windows.FrameworkElement.SizeChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Windows.UIElement.OnRenderSizeChanged%2A> をオーバーライドします。 このメソッドを呼び出す場合は、リセット、<xref:System.Windows.FrameworkElement.ActualWidth%2A>プロパティ、<xref:System.Windows.FrameworkElement.ActualHeight%2A>プロパティ、またはその両方として指定されている内容によっては、指定された引数で変更されは常にイベントが発生します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>一般的なレイアウト シナリオには、このメソッドをオーバーライドしません。 レイアウト システムは、すべての可能なレイアウトの配置し、メジャーの場合は考慮のことを保証するために意図的に非同期の方法で動作します。 レイアウト システムは、メソッドをオーバーライド<see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />と<see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />で必要なレイアウトのカスタマイズ、通常は十分です。 <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> バーチャル マシンとして公開されます。 オーバーライドできます<see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />実行時動作の変更が入力コントロールと組み合わせてイベントに関連する例外的なケースを修正する応答で満たしますが不正確なレイアウト情報を与える可能性があります。  
  
でも、(これは、保護は封印されていません) の派生クラスでこのメソッドをオーバーライドできます。 常に既定の WPF フレームワーク レベルのレンダリング動作を無効にするための非常に特定の理由がない限りは、上記のように動作を保持する基本実装を呼び出します。 生成に失敗する、<see cref="E:System.Windows.FrameworkElement.SizeChanged" />イベントは、標準の WPF フレームワーク レベルのレイアウト システムの実装を使用する場合、非標準のレイアウト動作が発生します。</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">元のスタイル。</param>
        <param name="newStyle">新しいスタイル。</param>
        <summary>この要素で使用されているスタイルが変更された場合に呼び出されます。スタイルが変更されるとレイアウトが無効になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、スタイルが変更された状態を記録する内部フラグを設定する既定の実装があります。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>通常、このメソッドをオーバーライドするが必要ありません。 いずれかのメジャーを含むスタイルを変更または変更はの一般的な実装と仮定すると、別のレンダリングのサイクルをトリガーして既に配置<see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />、か、既定値。 オーバーライド<see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />適切な場合がある場合、 <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />実装が意図的に最適化された、または直接スタイルに変更を適用する、部分的な更新プログラムをサポートしている必要があります。 (部分的な更新を増分複数の呼び出しを回避しようとなります<see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" />と<see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />ですべての子要素)。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary>未処理の <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> ルーティング イベントが、その経路上でこのクラスに到達するたびに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスがこのメソッドを実装している場合は、基本実装を呼び出す必要があります。  
  
 このメソッドの目的は、類似した[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: 一致する、インスタンス ハンドラーではなく、クラス ハンドラーで、派生クラスからイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンはルーティング イベントのさまざまなルーティング イベントをハンドラー イベント引数のソースを実行する必要があります、実装を呼び出すは必ずしもの要素の子要素で発生する可能性があります。アカウントにプロパティ (および再ほとんどの場合、イベントを発生しないでください)。 サブクラス<xref:System.Windows.FrameworkElement>にイベントが経路上に受信したときに、プライベート クラス ハンドラー メソッドを呼び出すこともできます。 イベントの引数を受け取り、処理済みとして意図的にイベントをマークする 1 つの潜在的なシナリオです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントに関するデータを提供します。</param>
        <summary><see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> ルーティング イベントが、その経路上でこのクラスに到達するたびに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスがこのメソッドを実装している場合は、基本実装を呼び出す必要があります。  
  
 このメソッドの目的は、類似した[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: 一致する、インスタンス ハンドラーではなく、クラス ハンドラーで、派生クラスからイベントを処理するための手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンはルーティング イベントのさまざまなルーティング イベントをハンドラー イベント引数のソースを実行する必要があります、実装を呼び出すは必ずしもの要素の子要素で発生する可能性があります。アカウントにプロパティ (および再ほとんどの場合、イベントを発生しないでください)。 サブクラス<xref:System.Windows.FrameworkElement>にイベントが経路上に受信したときに、プライベート クラス ハンドラー メソッドを呼び出すこともできます。 イベントの引数を受け取り、経路を短縮する処理済みとして意図的にイベントをマークする 1 つの潜在的なシナリオです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="frameworkElement.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">前の親要素。 以前、要素にビジュアル親が存在していなかったことを示す <see langword="null" /> である可能性があります。</param>
        <summary>ビジュアル ツリー内のこの要素の親が変更されたときに呼び出されます。 <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" /> をオーバーライドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビジュアル ツリーは、コレクションなどに視覚的にレンダリングされない要素を省略しているため、論理ツリーとは異なる可能性がありますがし、そのテーマとスタイルの合成に基づいていくつかの要素を展開します。 詳細については、「[WPF のツリー](~/docs/framework/wpf/advanced/trees-in-wpf.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>この仮想メソッドの既定の実装は、新しい親のクエリを実行し、さまざまな初期化イベントを発生させますの初期化の状態に関する内部フラグを設定、<see cref="T:System.Windows.FrameworkElement" />に応じて。 宣言される一連の基本実装を呼び出し、最後に、 <see cref="T:System.Windows.UIElement" />、さらにその基本で呼び出し<see cref="T:System.Windows.Media.Visual" />します。 常にこの動作を保持する基本実装を呼び出す、それ以外の場合別の要素の子として宣言されている場合は、この要素の要素ツリーの動作が期待どおりに。  
  
既存のいくつか[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]クラスなど、このメソッドをオーバーライド: <see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />、<see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" />します。 最も一般的なシナリオは、新しい親は、特定の型である必要がありますを強制します。 これは、新しい親には、何らかの型のテストが失敗した場合、例外をスローすることが含まれる可能性があります。 このシナリオの特殊なバージョンは、リスト項目およびメニュー項目がなさない、親の外部 visual でそれらを格納する適切なコレクションを所有している実装に存在します。 デザイナーのシナリオは、一時的に"regular"親要素親の変更に依存する可能性があるため、このような場合は必ずしも例外が発生に注意してください。  
  
このメソッドは、通常は、ルート要素など、特定の要素のオーバーライドも<see cref="T:System.Windows.Window" />します。 別のケースがマークアップの明確なルート要素である要素は、自動生成、コンパイル済みの論理ツリーに大きいインフラストラクチャ (など<see cref="T:System.Windows.Controls.Page" />)。 <see cref="T:System.Windows.Window" />と<see cref="T:System.Windows.Controls.Page" />実装が意図的に、メソッドをシールします。</para></block>
        <altmember cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に、テーマのスタイルのスタイル プロパティが含まれるかどうかを示す値を取得または設定します。</summary>
        <value>この要素がテーマ スタイル プロパティを使用しない場合は <see langword="true" /> (スタイルが生成するすべてのプロパティは、ローカルのアプリケーション スタイルに起因するため、テーマ スタイル プロパティは適用されません)。 まずアプリケーション スタイルを適用してから、アプリケーション スタイルで明確に設定されなかったプロパティに対してテーマ スタイルを適用する場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの最も一般的な使用方法は、間接のテーマが適用されたスタイル値を提供するスタイルの setter 内で使用します。  
  
> [!IMPORTANT]
>  設定した場合<xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>に`true`テーマ スタイルによって提供される既定のコントロール テンプレートにコントロールを抑制します。 そのコントロール テンプレートには通常、コンテンツ プレゼンターと基本を提供するその他の複合要素が含まれています[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]機能と、コントロールのビジュアル化します。 を既定のテーマ スタイルと同じ機能をサポートするために続行するには、制御する場合は、同じ構造をレプリケートするコントロール テンプレートを持つ別のスタイルを指定してください。 詳しくは、「[コントロールの作成の概要](~/docs/framework/wpf/controls/control-authoring-overview.md)」を参照してください。  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の論理上の親要素を取得します。</summary>
        <value>この要素の論理上の親。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Parent%2A> あります`null`要素がインスタンス化されたがページ レベルのルート要素で、またはアプリケーション オブジェクトに最終的に接続する任意の論理ツリーにアタッチされていない場合。  
  
 要素の論理上の親が、アプリケーションの機能に応じて変更できます可能性があると、このプロパティの値を保持してもその変更は反映されないことに注意してください。 通常は値を取得する必要がある直前。  
  
 参照してください[WPF のツリー](~/docs/framework/wpf/advanced/trees-in-wpf.md)論理ツリーの走査の詳細およびシナリオを使用した<xref:System.Windows.FrameworkElement.Parent%2A>検出は、適切な親要素の手法として。  
  
 プロパティのエンジンは可能性があると再計算要素のすべてのプロパティ値が親を再指定、いくつかのプロパティは、論理ツリー内の値を継承するため。 <xref:System.Windows.FrameworkElement.DataContext%2A>適用の場合に、バインドは変更もできます。  
  
 要素の親の変更は通常のみ実行コレクションの操作によって、dedicated を使用して追加または削除メソッド、または、要素のコンテンツのプロパティを設定します。  
  
 使用するための最も一般的なシナリオ、<xref:System.Windows.FrameworkElement.Parent%2A>プロパティの参照を取得し、取得し、さまざまな<xref:System.Windows.FrameworkElement>親からプロパティ値。 テンプレートの場合、<xref:System.Windows.FrameworkElement.Parent%2A>テンプレートの最終的になる`null`します。 この時点以降に取得し、テンプレートが実際に適用されている論理ツリーに拡張を使用<xref:System.Windows.FrameworkElement.TemplatedParent%2A>します。  
  
 このプロパティが論理ツリーの親と異なる場合、ビジュアル ツリーの親を報告していないことに注意してください。 ビジュアル ツリーの親では、通常重要アプリケーションの一般的なケースではないが、visual 特定レベルの場合に必要な親要素があります。 以下を参照してください。<xref:System.Windows.Media.VisualTreeHelper>  
  
   
  
## Examples  
 次の例では、要素の親をチェックし、親からのプロパティ値を使用して、一致する子要素のプロパティを設定するコードを示します。 ここで、これらは、表示サイズに影響するプロパティです。  
  
 [!code-csharp[GeometryDesigner#FEParentProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometryDesigner/CSharp/Window1.xaml.cs#feparentproperty)]
 [!code-vb[GeometryDesigner#FEParentProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometryDesigner/visualbasic/window1.xaml.vb#feparentproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.TemplatedParent" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="ParentLayoutInvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual void ParentLayoutInvalidated (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ParentLayoutInvalidated(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ParentLayoutInvalidated (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ParentLayoutInvalidated(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit&#xA;override this.ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit" Usage="frameworkElement.ParentLayoutInvalidated child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">変更を報告している子要素。</param>
        <summary><see cref="T:System.Windows.FrameworkElement" /> の特殊化されたサブクラスでインクリメンタル レイアウトの実装をサポートします。 レイアウト中に親のメジャーまたは整列パスに影響を与えるものとしてメタデータ内でマークされているプロパティを子要素が無効にすると、<see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" /> が呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この要素が子要素をいくつかのプロパティが無効にし、としてマークされたプロパティを持つ<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>または<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>プロパティ メタデータの登録時に、このメソッドが呼び出されます。 メソッドの呼び出しでは、この要素は、レイアウトの部分 (増分) の更新をサポートしている場合は、特定の子要素を再測定する必要があります、親要素に通知します。  
  
 既定では、<xref:System.Windows.FrameworkElement>インクリメンタルのレイアウトをサポートしていませんし、<xref:System.Windows.FrameworkElement>クラスのこのメソッドには、既定の実装がありません。 レイアウト システムの既定の動作を変更する必要があるため、このメソッドをオーバーライドする必要があるとするシナリオは一般的ではありません。  
  
 かどうか、クラスが、WPF フレームワーク レベルのレイアウト システムよりもはるかに厳しい使用可能な子要素の型の制限の実装のシナリオ例があります。 これらのカスタム要素の性質上、プロパティの変更を遅らせることができます意図的にいくつかのカスタム レイアウト動作を実装する場合。 たとえば、特定の種類別のレイアウト パスになる通常の変更のメジャー/配置のメソッド オーバーライドで、子要素を最適化しようとするパス、レンダリングを遅らせることができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">予想されるフォーカスの変更を決定する方向。</param>
        <summary>この要素を基準に、指定したフォーカスの移動方向で次にフォーカスを受け取る要素を特定します。ただし、実際のフォーカスの移動は行われません。</summary>
        <returns>フォーカスが実際にスキャンされた場合にフォーカスの移動先となる、次の要素。 この要素を基準に、指定した方向へフォーカスを移動できない場合は、<see langword="null" /> が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.MoveFocus%2A> 実際には、フォーカスを移動するが関連するメソッドです。  
  
   
  
## Examples  
 次の例では、各ボタンを表すことがあるいくつかのボタン入力を処理するハンドラーを実装する<xref:System.Windows.Input.FocusNavigationDirection>します。 ハンドラーは、要素を現在のキーボード フォーカスと呼び出しを追跡<xref:System.Windows.FrameworkElement.PredictFocus%2A>、その要素にし、適切なを指定します<xref:System.Windows.Input.FocusNavigationDirection>の初期化として、<xref:System.Windows.Input.TraversalRequest>指定されたパラメーターを入力します。 その要素への移行ではなく<xref:System.Windows.FrameworkElement.MoveFocus%2A>は、ハンドラーは、視覚化のための予測のフォーカスの変換先の物理の寸法を変更します。  
  
 [!code-csharp[FocusSample#FEPredictFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#fepredictfocus)]
 [!code-vb[FocusSample#FEPredictFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#fepredictfocus)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><see cref="T:System.Windows.Input.TraversalRequest" /> に、<see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.First" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Last" /> のいずれかの方向が指定されました。 これらの方向は、<see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> に対しては有効ではありません (<see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> に対しては有効です)。</exception>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">指定した名前オブジェクトの割り当てに使用する名前。</param>
        <param name="scopedElement">割り当て対象のオブジェクト。</param>
        <summary><see cref="T:System.Windows.NameScope" /> の登録メソッドへのアクセスを簡略化するアクセサーを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出す便利なメソッドは、<xref:System.Windows.NameScope.RegisterName%2A>します。 実装は、適切なが見つかるまで、連続する親要素は確認<xref:System.Windows.NameScope>実装で、実装する要素の検索によって見つかった<xref:System.Windows.Markup.INameScope>します。 名前スコープの詳細については、次を参照してください。 [WPF XAML 名前スコープ](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)します。  
  
 呼び出す<xref:System.Windows.FrameworkElement.RegisterName%2A>正しくコードで作成されたときに、アプリケーションのアニメーションのストーリー ボードをフックするために必要です。 これは、キーのいずれかのストーリー ボードのプロパティ、ため<xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>、ターゲット要素への参照を実行することではなく実行時の名の参照を使用します。 これは、その要素が、コードから参照でアクセス可能な場合でも当てはまります。 ストーリー ボード ターゲットの名前を登録する必要がある理由の詳細については、次を参照してください。[ストーリー ボードの概要](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)します。  
  
   
  
## Examples  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/ScopeExample.cs#namescopeexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/scopeexample.vb#namescopeexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">削除する要素。</param>
        <summary>指定されたオブジェクトをこの要素の論理ツリーから削除します。 <see cref="T:System.Windows.FrameworkElement" /> は、この削除との同期を維持するために影響を受ける論理ツリーの親ポインターを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素の論理的な子を表すオブジェクトのコレクションの実装には、このメソッドを使用します。 これは、プロパティ get アクセス操作子または set アクセス操作子のクラス ハンドラーで行うことがあります`Changed`イベント、コンス トラクター、またはコレクション内で自身の種類します。  
  
 指定された基本コントロール クラスのコンテンツ モデルに適切なものがない限りは、コントロールの作成者がこのレベルでの論理ツリーを操作することはお勧めできません。 サブクラス化のレベルを検討してください。 <xref:System.Windows.Controls.ContentControl>、 <xref:System.Windows.Controls.ItemsControl>、および<xref:System.Windows.Controls.HeaderedItemsControl>します。 これらのクラスは、専用を論理的な子の適用が特定のコンテンツ モデルを提供[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]、通常望ましい他の機能のサポートと、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]テンプレートをスタイル設定などのコントロール。  
  
   
  
## Examples  
 次の例では、実装、`Child`カスタム プロパティ<xref:System.Windows.FrameworkElement>独自のビジュアル層の実装を行うことです。 プロパティの set アクセス操作子では、古い値をクラスに固有のビジュアルのコレクションと同様に、論理ツリーから削除、値が変更された場合ように設計されています。 値がキャッシュされ、標準的な WPF フレームワーク レベル論理ツリーとカスタム ビジュアルのコレクションの両方に新しい値を追加します。  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoView">
      <MemberSignature Language="C#" Value="public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RequestBringIntoView As RequestBringIntoViewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RequestBringIntoViewEventHandler ^ RequestBringIntoView;" />
      <MemberSignature Language="F#" Value="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " Usage="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RequestBringIntoViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素で <see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /> が呼び出されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、親を示します。 <xref:System.Windows.Controls.ScrollViewer> (または派生クラス) 発生する要素、<xref:System.Windows.FrameworkElement.RequestBringIntoView>イベントに表示されるスクロール可能なリージョン内で。 <xref:System.Windows.Controls.ScrollViewer>はマークし、<xref:System.Windows.FrameworkElement.RequestBringIntoView>イベントをイベントのクラス処理を使用して、処理します。 一般に<xref:System.Windows.FrameworkElement.RequestBringIntoView>データ マークしないでまたはいずれかではスクロール領域を制御する任意のクラスによって処理済みイベント インスタンス ハンドラーと呼ばれる要素の目的の目標に支障をきたすそう<xref:System.Windows.FrameworkElement.BringIntoView%2A>します。  
  
<a name="routedEventInfo_RequestBringIntoView"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.RequestBringIntoViewEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoViewEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent RequestBringIntoViewEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RequestBringIntoViewEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ RequestBringIntoViewEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable RequestBringIntoViewEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkElement.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカルで定義されたリソース ディクショナリを取得または設定します。</summary>
        <value>ローカルで定義された現在のリソース ディクショナリ。各リソースにはキーでアクセスできます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リソース ディクショナリで完全にまたは部分的に定義できる[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]は、通常、プロパティ要素として作成し、個々 のページまたはアプリケーションのルート要素では、通常します。 このレベルでリソース ディクショナリを配置すると、ページ内の個々 の子要素 (またはアプリケーションの場合は、任意のページ) を検索しやすきます。 ほとんどのアプリケーション シナリオでお勧めのスタイルをリソース ディクショナリ内のオブジェクト要素として定義するか、スタイル リソース全体を自己完結できるように、外部のリソースとして定義する (このアプローチにより、別のデザイナー責任を編集する必要がある物理ファイルを分離することで、開発者の役割から)。  
  
 このプロパティがその要素内で直接宣言されているリソース ディクショナリのみを返すことに注意してください。 これは、実際のリソース ルックアップ プロセスが子要素がアクセスできる検索方向を再帰的に、各親要素で定義されているリソースのいずれかによって異なります。  
  
 リソースは、コレクション内からコードで参照することもできますでリソースが作成されたことに注意してください[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]は間違いなくできません後までアクセス<xref:System.Windows.FrameworkElement.Loaded>はディクショナリを宣言した要素から発生します。 リソースは解析されませんを非同期に実際には、でも、<xref:System.Windows.FrameworkElement.Loaded>イベントが参照できるように保証、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]リソースを定義します。 この理由でアクセスすることは一般的にのみ[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]またはその他の実行時のコードの一部として定義リソース[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]スタイルや属性の値をリソース拡張機能の参照などの手法です。 参照と基本的に同じがコードによって、リソースにアクセスするときに[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
 基になる<xref:System.Windows.ResourceDictionary>追加、削除、またはコードを使用して、コレクション内からリソースをクエリに必要なメソッドをサポートしています。 <xref:System.Windows.FrameworkElement.Resources%2A>プロパティは、要素を新しいまたは別のリソースのコレクションを完全に置き換えるのシナリオをサポートする設定<xref:System.Windows.ResourceDictionary>します。  
  
 なお、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]に示す構文の要素を含まない、 <xref:System.Windows.ResourceDictionary>。 これは、暗黙の型のコレクション構文の例コレクションの要素を表すタグを省略できます。 代わりに、コレクションに項目として追加される要素を指定します。 暗黙の型のコレクションの詳細については、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]を参照してください[XAML 構文の詳細](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)します。 1 つのケースで、<xref:System.Windows.ResourceDictionary>要素は、マージされたディクショナリを導入する場合に要素がない通常子を明示的に指定がまだ<xref:System.Windows.ResourceDictionary>します。 詳細については、次を参照してください。 [Merged Resource Dictionaries](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)します。  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>XAML 値  
 *oneOrMoreResourceElements*  
 1 つまたは複数のオブジェクト要素のリソースを定義します。 各リソースのプロパティ要素内で各<xref:System.Windows.ResourceDictionary>の値が一意である必要があります、 [X:key ディレクティブ](~/docs/framework/xaml-services/x-key-directive.md)から値を取得するときに、一意のキーとして使用される、<xref:System.Windows.ResourceDictionary>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
        <related type="Article" href="https://msdn.microsoft.com/library/1985cd45-f197-42d5-b75e-886add64b248">X:key 属性</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した依存関係プロパティのためのバインディングをこの要素に添付します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">バインディングを確立する必要がある対象のプロパティを識別します。</param>
        <param name="path">ソース プロパティ名、またはバインドに使用されているプロパティへのパス。</param>
        <summary>指定したソース プロパティ名をデータ ソースへのパスの修飾として使用して、この要素にバインディングを添付します。</summary>
        <returns>バインドの条件を記録します。 この戻り値は、エラーをチェックするために役立ちます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出す便利なメソッドは、 <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>、現在のインスタンスを渡す、 <xref:System.Windows.DependencyObject>、新たに作成および<xref:System.Windows.Data.Binding>に基づいて、指定された`path`パラメーター。 この署名は、単純な既定のバインディングを確立している場合より便利です。 既定以外の条件へのバインディング プロパティを使用する必要がある場合、<xref:System.Windows.Data.MultiBinding>または<xref:System.Windows.Data.PriorityBinding>、使用する必要があります、<xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>署名します。  
  
   
  
## Examples  
 次の例では、特定のパスを使用してバインドを設定します。  
  
 [!code-csharp[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#setbindingpath)]
 [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#setbindingpath)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">バインドを確立する必要があるプロパティを識別します。</param>
        <param name="binding">データ バインディングの詳細を表します。</param>
        <summary>指定したバインディング オブジェクトに基づいて、この要素にバインドをアタッチします。</summary>
        <returns>バインドの条件を記録します。 この戻り値は、エラーをチェックするために役立ちます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、便利なメソッドを呼び出す<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>、現在のインスタンスを渡す、<xref:System.Windows.DependencyObject>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFlowDirection">
      <MemberSignature Language="C#" Value="public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFlowDirection(class System.Windows.DependencyObject element, valuetype System.Windows.FlowDirection value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFlowDirection (element As DependencyObject, value As FlowDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFlowDirection(System::Windows::DependencyObject ^ element, System::Windows::FlowDirection value);" />
      <MemberSignature Language="F#" Value="static member SetFlowDirection : System.Windows.DependencyObject * System.Windows.FlowDirection -&gt; unit" Usage="System.Windows.FrameworkElement.SetFlowDirection (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FlowDirection" />
      </Parameters>
      <Docs>
        <param name="element">フロー方向を指定する要素。</param>
        <param name="value">方向を指定する列挙値。</param>
        <summary>指定された要素の <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 添付プロパティの値を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはサポートされている添付プロパティの構文、<xref:System.Windows.FrameworkElement.FlowDirection%2A>プロパティ、そのための指定された要素を子に許可<xref:System.Windows.FrameworkElement>それぞれの親要素内の配置のフロー方向を指定します。 現在の値を設定する<xref:System.Windows.FrameworkElement>、ダイレクトを使用して、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]アクセサー<xref:System.Windows.FrameworkElement.FlowDirection%2A>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">リソースのバインド先のプロパティ。</param>
        <param name="name">リソースの名前。</param>
        <summary>指定した名前のリソースを検索し、指定したプロパティにそのリソースへのリソース参照を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リソースの参照の使用と似ています、 [DynamicResource マークアップ拡張機能](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)マークアップ。 リソース参照では、実行時の遅延単位で指定したプロパティの値を提供する内部式を作成します。 式は、リソース ディクショナリの内部イベントを通じて変更された値を示しますたびに、または、現在の要素が親を再指定されるたびに再評価されます (親の変更は、ディクショナリの検索パスを変更が)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスが、<see cref="P:System.Windows.FrameworkElement.Resources" /> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.FrameworkElement.Resources" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これにより返されます`true`、ローカルの少なくとも 1 つのキーを持つリソースがある限り<xref:System.Windows.FrameworkElement.Resources%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスが、<see cref="P:System.Windows.FrameworkElement.Style" /> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.FrameworkElement.Style" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返されます`true`場合、<xref:System.Windows.Style>がローカルに設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTriggers">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeTriggers" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTriggers () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTriggers();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTriggers : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeTriggers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスが、<see cref="P:System.Windows.FrameworkElement.Triggers" /> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.FrameworkElement.Triggers" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る`true`場合、<xref:System.Windows.FrameworkElement.Triggers%2A>プロパティがローカルに設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.SizeChangedEventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SizeChangedEventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As SizeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SizeChangedEventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : System.Windows.SizeChangedEventHandler " Usage="member this.SizeChanged : System.Windows.SizeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> プロパティまたは <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> プロパティの値が変更されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 直接ルーティング イベントがルートに従っていない、発生しますが、同じ要素内でのみ処理されます。 直接ルーティング イベントは、その他のルーティング イベントの動作をサポートして: アクセスできるハンドラーのコレクションをサポートし、として使用できる、<xref:System.Windows.EventTrigger>スタイル。  
  
 レイアウト システム内のプロパティを読み取り、<xref:System.Windows.SizeChangedEventArgs>報告されるサイズの変更を重要な考慮するかどうかを判断する、このイベントの引数クラスです。 これにより、レイアウト システムまたは強制的に新旧の高さまたは幅の値の視覚的にこうしたわずかな違いのためのレイアウトの変更を回避するために、コントロールに固有のレイアウトの実装。 こうしたわずかな違いは、浮動小数点データ型の丸め処理を行うか、同じ結果の計算があります。  
  
<a name="routedEventInfo_SizeChanged"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.SizeChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Height" />
        <altmember cref="P:System.Windows.FrameworkElement.Width" />
      </Docs>
    </Member>
    <Member MemberName="SizeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SizeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SizeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SizeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkElement.SizeChanged" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の既存のプロパティ バインディングのソース値が変更されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Data.Binding.SourceUpdated>いずれかで発生するイベントを<xref:System.Windows.Data.Binding>この要素に関連付けられています。  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object SourceUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.SourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が使用するスタイルを、表示されるときに取得または設定します。</summary>
        <value>要素に適用される既定以外のスタイル (存在する場合)。 それ以外の場合は <see langword="null" />。 既定で構築された <see cref="T:System.Windows.FrameworkElement" /> の既定値は <see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの現在のスタイルは多くの場合、コントロールのテーマから既定のスタイルによって提供されるまたはスタイルから通常によって適用されるその種類のコントロールに (暗黙的なスタイル) のページまたはアプリケーション レベルのリソース。 このプロパティが設定されていないか、戻り値の既定 (テーマ) のスタイルが、暗黙的なスタイルまたは要素に機能している明示的なスタイルのいずれかに戻ることはできます。 暗黙的または明示的なスタイルの場合、スタイルのリソースとして指定またはローカルで定義されているかどうかは関係ありません。  
  
 スタイルの設定の制限があります。 全体をリセットする<xref:System.Windows.FrameworkElement.Style%2A>プロパティを新しい<xref:System.Windows.Style>、いつでもレイアウトの再合成を強制します。 ただし、としてすぐにそのスタイルによって読み込まれた要素では、使用中に配置されるため、<xref:System.Windows.Style>見なす必要がありますシールします。 使用中のスタイルの個々 のプロパティを変更しようとしています (などのコレクション内のすべて<xref:System.Windows.Style.Setters%2A>) がスローされる例外が発生します。 マークアップで定義されているスタイルは、(リソース) のリソース ディクショナリから読み込まれるまたはインライン スタイル) (に含まれるページが読み込まれるとすぐに使用されていると見なされます。  
  
 <xref:System.Windows.FrameworkElement.Style%2A> 特殊な優先順位を持つ依存関係プロパティです。 ローカルに設定されたスタイルが一般に、プロパティ システムで最高の優先順位で動作します。 場合、<xref:System.Windows.FrameworkElement.Style%2A>プロパティ システムがその型を指定するローカルまたはアプリケーションのリソースでの暗黙的なスタイルのチェックの読み込み中にこの時点では、null です。 この手順の後に、スタイルはまだ null 場合し、プレゼンテーションの目的で動作するスタイルは、一般に、既定 (テーマ) スタイルはでは、既定のスタイルは返されません、<xref:System.Windows.FrameworkElement.Style%2A>プロパティの値。 参照してください[依存関係プロパティの値の優先順位](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)または[スタイルとテンプレート](~/docs/framework/wpf/controls/styling-and-templating.md)します。  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object Style="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_Style"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>XAML 値  
 *resourceExtension*  
 次のいずれか: または。 参照してください[XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)します。  
  
 *styleResourceKey*  
 要求されているスタイルを識別するキー。 このキーは、既存のリソースで、<xref:System.Windows.ResourceDictionary>します。  
  
> [!NOTE]
>  プロパティ要素構文は技術的に可能であれば、ほとんどのスタイルのシナリオは推奨されません。 参照してください[インライン スタイルおよびテンプレート](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)します。 使用してバインドの参照または<xref:System.Windows.Data.Binding>も可能ですが、一般的ではありません。  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.StyleProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 次の例では、リソース ディクショナリでスタイルを定義します。  
  
 [!code-xaml[FEResource#StyleProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty)]  
[!code-xaml[FEResource#StyleProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty2)]  
[!code-xaml[FEResource#StyleProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty3)]  
[!code-xaml[FEResource#StyleProperty4](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.Style" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">要求されたアンビエント プロパティの名前。</param>
        <summary>このメンバーの説明については、<see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> メソッドのトピックを参照してください。</summary>
        <returns><paramref name="propertyName" /> を使用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Windows.FrameworkElement> のインスタンスが <xref:System.Windows.Markup.IQueryAmbient> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に関するユーザー定義情報の格納に使用できる任意のオブジェクト値を取得または設定します。</summary>
        <value>任意の値。 このプロパティには既定値はありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、その他のマイクロソフトのプログラミング モデルで、アプリケーションまたは Windows フォームの Visual Basic などのタグ プロパティに似ています。 <xref:System.Windows.FrameworkElement.Tag%2A> いずれかに関する基本的なカスタム情報を格納する既存プロパティ場所を指定するためのものが<xref:System.Windows.FrameworkElement>しなくても、サブクラス化する要素。  
  
 設定するには、プロパティ要素の使用方法を使用する必要がありますので、このプロパティは、オブジェクトを受け取り、<xref:System.Windows.FrameworkElement.Tag%2A>文字列などの既知と組み込みの型コンバーターを使用してオブジェクト以外に XAML のプロパティ。 この方法で使用されるオブジェクトしない標準の WPF 名前空間内で通常はそのため可能性がありますやを必要し、外部名前空間への名前空間マッピング XAML 要素として導入します。 詳細については、次を参照してください。 [XAML 名前空間および WPF XAML のマッピングの Namespace](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)と[XAML とカスタム クラスの WPF](~/docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md)します。  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.TagProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.Tag" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素のプロパティ バインディングのターゲット値が変更されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Data.Binding.TargetUpdated>いずれかで発生するイベントを<xref:System.Windows.Data.Binding>この要素に関連付けられています。 通常つまり、対象のバインドは双方向のバインド、バインドされた依存関係プロパティが確認された前のプロパティ値でないようになりました検証またはプロパティまたはデータ ソースをサポートするキャッシュ スキームに対して無効です。  
  
 イベント データを使用して、<xref:System.Windows.FrameworkElement.TargetUpdated>ターゲット値の更新を報告している特定のプロパティを決定するイベントです。  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object TargetUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.TargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の親テンプレートへの参照を取得します。 このプロパティは、要素がテンプレートによって作成されていない場合は無効です。</summary>
        <value>要素が<see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" />この要素を作成します。 この値は、頻繁に<see langword="null" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> 多くの場合は、`null`アプリケーション マークアップまたはコードに作成されるオブジェクト。 これは、テンプレートを使用していないこれらのオブジェクトを直接作成するためです。 オブジェクトをルートから、論理ツリーをウォークすることによって取得した参照またはテンプレートから提供されない参照を通常の名前。  
  
 あるケース<xref:System.Windows.FrameworkElement.TemplatedParent%2A>できない可能性があります`null`とビジュアル ツリーをウォーク特定低レベル入力イベントのイベント処理のヒット テストなどの操作を含める<xref:System.Windows.Media.VisualTreeHelper>、列挙子の使用、付属している要素を返す可能性がありますかテンプレートです。 別のケースでは具体的には呼び出すかどうか<xref:System.Windows.FrameworkTemplate.FindName%2A>に対して既存の<xref:System.Windows.FrameworkTemplate>返されたオブジェクトと連携します。  
  
 テンプレートは、実際には共有オブジェクト、テンプレートの内容が 1 回だけ作成される場所です。 そのため、テンプレートから付属している要素へのオブジェクト参照を取得する場合、見かけ上の論理ツリーは、ページのルートに到達していないことを見つけることがあります。 このようなテンプレートへの参照をページの論理ツリーを接続するために取得する必要があります、<xref:System.Windows.FrameworkElement.TemplatedParent%2A>値し、必要に応じて、その要素のツリーを移動します。 続行します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.ToolTip)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] でこの要素に対して表示されるツールヒント オブジェクトを取得または設定します。</summary>
        <value>ツールヒント オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値が型の場合<xref:System.Windows.Controls.ToolTip>、その値はツール ヒントで使用される、[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]します。  値は、その他の種類のかどうかは、その値として使用されます、*コンテンツ*の<xref:System.Windows.Controls.ToolTip>提供システムによっては、(作成) します。 詳細については、「<xref:System.Windows.Controls.ToolTipService>」を参照してください。 サービス クラスをさらにカスタマイズするために使用する添付プロパティを提供する、<xref:System.Windows.Controls.ToolTip>します。  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>XAML 値  
 *toolTipContent*  
 表示テキストとなる文字列、<xref:System.Windows.FrameworkElement.ToolTip%2A>します。  
  
 *toolTipObjectContent*  
 コンテンツとして使用するオブジェクト要素の形式で提供される一部のオブジェクト、<xref:System.Windows.FrameworkElement>します。 通常、<xref:System.Windows.FrameworkElement>またはその他の要素のレイアウトの複合を作成する、 <xref:System.Windows.FrameworkElement.ToolTip%2A>、最終的に、合成内のテキスト コンテンツを格納しています。 この使用法 で、<xref:System.Windows.Controls.ToolTip>要素を作成、解析されたから暗黙的に[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]と*方法*としてコンテンツが設定されてその<xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType>プロパティ。  
  
 <`ToolTip` .../>  
 以下を参照してください。<xref:System.Windows.Controls.ToolTip>  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.ToolTipProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次の例では、作成、<xref:System.Windows.Controls.ToolTip>でコードを設定、<xref:System.Windows.FrameworkElement.ToolTip%2A>プロパティを<xref:System.Windows.Controls.Primitives.StatusBar>コントロール。  
  
 [!code-csharp[StatusBar#MakeProgressBar](~/samples/snippets/csharp/VS_Snippets_Wpf/StatusBar/CSharp/Window1.xaml.cs#makeprogressbar)]
 [!code-vb[StatusBar#MakeProgressBar](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StatusBar/visualbasic/window1.xaml.vb#makeprogressbar)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素のツールヒントが閉じる直前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マーク、<xref:System.Windows.FrameworkElement.ToolTipClosing>処理済みとしてのイベントは、ツールヒントを閉じる取り消されません。 ツールヒントが表示されたら後、は、UI を使用したユーザーの操作への応答でのみ行われますツールヒントを閉じるします。  
  
 このイベントにすることはできません、<xref:System.Windows.EventTrigger>スタイル。 これは、このイベントの識別子フィールドは、サービス レベルのイベントの追加と削除イベントのメソッドを公開しないサービスの実装を再使用するためです。  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   オーバーライド<xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素のツールヒントが開かれたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ツールヒントが ui で、ハンドラーの表示されないようにする<xref:System.Windows.FrameworkElement.ToolTipOpening>マークを付けることができます、<xref:System.Windows.Controls.ToolTipEventArgs>イベント データを処理します。 それ以外の場合、ツールヒントが表示されますの値を使用して、<xref:System.Windows.FrameworkElement.ToolTip%2A>ツールヒントの内容としてプロパティ。 もう 1 つの考えられるシナリオは、の値をリセットするハンドラーを記述することが、<xref:System.Windows.FrameworkElement.ToolTip%2A>のツールヒントが表示される直前に、イベント ソースである要素のプロパティ。  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> 場合に発生しませんの値<xref:System.Windows.FrameworkElement.ToolTip%2A>は`null`それ以外の場合、または設定を解除します。 意図的に設定しないでください<xref:System.Windows.FrameworkElement.ToolTip%2A>に`null`tooltip が開いてまたは; これは、ツールヒントを閉じるの効果がありませんを開き、UI に望ましくない visual 成果物を作成します。  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening>イベントにすることはできません、<xref:System.Windows.EventTrigger>スタイル。 これは、このイベントの識別子フィールドは、サービス レベルのイベントの追加と削除イベントのメソッドを公開しないサービスの実装を再使用するためです。  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   オーバーライド<xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.ToolTip" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.FrameworkElement.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に直接、または子要素で設定されているトリガーのコレクションを取得します。</summary>
        <value>厳密に型指定された <see cref="T:System.Windows.Trigger" /> オブジェクトのコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このプロパティのみ設定できます[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]コレクション オブジェクトにアクセスして、追加などのさまざまなメソッドを使用して、表示、コレクション構文を使用します。 コレクション オブジェクト自体にアクセスするプロパティは読み取り専用、コレクション自体は読み取り/書き込みです。 プロパティは、ルート要素にのみ存在します検索や他の場所で設定しようがスローされる例外が発生します。  
  
 このプロパティでは、この要素で使用されているスタイルの一部として存在するトリガーを確認できません。 マークアップまたはコードでは、コレクションに追加されることはトリガーのコレクションを報告するだけです。 要素は、既存の既定では、このような要素を通常必要はありません (テンプレートを使ってインスタンス)。コントロールの複合スタイルで設定する代わりに由来するトリガーの方が一般的です。  
  
 動作の観点から (どちらの効果がのどの要素の宣言された元の確立を試みると<xref:System.Windows.FrameworkElement.Triggers%2A>コレクション)、トリガーの条件とトリガーの影響の両方で、この要素がありますまたは論理ツリーの子要素にあります。 などの有効期間イベントを使用する場合<xref:System.Windows.FrameworkElement.Loaded>をこのコレクションを取得するには、子要素のトリガーできない可能性がありますまだ完全に読み込まれると、コレクションは、実行時に本当にはそれよりも小さいになります。  
  
 要素に設定されているトリガーのコレクションのみがサポートされます。 注<xref:System.Windows.EventTrigger>、プロパティ トリガーではありません (<xref:System.Windows.Trigger>)。 スタイルまたはテンプレート内でこれらの配置し、し、そのスタイルまたはテンプレートの要素に代入かする必要がありますプロパティ トリガーが必要な場合経由で直接、<xref:System.Windows.FrameworkElement.Style%2A>プロパティ、または、暗黙的なスタイルの参照を通じて間接的にします。  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>XAML 値  
 *oneOrMoreTriggers*  
 1 つ以上定義されている<xref:System.Windows.EventTrigger>要素。 このような各トリガーは、有効なストーリー ボード アクションと参照を含めることが必要です。 このコレクションは、ページのルート要素でのみ設定できますに注意してください。 詳細については、次を参照してください。[ストーリー ボードの概要](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.EventTrigger" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">検索するリソースのキー識別子。</param>
        <summary>指定されたキーを使用してリソースを検索し、見つかった場合はそのリソースを返します。</summary>
        <returns>見つかったリソース。指定した <paramref name="key" /> のリソースが見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出し元の要素で、リソースが見つからない場合は、親リソースのツリーは論理ツリーを上へ検索、ツリーになるのと同じ方法で検索すると、リソースは実行時に要求キーにされました。 メソッドを返します`null`キーのリソースがリソース ツリー、時にツリーの既存の条件ごとに任意の場所存在しなかった場合にのみを<xref:System.Windows.FrameworkElement.TryFindResource%2A>が呼び出されます。  
  
 通常返されるリソース値に設定しようとしているプロパティの型を戻り値をキャストするとすぐに。  
  
 <xref:System.Windows.FrameworkElement.FindResource%2A>メソッドには同様の動作があるが、指定されたキーを持つリソースが返されない場合、例外をスローします。  
  
   
  
## Examples  
 次の例は、セットがクリックしてされたボタンのバック グラウンド リソースによって定義されるブラシを呼び出すことによって取得ボタンとして実装<xref:System.Windows.FrameworkElement.TryFindResource%2A>自体。 これで、要素ツリーについて説明し、リソースを検索します (リソース自体がで定義されている[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]は示されていません)。  
  
 [!code-csharp[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#fetryfindresource)]
 [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#fetryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>読み込まれた要素の要素ツリーから要素が削除されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 直接ルーティング イベントがルートに従っていない、発生しますが、同じ要素内でのみ処理されます。 直接ルーティング イベントは、その他のルーティング イベントの動作をサポートして: アクセスできるハンドラーのコレクションをサポートし、として使用できる、<xref:System.Windows.EventTrigger>スタイル。  
  
 <xref:System.Windows.FrameworkElement.Loaded> <xref:System.Windows.FrameworkElement.Unloaded>両方ユーザーによるシステムのテーマを変更した結果のコントロールで発生する可能性があります。 テーマの変更により、コントロール テンプレートと、コントロール全体をアンロードして再読み込みが含まれているビジュアル ツリーの無効化します。 そのため<xref:System.Windows.FrameworkElement.Unloaded>ページから移動したときにのみ発生すると想定することはできません。  
  
 なお、<xref:System.Windows.FrameworkElement.Unloaded>アプリケーションでは、シャット ダウンが開始された後、イベントは発生しません。 アプリケーションのシャット ダウンが発生して、条件が定義されている場合、<xref:System.Windows.Application.ShutdownMode%2A>プロパティに発生します。 ハンドラー内でクリーンアップ コードを配置する場合、<xref:System.Windows.FrameworkElement.Unloaded>など、イベント、<xref:System.Windows.Window>または<xref:System.Windows.Controls.UserControl>、期待どおりにない呼び出されます。  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.UnloadedEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkElement.Unloaded" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">現在のスコープから削除する名前とオブジェクトのペアの名前。</param>
        <summary><see cref="T:System.Windows.NameScope" /> の登録解除メソッドへのアクセスを簡略化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 だけの登録を解除名に同じ名前の別の要素を再登録する場合です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Windows.FrameworkElement" /> に既定のスタイルを再度適用します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRounding">
      <MemberSignature Language="C#" Value="public bool UseLayoutRounding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseLayoutRounding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberSignature Language="VB.NET" Value="Public Property UseLayoutRounding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseLayoutRounding { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseLayoutRounding : bool with get, set" Usage="System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウトの間に、この要素のサイズおよび位置にレイアウトの丸めを適用するかどうかを示す値を取得または設定します。</summary>
        <value>レイアウトの丸めを適用する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>要素のプロパティは`true`、中に計算されるすべての整数以外のピクセル値、<xref:System.Windows.UIElement.Measure%2A>と<xref:System.Windows.UIElement.Arrange%2A>パスは全体のピクセル値に丸められます。  
  
 このプロパティは、子要素によって継承されます。  
  
> [!NOTE]
>  設定する必要があります<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>に`true`ルート要素。 レイアウト システムは、親の座標に子の座標を追加します。そのため、親の座標がピクセル境界にない場合は、子の座標上にないもピクセルの境界。 場合<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>ルートにある設定を設定できません<xref:System.Windows.UIElement.SnapsToDevicePixels%2A>を希望する効果を取得する子。  
  
 デバイス ピクセルの途中でエッジになった場合に、アンチ エイリアスによって生成される半透明のエッジを排除するピクセルの境界にオブジェクトを描画します。 次の図は、デバイスのピクセルの途中である 1 つのピクセル幅の行の出力を示します。 左側の線は、レイアウトの丸め処理を使用しませんし、アンチ エイリアス処理します。 右側の線は、レイアウトの丸め処理を使用します。  
  
 ![アンチ&#45;エイリアス化された行が 1 つのピクセルの行と比較します。](~/add/media/pixelsnaplinecompare.PNG "アンチ エイリアス線が 1 つのピクセルの行と比較します。")  
  
 レイアウトの丸め処理を使用する場合と<xref:System.Windows.GridUnitType.Star>サイズ変更、レイアウト システムに作成します小さな差異サブピクセル レンダリングを回避するために、列または行の測定値。 たとえば、グリッドがある 3 列のサイズの 100 の合計幅<xref:System.Windows.GridUnitType.Star>33.3 の等しい幅がある 3 つの列を作成する代わりに、レイアウト システムは、幅が 33 と 34 の幅のある 1 つの 2 つの列を作成します。  
  
> [!NOTE]
>  .NET 4.6 で変更にはレイアウトの境界線でコントロールのクリッピングの発生を削減する丸め処理が行われました。 既定では、この機能は、ターゲット フレームワークが .NET Framework 4.6 以降である場合に有効にします。 以前のバージョンの framework を対象とするアプリケーションは、app.config ファイルに次の設定を追加して、新しい動作にオプトインできます。`<runtime><AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/></runtime>` 設定は、アプリケーションが .NET Framework 4.6 で実行されている場合にのみ有効です。  
  
   
  
## Examples  
 次の例を説明する、<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>プロパティは、1 つのピクセル幅の行にします。 左側の線では、レイアウトの丸め処理は使用しませんし、右側の線は、レイアウトの丸め処理を使用します。 緩やかに変化ウィンドウをサイズ変更する場合は、違いは、レイアウトの丸めによるを確認できます。  
  
```xaml  
  
<Page x:Class="LayoutRounding.Lines"  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"  
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
    Title="Lines" Name="linesPage"  
    >  
  <StackPanel Width="150"  Margin="7" Orientation="Horizontal">  
    <!-- Single pixel line with layout rounding turned OFF.-->  
    <Rectangle UseLayoutRounding="False"  
       Width="45.5" Margin="10" Height="1" Fill="Red"/>  
    <!-- Single pixel line with layout rounding turned ON.-->  
    <Rectangle UseLayoutRounding="True"  
      Width="45.5" Margin="10" Height="1" Fill="Red"/>  
  </StackPanel>  
  <!-- Background Grid -->  
  <Page.Background>  
    <DrawingBrush  Viewport="0,0,10,10" ViewportUnits="Absolute" TileMode="Tile">  
      <DrawingBrush.Drawing>  
        <DrawingGroup>  
          <GeometryDrawing Brush="White">  
            <GeometryDrawing.Geometry>  
              <RectangleGeometry Rect="0,0,1,1" />  
            </GeometryDrawing.Geometry>  
          </GeometryDrawing>  
          <GeometryDrawing Geometry="M0,0 L1,0 1,0.1, 0,0.1Z " Brush="#CCCCFF" />  
          <GeometryDrawing Geometry="M0,0 L0,1 0.1,1, 0.1,0Z" Brush="#CCCCFF" />  
        </DrawingGroup>  
      </DrawingBrush.Drawing>  
    </DrawingBrush>  
  </Page.Background>  
</Page>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRoundingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UseLayoutRoundingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UseLayoutRoundingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UseLayoutRoundingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable UseLayoutRoundingProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAlignment As VerticalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::VerticalAlignment VerticalAlignment { System::Windows::VerticalAlignment get(); void set(System::Windows::VerticalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalAlignment : System.Windows.VerticalAlignment with get, set" Usage="System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が、Panel またはアイテム コントロールのような親要素内に作成されるときに適用される垂直方向の配置特性を取得または設定します。</summary>
        <value>垂直方向の配置の設定。 既定値は、<see cref="F:System.Windows.VerticalAlignment.Stretch" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに<xref:System.Windows.FrameworkElement.Height%2A>と<xref:System.Windows.FrameworkElement.Width%2A>要素にプロパティが明示的に設定されている場合、これらの測定値はレイアウトを優先このプロパティの設定の通常の結果を取り消す<xref:System.Windows.VerticalAlignment.Stretch>します。  
  
 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]何が実際には、依存関係プロパティのプロパティ アクセサー。 この特定の依存関係プロパティでは、その見かけ上の「既定」値が派生型の要素のクラス、特にコントロールで設定が異なりますがよくあります。 これは 2 つの方法のいずれかで一般的に発生します特定の派生クラスがその既定値を設定するためのさまざまなメタデータ、依存関係プロパティが再登録。またはが適用されている既定のスタイルを異なる方法でその依存関係プロパティの値を設定します。 たとえば、明らかな「既定」の<xref:System.Windows.FrameworkElement.VerticalAlignment%2A>の<xref:System.Windows.Controls.ComboBoxItem>コントロールである<xref:System.Windows.VerticalAlignment.Center>場合でも、<xref:System.Windows.Controls.ComboBoxItem>継承<xref:System.Windows.FrameworkElement.VerticalAlignment%2A>から直接<xref:System.Windows.FrameworkElement>。 これは、既定のスタイル内でその値がリセットされたため<xref:System.Windows.Controls.ComboBoxItem>スタイルのコントロール テンプレート内で。  
  
 <xref:System.Windows.Controls.Canvas> 使用しない<xref:System.Windows.FrameworkElement.VerticalAlignment%2A>ため、レイアウトの作成時に<xref:System.Windows.Controls.Canvas>絶対位置に基づきます。  
  
 継承するときに<xref:System.Windows.Controls.ComboBoxItem>またはその派生クラス、<xref:System.Windows.Controls.ComboBoxItem>にするには、このプロパティの既定値を再定義<xref:System.Windows.VerticalAlignment.Center>します。  
  
<a name="dependencyPropertyInfo_VerticalAlignment"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VerticalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.VerticalAlignment" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素内でビジュアル子要素の数を取得します。</summary>
        <value>この要素のビジュアル子要素の数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement>の実装<xref:System.Windows.FrameworkElement.VisualChildrenCount%2A>常に 0 個または 1 を返します。 1 つを超える可能性のあるビジュアル子コレクションを保持するクラスは、この両方のプロパティをオーバーライドする必要がありますと<xref:System.Windows.FrameworkElement.GetVisualChild%2A>します。  
  
 このプロパティはレイアウトのオーバーライドを実装するため、現在の子コレクションの上限を判断する一般的に使用されます (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>、 <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>)。  
  
   
  
## Examples  
 次の例は、カスタム装飾で宣言されている値の使用方法を示しています、<xref:System.Windows.Media.VisualCollection>の上書きによって値は、複数のビジュアル子を保持し、これらを報告する<xref:System.Windows.FrameworkElement.VisualChildrenCount%2A>と<xref:System.Windows.FrameworkElement.GetVisualChild%2A>します。  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>クラスは、子要素のコレクションでは、複数のビジュアル子をサポートする場合は、そのコレクション内の要素の数を返すには、このプロパティをオーバーライドします。 コレクション オブジェクト自体が、カウントを返した場合であっても、これを行う必要があります。 WPF フレームワーク レベル要素のレイアウト ロジックは、すべての要素がを通じて有効なカウントを返すこと前提としています。 その<see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" />プロパティ。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public double Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Width : double with get, set" Usage="System.Windows.FrameworkElement.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の幅を取得または設定します。</summary>
        <value>要素の幅 ([!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 単位)。 既定値は <see cref="F:System.Double.NaN" /> です。 この値は 0.0 以上にする必要があります。 上限については、「解説」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これで 3 つのプロパティの 1 つは<xref:System.Windows.FrameworkElement>幅情報を指定します。  その他の 2 つは<xref:System.Windows.FrameworkElement.MinWidth%2A>と<xref:System.Windows.FrameworkElement.MaxWidth%2A>します。  これらの値の間に競合がある場合は、実際の幅を決定するためのアプリケーションの順序は最初<xref:System.Windows.FrameworkElement.MinWidth%2A>し、適用する必要があります<xref:System.Windows.FrameworkElement.MaxWidth%2A>、最後に、境界内にある場合これらの各<xref:System.Windows.FrameworkElement.Width%2A>します。  
  
 このプロパティの戻り値は、任意の値に設定されたのと同じでは常にします。 これに対しての値、<xref:System.Windows.FrameworkElement.ActualWidth%2A>異なる場合があります。 レイアウトには、何らかの理由により推奨されるサイズが拒否が可能性があります。 また、レイアウト システム自体が、プロパティ システムの<xref:System.Windows.FrameworkElement.Width%2A>が処理されていない特定のプロパティの変更をまだサイズ変更とします。  
  
 さらに許容される<xref:System.Double>値、このプロパティにすることができますも<xref:System.Double.NaN?displayProperty=nameWithType>します。 これは、自動サイズ変更動作を指定する方法です。 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] "Auto"(大文字と小文字は区別されません)、自動サイズ変更動作を有効にする、文字列に値を設定します。 自動サイズ変更動作は、要素の高さは、幅を使用することを意味します。 ただし特定のコントロールがサイズ変更動作は具体的には、再度有効にしない限り、自動を無効にするには既定のスタイルの既定値を頻繁に提供することに注意してください。  
  
 非決定的の上限値のバインドがあるだけでなく、検証チェック<xref:System.Windows.FrameworkElement.Width%2A>レイアウト システムによって強制適用されるは (これは非常に大きい番号より大きい<xref:System.Single.MaxValue?displayProperty=nameWithType>よりも小さい<xref:System.Double.MaxValue?displayProperty=nameWithType>)。 この上限値を超過した場合、要素は表示されませんし、例外はスローされません。 設定しない<xref:System.Windows.FrameworkElement.Width%2A>の表示可能な最大サイズは、非決定的であるこの上限を超える可能性がありますよりも大幅に大きい値にします。  
  
<a name="xamlAttributeUsage_Width"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object Width="double"/>  
- or -  
<object Width ="qualifiedDouble"/>  
- or -  
<object Width ="Auto"/>  
```  
  
<a name="xamlValues_Width"></a>   
## <a name="xaml-values"></a>XAML 値  
 *double*  
 <xref:System.Double>  
  
 文字列表現を<xref:System.Double>0.0 以上の値。 上限については、「解説」を参照してください。 この値として解釈されます、[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]測定します。 文字列が必要な 10 進数のポイントを明示的に含まれません。 値のインスタンス`1`は許容されます。  
  
 *qualifiedDouble*  
 A*二重*値、上記と続く単位の次の宣言文字列のいずれか: `px`、 `in`、 `cm`、`pt`します。  
  
 `px` (既定値) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 in 96px = =  
  
 `cm` センチメートル; は、します。1cm==(96/2.54) px  
  
 `pt` ポイントです。1pt==(96/72) px  
  
 `Auto`  
 自動サイズ調整の動作を有効にします。 「解説」を参照してください。  
  
<a name="dependencyPropertyInfo_Width"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.FrameworkElement.WidthProperty>|  
|メタデータのプロパティを設定するには `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.WidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.WidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkElement.Width" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>