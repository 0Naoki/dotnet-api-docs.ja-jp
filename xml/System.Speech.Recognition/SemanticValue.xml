<Type Name="SemanticValue" FullName="System.Speech.Recognition.SemanticValue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6d8e2917a3be2218468aa2534710f76c33960cbf" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SemanticValue : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;string,System.Speech.Recognition.SemanticValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit SemanticValue extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.SemanticValue" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SemanticValue&#xA;Implements ICollection(Of KeyValuePair(Of String, SemanticValue)), IDictionary(Of String, SemanticValue), IEnumerable(Of KeyValuePair(Of String, SemanticValue))" />
  <TypeSignature Language="C++ CLI" Value="public ref class SemanticValue sealed : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;, System::Collections::Generic::IDictionary&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("'{_keyName}'= {Value}  -  Children = {_dictionary.Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Speech.Recognition.SemanticValue/SemanticValueDebugDisplay))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="70bca-101">認識された語句のセマンティックの組織を表します。</span>
      <span class="sxs-lookup">
        <span data-stu-id="70bca-101">Represents the semantic organization of a recognized phrase.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70bca-102"><xref:System.Speech.Recognition.SemanticValue> System.Speech でセマンティック テクノロジを実装する主要なオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="70bca-102"><xref:System.Speech.Recognition.SemanticValue> is the primary object that implements the semantic technology in System.Speech.</span></span> <span data-ttu-id="70bca-103">セマンティクス解釈は、オーディオ入力が正しく解釈する認識エンジンで使用するためのルールを定義する文法を使用できます。</span><span class="sxs-lookup"><span data-stu-id="70bca-103">Semantic interpretation allows grammars to define rules for use by a recognition engine to correctly interpret audio input.</span></span> <span data-ttu-id="70bca-104">セマンティクス解釈は、認識エンジンのみを返す単語や単語のシーケンスを認識するのではなくより簡単に処理できる、ようにそれらの結果を整理することもできます。</span><span class="sxs-lookup"><span data-stu-id="70bca-104">Semantic interpretation also enables recognition engines to organize their results so that they can be more easily processed, rather than returning only recognized words and sequences of words.</span></span>  
  
 <span data-ttu-id="70bca-105">たとえば、「赤の背景を変更する」を解析して操作した前に、アプリケーションで解釈する必要があります、認識エンジンを出力します。</span><span class="sxs-lookup"><span data-stu-id="70bca-105">For example, the recognition engine output "Change background to red" would have to be parsed and interpreted by an application before it could be acted upon.</span></span> <span data-ttu-id="70bca-106">A<xref:System.Speech.Recognition.Grammar>オブジェクトは、セマンティクスの解釈という語句が 2 つセマンティック サブ構造体を選択するための背景または前景 (テキスト「バック グラウンド」で表される)、("red"のテキストで表される) の色を選択するため、その他のいずれかを指定して明確に処理することを指定できます。</span><span class="sxs-lookup"><span data-stu-id="70bca-106">A <xref:System.Speech.Recognition.Grammar> object can specify a semantic interpretation to make processing clearer by specifying that the phrase has two semantic substructures, one for selecting background or foreground (represented by the text "background"), and the other for selecting color (represented by the text "red").</span></span>  
  
 <span data-ttu-id="70bca-107">System.Speech のツリーで認識操作のセマンティクスを表す<xref:System.Speech.Recognition.SemanticValue>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="70bca-107">System.Speech represents the semantics of a recognition operation in a tree of <xref:System.Speech.Recognition.SemanticValue> objects.</span></span>  
  
 <span data-ttu-id="70bca-108">各<xref:System.Speech.Recognition.SemanticValue>インスタンスには、次が含まれています。</span><span class="sxs-lookup"><span data-stu-id="70bca-108">Each <xref:System.Speech.Recognition.SemanticValue> instance includes the following:</span></span>  
  
-   <span data-ttu-id="70bca-109"><xref:System.Object>によりアクセスされる、<xref:System.Speech.Recognition.SemanticValue.Value%2A>のインスタンスのキーに使用する、プロパティ、<xref:System.Speech.Recognition.SemanticValue>です。</span><span class="sxs-lookup"><span data-stu-id="70bca-109">An <xref:System.Object>, accessed by means of the <xref:System.Speech.Recognition.SemanticValue.Value%2A> property, used to key the instance of the <xref:System.Speech.Recognition.SemanticValue>.</span></span>  
  
-   <span data-ttu-id="70bca-110">によって返される、意味的な解析の精度のメジャー、<xref:System.Speech.Recognition.SemanticValue.Confidence%2A>プロパティです。</span><span class="sxs-lookup"><span data-stu-id="70bca-110">A measure of the accuracy of semantic parsing, returned by the <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> property.</span></span>  
  
-   <span data-ttu-id="70bca-111">名前/値ペアのコレクション (<xref:System.Collections.Generic.KeyValuePair%602>) も、子オブジェクトの<xref:System.Speech.Recognition.SemanticValue>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="70bca-111">A collection of name/value pairs (<xref:System.Collections.Generic.KeyValuePair%602>) of child objects, which are also <xref:System.Speech.Recognition.SemanticValue> instances.</span></span> <span data-ttu-id="70bca-112">子ノードが経由でアクセスできる、<xref:System.Speech.Recognition.SemanticValue>の実装<xref:System.Collections.Generic.IDictionary%602>文字列参照キーを使用して、<xref:System.Speech.Recognition.SemanticValue>例を次のインスタンス。</span><span class="sxs-lookup"><span data-stu-id="70bca-112">Child nodes are accessible through the <xref:System.Speech.Recognition.SemanticValue> implementation of <xref:System.Collections.Generic.IDictionary%602> using a string lookup key and a <xref:System.Speech.Recognition.SemanticValue> instance, as in the following example.</span></span>  
  
    ```csharp  
    foreach (KeyValuePair<String, SemanticValue> child in semantics)   
    {  
      Utils.CreateSemanticsTreeNodes(semanticsNode.Nodes, child.Value, child.Key);  
    }  
    ```  
  
 <span data-ttu-id="70bca-113">System.Speech に基づいて認識エンジンの有効なインスタンスを提供する<xref:System.Speech.Recognition.SemanticValue>すべてからの出力の認識、語句を使用してもない明示的なセマンティック構造体。</span><span class="sxs-lookup"><span data-stu-id="70bca-113">Recognition engines based on System.Speech provide valid instances of <xref:System.Speech.Recognition.SemanticValue> for all output from recognition, even for phrases with no explicit semantic structure.</span></span>  
  
 <span data-ttu-id="70bca-114"><xref:System.Speech.Recognition.SemanticValue>インスタンスを使用して、そのフレーズを取得するため、<xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A>プロパティを<xref:System.Speech.Recognition.RecognizedPhrase>オブジェクト (またはから継承されるオブジェクト<xref:System.Speech.Recognition.RecognitionResult>)。</span><span class="sxs-lookup"><span data-stu-id="70bca-114">The <xref:System.Speech.Recognition.SemanticValue> instance for a phrase is obtained using the <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> property on the <xref:System.Speech.Recognition.RecognizedPhrase> object (or objects that inherit from it, such as <xref:System.Speech.Recognition.RecognitionResult>).</span></span>  
  
 <span data-ttu-id="70bca-115"><xref:System.Speech.Recognition.SemanticValue> 非セマンティック構造の認識された語句に取得されたオブジェクトは、によって特徴付けられます。</span><span class="sxs-lookup"><span data-stu-id="70bca-115"><xref:System.Speech.Recognition.SemanticValue> objects obtained for recognized phrases without semantic structure are characterized by:</span></span>  
  
-   <span data-ttu-id="70bca-116">子がないこと (<xref:System.Speech.Recognition.SemanticValue.Count%2A>は 0) です。</span><span class="sxs-lookup"><span data-stu-id="70bca-116">The lack of children (<xref:System.Speech.Recognition.SemanticValue.Count%2A> is 0).</span></span>  
  
-   <span data-ttu-id="70bca-117"><xref:System.Speech.Recognition.SemanticValue.Value%2A> プロパティが `null` です。</span><span class="sxs-lookup"><span data-stu-id="70bca-117">The <xref:System.Speech.Recognition.SemanticValue.Value%2A> property is `null`.</span></span>  
  
-   <span data-ttu-id="70bca-118">1.0、人為的なセマンティック信頼レベル (によって返される<xref:System.Speech.Recognition.SemanticValue.Confidence%2A>)。</span><span class="sxs-lookup"><span data-stu-id="70bca-118">An artificial semantic confidence level of 1.0 (returned by <xref:System.Speech.Recognition.SemanticValue.Confidence%2A>).</span></span>  
  
 <span data-ttu-id="70bca-119">通常、アプリケーションを作成<xref:System.Speech.Recognition.SemanticValue>に追加することを直接いないインスタンス<xref:System.Speech.Recognition.Grammar>を使用してオブジェクト<xref:System.Speech.Recognition.SemanticResultValue>と<xref:System.Speech.Recognition.SemanticResultKey>と共に内で、インスタンス<xref:System.Speech.Recognition.Choices>と<xref:System.Speech.Recognition.GrammarBuilder>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="70bca-119">Typically, applications create <xref:System.Speech.Recognition.SemanticValue> instances indirectly, adding them to <xref:System.Speech.Recognition.Grammar> objects by using <xref:System.Speech.Recognition.SemanticResultValue> and <xref:System.Speech.Recognition.SemanticResultKey> instances,  in conjunction with  <xref:System.Speech.Recognition.Choices> and <xref:System.Speech.Recognition.GrammarBuilder> objects.</span></span>  
  
 <span data-ttu-id="70bca-120">構築を直接、<xref:System.Speech.Recognition.SemanticValue>インスタンスは、厳密に型指定された文法の作成時に便利です。</span><span class="sxs-lookup"><span data-stu-id="70bca-120">Direct construction of a <xref:System.Speech.Recognition.SemanticValue> instance is useful during the creation of strongly-typed grammars.</span></span>  
  
 <span data-ttu-id="70bca-121"><xref:System.Speech.Recognition.SemanticValue> 実装する、 <xref:System.Collections.Generic.IDictionary%602>、 <xref:System.Collections.Generic.ICollection%601>、および<xref:System.Collections.Generic.IEnumerable%601>インターフェイスです。</span><span class="sxs-lookup"><span data-stu-id="70bca-121"><xref:System.Speech.Recognition.SemanticValue> implements the <xref:System.Collections.Generic.IDictionary%602>, <xref:System.Collections.Generic.ICollection%601>, and <xref:System.Collections.Generic.IEnumerable%601> interfaces.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70bca-122">次の例では、ハンドラーを<xref:System.Speech.Recognition.Grammar.SpeechRecognized>イベントの前景色と背景色を変更するコマンドを処理するよう設計されています。</span><span class="sxs-lookup"><span data-stu-id="70bca-122">The following example shows a handler for a <xref:System.Speech.Recognition.Grammar.SpeechRecognized> event designed to handle commands to change foreground and background color.</span></span>  
  
 <span data-ttu-id="70bca-123">ハンドラーを検出することによって基になるセマンティック構造を持たない認識された語句を識別する、 <xref:System.Speech.Recognition.SemanticValue.Count%2A> 0 と<xref:System.Speech.Recognition.SemanticValue.Value%2A>の`null`します。</span><span class="sxs-lookup"><span data-stu-id="70bca-123">The handler identifies recognized phrases that have no underlying semantic structure by detecting a <xref:System.Speech.Recognition.SemanticValue.Count%2A> of zero and a <xref:System.Speech.Recognition.SemanticValue.Value%2A> of `null`.</span></span> <span data-ttu-id="70bca-124">この認識出力は、未加工のテキストを解析して直接が処理されます。</span><span class="sxs-lookup"><span data-stu-id="70bca-124">This recognition output is then processed directly by parsing the raw text.</span></span>  
  
 <span data-ttu-id="70bca-125">それ以外の場合にのハンドラーは、rgb 色の名前、または有効なキーが見つからなかったことを示すために、コマンドでは、フォア グラウンドまたはバック グラウンドで変更するかどうかを決定するのにを取得するのにキーを使用します。</span><span class="sxs-lookup"><span data-stu-id="70bca-125">In other cases, the handler uses keys to obtain the RGB components of a color name, to determine whether the command will change the foreground or background, or to indicate that no valid key was found.</span></span>  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        // and search for "background" or "foreground" in the input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantics keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
  
      // Make sure that text is readable regardless of the background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
  
      // Make sure that text is readable regardless of Foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="70bca-126">
            <see cref="T:System.Speech.Recognition.SemanticValue" /> クラスの新しいインスタンスを初期化します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-126">Initializes a new instance of the <see cref="T:System.Speech.Recognition.SemanticValue" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70bca-127">通常、するは作成できません<xref:System.Speech.Recognition.SemanticValue>オブジェクトを明示的に、以外を厳密に型指定された文法の構築をサポートします。</span><span class="sxs-lookup"><span data-stu-id="70bca-127">Typically, you will not create <xref:System.Speech.Recognition.SemanticValue> objects explicitly, except to support the building of strongly-typed grammars.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemanticValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemanticValue(System::Object ^ value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="70bca-128">
            <see cref="T:System.Speech.Recognition.SemanticValue" /> オブジェクトに格納される情報。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-128">The information to be stored in the <see cref="T:System.Speech.Recognition.SemanticValue" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="70bca-129">
            <see cref="T:System.Speech.Recognition.SemanticValue" /> クラスの新しいインスタンスを初期化して、セマンティクス値を指定します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-129">Initializes a new instance of the <see cref="T:System.Speech.Recognition.SemanticValue" /> class and specifies a semantic value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70bca-130">型に制限はありません`value`を格納します。</span><span class="sxs-lookup"><span data-stu-id="70bca-130">There are no restrictions on the type of `value` to be stored.</span></span>  
  
 <span data-ttu-id="70bca-131">アプリケーションで取得できます`value`を使用して、<xref:System.Speech.Recognition.SemanticValue.Value%2A>プロパティを<xref:System.Speech.Recognition.SemanticValue>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="70bca-131">An application can retrieve `value` by using the <xref:System.Speech.Recognition.SemanticValue.Value%2A> property on a <xref:System.Speech.Recognition.SemanticValue> instance.</span></span>  
  
 <span data-ttu-id="70bca-132">値、<xref:System.Speech.Recognition.SemanticValue.Confidence%2A>プロパティを<xref:System.Speech.Recognition.SemanticValue>インスタンスは、-1 に設定されます。</span><span class="sxs-lookup"><span data-stu-id="70bca-132">The value of the <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> property for the <xref:System.Speech.Recognition.SemanticValue> instance will be set to -1.</span></span>  
  
 <span data-ttu-id="70bca-133">A<xref:System.Speech.Recognition.SemanticValue>これで構築されるメソッドは、キーの名前で参照できることはできません。</span><span class="sxs-lookup"><span data-stu-id="70bca-133">A <xref:System.Speech.Recognition.SemanticValue> constructed with this method cannot be referenced by key name.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemanticValue (string keyName, object value, float confidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string keyName, object value, float32 confidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.#ctor(System.String,System.Object,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (keyName As String, value As Object, confidence As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemanticValue(System::String ^ keyName, System::Object ^ value, float confidence);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="confidence" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="keyName">
          <span data-ttu-id="70bca-134">この <see cref="T:System.Speech.Recognition.SemanticValue" /> インスタンスを参照するために使用できるキー。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-134">A key that can be used to reference this <see cref="T:System.Speech.Recognition.SemanticValue" /> instance.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="70bca-135">
            <see cref="T:System.Speech.Recognition.SemanticValue" /> オブジェクトに格納される情報を含むオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-135">An object containing information to be stored in the <see cref="T:System.Speech.Recognition.SemanticValue" /> object.</span>
          </span>
        </param>
        <param name="confidence">
          <span data-ttu-id="70bca-136">セマンティクス解析の確実性の概算を含む <see langword="float" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-136">A <see langword="float" /> containing an estimate of the certainty of semantic analysis.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="70bca-137">
            <see cref="T:System.Speech.Recognition.SemanticValue" /> クラスの新しいインスタンスを初期化し、セマンティクス値、キー名、信頼レベルを指定します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-137">Initializes a new instance of the <see cref="T:System.Speech.Recognition.SemanticValue" /> class and specifies a semantic value, a key name, and a confidence level.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70bca-138">型に制限はありません`value`を格納します。</span><span class="sxs-lookup"><span data-stu-id="70bca-138">There are no restrictions on the type of `value` to be stored.</span></span>  
  
 <span data-ttu-id="70bca-139">アプリケーションで取得できます`value`を使用して、<xref:System.Speech.Recognition.SemanticValue.Value%2A>プロパティを<xref:System.Speech.Recognition.SemanticValue>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="70bca-139">An application can retrieve `value` by using the <xref:System.Speech.Recognition.SemanticValue.Value%2A> property on a <xref:System.Speech.Recognition.SemanticValue> instance.</span></span>  
  
 <span data-ttu-id="70bca-140">`confidence`パラメーター (によって返される、<xref:System.Speech.Recognition.SemanticValue.Confidence%2A>プロパティを<xref:System.Speech.Recognition.SemanticValue>インスタンス)、0.0 と 1.0 の間にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="70bca-140">The `confidence` parameter (returned by the <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> property on a <xref:System.Speech.Recognition.SemanticValue> instance), should be between 0.0 and 1.0.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Confidence">
      <MemberSignature Language="C#" Value="public float Confidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 Confidence" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Confidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Confidence As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float Confidence { float get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="70bca-141">
            <see cref="T:System.Speech.Recognition.SemanticValue" /> の現在のインスタンスを返すセマンティック解析の正確性について相対計測を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-141">Returns a relative measure of the certainty as to the correctness of the semantic parsing that returned the current instance of <see cref="T:System.Speech.Recognition.SemanticValue" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="70bca-142">
            <see cref="T:System.Speech.Recognition.SemanticValue" /> の現在のインスタンスを返すセマンティック解析の確実性の相対計測である <see langword="float" /> を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-142">Returns a <see langword="float" /> that is a relative measure of the certainty of semantic parsing that returned the current instance of <see cref="T:System.Speech.Recognition.SemanticValue" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70bca-143"><xref:System.Speech.Recognition.SemanticValue.Confidence%2A?displayProperty=nameWithType>プロパティで、セマンティック解析の正確性の測定結果が返される必要がありますと混同しないで、<xref:System.Speech.Recognition.RecognizedPhrase.Confidence%2A?displayProperty=nameWithType>プロパティで、音声認識の精度のメジャーを返します。</span><span class="sxs-lookup"><span data-stu-id="70bca-143">The <xref:System.Speech.Recognition.SemanticValue.Confidence%2A?displayProperty=nameWithType> property, which returns a measure of the correctness of semantic parsing, should not be confused with the <xref:System.Speech.Recognition.RecognizedPhrase.Confidence%2A?displayProperty=nameWithType> property, which returns a measure of the accuracy of speech recognition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70bca-144">次の例は、再帰的にスキャンするために使用し、として情報 (信頼度を含む) を表示、 <xref:System.Windows.Forms.TreeNodeCollection>、またはノードとのセマンティクスのツリー構造を構成するために使用、語句を認識します。</span><span class="sxs-lookup"><span data-stu-id="70bca-144">The following example is used to recursively traverse and then display information (including confidence) as a <xref:System.Windows.Forms.TreeNodeCollection>, or as the nodes making up the tree structure of the semantics used to recognize a phrase.</span></span>  
  
```csharp  
internal static void CreateSemanticsTreeNodes(  
        TreeNodeCollection nodes,  
        SemanticValue semantics,  
        String name)   
{  
  string semanticsText =   
      String.Format("  {0}  (Confidence {1})", name,semantics.Confidence);  
  
  // Format integers as hexadecimal.  
  if (semantics.Value == null )  
  {  
    semanticsText = semanticsText + " = null";  
  }  
  else if (semantics.Value.GetType() == typeof(int))   
  {  
    semanticsText = String.Format("{0} = {1:X} ", semanticsText, semantics.Value);  
  }   
  else   
  {  
    semanticsText = semanticsText + " = " + semantics.Value.ToString();  
  }  
  
  TreeNode semanticsNode = new TreeNode(semanticsText);  
  foreach (KeyValuePair<String, SemanticValue> child in semantics)   
  {  
    CreateSemanticsTreeNodes(semanticsNode.Nodes, child.Value, child.Key);  
  }  
  nodes.Add(semanticsNode);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue})" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As KeyValuePair(Of String, SemanticValue)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt; item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="70bca-145">キー文字列の任意の値にインスタンス化された <see cref="T:System.Collections.Generic.KeyValuePair`2" /> のインスタンスと <see cref="T:System.Speech.Recognition.SemanticValue" /> のインスタンス。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-145">An instance of <see cref="T:System.Collections.Generic.KeyValuePair`2" /> instantiated for a given value of a key string and a <see cref="T:System.Speech.Recognition.SemanticValue" /> instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="70bca-146">現在の <see cref="T:System.Speech.Recognition.SemanticValue" /> インスタンス コレクションにキー/値ペアとして表された <see cref="T:System.Speech.Recognition.SemanticValue" /> の特定のキーと特定のインスタンスが含まれるかどうかを示します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-146">Indicates whether the current <see cref="T:System.Speech.Recognition.SemanticValue" /> instance collection contains a specific key and a specific instance of <see cref="T:System.Speech.Recognition.SemanticValue" /> expressed as a key/value pair.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="70bca-147">現在の <see cref="T:System.Speech.Recognition.SemanticValue" /> に、指定した値のキー文字列の <c>KeyValuePair&lt;String, SemanticValue&gt;</c> インスタンスと <see cref="T:System.Speech.Recognition.SemanticValue" /> が含まれている場合は、<see langword="true" /> である <see langword="bool" /> を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-147">Returns a <see langword="bool" /> which is <see langword="true" /> if the current <see cref="T:System.Speech.Recognition.SemanticValue" /> contains an instance of <c>KeyValuePair&lt;String, SemanticValue&gt;</c> for a specified value of the key string and the <see cref="T:System.Speech.Recognition.SemanticValue" />.</span>
          </span>
          <span data-ttu-id="70bca-148">それ以外の場合は、<see langword="false" /> が返されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-148">Otherwise, <see langword="false" /> is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.ContainsKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="70bca-149">現在の <see cref="T:System.String" /> の下の <see cref="T:System.Speech.Recognition.SemanticValue" /> 子インスタンスを識別するために使用されるキーの文字列を含む <see cref="T:System.Speech.Recognition.SemanticValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-149">
              <see cref="T:System.String" /> containing the key string used to identify a child instance of <see cref="T:System.Speech.Recognition.SemanticValue" /> under the current <see cref="T:System.Speech.Recognition.SemanticValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="70bca-150">現在の <see cref="T:System.Speech.Recognition.SemanticValue" /> インスタンス コレクションに、指定されたキー文字列を持つ子 <see cref="T:System.Speech.Recognition.SemanticValue" /> インスタンスが含まれるかどうかを示します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-150">Indicates whether the current <see cref="T:System.Speech.Recognition.SemanticValue" /> instance collection contains a child <see cref="T:System.Speech.Recognition.SemanticValue" /> instance with a given key string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="70bca-151">文字列 <paramref name="key" /> でタグ付けされた子インスタンス <see cref="T:System.Speech.Recognition.SemanticValue" /> が見つかった場合は、<see langword="bool" />、<see langword="true" /> を返します。見つからなかった場合は <see langword="false" /> を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-151">Returns a <see langword="bool" />, <see langword="true" /> if a child instance <see cref="T:System.Speech.Recognition.SemanticValue" /> tagged with the string <paramref name="key" /> is found, <see langword="false" /> if not.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70bca-152">キーの値を確認する例については、実行時にデータにアクセスすることができますのみ*セマンティック ["myKey"]。値*、し、例外が生成されます。</span><span class="sxs-lookup"><span data-stu-id="70bca-152">You can only access data by key value at runtime, for example to check *semantic["myKey"].Value*, and this generates an exception.</span></span> <span data-ttu-id="70bca-153">オブジェクトをクエリすることをお勧め<xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A>使用する前に<xref:System.Speech.Recognition.SemanticValue.Item%2A>の特定のインスタンスで<xref:System.Speech.Recognition.SemanticValue>です。</span><span class="sxs-lookup"><span data-stu-id="70bca-153">We recommend that you query the object with <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> before using <xref:System.Speech.Recognition.SemanticValue.Item%2A> with a given instance of <xref:System.Speech.Recognition.SemanticValue>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70bca-154">次の例では、ハンドラーを<xref:System.Speech.Recognition.Grammar.SpeechRecognized>イベントの前景色と背景色を変更するコマンドを処理するよう設計されています。</span><span class="sxs-lookup"><span data-stu-id="70bca-154">The following example shows a handler for a <xref:System.Speech.Recognition.Grammar.SpeechRecognized> event designed to handle commands to change foreground and background color.</span></span>  
  
 <span data-ttu-id="70bca-155">語句が認識されますが、できません意味構造を処理するを使用して適切なキーの有無が確認ハンドラー <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> (`applyChgToBackground`、 `colorRGBValueList`、または`colorStringList)`、意味的に編成されたデータを処理します。</span><span class="sxs-lookup"><span data-stu-id="70bca-155">After handling phrases that are recognized but have no semantic structure, the handler checks for the presence of appropriate keys using <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> (`applyChgToBackground`, `colorRGBValueList`, or `colorStringList)`,  and then processes the semantically organized data.</span></span>  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        // searching for background or foreground in input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantics keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
      // Make sure that text is readable regardless of background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
      // Make sure that text is readable regardless of Foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="70bca-156">現在の <see cref="T:System.Speech.Recognition.SemanticValue" /> インスタンスにある子 <see cref="T:System.Speech.Recognition.SemanticValue" /> オブジェクトの数を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-156">Returns the number of child <see cref="T:System.Speech.Recognition.SemanticValue" /> objects under the current <see cref="T:System.Speech.Recognition.SemanticValue" /> instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="70bca-157">現在の <see cref="T:System.Speech.Recognition.SemanticValue" /> にある子 <see cref="T:System.Speech.Recognition.SemanticValue" /> オブジェクトの数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-157">The number of child <see cref="T:System.Speech.Recognition.SemanticValue" /> objects under the current <see cref="T:System.Speech.Recognition.SemanticValue" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70bca-158">セマンティックの解析を行わない認識の結果を使用して常にある、<xref:System.Speech.Recognition.SemanticValue.Count%2A>ゼロの値と同様に、<xref:System.Speech.Recognition.SemanticValue.Value%2A>の`null`します。</span><span class="sxs-lookup"><span data-stu-id="70bca-158">Recognition results that do not make use of semantic parsing always have a <xref:System.Speech.Recognition.SemanticValue.Count%2A> value of zero, as well as a <xref:System.Speech.Recognition.SemanticValue.Value%2A> of `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70bca-159">次の例では、ハンドラーを<xref:System.Speech.Recognition.Grammar.SpeechRecognized>イベントの前景色と背景色を変更するコマンドを処理するよう設計されています。</span><span class="sxs-lookup"><span data-stu-id="70bca-159">The following example shows a handler for a <xref:System.Speech.Recognition.Grammar.SpeechRecognized> event designed to handle commands to change foreground and background color.</span></span>  
  
 <span data-ttu-id="70bca-160">ハンドラーを検出することによって基になるセマンティック構造を持たない認識された語句を識別する、 <xref:System.Speech.Recognition.SemanticValue.Count%2A> 0 と<xref:System.Speech.Recognition.SemanticValue.Value%2A>の`null`します。</span><span class="sxs-lookup"><span data-stu-id="70bca-160">The handler identifies recognized phrases that have no underlying semantic structure by detecting a <xref:System.Speech.Recognition.SemanticValue.Count%2A> of zero and a <xref:System.Speech.Recognition.SemanticValue.Value%2A> of `null`.</span></span> <span data-ttu-id="70bca-161">この認識出力は、未加工のテキストを解析して直接が処理されます。</span><span class="sxs-lookup"><span data-stu-id="70bca-161">This recognition output is then processed directly by parsing the raw text.</span></span>  
  
 <span data-ttu-id="70bca-162">それ以外の場合にのハンドラーは、rgb 色の名前、または有効なキーが見つからなかったことを示すために、コマンドでは、フォア グラウンドまたはバック グラウンドで変更するかどうかを決定するのにを取得するのにキーを使用します。</span><span class="sxs-lookup"><span data-stu-id="70bca-162">In other cases, the handler uses keys to obtain the RGB components of a color name, to determine whether the command will change the foreground or background, or to indicate that no valid key was found.</span></span>  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        //  searching for background or foreground in input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantics keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
      // Make sure that text is readable regardless of background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
  
      // Make sure that text is readable regardless of Foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="70bca-163">評価するオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-163">The object to evaluate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="70bca-164">指定したオブジェクトが <c>SemanticValue</c> のインスタンスで、現在の <c>SemanticValue</c> インスタンスと等しいかどうかを判定します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-164">Determines whether a specified object is an instance of <c>SemanticValue</c> and equal to the current instance of <c>SemanticValue</c>.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="70bca-165">指定された Object が現在の Object と等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-165">
              <see langword="true" /> if the specified Object is equal to the current Object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="70bca-166">
            <c>SemanticValue</c> オブジェクト用のハッシュ コードを提供します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-166">Provides a hash code for a <c>SemanticValue</c> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="70bca-167">現在の <see cref="T:System.Speech.Recognition.SemanticValue" /> オブジェクトのハッシュ コード。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-167">A hash code for the current <see cref="T:System.Speech.Recognition.SemanticValue" /> object.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Speech.Recognition.SemanticValue this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Speech.Recognition.SemanticValue Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As String) As SemanticValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Speech::Recognition::SemanticValue ^ default[System::String ^] { System::Speech::Recognition::SemanticValue ^ get(System::String ^ key); void set(System::String ^ key, System::Speech::Recognition::SemanticValue ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.SemanticValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="70bca-168">
            <see cref="T:System.Speech.Recognition.SemanticValue" /> の現在のインスタンスに含まれている <see langword="KeyValuePair&lt;String, SemanticValue&gt;" /> のキー。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-168">A key for a <see langword="KeyValuePair&lt;String, SemanticValue&gt;" /> contained in the current instance of <see cref="T:System.Speech.Recognition.SemanticValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="70bca-169">現在の <see cref="T:System.Speech.Recognition.SemanticValue" /> に属する子 <see cref="T:System.Speech.Recognition.SemanticValue" /> インスタンスを返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-169">Returns child <see cref="T:System.Speech.Recognition.SemanticValue" /> instances that  belong to the current <see cref="T:System.Speech.Recognition.SemanticValue" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="70bca-170">現在の子を返します<see cref="T:System.Speech.Recognition.SemanticValue" />をキー値のペアの一部としてインデックスを作成できます: <c>KeyValuePair&lt;文字列、</c><c>SemanticValue&gt;</c>です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-170">Returns a child of the current <see cref="T:System.Speech.Recognition.SemanticValue" /> that can be indexed as part of a key value pair: <c>KeyValuePair&lt;String,</c><c>SemanticValue&gt;</c>.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70bca-171"><xref:System.Speech.Recognition.SemanticValue.Item%2A>は読み取り専用とメンバーが変更された場合に例外を生成します。</span><span class="sxs-lookup"><span data-stu-id="70bca-171">The <xref:System.Speech.Recognition.SemanticValue.Item%2A> is read-only and generates exceptions if members are modified.</span></span>  
  
 <span data-ttu-id="70bca-172">キーの値を確認する例については、コンパイル時ではなく、実行時にデータにアクセスすることができますのみ`semantic["myKey"].Value`です。</span><span class="sxs-lookup"><span data-stu-id="70bca-172">You can only access data by key value at run-time, not at compile-time, for example to check `semantic["myKey"].Value`.</span></span> <span data-ttu-id="70bca-173">存在しないキーを指定するには、例外が生成されます。</span><span class="sxs-lookup"><span data-stu-id="70bca-173">Specifying a key that is not present generates an exception.</span></span>  
  
 <span data-ttu-id="70bca-174">指定されたキーの存在を検出するを使用して、<xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A>プロパティを<xref:System.Speech.Recognition.SemanticValue>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="70bca-174">To detect the presence of a given key, use the <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> property on an <xref:System.Speech.Recognition.SemanticValue> instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70bca-175">次の例では、ハンドラーを<xref:System.Speech.Recognition.Grammar.SpeechRecognized>イベントの前景色と背景色を変更するコマンドを処理するよう設計されています。</span><span class="sxs-lookup"><span data-stu-id="70bca-175">The following example shows a handler for a <xref:System.Speech.Recognition.Grammar.SpeechRecognized> event designed to handle commands to change foreground and background color.</span></span>  
  
 <span data-ttu-id="70bca-176">構造体のセマンティクスを持たない認識された語句を処理するを使用して適切なキーの有無が確認ハンドラー <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> (`applyChgToBackground`、 `colorRGBValueList`、または`colorStringList)`、しを使用して、<xref:System.Speech.Recognition.SemanticValue.Item%2A>ノードを取得するプロパティ必要な情報です。</span><span class="sxs-lookup"><span data-stu-id="70bca-176">After handling recognized phrases that have no semantic structure, the handler checks for the presence of appropriate keys using <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> (`applyChgToBackground`, `colorRGBValueList`, or `colorStringList)`, and then uses the <xref:System.Speech.Recognition.SemanticValue.Item%2A> property to obtain the nodes with needed information.</span></span>  
  
 <span data-ttu-id="70bca-177">使用<xref:System.Speech.Recognition.SemanticValue.Item%2A>下が強調表示されます。</span><span class="sxs-lookup"><span data-stu-id="70bca-177">The use of <xref:System.Speech.Recognition.SemanticValue.Item%2A> is highlighted below.</span></span>  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        //  searching for background or foreground in input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantic keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
      // Make sure that text is readable regardless of background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
  
      // Make sure that text is readable regardless of the foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">
          <span data-ttu-id="70bca-178">
            <see cref="T:System.Speech.Recognition.SemanticValue" /> の現在のインスタンスの子メンバーに、<paramref name="key" /> パラメーターに一致するキーがない場合にスローされます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-178">Thrown if no child member of the current instance of <see cref="T:System.Speech.Recognition.SemanticValue" /> has the key matching the <paramref name="key" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="70bca-179">コードが、指定されたインデックス位置の <see cref="T:System.Speech.Recognition.SemanticValue" /> を変更しようとするとスローされます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-179">Thrown if code attempts to change the <see cref="T:System.Speech.Recognition.SemanticValue" /> at a given index.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt; key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt; key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue})" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As KeyValuePair(Of String, SemanticValue)) Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Add(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt; key) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Clear">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Clear() = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.CopyTo (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As KeyValuePair(Of String, SemanticValue)(), index As Integer) Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt; ^ array, int index) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt; key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt; key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue})" />
      <MemberSignature Language="VB.NET" Value="Function Remove (key As KeyValuePair(Of String, SemanticValue)) As Boolean Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Remove(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt; key) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Add">
      <MemberSignature Language="C#" Value="void IDictionary&lt;string,SemanticValue&gt;.Add (string key, System.Speech.Recognition.SemanticValue value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Add(string key, class System.Speech.Recognition.SemanticValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Add(System.String,System.Speech.Recognition.SemanticValue)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As String, value As SemanticValue) Implements IDictionary(Of String, SemanticValue).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Add(System::String ^ key, System::Speech::Recognition::SemanticValue ^ value) = System::Collections::Generic::IDictionary&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;string&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;string&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection(Of String) Implements IDictionary(Of String, SemanticValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys { System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Remove">
      <MemberSignature Language="C#" Value="bool IDictionary&lt;string,SemanticValue&gt;.Remove (string key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Remove(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Remove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function Remove (key As String) As Boolean Implements IDictionary(Of String, SemanticValue).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Remove(System::String ^ key) = System::Collections::Generic::IDictionary&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.TryGetValue">
      <MemberSignature Language="C#" Value="bool IDictionary&lt;string,SemanticValue&gt;.TryGetValue (string key, out System.Speech.Recognition.SemanticValue value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.TryGetValue(string key, [out] class System.Speech.Recognition.SemanticValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#TryGetValue(System.String,System.Speech.Recognition.SemanticValue@)" />
      <MemberSignature Language="VB.NET" Value="Function TryGetValue (key As String, ByRef value As SemanticValue) As Boolean Implements IDictionary(Of String, SemanticValue).TryGetValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.TryGetValue(System::String ^ key, [Runtime::InteropServices::Out] System::Speech::Recognition::SemanticValue ^ % value) = System::Collections::Generic::IDictionary&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;::TryGetValue;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;System.Speech.Recognition.SemanticValue&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class System.Speech.Recognition.SemanticValue&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection(Of SemanticValue) Implements IDictionary(Of String, SemanticValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;System::Speech::Recognition::SemanticValue ^&gt; ^ System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values { System::Collections::Generic::ICollection&lt;System::Speech::Recognition::SemanticValue ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Speech.Recognition.SemanticValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, SemanticValue)) Implements IEnumerable(Of KeyValuePair(Of String, SemanticValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="70bca-180">コレクションを反復処理する列挙子を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-180">Returns an enumerator that iterates through a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="70bca-181">コレクションを反復処理する列挙子を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-181">Returns an enumerator that iterates through a collection.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="70bca-182">現在の <see cref="T:System.Speech.Recognition.SemanticValue" /> に含まれている情報を返す、読み取り専用プロパティ。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-182">A read-only property that returns the information contained in the current <see cref="T:System.Speech.Recognition.SemanticValue" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="70bca-183">現在の <see cref="T:System.Object" /> インスタンスに格納された情報を含む <see cref="T:System.Speech.Recognition.SemanticValue" /> インスタンスを返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="70bca-183">Returns an <see cref="T:System.Object" /> instance containing the information stored in the current <see cref="T:System.Speech.Recognition.SemanticValue" /> instance.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70bca-184">セマンティックの解析を行わない認識の結果を使用して常にある、<xref:System.Speech.Recognition.SemanticValue.Value%2A>の`null`と<xref:System.Speech.Recognition.SemanticValue.Count%2A>0 のプロパティです。</span><span class="sxs-lookup"><span data-stu-id="70bca-184">Recognition results which do not make use of semantic parsing always have a <xref:System.Speech.Recognition.SemanticValue.Value%2A> of `null` and a <xref:System.Speech.Recognition.SemanticValue.Count%2A> property of zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70bca-185">次の例は、再帰的にスキャンするために使用し、として情報 (信頼度を含む) を表示、 <xref:System.Windows.Forms.TreeNodeCollection>、またはノードとのセマンティクスのツリー構造を構成するために使用、語句を認識します。</span><span class="sxs-lookup"><span data-stu-id="70bca-185">The following example is used to recursively traverse and then display information (including confidence) as a <xref:System.Windows.Forms.TreeNodeCollection>, or as the nodes making up the tree structure of the semantics used to recognize a phrase.</span></span>  
  
```csharp  
internal static void CreateSemanticsTreeNodes(  
          TreeNodeCollection nodes,  
          SemanticValue semantics,  
          String name)   
{  
  string semanticsText =   
      String.Format("  {0} ( Confidence {1})", name,semantics.Confidence);  
  
  // Format integers as hexadecimal.  
  if (semantics.Value == null )  
  {  
    semanticsText = semanticsText + " = null";  
  }  
  else if (semantics.Value.GetType() == typeof(int))   
  {  
    semanticsText = String.Format("{0} = {1:X} ", semanticsText, semantics.Value);  
  }  
  else   
  {  
    semanticsText = semanticsText + " = " + semantics.Value.ToString();  
  }  
  
  TreeNode semanticsNode = new TreeNode(semanticsText);  
  foreach (KeyValuePair<String, SemanticValue> child in semantics)   
  {  
    CreateSemanticsTreeNodes(semanticsNode.Nodes, child.Value, child.Key);  
  }  
  nodes.Add(semanticsNode);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>