<Type Name="Utf8JsonReader" FullName="System.Text.Json.Utf8JsonReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f96f08bbedddf791c3a57f3e7a62c982af293c15" /><Meta Name="ms.sourcegitcommit" Value="406d23aba879fbb482c6da0f64c8ef9494f6a944" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="07/31/2019" /><Meta Name="ms.locfileid" Value="68686107" /></Metadata><TypeSignature Language="C#" Value="public struct Utf8JsonReader" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Utf8JsonReader extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Text.Json.Utf8JsonReader" />
  <TypeSignature Language="VB.NET" Value="Public Structure Utf8JsonReader" />
  <TypeSignature Language="C++ CLI" Value="public value class Utf8JsonReader" />
  <TypeSignature Language="F#" Value="type Utf8JsonReader = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Json</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.IsByRefLike</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="5a93a-101">UTF-8 でエンコードされた JSON テキストに対する前方参照、読み取り専用のアクセスのために高パフォーマンスの API を提供します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-101">Provides a high-performance API for forward-only, read-only access to the UTF-8 encoded JSON text.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5a93a-102">`Utf8JsonReader`キャッシュを使用せずにテキストを順番に処理し、既定では[JSON RFC](https://tools.ietf.org/html/rfc8259)に厳密に準拠します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-102">`Utf8JsonReader` processes the text sequentially with no caching and by default adheres strictly to the [JSON RFC](https://tools.ietf.org/html/rfc8259).</span></span>

<span data-ttu-id="5a93a-103">が`Utf8JsonReader`無効な JSON を検出した<xref:System.Text.Json.JsonException>場合は、行の行番号やバイト位置などの基本的なエラー情報を使用してをスローします。</span><span class="sxs-lookup"><span data-stu-id="5a93a-103">When `Utf8JsonReader` encounters invalid JSON, it throws a <xref:System.Text.Json.JsonException>  with basic error information like line number and byte position on the line.</span></span>

<span data-ttu-id="5a93a-104">この型は ref 構造体であるため、非同期的には直接サポートされません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-104">Since this type is a ref struct, it doesn't directly support async.</span></span> <span data-ttu-id="5a93a-105">ただし、不完全なデータを読み取って、さらに多くのデータが表示された場合は、再入によるサポートを提供します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-105">However, it does provide support for reentrancy to read incomplete data and to continue reading once more data is presented.</span></span>

<span data-ttu-id="5a93a-106">コメントの読み取り中またはスキップを許可するときに、最大の深さを設定<xref:System.Text.Json.JsonReaderState>できるようにするには、のインスタンスを作成してリーダーに渡します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-106">To be able to set max depth while reading OR allow skipping comments, create an instance of <xref:System.Text.Json.JsonReaderState> and pass it to the reader.</span></span>

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (System.Buffers.ReadOnlySequence&lt;byte&gt; jsonData, System.Text.Json.JsonReaderOptions options = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Buffers.ReadOnlySequence`1&lt;unsigned int8&gt; jsonData, valuetype System.Text.Json.JsonReaderOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.Buffers.ReadOnlySequence{System.Byte},System.Text.Json.JsonReaderOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (jsonData As ReadOnlySequence(Of Byte), Optional options As JsonReaderOptions = null)" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader : System.Buffers.ReadOnlySequence&lt;byte&gt; * System.Text.Json.JsonReaderOptions -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.Buffers.ReadOnlySequence&lt;System.Byte&gt;" />
        <Parameter Name="options" Type="System.Text.Json.JsonReaderOptions" />
      </Parameters>
      <Docs>
        <param name="jsonData">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (ReadOnlySpan&lt;byte&gt; jsonData, System.Text.Json.JsonReaderOptions options = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; jsonData, valuetype System.Text.Json.JsonReaderOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.ReadOnlySpan{System.Byte},System.Text.Json.JsonReaderOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (jsonData As ReadOnlySpan(Of Byte), Optional options As JsonReaderOptions = null)" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader : ReadOnlySpan&lt;byte&gt; * System.Text.Json.JsonReaderOptions -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="options" Type="System.Text.Json.JsonReaderOptions" />
      </Parameters>
      <Docs>
        <param name="jsonData">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (System.Buffers.ReadOnlySequence&lt;byte&gt; jsonData, bool isFinalBlock, System.Text.Json.JsonReaderState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Buffers.ReadOnlySequence`1&lt;unsigned int8&gt; jsonData, bool isFinalBlock, valuetype System.Text.Json.JsonReaderState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.Buffers.ReadOnlySequence{System.Byte},System.Boolean,System.Text.Json.JsonReaderState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (jsonData As ReadOnlySequence(Of Byte), isFinalBlock As Boolean, state As JsonReaderState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Utf8JsonReader(System::Buffers::ReadOnlySequence&lt;System::Byte&gt; jsonData, bool isFinalBlock, System::Text::Json::JsonReaderState state);" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader : System.Buffers.ReadOnlySequence&lt;byte&gt; * bool * System.Text.Json.JsonReaderState -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, isFinalBlock, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.Buffers.ReadOnlySequence&lt;System.Byte&gt;" />
        <Parameter Name="isFinalBlock" Type="System.Boolean" />
        <Parameter Name="state" Type="System.Text.Json.JsonReaderState" />
      </Parameters>
      <Docs>
        <param name="jsonData"><span data-ttu-id="5a93a-107">UTF-8 でエンコードされた、処理対象の JSON テキスト。</span><span class="sxs-lookup"><span data-stu-id="5a93a-107">The UTF-8 encoded JSON text to process.</span></span></param>
        <param name="isFinalBlock"><span data-ttu-id="5a93a-108">入力シーケンスに処理対象のデータ全体が含まれている場合は、<see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-108"><see langword="true" /> when the input sequence contains the entire data to process.</span></span> <span data-ttu-id="5a93a-109">一部のデータが入力スパンに含まれていて、後続のデータがあることが確認されている場合にのみ <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-109"><see langword="false" /> only if it's known that the input span contains partial data with more data to follow.</span></span></param>
        <param name="state"><span data-ttu-id="5a93a-110">これがコンストラクターの最初の呼び出しである場合は、既定の状態が渡されます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-110">If this is the first call to the constructor, pass in a default state.</span></span> <span data-ttu-id="5a93a-111">それ以外の場合は、<see cref="T:System.Text.Json.Utf8JsonReader" /> の前のインスタンスから状態を取り込んで、それを返します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-111">Otherwise, capture the state from the previous instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> and pass that back.</span></span></param>
        <summary><span data-ttu-id="5a93a-112"><see cref="T:System.Text.Json.Utf8JsonReader" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-112">Initializes a new instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5a93a-113">この型は ref 構造体であるため、スタックのみの型であり、ref 構造体のすべての制限が適用されます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-113">Since this type is a ref struct, it is a stack-only type, and all the limitations of ref structs apply to it.</span></span>
<span data-ttu-id="5a93a-114">コンストラクターがを<xref:System.Text.Json.JsonReaderState>受け入れる理由は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="5a93a-114">This is the reason why the constructor accepts a <xref:System.Text.Json.JsonReaderState>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (ReadOnlySpan&lt;byte&gt; jsonData, bool isFinalBlock, System.Text.Json.JsonReaderState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; jsonData, bool isFinalBlock, valuetype System.Text.Json.JsonReaderState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Text.Json.JsonReaderState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (jsonData As ReadOnlySpan(Of Byte), isFinalBlock As Boolean, state As JsonReaderState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Utf8JsonReader(ReadOnlySpan&lt;System::Byte&gt; jsonData, bool isFinalBlock, System::Text::Json::JsonReaderState state);" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader : ReadOnlySpan&lt;byte&gt; * bool * System.Text.Json.JsonReaderState -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, isFinalBlock, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isFinalBlock" Type="System.Boolean" />
        <Parameter Name="state" Type="System.Text.Json.JsonReaderState" />
      </Parameters>
      <Docs>
        <param name="jsonData"><span data-ttu-id="5a93a-115">UTF-8 でエンコードされた、処理対象の JSON テキスト。</span><span class="sxs-lookup"><span data-stu-id="5a93a-115">The UTF-8 encoded JSON text to process.</span></span></param>
        <param name="isFinalBlock"><span data-ttu-id="5a93a-116">入力スパンに処理対象のデータ全体が含まれている場合は、<see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-116"><see langword="true" /> when the input span contains the entire data to process.</span></span> <span data-ttu-id="5a93a-117">一部のデータが入力スパンに含まれていて、後続のデータがあることが確認されている場合にのみ <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-117"><see langword="false" /> only if it's known that the input span contains partial data with more data to follow.</span></span></param>
        <param name="state"><span data-ttu-id="5a93a-118">リーダーの状態を格納する構造体。</span><span class="sxs-lookup"><span data-stu-id="5a93a-118">A struct that contains the reader state.</span></span> <span data-ttu-id="5a93a-119">コンストラクターの最初の呼び出しでは、既定の状態が反映されます。それ以外の場合は、<see cref="T:System.Text.Json.Utf8JsonReader" /> の前のインスタンスから状態が取り込まれ、それが返されます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-119">On the first call to the constructor, it should reflect a default state; otherwise, it should capture the state from the previous instance instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> and pass that back.</span></span></param>
        <summary><span data-ttu-id="5a93a-120"><see cref="T:System.Text.Json.Utf8JsonReader" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-120">Initializes a new instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5a93a-121">この型は ref 構造体であるため、スタックのみの型であり、ref 構造体のすべての制限が適用されます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-121">Since this type is a ref struct, it is a stack-only type, and all the limitations of ref structs apply to it.</span></span>
<span data-ttu-id="5a93a-122">コンストラクターがを<xref:System.Text.Json.JsonReaderState>受け入れる理由は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="5a93a-122">This is the reason why the constructor accepts a <xref:System.Text.Json.JsonReaderState>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BytesConsumed">
      <MemberSignature Language="C#" Value="public long BytesConsumed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 BytesConsumed" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.BytesConsumed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesConsumed As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long BytesConsumed { long get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesConsumed : int64" Usage="System.Text.Json.Utf8JsonReader.BytesConsumed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5a93a-123">UTF-8 でエンコードされた指定の入力テキストを含む <see cref="T:System.Text.Json.Utf8JsonReader" /> の現在のインスタンスのために、これまで <see cref="T:System.Text.Json.Utf8JsonReader" /> によって使用された合計バイト数を取得します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-123">Gets the total number of bytes consumed by the <see cref="T:System.Text.Json.Utf8JsonReader" /> so far for the current instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> with the given UTF-8 encoded input text.</span></span></summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentDepth">
      <MemberSignature Language="C#" Value="public int CurrentDepth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentDepth" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.CurrentDepth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentDepth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentDepth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDepth : int" Usage="System.Text.Json.Utf8JsonReader.CurrentDepth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5a93a-124">現在のトークンの深度を取得します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-124">Gets the depth of the current token.</span></span></summary>
        <value><span data-ttu-id="5a93a-125">現在のトークンの深さ。</span><span class="sxs-lookup"><span data-stu-id="5a93a-125">The depth of the current token.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5a93a-126">この`CurrentDepth`プロパティは、これまでに処理された JSON テキスト内の入れ子になったオブジェクトまたは配列の再帰的な深さを追跡します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-126">The `CurrentDepth` property tracks the recursive depth of the nested objects / arrays within the JSON text processed so far.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentState">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonReaderState CurrentState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonReaderState CurrentState" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.CurrentState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentState As JsonReaderState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonReaderState CurrentState { System::Text::Json::JsonReaderState get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentState : System.Text.Json.JsonReaderState" Usage="System.Text.Json.Utf8JsonReader.CurrentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonReaderState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5a93a-127">呼び出し元によって取り込まれ、より多くのデータを含む <see cref="T:System.Text.Json.Utf8JsonReader" /> コンストラクターに返される必要がある <see cref="T:System.Text.Json.Utf8JsonReader" /> 状態の現在のスナップショット。</span><span class="sxs-lookup"><span data-stu-id="5a93a-127">Gets the current snapshot of the <see cref="T:System.Text.Json.Utf8JsonReader" /> state that must  be captured by the caller and passed back in to the <see cref="T:System.Text.Json.Utf8JsonReader" /> constructor with more data.</span></span></summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5a93a-128">Ref 構造体であるとは異なり、非同期/待機の境界を越えて状態を維持することができます。したがって、この型は、の新しいインスタンスを続行する前に、 <xref:System.Text.Json.Utf8JsonReader>より多くのデータを非同期に読み取るためのサポートを提供するために必要です。 <xref:System.Text.Json.Utf8JsonReader></span><span class="sxs-lookup"><span data-stu-id="5a93a-128">Unlike the <xref:System.Text.Json.Utf8JsonReader>, which is a ref struct, the state can survive across async/await boundaries, and hence this type is required to provide support for reading in more data asynchronously before continuing with a new instance of the <xref:System.Text.Json.Utf8JsonReader>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBoolean">
      <MemberSignature Language="C#" Value="public bool GetBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetBoolean();" />
      <MemberSignature Language="F#" Value="member this.GetBoolean : unit -&gt; bool" Usage="utf8JsonReader.GetBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5a93a-129">次の JSON トークン値をソースから <see cref="T:System.Boolean" /> として読み取ります。</span><span class="sxs-lookup"><span data-stu-id="5a93a-129">Reads the next JSON token value from the source as a <see cref="T:System.Boolean" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-130"><see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> が <see cref="F:System.Text.Json.JsonTokenType.True" /> の場合は <see langword="true" />。<see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> が <see cref="F:System.Text.Json.JsonTokenType.False" /> の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-130"><see langword="true" /> if the <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> is <see cref="F:System.Text.Json.JsonTokenType.True" />; <see langword="false" /> if the <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> is <see cref="F:System.Text.Json.JsonTokenType.False" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-131">JSON トークンの値はブール値 (つまり、<see cref="F:System.Text.Json.JsonTokenType.True" /> または <see cref="F:System.Text.Json.JsonTokenType.False" />) ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-131">The value of the JSON token isn't a boolean value (that is, <see cref="F:System.Text.Json.JsonTokenType.True" /> or <see cref="F:System.Text.Json.JsonTokenType.False" />).</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetByte">
      <MemberSignature Language="C#" Value="public byte GetByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8 GetByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetByte" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByte () As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Byte GetByte();" />
      <MemberSignature Language="F#" Value="member this.GetByte : unit -&gt; byte" Usage="utf8JsonReader.GetByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytesFromBase64">
      <MemberSignature Language="C#" Value="public byte[] GetBytesFromBase64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytesFromBase64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetBytesFromBase64" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytesFromBase64 () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytesFromBase64();" />
      <MemberSignature Language="F#" Value="member this.GetBytesFromBase64 : unit -&gt; byte[]" Usage="utf8JsonReader.GetBytesFromBase64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5a93a-132">ソースから現在の JSON トークン値を解析し、base 64 でエンコードされた JSON 文字列をバイト配列としてデコードします。</span><span class="sxs-lookup"><span data-stu-id="5a93a-132">Parses the current JSON token value from the source and decodes the base 64 encoded JSON string as a byte array.</span></span></summary>
        <returns><span data-ttu-id="5a93a-133">現在の JSON トークン値を表すバイト配列。</span><span class="sxs-lookup"><span data-stu-id="5a93a-133">The byte array that represents the current JSON token value.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-134">JSON トークンの型が <see cref="F:System.Text.Json.JsonTokenType.String" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-134">The type of the JSON token is not a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="5a93a-135">値は base 64 テキストとしてエンコードされていないため、バイトにデコードできません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-135">The value is not encoded as base 64 text and hence cannot be decoded to bytes.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetComment">
      <MemberSignature Language="C#" Value="public string GetComment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetComment" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComment () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetComment();" />
      <MemberSignature Language="F#" Value="member this.GetComment : unit -&gt; string" Usage="utf8JsonReader.GetComment " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5a93a-136">ソースからの現在の JSON トークン値をコメントとして解析し、<see cref="T:System.String" /> としてトランスコードします。</span><span class="sxs-lookup"><span data-stu-id="5a93a-136">Parses the current JSON token value from the source as a comment, transcoded it as a <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-137">現在の JSON トークン値を表すコメント。</span><span class="sxs-lookup"><span data-stu-id="5a93a-137">The comment that represents the current JSON token value.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-138">JSON トークンがコメントではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-138">The JSON token is not a comment.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetDateTime">
      <MemberSignature Language="C#" Value="public DateTime GetDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime GetDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime GetDateTime();" />
      <MemberSignature Language="F#" Value="member this.GetDateTime : unit -&gt; DateTime" Usage="utf8JsonReader.GetDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5a93a-139">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.DateTime" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-139">Reads the next JSON token value from the source and parses it to a <see cref="T:System.DateTime" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-140">UTF-8 でエンコードされたトークン値全体を正常に解析できる場合は日時。</span><span class="sxs-lookup"><span data-stu-id="5a93a-140">The date and time, if the entire UTF-8 encoded token value can be successfully parsed.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-141">JSON トークン値が <see cref="F:System.Text.Json.JsonTokenType.String" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-141">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="5a93a-142">JSON トークン値はサポートされていない形式です。</span><span class="sxs-lookup"><span data-stu-id="5a93a-142">The JSON token value is in an unsupported format.</span></span> <span data-ttu-id="5a93a-143">ISO 8601 形式のサブセットのみがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-143">Only a subset of ISO 8601 formats are supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetDateTimeOffset">
      <MemberSignature Language="C#" Value="public DateTimeOffset GetDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset GetDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeOffset () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset GetDateTimeOffset();" />
      <MemberSignature Language="F#" Value="member this.GetDateTimeOffset : unit -&gt; DateTimeOffset" Usage="utf8JsonReader.GetDateTimeOffset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5a93a-144">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.DateTimeOffset" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-144">Reads the next JSON token value from the source and parses it to a <see cref="T:System.DateTimeOffset" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-145">UTF-8 でエンコードされたトークン値全体を正常に解析できる場合は日時の値。</span><span class="sxs-lookup"><span data-stu-id="5a93a-145">The date and time value, if the entire UTF-8 encoded token value can be successfully parsed.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-146">JSON トークン値が <see cref="F:System.Text.Json.JsonTokenType.String" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-146">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="5a93a-147">JSON トークン値はサポートされていない形式です。</span><span class="sxs-lookup"><span data-stu-id="5a93a-147">The JSON token value is in an unsupported format.</span></span> <span data-ttu-id="5a93a-148">ISO 8601 形式のサブセットのみがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-148">Only a subset of ISO 8601 formats are supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetDecimal">
      <MemberSignature Language="C#" Value="public decimal GetDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Decimal GetDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Decimal GetDecimal();" />
      <MemberSignature Language="F#" Value="member this.GetDecimal : unit -&gt; decimal" Usage="utf8JsonReader.GetDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5a93a-149">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.Decimal" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-149">Reads the next JSON token value from the source and parses it to a <see cref="T:System.Decimal" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-150"><see cref="T:System.Decimal" /> に解析された、UTF-8 でエンコードされたトークン値。</span><span class="sxs-lookup"><span data-stu-id="5a93a-150">The UTF-8 encoded token value parsed to a <see cref="T:System.Decimal" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5a93a-151">Utf-8 `GetDecimal`でエンコードされたトークンの値全体を<xref:System.Decimal>値に解析できない場合、メソッドは例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="5a93a-151">The `GetDecimal` method throws an exception if the entire UTF-8 encoded token value cannnot be parsed to a <xref:System.Decimal> value.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-152">JSON トークン値は <see cref="F:System.Text.Json.JsonTokenType.Number" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-152">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="5a93a-153">JSON トークン値は、<see cref="F:System.Decimal.MinValue" /> 未満の数値、または <see cref="F:System.Decimal.MaxValue" /> より大きい数値を表しています。</span><span class="sxs-lookup"><span data-stu-id="5a93a-153">The JSON token value represents a number less than <see cref="F:System.Decimal.MinValue" /> or greater than <see cref="F:System.Decimal.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetDouble">
      <MemberSignature Language="C#" Value="public double GetDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDouble" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetDouble();" />
      <MemberSignature Language="F#" Value="member this.GetDouble : unit -&gt; double" Usage="utf8JsonReader.GetDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5a93a-154">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.Double" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-154">Reads the next JSON token value from the source and parses it to a <see cref="T:System.Double" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-155"><see cref="T:System.Double" /> に解析された、UTF-8 でエンコードされたトークン値。</span><span class="sxs-lookup"><span data-stu-id="5a93a-155">The UTF-8 encoded token value parsed to a <see cref="T:System.Double" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5a93a-156">Utf-8 `GetDouble`でエンコードされたトークンの値全体を<xref:System.Double>値に解析できない場合、メソッドは例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="5a93a-156">The `GetDouble` method throws an exception if the entire UTF-8 encoded token value cannnot be parsed to a <xref:System.Double> value.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-157">JSON トークン値は <see cref="F:System.Text.Json.JsonTokenType.Number" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-157">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="5a93a-158">JSON トークン値は、<see cref="F:System.Double.MinValue" /> 未満の数値、または <see cref="F:System.Double.MaxValue" /> より大きい数値を表しています。</span><span class="sxs-lookup"><span data-stu-id="5a93a-158">The JSON token value represents a number less than <see cref="F:System.Double.MinValue" /> or greater than <see cref="F:System.Double.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetGuid">
      <MemberSignature Language="C#" Value="public Guid GetGuid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Guid GetGuid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetGuid" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGuid () As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Guid GetGuid();" />
      <MemberSignature Language="F#" Value="member this.GetGuid : unit -&gt; Guid" Usage="utf8JsonReader.GetGuid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5a93a-159">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.Guid" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-159">Reads the next JSON token value from the source and parses it to a <see cref="T:System.Guid" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-160">UTF-8 でエンコードされたトークン値全体を正常に解析できる場合は GUID の値。</span><span class="sxs-lookup"><span data-stu-id="5a93a-160">The GUID value, if the entire UTF-8 encoded token value can be successfully parsed.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-161">JSON トークン値が <see cref="F:System.Text.Json.JsonTokenType.String" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-161">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="5a93a-162">JSON トークン値は、GUID でサポートされていない形式です。</span><span class="sxs-lookup"><span data-stu-id="5a93a-162">The JSON token value is in an unsupported format for a Guid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt16">
      <MemberSignature Language="C#" Value="public short GetInt16 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int16 GetInt16() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetInt16" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInt16 () As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; short GetInt16();" />
      <MemberSignature Language="F#" Value="member this.GetInt16 : unit -&gt; int16" Usage="utf8JsonReader.GetInt16 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInt32">
      <MemberSignature Language="C#" Value="public int GetInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInt32 () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetInt32();" />
      <MemberSignature Language="F#" Value="member this.GetInt32 : unit -&gt; int" Usage="utf8JsonReader.GetInt32 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5a93a-163">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.Int32" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-163">Reads the next JSON token value from the source and parses it to an <see cref="T:System.Int32" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-164"><see cref="T:System.Int32" /> に解析された、UTF-8 でエンコードされたトークン値。</span><span class="sxs-lookup"><span data-stu-id="5a93a-164">The UTF-8 encoded token value parsed to an <see cref="T:System.Int32" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5a93a-165">Utf-8 `GetInt32`でエンコードされたトークンの値全体を<xref:System.Int32>値に解析できない場合、メソッドは例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="5a93a-165">The `GetInt32` method throws an exception if the entire UTF-8 encoded token value cannnot be parsed to a <xref:System.Int32> value.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-166">JSON トークン値は <see cref="F:System.Text.Json.JsonTokenType.Number" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-166">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="5a93a-167">JSON トークン値の数値形式が正しくありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-167">The JSON token value is of the incorrect numeric format.</span></span> <span data-ttu-id="5a93a-168">たとえば、それに 10 進数が含まれている場合や、それが科学的表記法で記述されている場合が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-168">For example, it contains a decimal or is written in scientific notation.</span></span>
            
<span data-ttu-id="5a93a-169">または</span><span class="sxs-lookup"><span data-stu-id="5a93a-169">- or-</span></span>

<span data-ttu-id="5a93a-170">JSON トークン値は、<see cref="F:System.Int32.MinValue" /> 未満の数値、または <see cref="F:System.Int32.MaxValue" /> より大きい数値を表しています。</span><span class="sxs-lookup"><span data-stu-id="5a93a-170">The JSON token value represents a number less than <see cref="F:System.Int32.MinValue" /> or greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetInt64">
      <MemberSignature Language="C#" Value="public long GetInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInt64 () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetInt64();" />
      <MemberSignature Language="F#" Value="member this.GetInt64 : unit -&gt; int64" Usage="utf8JsonReader.GetInt64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5a93a-171">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.Int64" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-171">Reads the next JSON token value from the source and parses it to an <see cref="T:System.Int64" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-172"><see cref="T:System.Int64" /> に解析された、UTF-8 でエンコードされたトークン値。</span><span class="sxs-lookup"><span data-stu-id="5a93a-172">The UTF-8 encoded token value parsed to an <see cref="T:System.Int64" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5a93a-173">Utf-8 `GetInt64`でエンコードされたトークンの値全体を<xref:System.Int64>値に解析できない場合、メソッドは例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="5a93a-173">The `GetInt64` method throws an exception if the entire UTF-8 encoded token value cannnot be parsed to a <xref:System.Int64> value.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-174">JSON トークン値は <see cref="F:System.Text.Json.JsonTokenType.Number" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-174">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="5a93a-175">JSON トークン値の数値形式が正しくありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-175">The JSON token value is of the incorrect numeric format.</span></span> <span data-ttu-id="5a93a-176">たとえば、それに 10 進数が含まれている場合や、それが科学的表記法で記述されている場合が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-176">For example, it contains a decimal or is written in scientific notation.</span></span>
            
<span data-ttu-id="5a93a-177">または</span><span class="sxs-lookup"><span data-stu-id="5a93a-177">- or-</span></span>

<span data-ttu-id="5a93a-178">JSON トークン値は、<see cref="F:System.Int64.MinValue" /> 未満の数値、または <see cref="F:System.Int64.MaxValue" /> より大きい数値を表しています。</span><span class="sxs-lookup"><span data-stu-id="5a93a-178">The JSON token value represents a number less than <see cref="F:System.Int64.MinValue" /> or greater than <see cref="F:System.Int64.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetSByte">
      <MemberSignature Language="C#" Value="public sbyte GetSByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int8 GetSByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetSByte" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSByte () As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::SByte GetSByte();" />
      <MemberSignature Language="F#" Value="member this.GetSByte : unit -&gt; sbyte" Usage="utf8JsonReader.GetSByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSingle">
      <MemberSignature Language="C#" Value="public float GetSingle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float32 GetSingle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetSingle" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSingle () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; float GetSingle();" />
      <MemberSignature Language="F#" Value="member this.GetSingle : unit -&gt; single" Usage="utf8JsonReader.GetSingle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5a93a-179">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.Single" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-179">Reads the next JSON token value from the source and parses it to a <see cref="T:System.Single" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-180"><see cref="T:System.Single" /> に解析された、UTF-8 でエンコードされたトークン値。</span><span class="sxs-lookup"><span data-stu-id="5a93a-180">The UTF-8 encoded token value parsed to a <see cref="T:System.Single" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5a93a-181">Utf-8 `GetSingle`でエンコードされたトークンの値全体を<xref:System.Single>値に解析できない場合、メソッドは例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="5a93a-181">The `GetSingle` method throws an exception if the entire UTF-8 encoded token value cannnot be parsed to a <xref:System.Single> value.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-182">JSON トークン値は <see cref="F:System.Text.Json.JsonTokenType.Number" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-182">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="5a93a-183">JSON トークン値は、<see cref="F:System.Single.MinValue" /> 未満の数値、または <see cref="F:System.Single.MaxValue" /> より大きい数値を表しています。</span><span class="sxs-lookup"><span data-stu-id="5a93a-183">The JSON token value represents a number less than <see cref="F:System.Single.MinValue" /> or greater than <see cref="F:System.Single.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetString" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString();" />
      <MemberSignature Language="F#" Value="member this.GetString : unit -&gt; string" Usage="utf8JsonReader.GetString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5a93a-184">次の JSON トークン値をソースから読み取り、エスケープ解除し、<see cref="T:System.String" /> としてトランスコードします。</span><span class="sxs-lookup"><span data-stu-id="5a93a-184">Reads the next JSON token value from the source, unescaped, and transcoded as a <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-185"><see cref="T:System.String" /> に解析されたトークン値。</span><span class="sxs-lookup"><span data-stu-id="5a93a-185">The token value parsed to a <see cref="T:System.String" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-186">トークン値は JSON 文字列ではありません (つまり、<see cref="F:System.Text.Json.JsonTokenType.String" /> または <see cref="F:System.Text.Json.JsonTokenType.PropertyName" /> ではない)。</span><span class="sxs-lookup"><span data-stu-id="5a93a-186">The JSON token value isn't a string (that is, not a <see cref="F:System.Text.Json.JsonTokenType.String" /> or <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</span></span>

<span data-ttu-id="5a93a-187">- または -</span><span class="sxs-lookup"><span data-stu-id="5a93a-187">-or-</span></span>

<span data-ttu-id="5a93a-188">JSON 文字列に無効な UTF-8 バイトまたは無効な UTF-16 サロゲートが含まれています。</span><span class="sxs-lookup"><span data-stu-id="5a93a-188">The JSON string contains invalid UTF-8 bytes or invalid UTF-16 surrogates.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetUInt16">
      <MemberSignature Language="C#" Value="public ushort GetUInt16 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int16 GetUInt16() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetUInt16" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUInt16 () As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt16 GetUInt16();" />
      <MemberSignature Language="F#" Value="member this.GetUInt16 : unit -&gt; uint16" Usage="utf8JsonReader.GetUInt16 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUInt32">
      <MemberSignature Language="C#" Value="public uint GetUInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int32 GetUInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetUInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUInt32 () As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt32 GetUInt32();" />
      <MemberSignature Language="F#" Value="member this.GetUInt32 : unit -&gt; uint32" Usage="utf8JsonReader.GetUInt32 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5a93a-189">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.UInt32" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-189">Reads the next JSON token value from the source and parses it to a <see cref="T:System.UInt32" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-190"><see cref="T:System.UInt32" /> に解析された、UTF-8 でエンコードされたトークン値。</span><span class="sxs-lookup"><span data-stu-id="5a93a-190">The UTF-8 encoded token value parsed to a <see cref="T:System.UInt32" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-191">JSON トークン値は <see cref="F:System.Text.Json.JsonTokenType.Number" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-191">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="5a93a-192">JSON トークン値の数値形式が正しくありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-192">The JSON token value is of the incorrect numeric format.</span></span> <span data-ttu-id="5a93a-193">たとえば、それに 10 進数が含まれている場合や、それが科学的表記法で記述されている場合が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-193">For example, it contains a decimal or is written in scientific notation.</span></span>
            
<span data-ttu-id="5a93a-194">または</span><span class="sxs-lookup"><span data-stu-id="5a93a-194">- or-</span></span>

<span data-ttu-id="5a93a-195">JSON トークン値は、<see cref="F:System.UInt32.MinValue" /> 未満の数値、または <see cref="F:System.UInt32.MaxValue" /> より大きい数値を表しています。</span><span class="sxs-lookup"><span data-stu-id="5a93a-195">The JSON token value represents a number less than <see cref="F:System.UInt32.MinValue" /> or greater than <see cref="F:System.UInt32.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetUInt64">
      <MemberSignature Language="C#" Value="public ulong GetUInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int64 GetUInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetUInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUInt64 () As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt64 GetUInt64();" />
      <MemberSignature Language="F#" Value="member this.GetUInt64 : unit -&gt; uint64" Usage="utf8JsonReader.GetUInt64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5a93a-196">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.UInt64" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-196">Reads the next JSON token value from the source and parses it to a <see cref="T:System.UInt64" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-197"><see cref="T:System.UInt64" /> に解析された、UTF-8 でエンコードされたトークン値。</span><span class="sxs-lookup"><span data-stu-id="5a93a-197">The UTF-8 encoded token value parsed to a <see cref="T:System.UInt64" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-198">JSON トークン値は <see cref="F:System.Text.Json.JsonTokenType.Number" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-198">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="5a93a-199">JSON トークン値の数値形式が正しくありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-199">The JSON token value is of the incorrect numeric format.</span></span> <span data-ttu-id="5a93a-200">たとえば、それに 10 進数が含まれている場合や、それが科学的表記法で記述されている場合が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-200">For example, it contains a decimal or is written in scientific notation.</span></span>
            
<span data-ttu-id="5a93a-201">または</span><span class="sxs-lookup"><span data-stu-id="5a93a-201">- or-</span></span>

<span data-ttu-id="5a93a-202">JSON トークン値は、<see cref="F:System.UInt64.MinValue" /> 未満の数値、または <see cref="F:System.UInt64.MaxValue" /> より大きい数値を表しています。</span><span class="sxs-lookup"><span data-stu-id="5a93a-202">The JSON token value represents a number less than <see cref="F:System.UInt64.MinValue" /> or greater than <see cref="F:System.UInt64.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="HasValueSequence">
      <MemberSignature Language="C#" Value="public bool HasValueSequence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValueSequence" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.HasValueSequence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValueSequence As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValueSequence { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValueSequence : bool" Usage="System.Text.Json.Utf8JsonReader.HasValueSequence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IsReadOnly</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5a93a-203">トークン値を取得するために使用する <c>Value</c> プロパティを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-203">Gets a value that indicates which <c>Value</c> property to use to get the token value.</span></span></summary>
        <value><span data-ttu-id="5a93a-204"><see langword="true" />トークン値を取得するには、を使用する必要があります。<see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /></span><span class="sxs-lookup"><span data-stu-id="5a93a-204"><see langword="true" /> if <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> should be used to get the token value.</span></span> <span data-ttu-id="5a93a-205"><see langword="false" />代わりに<see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" />を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5a93a-205"><see langword="false" /> if <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> should be used instead.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5a93a-206">が`HasValueSequence` <xref:System.Text.Json.Utf8JsonReader.ValueSequence>の場合、は空です。 `false`</span><span class="sxs-lookup"><span data-stu-id="5a93a-206">If `HasValueSequence` is `false`, <xref:System.Text.Json.Utf8JsonReader.ValueSequence> is empty.</span></span> <span data-ttu-id="5a93a-207">そのため、 <xref:System.Text.Json.Utf8JsonReader.ValueSpan>プロパティを使用してトークン値を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="5a93a-207">Therefore, read the token value using the <xref:System.Text.Json.Utf8JsonReader.ValueSpan> property.</span></span>

<span data-ttu-id="5a93a-208">内`ReadOnlySpan<byte>`の入力データの場合、これは`false`常にを返します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-208">For input data within a `ReadOnlySpan<byte>`, this always returns `false`.</span></span> <span data-ttu-id="5a93a-209">内`ReadOnlySequence<byte>`の入力データの場合は、トークン`true`値が1つ以上のセグメントをまたがっし、そのためにスパンとして表すことができない場合にのみ、が返されます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-209">For input data within a `ReadOnlySequence<byte>`, this only returns `true` if the token value straddles more than a single segment and hence can't be represented as a span.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalBlock">
      <MemberSignature Language="C#" Value="public bool IsFinalBlock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinalBlock" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.IsFinalBlock" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFinalBlock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFinalBlock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFinalBlock : bool" Usage="System.Text.Json.Utf8JsonReader.IsFinalBlock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5a93a-210">すべての JSON データが与えられたか、あるいは他にもデータが入ってくるのかを示す <see cref="T:System.Text.Json.Utf8JsonReader" /> のこのインスタンスのモードを取得します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-210">Gets the mode of this instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> which indicates whether all the JSON data was provided or there is more data to come.</span></span></summary>
        <value><span data-ttu-id="5a93a-211"><see langword="true" />処理する JSON データ全体を含む入力範囲またはシーケンスを使用してリーダーが構築された場合は。</span><span class="sxs-lookup"><span data-stu-id="5a93a-211"><see langword="true" /> if the reader was constructed with the input span or sequence containing the entire JSON data to process.</span></span> <span data-ttu-id="5a93a-212"><see langword="false" />入力範囲またはシーケンスを使用してリーダーが構築され、その後に続くデータを含む部分的な JSON データが含まれている場合。</span><span class="sxs-lookup"><span data-stu-id="5a93a-212"><see langword="false" /> if the reader was constructed with an input span or sequence that may contain partial JSON data with more data to follow.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public SequencePosition Position { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.SequencePosition Position" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.Position" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Position As SequencePosition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property SequencePosition Position { SequencePosition get(); };" />
      <MemberSignature Language="F#" Value="member this.Position : SequencePosition" Usage="System.Text.Json.Utf8JsonReader.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SequencePosition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5a93a-213">指定された UTF-8 でエンコードされた入力 ReadOnlySequence&lt;byte&gt; 内の現在の <see cref="T:System.SequencePosition" /> を取得します。<see cref="T:System.Text.Json.Utf8JsonReader" /> 構造体が ReadOnlySpan&lt;byte&gt; で構築されている場合は既定の <see cref="T:System.SequencePosition" /> を取得します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-213">Gets the current <see cref="T:System.SequencePosition" /> within the provided UTF-8 encoded input ReadOnlySequence&lt;byte&gt; or a default <see cref="T:System.SequencePosition" /> if the <see cref="T:System.Text.Json.Utf8JsonReader" /> struct was constructed with a ReadOnlySpan&lt;byte&gt;.</span></span></summary>
        <value><span data-ttu-id="5a93a-214">指定し<see cref="T:System.SequencePosition" />た utf-8 でエンコードされた入力 ReadOnlySequence&lt;バイト&gt; 、または<see cref="T:System.SequencePosition" /> <see cref="T:System.Text.Json.Utf8JsonReader" />構造体が ReadOnlySpan&lt;バイト&gt;を使用して構築された場合は既定値である、現在の。</span><span class="sxs-lookup"><span data-stu-id="5a93a-214">The current <see cref="T:System.SequencePosition" /> within the provided UTF-8 encoded input ReadOnlySequence&lt;byte&gt; or a default <see cref="T:System.SequencePosition" /> if the <see cref="T:System.Text.Json.Utf8JsonReader" /> struct was constructed with a ReadOnlySpan&lt;byte&gt;.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Read();" />
      <MemberSignature Language="F#" Value="member this.Read : unit -&gt; bool" Usage="utf8JsonReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5a93a-215">次の JSON トークンを入力ソースから読み取ります。</span><span class="sxs-lookup"><span data-stu-id="5a93a-215">Read the next JSON token from the input source.</span></span></summary>
        <returns><span data-ttu-id="5a93a-216">トークンが正常に読み取られた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-216"><see langword="true" /> if the token was read successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Text.Json.JsonException"><span data-ttu-id="5a93a-217">JSON RFC では無効な JSON トークンが検出されました。</span><span class="sxs-lookup"><span data-stu-id="5a93a-217">An invalid JSON token according to the JSON RFC is encountered.</span></span>
        
<span data-ttu-id="5a93a-218">または</span><span class="sxs-lookup"><span data-stu-id="5a93a-218">-or-</span></span>

<span data-ttu-id="5a93a-219">現在の深度が、最大深度によって設定された再帰の限度を超えています。</span><span class="sxs-lookup"><span data-stu-id="5a93a-219">The current depth exceeds the recursive limit set by the maximum depth.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Skip();" />
      <MemberSignature Language="F#" Value="member this.Skip : unit -&gt; unit" Usage="utf8JsonReader.Skip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5a93a-220">現在の JSON トークンの子をスキップします。</span><span class="sxs-lookup"><span data-stu-id="5a93a-220">Skips the children of the current JSON token.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5a93a-221"><xref:System.Text.Json.Utf8JsonReader.TokenType> が<xref:System.Text.Json.JsonTokenType.PropertyName?displayProperty=nameWithType>の場合、リーダーは最初にプロパティ値に移動します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-221">When <xref:System.Text.Json.Utf8JsonReader.TokenType> is <xref:System.Text.Json.JsonTokenType.PropertyName?displayProperty=nameWithType>, the reader first moves to the property value.</span></span>

<span data-ttu-id="5a93a-222">( <xref:System.Text.Json.Utf8JsonReader.TokenType>最初、または前進後) が<xref:System.Text.Json.JsonTokenType.StartObject?displayProperty=nameWithtype>また<xref:System.Text.Json.JsonTokenType.StartArray?displayProperty=nameWithType>はの場合、リーダーは一致<xref:System.Text.Json.JsonTokenType.EndObject?displayProperty=nameWithType>する<xref:System.Text.Json.JsonTokenType.EndArray?displayProperty=nameWithType>またはに進みます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-222">When <xref:System.Text.Json.Utf8JsonReader.TokenType> (originally, or after advancing) is <xref:System.Text.Json.JsonTokenType.StartObject?displayProperty=nameWithtype> or  <xref:System.Text.Json.JsonTokenType.StartArray?displayProperty=nameWithType>, the reader advances to the matching <xref:System.Text.Json.JsonTokenType.EndObject?displayProperty=nameWithType> or <xref:System.Text.Json.JsonTokenType.EndArray?displayProperty=nameWithType>.</span></span>
            
<span data-ttu-id="5a93a-223">他のすべてのトークン型については、リーダーは移動しません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-223">For all other token types, the reader does not move.</span></span> <span data-ttu-id="5a93a-224">次にを<xref:System.Text.Json.Utf8JsonReader.Read>呼び出した後、リーダーは次の値 (配列内の場合)、次のプロパティ名 (オブジェクトの場合)、または終了配列/オブジェクトトークンになります。</span><span class="sxs-lookup"><span data-stu-id="5a93a-224">After the next call to <xref:System.Text.Json.Utf8JsonReader.Read>, the reader will be at the next value (when in an array), the next property name (when in an object), or the end array/object token.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-225">リーダーに与えられたデータは一部であり、この後にデータが続きます (つまり、<see cref="P:System.Text.Json.Utf8JsonReader.IsFinalBlock" /> は <see langword="false" /> です)。</span><span class="sxs-lookup"><span data-stu-id="5a93a-225">The reader was given partial data with more data to follow (that is, <see cref="P:System.Text.Json.Utf8JsonReader.IsFinalBlock" /> is <see langword="false" />).</span></span></exception>
        <exception cref="T:System.Text.Json.JsonException"><span data-ttu-id="5a93a-226">JSON RFC に基づき、スキップ中、無効な JSON トークンが検出されました。</span><span class="sxs-lookup"><span data-stu-id="5a93a-226">An invalid JSON token was encountered while skipping, according to the JSON RFC.</span></span>

<span data-ttu-id="5a93a-227">または</span><span class="sxs-lookup"><span data-stu-id="5a93a-227">- or -</span></span>

<span data-ttu-id="5a93a-228">現在の深度が、最大深度によって設定された再帰の限度を超えています。</span><span class="sxs-lookup"><span data-stu-id="5a93a-228">The current depth exceeds the recursive limit set by the maximum depth.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TokenStartIndex">
      <MemberSignature Language="C#" Value="public long TokenStartIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 TokenStartIndex" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.TokenStartIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TokenStartIndex As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long TokenStartIndex { long get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenStartIndex : int64" Usage="System.Text.Json.Utf8JsonReader.TokenStartIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IsReadOnly</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5a93a-229">最後に処理された JSON トークンの (UTF-8 でエンコードされた指定の入力テキスト内の) 開始位置となるインデックスを取得します。空白はスキップされます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-229">Gets the index that the last processed JSON token starts at (within the given UTF-8 encoded input text), skipping any white space.</span></span></summary>
        <value><span data-ttu-id="5a93a-230">指定した UTF-8 でエンコードされた入力テキスト内で最後に処理された JSON トークンの開始インデックス。</span><span class="sxs-lookup"><span data-stu-id="5a93a-230">The starting index of the last processed JSON token within the given UTF-8 encoded input text.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5a93a-231">JSON 文字列 (プロパティ名を含む) の場合、この値は開始引用符の前を指します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-231">For JSON strings (including property names), this value points to before the start quote.</span></span>

<span data-ttu-id="5a93a-232">コメントの場合、この値は最初のコメント区切り記号 ('/') の前を指します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-232">For comments, this value points to before the first comment delimiter (that is, '/').</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonTokenType TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonTokenType TokenType" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TokenType As JsonTokenType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonTokenType TokenType { System::Text::Json::JsonTokenType get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : System.Text.Json.JsonTokenType" Usage="System.Text.Json.Utf8JsonReader.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonTokenType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5a93a-233">UTF-8 でエンコードされた JSON テキスト内で最後に処理された JSON トークンの種類を取得します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-233">Gets the type of the last processed JSON token in the UTF-8 encoded JSON text.</span></span></summary>
        <value><span data-ttu-id="5a93a-234">最後に処理された JSON トークンの型。</span><span class="sxs-lookup"><span data-stu-id="5a93a-234">The type of the last processed JSON token.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetByte">
      <MemberSignature Language="C#" Value="public bool TryGetByte (out byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetByte([out] unsigned int8&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetByte(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetByte (ByRef value As Byte) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetByte([Runtime::InteropServices::Out] System::Byte % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetByte :  -&gt; bool" Usage="utf8JsonReader.TryGetByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetBytesFromBase64">
      <MemberSignature Language="C#" Value="public bool TryGetBytesFromBase64 (out byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetBytesFromBase64([out] unsigned int8[]&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetBytesFromBase64(System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetBytesFromBase64 (ByRef value As Byte()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetBytesFromBase64([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetBytesFromBase64 :  -&gt; bool" Usage="utf8JsonReader.TryGetBytesFromBase64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5a93a-235">メソッドが成功した場合、base 64 テキストの (デコードされた) バイナリ表現が含まれます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-235">If the method succeeds, contains the decoded binary representation of the base 64 text.</span></span></param>
        <summary><span data-ttu-id="5a93a-236">ソースから現在の JSON トークン値の解析を試行し、base 64 でエンコードされた JSON 文字列をバイト配列としてデコードします。</span><span class="sxs-lookup"><span data-stu-id="5a93a-236">Tries to parse the current JSON token value from the source and decodes the base 64 encoded JSON string as a byte array.</span></span></summary>
        <returns><span data-ttu-id="5a93a-237">トークン値全体が有効な base 64 テキストとしてエンコードされ、正常にバイトにデコードできる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-237"><see langword="true" /> if the entire token value is encoded as valid base 64 text and can be successfully decoded to bytes; <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-238">JSON トークンが <see cref="F:System.Text.Json.JsonTokenType.String" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-238">The JSON token is not a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetDateTime">
      <MemberSignature Language="C#" Value="public bool TryGetDateTime (out DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDateTime([out] valuetype System.DateTime&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDateTime(System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDateTime (ByRef value As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDateTime([Runtime::InteropServices::Out] DateTime % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDateTime :  -&gt; bool" Usage="utf8JsonReader.TryGetDateTime value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5a93a-239">このメソッドから戻るときに、解析された値が格納されます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-239">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="5a93a-240">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.DateTime" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-240">Reads the next JSON token value from the source and parses it to a <see cref="T:System.DateTime" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-241">UTF-8 でエンコードされたトークン値全体を <see cref="T:System.DateTime" /> に正常に解析できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-241"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.DateTime" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-242">JSON トークン値が <see cref="F:System.Text.Json.JsonTokenType.String" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-242">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetDateTimeOffset">
      <MemberSignature Language="C#" Value="public bool TryGetDateTimeOffset (out DateTimeOffset value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDateTimeOffset([out] valuetype System.DateTimeOffset&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDateTimeOffset(System.DateTimeOffset@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDateTimeOffset (ByRef value As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDateTimeOffset([Runtime::InteropServices::Out] DateTimeOffset % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDateTimeOffset :  -&gt; bool" Usage="utf8JsonReader.TryGetDateTimeOffset value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTimeOffset" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5a93a-243">このメソッドから戻るときに、解析された値が格納されます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-243">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="5a93a-244">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.DateTimeOffset" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-244">Reads the next JSON token value from the source and parses it to a <see cref="T:System.DateTimeOffset" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-245">UTF-8 でエンコードされたトークン値全体を <see cref="T:System.DateTimeOffset" /> に正常に解析できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-245"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.DateTimeOffset" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-246">JSON トークン値が <see cref="F:System.Text.Json.JsonTokenType.String" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-246">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetDecimal">
      <MemberSignature Language="C#" Value="public bool TryGetDecimal (out decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDecimal([out] valuetype System.Decimal&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDecimal(System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDecimal (ByRef value As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDecimal([Runtime::InteropServices::Out] System::Decimal % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDecimal :  -&gt; bool" Usage="utf8JsonReader.TryGetDecimal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5a93a-247">このメソッドから戻るときに、解析された値が格納されます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-247">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="5a93a-248">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.Decimal" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-248">Reads the next JSON token value from the source and parses it to a <see cref="T:System.Decimal" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-249">UTF-8 でエンコードされたトークン値全体を <see cref="T:System.Decimal" /> に正常に解析できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-249"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Decimal" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-250">JSON トークン値は <see cref="F:System.Text.Json.JsonTokenType.Number" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-250">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetDouble">
      <MemberSignature Language="C#" Value="public bool TryGetDouble (out double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDouble([out] float64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDouble(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDouble (ByRef value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDouble([Runtime::InteropServices::Out] double % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDouble :  -&gt; bool" Usage="utf8JsonReader.TryGetDouble value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5a93a-251">このメソッドから戻るときに、解析された値が格納されます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-251">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="5a93a-252">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.Double" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-252">Reads the next JSON token value from the source and parses it to a <see cref="T:System.Double" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-253">UTF-8 でエンコードされたトークン値全体を <see cref="T:System.Double" /> に正常に解析できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-253"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Double" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-254">JSON トークン値は <see cref="F:System.Text.Json.JsonTokenType.Number" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-254">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetGuid">
      <MemberSignature Language="C#" Value="public bool TryGetGuid (out Guid value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetGuid([out] valuetype System.Guid&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetGuid(System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetGuid (ByRef value As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetGuid([Runtime::InteropServices::Out] Guid % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetGuid :  -&gt; bool" Usage="utf8JsonReader.TryGetGuid value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Guid" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5a93a-255">このメソッドから戻るときに、解析された値が格納されます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-255">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="5a93a-256">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.Guid" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-256">Reads the next JSON token value from the source and parses it to a <see cref="T:System.Guid" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-257">UTF-8 でエンコードされたトークン値全体を <see cref="T:System.Guid" /> に正常に解析できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-257"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Guid" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5a93a-258">このメソッドは、 <xref:System.Guid>ハイフンを使用した値の解析だけを行います。</span><span class="sxs-lookup"><span data-stu-id="5a93a-258">This method only parses <xref:System.Guid> values with hyphens and without any surrounding decorations.</span></span> 

         ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-259">JSON トークン値が <see cref="F:System.Text.Json.JsonTokenType.String" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-259">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetInt16">
      <MemberSignature Language="C#" Value="public bool TryGetInt16 (out short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetInt16([out] int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetInt16(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetInt16 (ByRef value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetInt16([Runtime::InteropServices::Out] short % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetInt16 :  -&gt; bool" Usage="utf8JsonReader.TryGetInt16 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetInt32">
      <MemberSignature Language="C#" Value="public bool TryGetInt32 (out int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetInt32([out] int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetInt32(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetInt32 (ByRef value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetInt32([Runtime::InteropServices::Out] int % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetInt32 :  -&gt; bool" Usage="utf8JsonReader.TryGetInt32 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5a93a-260">このメソッドから戻るときに、解析された値が格納されます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-260">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="5a93a-261">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.Int32" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-261">Reads the next JSON token value from the source and parses it to an <see cref="T:System.Int32" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-262">UTF-8 でエンコードされたトークン値全体を <see cref="T:System.Int32" /> に正常に解析できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-262"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to an <see cref="T:System.Int32" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-263">JSON トークン値は <see cref="F:System.Text.Json.JsonTokenType.Number" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-263">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetInt64">
      <MemberSignature Language="C#" Value="public bool TryGetInt64 (out long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetInt64([out] int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetInt64(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetInt64 (ByRef value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetInt64([Runtime::InteropServices::Out] long % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetInt64 :  -&gt; bool" Usage="utf8JsonReader.TryGetInt64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5a93a-264">このメソッドから戻るときに、解析された値が格納されます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-264">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="5a93a-265">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.Int64" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-265">Reads the next JSON token value from the source and parses it to an <see cref="T:System.Int64" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-266">UTF-8 でエンコードされたトークン値全体を <see cref="T:System.Int64" /> に正常に解析できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-266"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to an <see cref="T:System.Int64" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-267">JSON トークン値は <see cref="F:System.Text.Json.JsonTokenType.Number" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-267">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetSByte">
      <MemberSignature Language="C#" Value="public bool TryGetSByte (out sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetSByte([out] int8&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetSByte(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetSByte (ByRef value As SByte) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetSByte([Runtime::InteropServices::Out] System::SByte % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetSByte :  -&gt; bool" Usage="utf8JsonReader.TryGetSByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSingle">
      <MemberSignature Language="C#" Value="public bool TryGetSingle (out float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetSingle([out] float32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetSingle(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetSingle (ByRef value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetSingle([Runtime::InteropServices::Out] float % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetSingle :  -&gt; bool" Usage="utf8JsonReader.TryGetSingle value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5a93a-268">このメソッドから戻るときに、解析された値が格納されます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-268">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="5a93a-269">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.Single" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-269">Reads the next JSON token value from the source and parses it to a <see cref="T:System.Single" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-270">UTF-8 でエンコードされたトークン値全体を <see cref="T:System.Single" /> に正常に解析できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-270"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to an <see cref="T:System.Single" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-271">JSON トークン値は <see cref="F:System.Text.Json.JsonTokenType.Number" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-271">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetUInt16">
      <MemberSignature Language="C#" Value="public bool TryGetUInt16 (out ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetUInt16([out] unsigned int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetUInt16(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetUInt16 (ByRef value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetUInt16([Runtime::InteropServices::Out] System::UInt16 % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetUInt16 :  -&gt; bool" Usage="utf8JsonReader.TryGetUInt16 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetUInt32">
      <MemberSignature Language="C#" Value="public bool TryGetUInt32 (out uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetUInt32([out] unsigned int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetUInt32(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetUInt32 (ByRef value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetUInt32([Runtime::InteropServices::Out] System::UInt32 % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetUInt32 :  -&gt; bool" Usage="utf8JsonReader.TryGetUInt32 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5a93a-272">このメソッドから戻るときに、解析された値が格納されます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-272">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="5a93a-273">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.UInt32" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-273">Reads the next JSON token value from the source and parses it to a <see cref="T:System.UInt32" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-274">UTF-8 でエンコードされたトークン値全体を <see cref="T:System.UInt32" /> に正常に解析できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-274"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.UInt32" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-275">JSON トークン値は <see cref="F:System.Text.Json.JsonTokenType.Number" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-275">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetUInt64">
      <MemberSignature Language="C#" Value="public bool TryGetUInt64 (out ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetUInt64([out] unsigned int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetUInt64(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetUInt64 (ByRef value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetUInt64([Runtime::InteropServices::Out] System::UInt64 % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetUInt64 :  -&gt; bool" Usage="utf8JsonReader.TryGetUInt64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5a93a-276">このメソッドから戻るときに、解析された値が格納されます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-276">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="5a93a-277">次の JSON トークン値をソースから読み取り、それを <see cref="T:System.UInt64" /> に解析します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-277">Reads the next JSON token value from the source and parses it to a <see cref="T:System.UInt64" />.</span></span></summary>
        <returns><span data-ttu-id="5a93a-278">UTF-8 でエンコードされたトークン値全体を <see cref="T:System.UInt64" /> に正常に解析できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-278"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.UInt64" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5a93a-279">JSON トークン値は <see cref="F:System.Text.Json.JsonTokenType.Number" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-279">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TrySkip">
      <MemberSignature Language="C#" Value="public bool TrySkip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySkip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TrySkip" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySkip () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySkip();" />
      <MemberSignature Language="F#" Value="member this.TrySkip : unit -&gt; bool" Usage="utf8JsonReader.TrySkip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5a93a-280">現在の JSON トークンの子のスキップを試行します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-280">Tries to skip the children of the current JSON token.</span></span></summary>
        <returns><span data-ttu-id="5a93a-281">子を正常にスキップできるだけの十分なデータがあった場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5a93a-281"><see langword="true" /> if there was enough data for the children to be skipped successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5a93a-282">リーダーが、現在のトークンの子を完全にスキップするのに十分なデータを持っていなかった場合は、メソッドが呼び出される前の状態にリセットされます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-282">If the reader did not have enough data to completely skip the children of the current token, it will be reset to the state it was in before the method was called.</span></span>
              
<span data-ttu-id="5a93a-283"><xref:System.Text.Json.Utf8JsonReader.TokenType> が<xref:System.Text.Json.JsonTokenType.PropertyName?displayProperty=nameWithType>の場合、リーダーは最初にプロパティ値に移動します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-283">When <xref:System.Text.Json.Utf8JsonReader.TokenType> is <xref:System.Text.Json.JsonTokenType.PropertyName?displayProperty=nameWithType>, the reader first moves to the property value.</span></span>

<span data-ttu-id="5a93a-284">( <xref:System.Text.Json.Utf8JsonReader.TokenType>最初、または前進後) が<xref:System.Text.Json.JsonTokenType.StartObject?displayProperty=nameWithType>また<xref:System.Text.Json.JsonTokenType.StartArray?displayProperty=nameWithType>はの場合、リーダーは一致<xref:System.Text.Json.JsonTokenType.EndObject?displayProperty=nameWithType>する<xref:System.Text.Json.JsonTokenType.EndArray?displayProperty=nameWithType>またはに進みます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-284">When <xref:System.Text.Json.Utf8JsonReader.TokenType> (originally, or after advancing) is <xref:System.Text.Json.JsonTokenType.StartObject?displayProperty=nameWithType> or <xref:System.Text.Json.JsonTokenType.StartArray?displayProperty=nameWithType>, the reader advances to the matching <xref:System.Text.Json.JsonTokenType.EndObject?displayProperty=nameWithType> or <xref:System.Text.Json.JsonTokenType.EndArray?displayProperty=nameWithType>.</span></span>
            
<span data-ttu-id="5a93a-285">他のすべてのトークン型については、リーダーは移動しません。</span><span class="sxs-lookup"><span data-stu-id="5a93a-285">For all other token types, the reader does not move.</span></span> <span data-ttu-id="5a93a-286">次にを<xref:System.Text.Json.Utf8JsonReader.Read>呼び出した後、リーダーは次の値 (配列内の場合)、次のプロパティ名 (オブジェクトの場合)、または終了配列/オブジェクトトークンになります。</span><span class="sxs-lookup"><span data-stu-id="5a93a-286">After the next call to <xref:System.Text.Json.Utf8JsonReader.Read>, the reader will be at the next value (when in an array), the next property name (when in an object), or the end array/object token.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.Text.Json.JsonException"><span data-ttu-id="5a93a-287">JSON RFC に基づき、スキップ中、無効な JSON トークンが検出されました。</span><span class="sxs-lookup"><span data-stu-id="5a93a-287">An invalid JSON token was encountered while skipping, according to the JSON RFC.</span></span>
          
<span data-ttu-id="5a93a-288">または</span><span class="sxs-lookup"><span data-stu-id="5a93a-288">- or -</span></span>

<span data-ttu-id="5a93a-289">現在の深度が、最大深度によって設定された再帰の限度を超えています。</span><span class="sxs-lookup"><span data-stu-id="5a93a-289">The current depth exceeds the recursive limit set by the maximum depth.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ValueSequence">
      <MemberSignature Language="C#" Value="public System.Buffers.ReadOnlySequence&lt;byte&gt; ValueSequence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Buffers.ReadOnlySequence`1&lt;unsigned int8&gt; ValueSequence" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.ValueSequence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSequence As ReadOnlySequence(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Buffers::ReadOnlySequence&lt;System::Byte&gt; ValueSequence { System::Buffers::ReadOnlySequence&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSequence : System.Buffers.ReadOnlySequence&lt;byte&gt;" Usage="System.Text.Json.Utf8JsonReader.ValueSequence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IsReadOnly</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Buffers.ReadOnlySequence&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5a93a-290">最後に処理されたトークンの値を、入力ペイロードの ReadOnlySpan&lt;byte&gt; スライスとして取得します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-290">Gets the value of the last processed token as a ReadOnlySpan&lt;byte&gt; slice of the input payload.</span></span> <span data-ttu-id="5a93a-291">JSON が ReadOnlySequence&lt;byte&gt; 内に指定されていて、トークン値を表すスライスが単一のセグメント内に収まる場合、<see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> にはスライスされた値が格納されます。それをスパンとして表現できるからです。</span><span class="sxs-lookup"><span data-stu-id="5a93a-291">If the JSON is provided within a ReadOnlySequence&lt;byte&gt; and the slice that represents the token value fits in a single segment, then <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> contains the sliced value since it can be represented as a span.</span></span>
<span data-ttu-id="5a93a-292">それ以外の場合、<see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> にはトークン値が格納されます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-292">Otherwise, <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> contains the token value.</span></span></summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks


<span data-ttu-id="5a93a-293">が<xref:System.Text.Json.Utf8JsonReader.HasValueSequence> `ValueSequence`の場合、は空です。 `false`</span><span class="sxs-lookup"><span data-stu-id="5a93a-293">If <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> is `false`, `ValueSequence` is empty.</span></span> <span data-ttu-id="5a93a-294">したがって、が`ValueSequence` `true`の<xref:System.Text.Json.Utf8JsonReader.HasValueSequence>場合にのみアクセスします。</span><span class="sxs-lookup"><span data-stu-id="5a93a-294">Therefore, only access `ValueSequence` if <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> is `true`.</span></span>
<span data-ttu-id="5a93a-295">それ以外の場合は、から<xref:System.Text.Json.Utf8JsonReader.ValueSpan>トークン値にアクセスする必要があります。</span><span class="sxs-lookup"><span data-stu-id="5a93a-295">Otherwise, the token value must be accessed from <xref:System.Text.Json.Utf8JsonReader.ValueSpan>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSpan">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;byte&gt; ValueSpan { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; ValueSpan" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.ValueSpan" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSpan As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ReadOnlySpan&lt;System::Byte&gt; ValueSpan { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSpan : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Json.Utf8JsonReader.ValueSpan" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IsReadOnly</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5a93a-296">最後に処理されたトークンの値を、入力ペイロードの ReadOnlySpan&lt;byte&gt; スライスとして取得します。</span><span class="sxs-lookup"><span data-stu-id="5a93a-296">Gets the value of the last processed token as a ReadOnlySpan&lt;byte&gt; slice of the input payload.</span></span> <span data-ttu-id="5a93a-297">JSON が ReadOnlySequence&lt;byte&gt; 内に指定されていて、トークン値を表すスライスが単一のセグメント内に収まる場合、<see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> にはスライスされた値が格納されます。それをスパンとして表現できるからです。</span><span class="sxs-lookup"><span data-stu-id="5a93a-297">If the JSON is provided within a ReadOnlySequence&lt;byte&gt; and the slice that represents the token value fits in a single segment, then <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> contains the sliced value since it can be represented as a span.</span></span>
<span data-ttu-id="5a93a-298">それ以外の場合、<see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> にはトークン値が格納されます。</span><span class="sxs-lookup"><span data-stu-id="5a93a-298">Otherwise, the <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> contains the token value.</span></span></summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5a93a-299">が<xref:System.Text.Json.Utf8JsonReader.HasValueSequence> <xref:System.Text.Json.Utf8JsonReader.ValueSpan>の場合、は空です。 `true`</span><span class="sxs-lookup"><span data-stu-id="5a93a-299">If <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> is `true`, <xref:System.Text.Json.Utf8JsonReader.ValueSpan> is empty.</span></span> <span data-ttu-id="5a93a-300">したがって、が`ValueSpan` `false`の<xref:System.Text.Json.Utf8JsonReader.HasValueSequence>場合にのみアクセスします。</span><span class="sxs-lookup"><span data-stu-id="5a93a-300">Therefore, only access `ValueSpan` if <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> is `false`.</span></span>
<span data-ttu-id="5a93a-301">それ以外の場合は、から<xref:System.Text.Json.Utf8JsonReader.ValueSequence>トークン値にアクセスする必要があります。</span><span class="sxs-lookup"><span data-stu-id="5a93a-301">Otherwise, the token value must be accessed from <xref:System.Text.Json.Utf8JsonReader.ValueSequence>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueTextEquals">
      <MemberSignature Language="C#" Value="public bool ValueTextEquals (ReadOnlySpan&lt;byte&gt; utf8Text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValueTextEquals(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.ValueTextEquals(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function ValueTextEquals (utf8Text As ReadOnlySpan(Of Byte)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValueTextEquals(ReadOnlySpan&lt;System::Byte&gt; utf8Text);" />
      <MemberSignature Language="F#" Value="member this.ValueTextEquals : ReadOnlySpan&lt;byte&gt; -&gt; bool" Usage="utf8JsonReader.ValueTextEquals utf8Text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="utf8Text">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueTextEquals">
      <MemberSignature Language="C#" Value="public bool ValueTextEquals (ReadOnlySpan&lt;char&gt; text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValueTextEquals(valuetype System.ReadOnlySpan`1&lt;char&gt; text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.ValueTextEquals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function ValueTextEquals (text As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValueTextEquals(ReadOnlySpan&lt;char&gt; text);" />
      <MemberSignature Language="F#" Value="member this.ValueTextEquals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="utf8JsonReader.ValueTextEquals text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="text">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueTextEquals">
      <MemberSignature Language="C#" Value="public bool ValueTextEquals (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValueTextEquals(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.ValueTextEquals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ValueTextEquals (text As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValueTextEquals(System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.ValueTextEquals : string -&gt; bool" Usage="utf8JsonReader.ValueTextEquals text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>