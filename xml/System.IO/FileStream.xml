<Type Name="FileStream" FullName="System.IO.FileStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dc5ed181a3b71bafd66689b0d61664367786fda3" /><Meta Name="ms.sourcegitcommit" Value="662f143e6be46d519ff8ab4451d543d91e651478" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/18/2018" /><Meta Name="ms.locfileid" Value="53568708" /></Metadata><TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class FileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type FileStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>同期および非同期の読み取り操作と書き込み操作をサポートするファイル用の <see cref="T:System.IO.Stream" /> を提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.IO.FileStream>を読み取り、書き込みを開き、ファイル システム上のファイルを閉じると、パイプ、標準入力は、標準出力など、他のファイルに関連するオペレーティング システム ハンドルを操作するクラス。 使用することができます、 <xref:System.IO.FileStream.Read%2A>、 <xref:System.IO.FileStream.Write%2A>、 <xref:System.IO.Stream.CopyTo%2A>、および<xref:System.IO.FileStream.Flush%2A>同期操作を実行するメソッドまたは<xref:System.IO.FileStream.ReadAsync%2A>、 <xref:System.IO.FileStream.WriteAsync%2A>、 <xref:System.IO.Stream.CopyToAsync%2A>、および<xref:System.IO.FileStream.FlushAsync%2A>を非同期に実行するメソッド操作です。 非同期のメソッドを使用すると、メイン スレッドをブロックすることがなくリソースを消費するファイル操作を実行できます。 このパフォーマンスに関する考慮事項は、時間のかかるストリーム操作によって UI スレッドがブロックされ、アプリが動作していないと見なされる可能性がある [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリまたは[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] アプリで特に重要です。 <xref:System.IO.FileStream> 入力バッファーとパフォーマンス向上のための出力。  
  
> [!IMPORTANT]
>  この型は、<xref:System.IDisposable>インターフェイス。 型の使用が完了したら、直接的または間接的にそれを破棄する必要があります。 型の直接 dispose を呼び出してその<xref:System.IDisposable.Dispose%2A>メソッド、 `try` / `catch`ブロックします。 直接ことのない破棄する場合など、言語コンストラクトを使用して`using`(で C# の場合) または`Using`(Visual Basic) でします。 詳細については、"を使用して、オブジェクトを実装する IDisposable"のセクションを参照してください、<xref:System.IDisposable>インターフェイスに関するトピック。  
  
 <xref:System.IO.FileStream.IsAsync%2A>プロパティは、ファイル ハンドルが非同期的に開かれたかどうかを検出します。 インスタンスを作成するときに、この値を指定する、<xref:System.IO.FileStream>クラスを持つコンス トラクターを使用して、 `isAsync`、 `useAsync`、または`options`パラメーター。 プロパティが`true`ストリームがファイル操作を非同期的に実行する重複 I/O を利用します。 ただし、<xref:System.IO.FileStream.IsAsync%2A>プロパティにあるありません`true`を呼び出す、 <xref:System.IO.FileStream.ReadAsync%2A>、 <xref:System.IO.FileStream.WriteAsync%2A>、または<xref:System.IO.Stream.CopyToAsync%2A>メソッド。 ときに、<xref:System.IO.FileStream.IsAsync%2A>プロパティは`false`書き込み操作および非同期の読み取りを呼び出すと、まだ、UI スレッドはブロックされませんが、実際の I/O 操作が同期的に実行します。  
  
 <xref:System.IO.FileStream.Seek%2A>メソッドは、ファイルへのランダム アクセスをサポートしています。 <xref:System.IO.FileStream.Seek%2A> ファイル内の任意の位置に移動する読み取り/書き込み位置を使用できます。 これは、バイト オフセット参照点パラメーターを使用します。 バイト オフセットの 3 つのメンバーによって表される先頭、現在の位置または基になるファイルの末尾を指定できるシーク参照ポイントは、<xref:System.IO.SeekOrigin>列挙体。  
  
> [!NOTE]
>  ディスク ファイルは、常にランダム アクセスをサポートします。 構築時に、<xref:System.IO.FileStream.CanSeek%2A>プロパティの値に設定されます`true`または`false`基になるファイルの種類によって異なります。基になるファイルの種類が file_type_disk ではありません、winbase.h で定義されている場合、<xref:System.IO.FileStream.CanSeek%2A>プロパティの値が`true`します。 それ以外の場合、<xref:System.IO.FileStream.CanSeek%2A>プロパティの値が`false`します。  
  
 プロセスがロックされているファイルの一部で終了するかを未解決のロックを持つファイルを動作は定義されません。  
  
 ディレクトリ操作とその他のファイル操作では、次を参照してください。、 <xref:System.IO.File>、 <xref:System.IO.Directory>、および<xref:System.IO.Path>クラス。 <xref:System.IO.File>クラスは、ユーティリティ クラスの作成に主に静的メソッドを持つ<xref:System.IO.FileStream>オブジェクト ファイルのパスをベースにします。 <xref:System.IO.MemoryStream>クラスは、バイト配列からストリームを作成しに似ていますが、<xref:System.IO.FileStream>クラス。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
## <a name="detection-of-stream-position-changes"></a>Stream の位置の変更の検出  
 ときに、<xref:System.IO.FileStream>オブジェクトでは、そのハンドルでは、排他的に保持にいない、別のスレッド ファイル ハンドルを同時にアクセスし、ファイル ハンドルに関連付けられているオペレーティング システムのファイル ポインターの位置を変更します。 この場合、キャッシュ内の位置、<xref:System.IO.FileStream>オブジェクトと、バッファーにキャッシュされたデータを侵害する可能性があります。 <xref:System.IO.FileStream>オブジェクトは、オペレーティング システムのハンドルの位置で使用されるキャッシュの位置と同じであることを確認するキャッシュされたバッファーにアクセスするメソッドに対してチェックを定期的に実行、<xref:System.IO.FileStream>オブジェクト。  
  
 呼び出しでハンドルの位置で予期しない変更が検出されたかどうか、<xref:System.IO.FileStream.Read%2A>メソッド、.NET Framework は、バッファーの内容を破棄し、ファイルからストリームを再度読み取ります。 ファイル ストリームの位置に影響を与える他のプロセスとファイルのサイズによって、パフォーマンスに影響を与えることができます。  
  
 呼び出しでハンドルの位置で予期しない変更が検出されたかどうか、<xref:System.IO.FileStream.Write%2A>メソッド、バッファーの内容は破棄されます、<xref:System.IO.IOException>例外がスローされます。  
  
 A<xref:System.IO.FileStream>オブジェクトでは、そのハンドルでは、排他的に保持はないときか、<xref:System.IO.FileStream.SafeFileHandle%2A>ハンドルを公開するプロパティにアクセスまたは<xref:System.IO.FileStream>オブジェクトが割り当てられて、<xref:System.IO.FileStream.SafeFileHandle%2A>コンス トラクター内のプロパティ。  
  
   
  
## Examples  
 次の例では、一部を示します、<xref:System.IO.FileStream>コンス トラクター。  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 次の例では、ファイルへの書き込みを非同期にする方法を示します。 このコードは、TextBlock UserInput および Button_Click という Click イベント ハンドラーにフック ボタンという名前を含む WPF アプリで実行されます。 ファイルのパスは、コンピューター上に存在するファイルに変更する必要があります。  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
    <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">方法 : 新しく作成されたデータ ファイルに対して読み書きする</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのファイル ハンドル。</param>
        <param name="access"><see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> プロパティと <see cref="P:System.IO.FileStream.CanWrite" /> プロパティを設定する定数。</param>
        <summary><see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定した読み取り/書き込みアクセス許可を使用して、指定したファイル ハンドル用に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに<xref:System.IO.Stream.Close%2A>が呼び出されると、ハンドルも閉じられ、ファイルのハンドル カウントがデクリメントされます。  
  
 `FileStream` ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、またはシーク中に、`FileStream`データの破損の可能性があります、ハンドルを保持していることもできます。 データの安全性、呼び出す<xref:System.IO.FileStream.Flush%2A>前に、ハンドルを使用して、以外の任意のメソッドの呼び出しを回避`Close`が完了したら、ハンドルを使用して。  
  
> [!CAUTION]
>  特定のカルチャ設定と一連の文字をコンパイルして、同じ文字を別のカルチャ設定を取得すると、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 `FileShare.Read` これらの既定値は、<xref:System.IO.FileStream>なしのコンス トラクター、`FileShare`パラメーター。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> が <see cref="T:System.IO.FileAccess" /> のフィールドではありません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.IOException">ディスク エラーなどの I/O エラーが発生しました。  
  
または 
ストリームは閉じられました。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> が <see langword="Write" /> または <see langword="ReadWrite" /> であるのに、ファイル ハンドルが読み取り専用に設定されているなど、指定したファイル ハンドルに対する <paramref name="access" /> 要求がオペレーティング システムで許可されません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取り、書き込み、およびファイルに追加します。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />、および<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />します。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのファイル ハンドル。</param>
        <param name="access"><see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> プロパティと <see cref="P:System.IO.FileStream.CanWrite" /> プロパティを設定する定数。</param>
        <summary><see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定した読み取り/書き込みアクセス許可を使用して、指定したファイル ハンドル用に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに<xref:System.IO.Stream.Close%2A>が呼び出されると、ハンドルも閉じられ、ファイルのハンドル カウントがデクリメントされます。  
  
 `FileStream` ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、またはシーク中に、`FileStream`データの破損の可能性があります、ハンドルを保持していることもできます。 データの安全性、呼び出す<xref:System.IO.FileStream.Flush%2A>前に、ハンドルを使用して、以外の任意のメソッドの呼び出しを回避`Close`が完了したら、ハンドルを使用して。  
  
> [!CAUTION]
>  特定のカルチャ設定と一連の文字をコンパイルして、同じ文字を別のカルチャ設定を取得すると、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 `FileShare.Read` これらの既定値は、<xref:System.IO.FileStream>なしのコンス トラクター、`FileShare`パラメーター。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> が <see cref="T:System.IO.FileAccess" /> のフィールドではありません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.IOException">ディスク エラーなどの I/O エラーが発生しました。  
  
または 
ストリームは閉じられました。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> が <see langword="Write" /> または <see langword="ReadWrite" /> であるのに、ファイル ハンドルが読み取り専用に設定されているなど、指定したファイル ハンドルに対する <paramref name="access" /> 要求がオペレーティング システムで許可されません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取り、書き込み、およびファイルに追加します。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />、および<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />します。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルの相対パスまたは絶対パス。</param>
        <param name="mode">ファイルを開く方法または作成する方法を決定する定数。</param>
        <summary><see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定したパスと作成モードを使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework は、デバイス名をなどにパスを使用して物理ディスクへの直接アクセスをサポートしていません"\\\\。 \PHYSICALDRIVE0"です。  
  
 `path`パラメーターは、汎用名前付け規則 (UNC) 共有上のファイルを含む、ファイル名を指定できます。  
  
 コンス トラクターには、ファイルを読み取り/書き込みアクセスが与えられるし、共有読み取りアクセスが開かれる (まで、同じまたは別のプロセスでの書き込みは失敗のファイルを開くには、要求、`FileStream`オブジェクトが閉じられましたが、読み取り試行が成功)。  
  
 このコンス トラクターを使用して、読み取り専用のファイルを開くことはできません。代わりに、受け取るコンス トラクターを使用する必要があります、`FileAccess`パラメーター値を設定して`FileAccess.Read`します。  
  
 バッファー サイズは 4096 バイト (KB) の既定のサイズに設定されます。  
  
> [!NOTE]
>  `path` ディスクに格納されているファイルにする必要はありません。ストリーム経由でアクセスをサポートするシステムの任意の部分であることができます。 たとえば、システムによってこのクラスは、物理デバイスをアクセスできます。  
  
 <xref:System.IO.Stream.CanSeek%2A> `true`すべて<xref:System.IO.FileStream>ファイルをカプセル化するオブジェクト。 場合`path`、シークをサポートしていないデバイスを示す、<xref:System.IO.FileStream.CanSeek%2A>プロパティ、結果として<xref:System.IO.FileStream>は`false`します。 詳細については、「<xref:System.IO.Stream.CanSeek%2A>」を参照してください。  
  
 `FileShare.Read` これらの既定値は、<xref:System.IO.FileStream>なしのコンス トラクター、`FileShare`パラメーター。  
  
 なしのコンス トラクター、<xref:System.IO.FileAccess>パラメーター場合、`mode`パラメーターを設定する<xref:System.IO.FileMode.Append>、<xref:System.IO.FileAccess.Write>は既定のアクセス。 アクセスを設定する場合は、<xref:System.IO.FileAccess.ReadWrite>します。  
  
> [!CAUTION]
>  特定のカルチャ設定と一連の文字をコンパイルして、同じ文字を別のカルチャ設定を取得すると、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
   
  
## Examples  
 次のコード例では、ファイル、1 バイトずつデータを書き込むし、データが正しく書き込まれていることを確認する方法を示します。  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> は空の文字列 ("") であるか、空白のみで構成されているか、または 1 つ以上の正しくない文字を含んでいます。  
  
または 
 <paramref name="path" /> が NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照しています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> がファイル以外のデバイスを参照しています (NTFS 以外の環境の "con:"、"com1:"、"lpt1:" など)。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイルが見つかりません。たとえば、<paramref name="mode" /> が <see langword="FileMode.Truncate" /> または <see langword="FileMode.Open" /> の場合に、<paramref name="path" /> で指定されたファイルが存在しません。 これらのモードではファイルが既に存在している必要があります。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> で指定したファイルが既に存在している場合に <see langword="FileMode.CreateNew" /> を指定しているなどの I/O エラーが発生しました。  
  
または 
ストリームは閉じられています。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">マップされていないドライブにあるなど、指定されたパスが無効です。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定したパス、ファイル名、またはその両方がシステム定義の最大長を超えています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> に無効な値が含まれています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取り、書き込み、およびファイルに追加します。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />、および<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />します。</permission>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのファイル ハンドル。</param>
        <param name="access"><see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> プロパティと <see cref="P:System.IO.FileStream.CanWrite" /> プロパティを設定する <see cref="T:System.IO.FileAccess" /> 定数。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは、4096 です。</param>
        <summary><see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定した読み取り/書き込みアクセス許可、およびバッファー サイズを使用して、指定したファイル ハンドル用に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、またはシーク中に、`FileStream`データの破損の可能性があります、ハンドルを保持していることもできます。 データの安全性、呼び出す<xref:System.IO.FileStream.Flush%2A>前に、ハンドルを使用して、以外の任意のメソッドの呼び出しを回避`Close`が完了したら、ハンドルを使用して。 代わりに、読み取りし、これを呼び出す前に、ハンドルを書き込む`FileStream`コンス トラクター。  
  
 `FileShare.Read` これらの既定値は、<xref:System.IO.FileStream>なしのコンス トラクター、`FileShare`パラメーター。  
  
> [!CAUTION]
>  特定のカルチャ設定と一連の文字をコンパイルして、同じ文字を別のカルチャ設定を取得すると、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="handle" /> パラメーターが無効なハンドルです。  
  
または 
同期ハンドルである <paramref name="handle" /> パラメーターが、非同期的に使用されました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> パラメーターが負です。</exception>
        <exception cref="T:System.IO.IOException">ディスク エラーなどの I/O エラーが発生しました。  
  
- または - 
ストリームは閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> が <see langword="Write" /> または <see langword="ReadWrite" /> であるのに、ファイル ハンドルが読み取り専用に設定されているなど、指定したファイル ハンドルに対する <paramref name="access" /> 要求がオペレーティング システムで許可されません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取り、書き込み、およびファイルに追加します。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />、および<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />します。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出すアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのファイル ハンドル。</param>
        <param name="access"><see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> プロパティと <see cref="P:System.IO.FileStream.CanWrite" /> プロパティを設定する定数。</param>
        <param name="ownsHandle">この <see langword="FileStream" /> インスタンスがファイル ハンドルを所有する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary><see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定した読み取り/書き込みアクセス許可と <see langword="FileStream" /> インスタンスの所有権を使用して、指定したファイル ハンドル用に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream`オブジェクトには、ファイルに指定したアクセスが与えられます。 ハンドルの所有権があると指定します。 このプロセスが、ハンドルへの呼び出しを所有しているかどうか、<xref:System.IO.Stream.Close%2A>メソッドは、ハンドルも閉じるし、ファイルのハンドルの数がデクリメントされます。 `FileStream`オブジェクトには、既定のバッファー サイズは 4096 バイトが与えられます。  
  
 `FileStream` ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、またはシーク中に、`FileStream`データの破損の可能性があります、ハンドルを保持していることもできます。 データの安全性、呼び出す<xref:System.IO.FileStream.Flush%2A>前に、ハンドルを使用して、以外のメソッドは呼び出しません`Close`が完了したら、ハンドルを使用して。  
  
 `FileShare.Read` これらの既定値は、<xref:System.IO.FileStream>なしのコンス トラクター、`FileShare`パラメーター。  
  
> [!CAUTION]
>  特定のカルチャ設定と一連の文字をコンパイルして、同じ文字を別のカルチャ設定を取得すると、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> が <see cref="T:System.IO.FileAccess" /> のフィールドではありません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.IOException">ディスク エラーなどの I/O エラーが発生しました。  
  
または 
ストリームは閉じられました。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> が <see langword="Write" /> または <see langword="ReadWrite" /> であるのに、ファイル ハンドルが読み取り専用に設定されているなど、指定したファイル ハンドルに対する <paramref name="access" /> 要求がオペレーティング システムで許可されません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取り、書き込み、およびファイルに追加します。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />、および<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />します。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルの相対パスまたは絶対パス。</param>
        <param name="mode">ファイルを開く方法または作成する方法を決定する定数。</param>
        <param name="access"><see langword="FileStream" /> オブジェクトがファイルにアクセスできる方法を決定する定数。 これにより、<see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> および <see cref="P:System.IO.FileStream.CanWrite" /> プロパティによって返される値も決まります。 <paramref name="path" /> がディスク ファイルを指定している場合、<see cref="P:System.IO.FileStream.CanSeek" /> は <see langword="true" /> になります。</param>
        <summary><see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定したパス、作成モード、および読み取り/書き込みアクセス許可を使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework は、デバイス名をなどにパスを使用して物理ディスクへの直接アクセスをサポートしていません"\\\\。 \PHYSICALDRIVE0"です。  
  
 `path`パラメーターは、汎用名前付け規則 (UNC) 共有上のファイルを含む、ファイル名を指定できます。  
  
 コンス トラクターには、ファイルを読み取り/書き込みアクセスが与えられるし、共有読み取りアクセスが開かれる (まで、同じまたは別のプロセスでの書き込みは失敗のファイルを開くには、要求、`FileStream`オブジェクトが閉じられましたが、読み取り試行が成功)。 バッファー サイズは 4096 バイト (KB) の既定のサイズに設定されます。  
  
> [!NOTE]
>  `path` ディスクに格納されているファイルにする必要はありません。ストリーム経由でアクセスをサポートするシステムの任意の部分であることができます。 たとえば、システムによってこのクラスは、物理デバイスをアクセスできます。  
  
 <xref:System.IO.Stream.CanSeek%2A> `true`すべて<xref:System.IO.FileStream>ファイルをカプセル化するオブジェクト。 場合`path`、シークをサポートしていないデバイスを示す、<xref:System.IO.FileStream.CanSeek%2A>プロパティ、結果として<xref:System.IO.FileStream>は`false`します。 詳細については、「<xref:System.IO.Stream.CanSeek%2A>」を参照してください。  
  
 `FileShare.Read` これらの既定値は、<xref:System.IO.FileStream>なしのコンス トラクター、`FileShare`パラメーター。  
  
> [!CAUTION]
>  特定のカルチャ設定と一連の文字をコンパイルして、同じ文字を別のカルチャ設定を取得すると、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> は空の文字列 ("") であるか、空白のみで構成されているか、または 1 つ以上の正しくない文字を含んでいます。  
  
または 
 <paramref name="path" /> が NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照しています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> は非 NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照します。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイルが見つかりません。たとえば、<paramref name="mode" /> が <see langword="FileMode.Truncate" /> または <see langword="FileMode.Open" /> の場合に、<paramref name="path" /> で指定されたファイルが存在しません。 これらのモードではファイルが既に存在している必要があります。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> で指定したファイルが既に存在している場合に <see langword="FileMode.CreateNew" /> を指定しているなどの I/O エラーが発生しました。  
  
- または - 
ストリームは閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">マップされていないドライブにあるなど、指定されたパスが無効です。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> が <see langword="Write" /> または <see langword="ReadWrite" /> であるのに、ファイルまたはディレクトリが読み取り専用に設定されているなど、指定した <paramref name="path" /> に対する <paramref name="access" /> 要求がオペレーティング システムで許可されません。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定したパス、ファイル名、またはその両方がシステム定義の最大長を超えています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> に無効な値が含まれています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取り、書き込み、およびファイルに追加します。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />、および<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />します。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">この <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのファイル ハンドル。</param>
        <param name="access"><see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> プロパティと <see cref="P:System.IO.FileStream.CanWrite" /> プロパティを設定する定数。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは、4096 です。</param>
        <param name="isAsync">ハンドルが非同期的に開かれた場合 (重複 I/O モード用) は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary><see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定した読み取り/書き込みアクセス許可、バッファー サイズ、および同期状態または非同期状態を使用して、指定したファイル ハンドル用に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定する、`isAsync`パラメーターを`true`を非同期的にファイル ハンドルを開きます。 パラメーターの場合は`true`ストリームがファイル操作を非同期的に実行する重複 I/O を利用します。 ただし、パラメーターは、する必要はない`true`を呼び出す、 <xref:System.IO.FileStream.ReadAsync%2A>、 <xref:System.IO.FileStream.WriteAsync%2A>、または<xref:System.IO.Stream.CopyToAsync%2A>メソッド。 ときに、`isAsync`パラメーターが`false`書き込み操作および非同期の読み取りを呼び出すと、まだ、UI スレッドはブロックされませんが、実際の I/O 操作が同期的に実行します。  
  
 `FileStream` ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、またはシーク中に、`FileStream`データの破損の可能性があります、ハンドルを保持していることもできます。 データの安全性、呼び出す<xref:System.IO.FileStream.Flush%2A>前に、ハンドルを使用して、以外の任意のメソッドの呼び出しを回避`Close`が完了したら、ハンドルを使用して。 代わりに、読み取りし、これを呼び出す前に、ハンドルを書き込む`FileStream`コンス トラクター。  
  
 `FileShare.Read` これらの既定値は、<xref:System.IO.FileStream>なしのコンス トラクター、`FileShare`パラメーター。  
  
> [!CAUTION]
>  特定のカルチャ設定と一連の文字をコンパイルして、同じ文字を別のカルチャ設定を取得すると、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="handle" /> パラメーターが無効なハンドルです。  
  
または 
同期ハンドルである <paramref name="handle" /> パラメーターが、非同期的に使用されました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> パラメーターが負です。</exception>
        <exception cref="T:System.IO.IOException">ディスク エラーなどの I/O エラーが発生しました。  
  
または 
ストリームは閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> が <see langword="Write" /> または <see langword="ReadWrite" /> であるのに、ファイル ハンドルが読み取り専用に設定されているなど、指定したファイル ハンドルに対する <paramref name="access" /> 要求がオペレーティング システムで許可されません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取り、書き込み、およびファイルに追加します。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />、および<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />します。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出すアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">この <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのファイル ハンドル。</param>
        <param name="access"><see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> プロパティと <see cref="P:System.IO.FileStream.CanWrite" /> プロパティを設定する定数。</param>
        <param name="ownsHandle">この <see langword="FileStream" /> インスタンスがファイル ハンドルを所有する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは、4096 です。</param>
        <summary><see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定した読み取り/書き込みアクセス許可、<see langword="FileStream" /> インスタンスの所有権、およびバッファー サイズを使用して、指定したファイル ハンドル用に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream`オブジェクトには、ファイルに指定したアクセスが与えられます。 ハンドルの所有権があると指定します。 この場合`FileStream`への呼び出し、ハンドルを所有している、<xref:System.IO.Stream.Close%2A>メソッドは、ハンドルも閉じられます。 具体的には、ファイルのハンドル数は減少します。 `FileStream`オブジェクトが指定されたバッファー サイズを指定します。  
  
 `FileStream` ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、またはシーク中に、`FileStream`データの破損の可能性があります、ハンドルを保持していることもできます。 データの安全性、呼び出す<xref:System.IO.FileStream.Flush%2A>前に、ハンドルを使用して、以外の任意のメソッドの呼び出しを回避`Close`が完了したら、ハンドルを使用して。 代わりに、読み取りし、これを呼び出す前に、ハンドルを書き込む`FileStream`コンス トラクター。  
  
 `FileShare.Read` これらの既定値は、<xref:System.IO.FileStream>なしのコンス トラクター、`FileShare`パラメーター。  
  
> [!CAUTION]
>  特定のカルチャ設定と一連の文字をコンパイルして、同じ文字を別のカルチャ設定を取得すると、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> が負の値です。</exception>
        <exception cref="T:System.IO.IOException">ディスク エラーなどの、I/O エラーが発生しました。  
  
または 
ストリームは閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> が <see langword="Write" /> または <see langword="ReadWrite" /> であるのに、ファイル ハンドルが読み取り専用に設定されているなど、指定したファイル ハンドルに対する <paramref name="access" /> 要求がオペレーティング システムで許可されません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取り、書き込み、およびファイルに追加します。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />、および<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />します。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルの相対パスまたは絶対パス。</param>
        <param name="mode">ファイルを開く方法または作成する方法を決定する定数。</param>
        <param name="access"><see langword="FileStream" /> オブジェクトがファイルにアクセスできる方法を決定する定数。 これにより、<see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> および <see cref="P:System.IO.FileStream.CanWrite" /> プロパティによって返される値も決まります。 <paramref name="path" /> がディスク ファイルを指定している場合、<see cref="P:System.IO.FileStream.CanSeek" /> は <see langword="true" /> になります。</param>
        <param name="share">プロセスによるファイルの共有方法を決定する定数。</param>
        <summary><see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定したパス、作成モード、読み取り/書き込みアクセス許可、および共有アクセス許可を使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework は、デバイス名をなどにパスを使用して物理ディスクへの直接アクセスをサポートしていません"\\\\。 \PHYSICALDRIVE0"です。  
  
 `path`パラメーターは、汎用名前付け規則 (UNC) 共有上のファイルを含む、ファイル名を指定できます。  
  
 コンス トラクターには、ファイルを読み取り/書き込みアクセスが与えられるし、共有読み取りアクセスが開かれる (まで、同じまたは別のプロセスでの書き込みは失敗のファイルを開くには、要求、`FileStream`オブジェクトが閉じられましたが、読み取り試行が成功)。 バッファー サイズは 4096 バイト (KB) の既定のサイズに設定されます。  
  
> [!NOTE]
>  `path` ディスクに格納されているファイルにする必要はありません。ストリーム経由でアクセスをサポートするシステムの任意の部分であることができます。 たとえば、システムによってこのクラスは、物理デバイスをアクセスできます。  
  
 <xref:System.IO.Stream.CanSeek%2A> `true`すべて<xref:System.IO.FileStream>ファイルをカプセル化するオブジェクト。 場合`path`、シークをサポートしていないデバイスを示す、<xref:System.IO.FileStream.CanSeek%2A>プロパティ、結果として<xref:System.IO.FileStream>は`false`します。 詳細については、「<xref:System.IO.Stream.CanSeek%2A>」を参照してください。  
  
> [!CAUTION]
>  特定のカルチャ設定と一連の文字をコンパイルして、同じ文字を別のカルチャ設定を取得すると、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
   
  
## Examples  
 このコード例が示されている例の一部、<xref:System.IO.FileStream.Lock%2A>メソッド。  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> は空の文字列 ("") であるか、空白のみで構成されているか、または 1 つ以上の正しくない文字を含んでいます。  
  
- または - 
 <paramref name="path" /> が NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照しています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> は非 NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照します。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイルが見つかりません。たとえば、<paramref name="mode" /> が <see langword="FileMode.Truncate" /> または <see langword="FileMode.Open" /> の場合に、<paramref name="path" /> で指定されたファイルが存在しません。 これらのモードではファイルが既に存在している必要があります。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> で指定したファイルが既に存在している場合に <see langword="FileMode.CreateNew" /> を指定しているなどの I/O エラーが発生しました。  
  
または 
システムが Windows 98 または Windows 98 Second Edition を実行中で、<paramref name="share" /> が <see langword="FileShare.Delete" /> に設定されています。  
  
- または - 
ストリームは閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">マップされていないドライブにあるなど、指定されたパスが無効です。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> が <see langword="Write" /> または <see langword="ReadWrite" /> であるのに、ファイルまたはディレクトリが読み取り専用に設定されているなど、指定した <paramref name="path" /> に対する <paramref name="access" /> 要求がオペレーティング システムで許可されません。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定したパス、ファイル名、またはその両方がシステム定義の最大長を超えています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> に無効な値が含まれています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取り、書き込み、およびファイルに追加します。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />、および<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />します。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">この <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのファイル ハンドル。</param>
        <param name="access"><see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> プロパティと <see cref="P:System.IO.FileStream.CanWrite" /> プロパティを設定する定数。</param>
        <param name="ownsHandle">この <see langword="FileStream" /> インスタンスがファイル ハンドルを所有する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは、4096 です。</param>
        <param name="isAsync">ハンドルが非同期的に開かれた場合 (重複 I/O モード用) は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary><see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定した読み取り/書き込みアクセス許可、<see langword="FileStream" /> インスタンスの所有権、バッファー サイズ、および同期状態または非同期状態を使用して、指定したファイル ハンドル用に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream`オブジェクトには、ファイルに指定したアクセスが与えられます。 ハンドルの所有権があると指定します。 この場合`FileStream`への呼び出し、ハンドルを所有している、<xref:System.IO.Stream.Close%2A>メソッドは、ハンドルも閉じられます。 具体的には、ファイルのハンドル数は減少します。 `FileStream`オブジェクトが指定されたバッファー サイズを指定します。  
  
 `FileStream` ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、またはシーク中に、`FileStream`データの破損の可能性があります、ハンドルを保持していることもできます。 データの安全性、呼び出す<xref:System.IO.FileStream.Flush%2A>前に、ハンドルを使用して、以外の任意のメソッドの呼び出しを回避`Close`が完了したら、ハンドルを使用して。 代わりに、読み取りし、これを呼び出す前に、ハンドルを書き込む`FileStream`コンス トラクター。  
  
 `FileShare.Read` これらの既定値は、<xref:System.IO.FileStream>なしのコンス トラクター、`FileShare`パラメーター。  
  
> [!CAUTION]
>  特定のカルチャ設定と一連の文字をコンパイルして、同じ文字を別のカルチャ設定を取得すると、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="access" /> が <see langword="FileAccess.Read" /> 未満であるか、<see langword="FileAccess.ReadWrite" /> 以上であるか、または <paramref name="bufferSize" /> が 0 以下です。</exception>
        <exception cref="T:System.ArgumentException">ハンドルが正しくありません。</exception>
        <exception cref="T:System.IO.IOException">ディスク エラーなどの I/O エラーが発生しました。  
  
- または - 
ストリームは閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> が <see langword="Write" /> または <see langword="ReadWrite" /> であるのに、ファイル ハンドルが読み取り専用に設定されているなど、指定したファイル ハンドルに対する <paramref name="access" /> 要求がオペレーティング システムで許可されません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードにアクセスします。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルの相対パスまたは絶対パス。</param>
        <param name="mode">ファイルを開く方法または作成する方法を決定する定数。</param>
        <param name="access"><see langword="FileStream" /> オブジェクトがファイルにアクセスできる方法を決定する定数。 これにより、<see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> および <see cref="P:System.IO.FileStream.CanWrite" /> プロパティによって返される値も決まります。 <paramref name="path" /> がディスク ファイルを指定している場合、<see cref="P:System.IO.FileStream.CanSeek" /> は <see langword="true" /> になります。</param>
        <param name="share">プロセスによるファイルの共有方法を決定する定数。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは、4096 です。</param>
        <summary><see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定したパス、作成モード、読み取り/書き込みアクセス許可、共有アクセス許可、およびバッファー サイズを使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework は、デバイス名をなどにパスを使用して物理ディスクへの直接アクセスをサポートしていません"\\\\。 \PHYSICALDRIVE0"です。  
  
 `path`パラメーターは、汎用名前付け規則 (UNC) 共有上のファイルを含む、ファイル名を指定できます。  
  
> [!NOTE]
>  `path` ディスクに格納されているファイルにする必要はありません。ストリーム経由でアクセスをサポートするシステムの任意の部分であることができます。 たとえば、システムによってこのクラスは、物理デバイスをアクセスできます。  
  
 <xref:System.IO.Stream.CanSeek%2A> `true`すべて<xref:System.IO.FileStream>ファイルをカプセル化するオブジェクト。 場合`path`、シークをサポートしていないデバイスを示す、<xref:System.IO.FileStream.CanSeek%2A>プロパティ、結果として<xref:System.IO.FileStream>は`false`します。 詳細については、「<xref:System.IO.Stream.CanSeek%2A>」を参照してください。  
  
> [!CAUTION]
>  特定のカルチャ設定と一連の文字をコンパイルして、同じ文字を別のカルチャ設定を取得すると、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> は空の文字列 ("") であるか、空白のみで構成されているか、または 1 つ以上の正しくない文字を含んでいます。  
  
- または - 
 <paramref name="path" /> が NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照しています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> が非 NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> が負の値であるかゼロです。  
  
または 
 <paramref name="mode" />、<paramref name="access" />、または <paramref name="share" /> に正しくない値が含まれています。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="mode" /> が <see langword="FileMode.Truncate" /> または <see langword="FileMode.Open" /> であるときなどに、ファイルが見つかりません。<paramref name="path" /> が指定したファイルが存在しません。 これらのモードではファイルが既に存在している必要があります。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> で指定したファイルが既に存在している場合に <see langword="FileMode.CreateNew" /> を指定しているなどの I/O エラーが発生しました。  
  
- または - 
システムが Windows 98 または Windows 98 Second Edition を実行中で、<paramref name="share" /> が <see langword="FileShare.Delete" /> に設定されています。  
  
- または - 
ストリームは閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">マップされていないドライブにあるなど、指定されたパスが無効です。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> が <see langword="Write" /> または <see langword="ReadWrite" /> であるのに、ファイルまたはディレクトリが読み取り専用に設定されているなど、指定した <paramref name="path" /> に対する <paramref name="access" /> 要求がオペレーティング システムで許可されません。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定したパス、ファイル名、またはその両方がシステム定義の最大長を超えています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取り、書き込み、およびファイルに追加します。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />、および<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />します。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, useAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, useAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルの相対パスまたは絶対パス。</param>
        <param name="mode">ファイルを開く方法または作成する方法を決定する定数。</param>
        <param name="access"><see langword="FileStream" /> オブジェクトがファイルにアクセスできる方法を決定する定数。 これにより、<see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> および <see cref="P:System.IO.FileStream.CanWrite" /> プロパティによって返される値も決まります。 <paramref name="path" /> がディスク ファイルを指定している場合、<see cref="P:System.IO.FileStream.CanSeek" /> は <see langword="true" /> になります。</param>
        <param name="share">プロセスによるファイルの共有方法を決定する定数。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは、4096 です。</param>
        <param name="useAsync">非同期 I/O または同期 I/O のどちらを使用するかを指定します。 ただし、基になるオペレーティング システムが非同期 I/O をサポートしていないことがあります。したがって、<see langword="true" /> を指定しても、プラットフォームによってはハンドルが同期的に開かれることがあります。 非同期的に開いた場合、<see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> メソッドと <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> メソッドは、大量の読み取りまたは書き込み時にはパフォーマンスがより高くなりますが、少量の読み取りまたは書き込み時にはパフォーマンスが非常に低くなることがあります。 アプリケーションが非同期 I/O を利用するように設計されている場合は、<paramref name="useAsync" /> パラメーターを <see langword="true" /> に設定します。 非同期 I/O を正しく使用すると、アプリケーションが 10 倍ほど高速化することがあります。ただし、非同期 I/O 用にアプリケーションを再設計せずに非同期 I/O を使用すると、パフォーマンスが 10 分の 1 ほど低下することがあります。</param>
        <summary><see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定したパス、作成モード、読み取り/書き込みアクセス許可、共有アクセス許可、バッファー サイズ、および同期状態または非同期状態を使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework は、デバイス名をなどにパスを使用して物理ディスクへの直接アクセスをサポートしていません"\\\\。 \PHYSICALDRIVE0"です。  
  
 `path`パラメーターは、汎用名前付け規則 (UNC) 共有上のファイルを含む、ファイル名を指定できます。  
  
> [!NOTE]
>  `path` ディスクに格納されているファイルにする必要はありません。ストリーム経由でアクセスをサポートするシステムの任意の部分であることができます。 たとえば、システムによってこのクラスは、物理デバイスをアクセスできます。  
  
 <xref:System.IO.Stream.CanSeek%2A> `true`すべて<xref:System.IO.FileStream>ファイルをカプセル化するオブジェクト。 場合`path`、シークをサポートしていないデバイスを示す、<xref:System.IO.FileStream.CanSeek%2A>プロパティ、結果として<xref:System.IO.FileStream>は`false`します。 詳細については、「<xref:System.IO.Stream.CanSeek%2A>」を参照してください。  
  
> [!CAUTION]
>  特定のカルチャ設定と一連の文字をコンパイルして、同じ文字を別のカルチャ設定を取得すると、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
   
  
## Examples  
 次のコード例では、ファイルにデータを非同期的に書き込むし、データが正常に書き込まれたことを確認する方法を示します。 A`State`にメイン スレッドから情報を渡すオブジェクトを作成、`EndReadCallback`と`EndWriteCallback`メソッド。  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> は空の文字列 ("") であるか、空白のみで構成されているか、または 1 つ以上の正しくない文字を含んでいます。  
  
または 
 <paramref name="path" /> が NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照しています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> が非 NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> が負の値であるかゼロです。  
  
- または - 
 <paramref name="mode" />、<paramref name="access" />、または <paramref name="share" /> に正しくない値が含まれています。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="mode" /> が <see langword="FileMode.Truncate" /> または <see langword="FileMode.Open" /> であるときなどに、ファイルが見つかりません。<paramref name="path" /> が指定したファイルが存在しません。 これらのモードではファイルが既に存在している必要があります。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> で指定したファイルが既に存在している場合に <see langword="FileMode.CreateNew" /> を指定しているなどの I/O エラーが発生しました。  
  
または 
システムが Windows 98 または Windows 98 Second Edition を実行中で、<paramref name="share" /> が <see langword="FileShare.Delete" /> に設定されています。  
  
または 
ストリームは閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">マップされていないドライブにあるなど、指定されたパスが無効です。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> が <see langword="Write" /> または <see langword="ReadWrite" /> であるのに、ファイルまたはディレクトリが読み取り専用に設定されているなど、指定した <paramref name="path" /> に対する <paramref name="access" /> 要求がオペレーティング システムで許可されません。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定したパス、ファイル名、またはその両方がシステム定義の最大長を超えています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取り、書き込み、およびファイルに追加します。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />、および<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />します。</permission>
        <altmember cref="T:System.IO.File" />
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルの相対パスまたは絶対パス。</param>
        <param name="mode">ファイルを開く方法または作成する方法を決定する定数。</param>
        <param name="access"><see langword="FileStream" /> オブジェクトがファイルにアクセスできる方法を決定する定数。 これにより、<see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> および <see cref="P:System.IO.FileStream.CanWrite" /> プロパティによって返される値も決まります。 <paramref name="path" /> がディスク ファイルを指定している場合、<see cref="P:System.IO.FileStream.CanSeek" /> は <see langword="true" /> になります。</param>
        <param name="share">プロセスによるファイルの共有方法を決定する定数。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは、4096 です。</param>
        <param name="options">追加のファイル オプションを指定する値。</param>
        <summary><see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定したパス、作成モード、読み取り/書き込みアクセス許可、共有アクセス許可、同一のファイルに対して他の FileStream が保有できるアクセス、バッファー サイズ、および追加のファイル オプションを使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework は、デバイス名をなどにパスを使用して物理ディスクへの直接アクセスをサポートしていません"\\\\。 \PHYSICALDRIVE0"です。  
  
 `fileOptions`を作成するときに利用できる高度な操作へのアクセスを提供するパラメーターを使用する<xref:System.IO.FileStream>オブジェクト。  
  
 `path`パラメーターは、汎用名前付け規則 (UNC) 共有上のファイルを含む、ファイル名を指定できます。  
  
> [!NOTE]
>  `path` ディスクに格納されているファイルにする必要はありません。ストリーム経由でアクセスをサポートするシステムの任意の部分であることができます。 たとえば、システムによってこのクラスは、物理デバイスをアクセスできます。  
  
 <xref:System.IO.Stream.CanSeek%2A> `true`すべて<xref:System.IO.FileStream>ファイルをカプセル化するオブジェクト。 場合`path`、シークをサポートしていないデバイスを示す、<xref:System.IO.FileStream.CanSeek%2A>プロパティ、結果として<xref:System.IO.FileStream>は`false`します。 詳細については、「<xref:System.IO.Stream.CanSeek%2A>」を参照してください。  
  
> [!CAUTION]
>  特定のカルチャ設定と一連の文字をコンパイルして、同じ文字を別のカルチャ設定を取得すると、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
   
  
## Examples  
 次の例は、データをファイルに書き込み、しを使用してデータを読み取り、<xref:System.IO.FileStream>オブジェクト。  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> は空の文字列 ("") であるか、空白のみで構成されているか、または 1 つ以上の正しくない文字を含んでいます。  
  
- または - 
 <paramref name="path" /> が NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照しています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> が非 NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> が負の値であるかゼロです。  
  
- または - 
 <paramref name="mode" />、<paramref name="access" />、または <paramref name="share" /> に正しくない値が含まれています。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="mode" /> が <see langword="FileMode.Truncate" /> または <see langword="FileMode.Open" /> であるときなどに、ファイルが見つかりません。<paramref name="path" /> が指定したファイルが存在しません。 これらのモードではファイルが既に存在している必要があります。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> で指定したファイルが既に存在している場合に <see langword="FileMode.CreateNew" /> を指定しているなどの I/O エラーが発生しました。  
  
または 
ストリームは閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">マップされていないドライブにあるなど、指定されたパスが無効です。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定された <paramref name="path" /> に対する要求された <paramref name="access" /> は、オペレーティング システムによって許可されません。たとえば、<paramref name="access" /> が <see langword="Write" /> か <see langword="ReadWrite" /> で、ファイルまたはディレクトリが読み取り専用アクセスに設定されているなどの場合です。  
  
または 
 <paramref name="options" /> に対して <see cref="F:System.IO.FileOptions.Encrypted" /> が指定されていますが、ファイルの暗号化は現在のプラットフォームではサポートされていません。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定したパス、ファイル名、またはその両方がシステム定義の最大長を超えています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取り、書き込み、およびファイルに追加します。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />、および<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />します。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">現在の <see cref="T:System.IO.FileStream" /> オブジェクトによってカプセル化されるファイルの相対パスまたは絶対パス。</param>
        <param name="mode">ファイルを開く方法または作成する方法を決定する定数。</param>
        <param name="rights">ファイルのアクセス規則および監査規則の作成時に使用するアクセス権を決定する定数。</param>
        <param name="share">プロセスによるファイルの共有方法を決定する定数。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは、4096 です。</param>
        <param name="options">追加のファイル オプションを指定する定数。</param>
        <summary><see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定したパス、作成モード、アクセス権、共有アクセス許可、バッファー サイズ、および追加のファイル オプションを使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework は、デバイス名をなどにパスを使用して物理ディスクへの直接アクセスをサポートしていません"\\\\。 \PHYSICALDRIVE0"です。  
  
 これを使用して、<xref:System.IO.FileStream.%23ctor%2A>ファイルの作成時点でのコンス トラクターへのアクセスを適用する権限します。 アクセスしたり、既存のファイルに対する権限を変更するには、使用を検討して、<xref:System.IO.File.GetAccessControl%2A>と<xref:System.IO.File.SetAccessControl%2A>メソッド。  
  
 `fileOptions`を作成するときに利用できる高度な操作へのアクセスを提供するパラメーターを使用する<xref:System.IO.FileStream>オブジェクト。  
  
 `path`パラメーターは、汎用名前付け規則 (UNC) 共有上のファイルを含む、ファイル名を指定できます。  
  
> [!NOTE]
>  `path` ディスクに格納されているファイルにする必要はありません。ストリーム経由でアクセスをサポートするシステムの任意の部分であることができます。 たとえば、システムによってこのクラスは、物理デバイスをアクセスできます。  
  
 <xref:System.IO.Stream.CanSeek%2A> `true`すべて<xref:System.IO.FileStream>ファイルをカプセル化するオブジェクト。 場合`path`、シークをサポートしていないデバイスを示す、<xref:System.IO.FileStream.CanSeek%2A>プロパティ、結果として<xref:System.IO.FileStream>は`false`します。 詳細については、「<xref:System.IO.Stream.CanSeek%2A>」を参照してください。  
  
> [!CAUTION]
>  特定のカルチャ設定と一連の文字をコンパイルして、同じ文字を別のカルチャ設定を取得すると、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> は空の文字列 ("") であるか、空白のみで構成されているか、または 1 つ以上の正しくない文字を含んでいます。  
  
- または - 
 <paramref name="path" /> が NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照しています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> が非 NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> が負の値であるかゼロです。  
  
または 
 <paramref name="mode" />、<paramref name="access" />、または <paramref name="share" /> に正しくない値が含まれています。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="mode" /> が <see langword="FileMode.Truncate" /> または <see langword="FileMode.Open" /> であるときなどに、ファイルが見つかりません。<paramref name="path" /> が指定したファイルが存在しません。 これらのモードではファイルが既に存在している必要があります。</exception>
        <exception cref="T:System.PlatformNotSupportedException">現在のオペレーティング システムは Windows NT 以降ではありません。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> で指定したファイルが既に存在している場合に <see langword="FileMode.CreateNew" /> が指定されているなどの I/O エラーが発生しました。  
  
- または - 
ストリームは閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">マップされていないドライブにあるなど、指定されたパスが無効です。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定された <paramref name="path" /> に対する要求された <paramref name="access" /> は、オペレーティング システムによって許可されません。たとえば、<paramref name="access" /> が <see langword="Write" /> か <see langword="ReadWrite" /> で、ファイルまたはディレクトリが読み取り専用アクセスに設定されているなどの場合です。  
  
または 
 <paramref name="options" /> に対して <see cref="F:System.IO.FileOptions.Encrypted" /> が指定されていますが、ファイルの暗号化は現在のプラットフォームではサポートされていません。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定した <paramref name="path" />、ファイル名、またはその両方がシステム定義の最大長を超えています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取り、書き込み、およびファイルに追加します。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />、および<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />します。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">現在の <see cref="T:System.IO.FileStream" /> オブジェクトによってカプセル化されるファイルの相対パスまたは絶対パス。</param>
        <param name="mode">ファイルを開く方法または作成する方法を決定する定数。</param>
        <param name="rights">ファイルのアクセス規則および監査規則の作成時に使用するアクセス権を決定する定数。</param>
        <param name="share">プロセスによるファイルの共有方法を決定する定数。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは、4096 です。</param>
        <param name="options">追加のファイル オプションを指定する定数。</param>
        <param name="fileSecurity">ファイルのアクセス制御と監査セキュリティを決定する定数。</param>
        <summary><see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定したパス、作成モード、アクセス権、共有アクセス許可、バッファー サイズ、追加のファイル オプション、アクセス制御、および監査セキュリティを使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework は、デバイス名をなどにパスを使用して物理ディスクへの直接アクセスをサポートしていません"\\\\。 \PHYSICALDRIVE0"です。  
  
 これを使用して、<xref:System.IO.FileStream.%23ctor%2A>ファイルの作成時点でのコンス トラクターへのアクセスを適用する権限します。 アクセスしたり、既存のファイルに対する権限を変更するには、使用を検討して、<xref:System.IO.File.GetAccessControl%2A>と<xref:System.IO.File.SetAccessControl%2A>メソッド。  
  
 `fileOptions`を作成するときに利用できる高度な操作へのアクセスを提供するパラメーターを使用する<xref:System.IO.FileStream>オブジェクト。  
  
 `path`パラメーターは、汎用名前付け規則 (UNC) 共有上のファイルを含む、ファイル名を指定できます。  
  
> [!NOTE]
>  `path` ディスクに格納されているファイルにする必要はありません。ストリーム経由でアクセスをサポートするシステムの任意の部分であることができます。 たとえば、システムによってこのクラスは、物理デバイスをアクセスできます。  
  
 <xref:System.IO.Stream.CanSeek%2A> `true`すべて<xref:System.IO.FileStream>ファイルをカプセル化するオブジェクト。 場合`path`、シークをサポートしていないデバイスを示す、<xref:System.IO.FileStream.CanSeek%2A>プロパティ、結果として<xref:System.IO.FileStream>は`false`します。 詳細については、「<xref:System.IO.Stream.CanSeek%2A>」を参照してください。  
  
> [!CAUTION]
>  特定のカルチャ設定と一連の文字をコンパイルして、同じ文字を別のカルチャ設定を取得すると、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
   
  
## Examples  
 次の例は、データをファイルに書き込み、しを使用してデータを読み取り、<xref:System.IO.FileStream>オブジェクト。  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> は空の文字列 ("") であるか、空白のみで構成されているか、または 1 つ以上の正しくない文字を含んでいます。  
  
または 
 <paramref name="path" /> が NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照しています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> が非 NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> が負の値であるかゼロです。  
  
- または - 
 <paramref name="mode" />、<paramref name="access" />、または <paramref name="share" /> に正しくない値が含まれています。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="mode" /> が <see langword="FileMode.Truncate" /> または <see langword="FileMode.Open" /> であるときなどに、ファイルが見つかりません。<paramref name="path" /> が指定したファイルが存在しません。 これらのモードではファイルが既に存在している必要があります。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> で指定したファイルが既に存在している場合に <see langword="FileMode.CreateNew" /> を指定しているなどの I/O エラーが発生しました。  
  
または 
ストリームは閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">マップされていないドライブにあるなど、指定されたパスが無効です。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定された <paramref name="path" /> に対する要求された <paramref name="access" /> は、オペレーティング システムによって許可されません。たとえば、<paramref name="access" /> が <see langword="Write" /> か <see langword="ReadWrite" /> で、ファイルまたはディレクトリが読み取り専用アクセスに設定されているなどの場合です。  
  
- または - 
 <paramref name="options" /> に対して <see cref="F:System.IO.FileOptions.Encrypted" /> が指定されていますが、ファイルの暗号化は現在のプラットフォームではサポートされていません。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定した <paramref name="path" />、ファイル名、またはその両方がシステム定義の最大長を超えています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">現在のオペレーティング システムは Windows NT 以降ではありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">読み取り、書き込み、およびファイルに追加します。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />、および<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />します。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, userCallback, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">データを読み取るバッファー。</param>
        <param name="offset">読み取りの開始位置を示す <paramref name="array" /> 内のバイト オフセット。</param>
        <param name="numBytes">読み取る最大バイト数。</param>
        <param name="userCallback">非同期の読み取り操作が完了したときに呼び出されるメソッド。</param>
        <param name="stateObject">この特定の非同期読み取り要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>非同期の読み込み動作を開始します。 代わりに <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> を使用することを検討してください。</summary>
        <returns>非同期の読み取りを参照するオブジェクト。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">配列の長さから <paramref name="offset" /> を引いた長さが <paramref name="numBytes" /> 未満です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> または <paramref name="numBytes" /> が負の値です。</exception>
        <exception cref="T:System.IO.IOException">非同期の読み取りがファイルの終わりを超えて試行されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, userCallback, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">現在のストリームに書き込むデータを格納しているバッファー。</param>
        <param name="offset">現在のストリームへのバイトのコピーを開始する位置を示す <paramref name="array" /> 内のバイト オフセット。インデックス番号は 0 から始まります。</param>
        <param name="numBytes">書き込む最大バイト数。</param>
        <param name="userCallback">非同期の書き込み操作が完了したときに呼び出されるメソッド。</param>
        <param name="stateObject">この特定の非同期書き込み要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>非同期の書き込み操作を開始します。 代わりに <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> を使用することを検討してください。</summary>
        <returns>非同期の書き込みを参照するオブジェクト。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> の長さから <paramref name="offset" /> を引いた長さが <paramref name="numBytes" /> 未満です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> または <paramref name="numBytes" /> が負の値です。</exception>
        <exception cref="T:System.NotSupportedException">ストリームは書き込みをサポートしません。</exception>
        <exception cref="T:System.ObjectDisposedException">ストリームは閉じられています。</exception>
        <exception cref="T:System.IO.IOException">I/O エラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.FileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のストリームが読み込みをサポートしているかどうかを示す値を取得します。</summary>
        <value>ストリームが読み取りをサポートしている場合は <see langword="true" />。ストリームが閉じているか、書き込み専用アクセスで開かれた場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生したクラスの場合<xref:System.IO.Stream>読み取りをサポートしませんへの呼び出し、 <xref:System.IO.FileStream.Read%2A>、 <xref:System.IO.FileStream.ReadByte%2A>、および<xref:System.IO.FileStream.BeginRead%2A>メソッドでスロー、<xref:System.NotSupportedException>します。  
  
 このプロパティを返しますのかどうかは、ストリームが閉じている、`false`します。  
  
   
  
## Examples  
 次の例を使用して、`CanRead`プロパティ。 このコードの出力は「MyFile.txt 書き込みができません」 出力メッセージ「MyFile.txt に書き込まれるおよびできる読み取ったりします。」、変更を取得する、`FileAccess`パラメーターを`ReadWrite`で、`FileStream`コンス トラクター。  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.FileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のストリームがシークをサポートしているかどうかを示す値を取得します。</summary>
        <value>ストリームがシークをサポートしている場合は <see langword="true" />。ストリームが閉じているか、<see langword="FileStream" /> がパイプまたはコンソール出力などのオペレーティング システム ハンドルから構築された場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生したクラスの場合<xref:System.IO.Stream>への呼び出しをシークをサポートしていない<xref:System.IO.FileStream.Length%2A>、 <xref:System.IO.FileStream.SetLength%2A>、 <xref:System.IO.FileStream.Position%2A>、および<xref:System.IO.FileStream.Seek%2A>スロー、<xref:System.NotSupportedException>します。  
  
 このプロパティを返しますのかどうかは、ストリームが閉じている、`false`します。  
  
   
  
## Examples  
 次の例では、`CanSeek`ストリームがシークをサポートしているかどうかを確認するプロパティ。  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.FileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のストリームが書き込みをサポートしているかどうかを示す値を取得します。</summary>
        <value>ストリームが書き込みをサポートしている場合は <see langword="true" />。ストリームが閉じているか、読み取り専用アクセスで開かれた場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生したクラスの場合<xref:System.IO.Stream>への呼び出しの書き込みをサポートしていません<xref:System.IO.FileStream.SetLength%2A>、 <xref:System.IO.FileStream.Write%2A>、 <xref:System.IO.FileStream.BeginWrite%2A>、または<xref:System.IO.FileStream.WriteByte%2A>スロー、<xref:System.NotSupportedException>します。  
  
 このプロパティを返しますのかどうかは、ストリームが閉じている、`false`します。  
  
   
  
## Examples  
 次の例では、`CanWrite`ストリームが書き込みをサポートするかどうかを確認するプロパティ。  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 次に例を使用して、`CanWrite`プロパティ。 このコードの出力では、書き込み可能です「MyFile.txt を行うことができます」 出力メッセージ「MyFile.txt に書き込まれるおよびできる読み取ったりします。」、変更を取得する、`FileAccess`パラメーターを`ReadWrite`で、`FileStream`コンス トラクター。  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="fileStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメンバーは <see cref="M:System.IO.Stream.Close" /> をオーバーライドし、より詳細なドキュメントがそのトピックで使用できるようになる場合があります。

現在のストリームを閉じ、現在のストリームに関連付けられているすべてのリソース (ソケット、ファイル ハンドルなど) を解放します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary><see cref="T:System.IO.FileStream" /> によって使用されているアンマネージド リソースを解放し、オプションでマネージド リソースも解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリック<xref:System.ComponentModel.Component.Dispose%2A>メソッドと<xref:System.Object.Finalize%2A>メソッド。 <xref:System.ComponentModel.Component.Dispose%2A> 保護された起動<xref:System.IO.FileStream.Dispose%2A>メソッドを`disposing`パラメーターに設定`true`します。 <xref:System.Object.Finalize%2A> 呼び出す<xref:System.IO.FileStream.Dispose%2A>で`disposing`に設定`false`します。  
  
 `disposing` パラメーターが `true` の場合、このメソッドは、この <xref:System.IO.FileStream> が参照しているすべてのマネージド オブジェクトによって保持されているリソースをすべて解放します。 このメソッドは、参照される各オブジェクトの <xref:System.ComponentModel.Component.Dispose%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> は、他のオブジェクトから複数回呼び出すことができます。 オーバーライドするときに<see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />の事前に呼び出したで以前破棄されたオブジェクトを参照しないように注意する<see cref="M:System.ComponentModel.Component.Dispose" />します。 実装する方法についての詳細は<see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />を参照してください[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)します。  
  
詳細については<see cref="M:System.ComponentModel.Component.Dispose" />と<see cref="M:System.Object.Finalize" />を参照してください[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)します。</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="fileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">待機する保留状態の非同期要求への参照。</param>
        <summary>保留中の非同期の読み取り操作が完了するまで待機します。 (代わりに、<see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> の使用を検討してください。)</summary>
        <returns>ストリームから読み込んだバイト数 (0 ～要求したバイト数の間の数値)。 ストリームの末尾では 0 が返されるだけです。それ以外の場合は、少なくとも 1 バイトが読み込み可能になるまでブロックします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 4 と以前のバージョンでは、メソッドを使用する必要がある<xref:System.IO.FileStream.BeginRead%2A>と<xref:System.IO.FileStream.EndRead%2A>ファイルの非同期操作を実装します。 これらのメソッドはでまだ使用できる、[!INCLUDE[net_v45](~/includes/net-v45-md.md)]レガシ コードをサポートするために、新しい非同期メソッドなど<xref:System.IO.FileStream.ReadAsync%2A>、 <xref:System.IO.FileStream.WriteAsync%2A>、<xref:System.IO.Stream.CopyToAsync%2A>と<xref:System.IO.FileStream.FlushAsync%2A>、ヘルプ ファイルの非同期操作をより簡単に実装します。  
  
 <xref:System.IO.FileStream.EndRead%2A> すべての呼び出しを正確に呼び出す必要がある<xref:System.IO.FileStream.BeginRead%2A>します。 別の読み取りを開始する前に読み取りのプロセスを終了に失敗すると、デッドロックなどの動作が望ましくない可能性があります。  
  
 このメソッドは、<xref:System.IO.Stream.EndRead%2A> をオーバーライドします。  
  
 <xref:System.IO.FileStream.EndRead%2A> 呼び出すことがすべて<xref:System.IAsyncResult>から<xref:System.IO.FileStream.BeginRead%2A>します。 呼び出す<xref:System.IO.FileStream.EndRead%2A>ストリームから読み取られたバイト数がわかります。 <xref:System.IO.FileStream.EndRead%2A> I/O 操作が完了するまでブロックされます。  
  
   
  
## Examples  
 このコード例が示されている例の一部、<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>コンス トラクター。  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">この <see cref="T:System.IAsyncResult" /> オブジェクトは、このクラスで <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> を呼び出すことによって作成されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> は複数回呼び出されます。</exception>
        <exception cref="T:System.IO.IOException">ストリームが閉じているか、内部エラーが発生しました。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">非同期ファイル I/O</related>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="fileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">保留中の非同期 I/O 要求。</param>
        <summary>非同期の書き込み操作を終了し、I/O 操作が完了するまでブロックします。 (代わりに、<see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> の使用を検討してください。)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 4 と以前のバージョンでは、メソッドを使用する必要がある<xref:System.IO.FileStream.BeginWrite%2A>と<xref:System.IO.FileStream.EndWrite%2A>ファイルの非同期操作を実装します。 これらのメソッドはでまだ使用できる、[!INCLUDE[net_v45](~/includes/net-v45-md.md)]レガシ コードをサポートするために、新しい非同期メソッドなど<xref:System.IO.FileStream.ReadAsync%2A>、 <xref:System.IO.FileStream.WriteAsync%2A>、<xref:System.IO.Stream.CopyToAsync%2A>と<xref:System.IO.FileStream.FlushAsync%2A>、ヘルプ ファイルの非同期操作をより簡単に実装します。  
  
 このメソッドは、<xref:System.IO.Stream.EndWrite%2A> をオーバーライドします。  
  
 <xref:System.IO.FileStream.EndWrite%2A> 1 回だけ呼び出す必要がありますすべて<xref:System.IAsyncResult>から<xref:System.IO.FileStream.BeginWrite%2A>します。 <xref:System.IO.FileStream.EndWrite%2A> I/O 操作が完了するまでブロックされます。  
  
   
  
## Examples  
 このコード例が示されている例の一部、<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>コンス トラクター。  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">この <see cref="T:System.IAsyncResult" /> オブジェクトは、このクラスで <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> を呼び出すことによって作成されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> は複数回呼び出されます。</exception>
        <exception cref="T:System.IO.IOException">ストリームが閉じているか、内部エラーが発生しました。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">非同期ファイル I/O</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ガベージ コレクターが <see langword="FileStream" /> を再利用するときに、リソースの解放およびその他のクリーンアップ操作を確実に実行するようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ガベージ コレクター`Finalize`と現在のオブジェクトが完了するを準備します。 `Finalize` 閉じる、`FileStream`します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このストリームのバッファーをクリアして、バッファー内のデータがファイルに書き込まれるようにします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="fileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このストリームのバッファーをクリアして、バッファー内のデータがファイルに書き込まれるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType> をオーバーライドします。  
  
 呼び出すと、<xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType>メソッド、オペレーティング システムの I/O バッファーがフラッシュされることもできます。  
  
 ストリームのエンコーダーを明示的に呼び出さない限り、フラッシュされません<xref:System.IO.FileStream.Flush%2A>またはオブジェクトを破棄します。 設定<xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType>に`true`データは、バッファーからストリームにフラッシュされますが、エンコーダーの状態はフラッシュされないことを意味します。 これにより、エンコーダーで、次の文字のブロックは正常にエンコードできるように、(一部の文字) の状態を維持できます。 このシナリオでは、UTF8、UTF7、特定の文字をエンコードするため、エンコーダーは、隣接する文字または文字列を受信した後に影響します。  
  
 読み取りまたは書き込みのいずれかのバッファーを使用できるため<xref:System.IO.FileStream.Flush>次の 2 つの関数を実行します。  
  
-   以前、バッファーに書き込まれたデータがファイルにコピーされ、エンコーダーの状態を除く、バッファーをクリアします。  
  
-   場合<xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType>は`true`読み取りバッファーにデータが以前コピー ファイルから、ファイル内の現在位置は、バッファー内の未読のバイト数だけデクリメントします。 バッファーをクリアします。  
  
 使用して、<xref:System.IO.FileStream.Flush%28System.Boolean%29>の中間ファイル バッファーでデータをバッファリングされたすべてのことを確認するときにメソッドのオーバー ロードが書き込まれるディスクにします。  
  
   
  
## Examples  
 このコード例が示されている例の一部、<xref:System.IO.FileStream.Lock%2A>メソッド。  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">I/O エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">ストリームは閉じられています。</exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Flush(bool flushToDisk);" />
      <MemberSignature Language="F#" Value="override this.Flush : bool -&gt; unit" Usage="fileStream.Flush flushToDisk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">すべての中間ファイル バッファーをフラッシュする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>このストリームのバッファーをクリアして、バッファー内のデータがファイルに書き込まれるようにし、すべての中間ファイル バッファーもクリアします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して中間ファイル バッファーにデータをバッファリングされたすべてのことを確認する場合は、このオーバー ロードが書き込まれるディスクにします。  
  
 呼び出すと、<xref:System.IO.FileStream.Flush%2A>メソッド、オペレーティング システムの I/O バッファーがフラッシュされることもできます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">キャンセル要求を監視するためのトークン。</param>
        <summary>ストリームに対応するすべてのバッファーを非同期にクリアし、バッファー内のデータを基になるデバイスに書き込み、キャンセル要求を監視します。</summary>
        <returns>非同期のフラッシュ操作を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すと、<xref:System.IO.FileStream.FlushAsync%2A>メソッド、オペレーティング システムの I/O バッファーがフラッシュされることもできます。  
  
 完了前に、操作が取り消された場合、返されたタスクが含まれています、<xref:System.Threading.Tasks.TaskStatus.Canceled>値、<xref:System.Threading.Tasks.Task.Status%2A>プロパティ。 返されたタスクに含まれるファイルへのハンドルが破棄されている場合、<xref:System.ObjectDisposedException>で例外が発生、<xref:System.Threading.Tasks.Task.Exception%2A>プロパティ。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">ストリームは破棄されています。</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">キャンセル</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Security.AccessControl.FileSecurity" /> オブジェクトが示すファイルのアクセス制御リスト (ACL) エントリをカプセル化する <see cref="T:System.IO.FileStream" /> オブジェクトを取得します。</summary>
        <returns>現在の <see cref="T:System.IO.FileStream" /> オブジェクトが示すファイルのアクセス制御設定をカプセル化するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中に、<xref:System.IO.FileStream>クラスと<xref:System.IO.FileStream.GetAccessControl%2A>既存のファイルのアクセス制御リスト (ACL) エントリを取得、使用を検討することできます<xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType>ほどのメソッドは簡単に使用します。  
  
 使用して、<xref:System.IO.FileStream.GetAccessControl%2A>ファイルの ACL エントリを取得するメソッド。  
  
 ACL には、個人やグループがある、または権限がない、特定のファイルの特定のアクションをユーザーがについて説明します。 詳細については、「[方法: アクセス制御リスト エントリを追加または削除する](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">ファイルは閉じられています。</exception>
        <exception cref="T:System.IO.IOException">ファイルを開くときに、I/O エラーが発生しました。</exception>
        <exception cref="T:System.SystemException">ファイルが見つかりませんでした。</exception>
        <exception cref="T:System.UnauthorizedAccessException">この操作は、現在のプラットフォームではサポートされていません。  
  
または 
呼び出し元に、必要なアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.IO.FileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのオペレーティング システム ファイル ハンドルを取得します。</summary>
        <value>この <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのオペレーティング システム ファイル ハンドル。または <see langword="FileStream" /> が閉じられている場合は -1。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、オペレーティング システムに用意されているシステムの呼び出しで使用するためのオペレーティング システム ハンドル (など`ReadFile`Windows 上)。 など、ファイル記述子を期待する C ライブラリ関数では機能しません`fread`します。  
  
 オペレーティング システム ハンドルが開かれた同期的または非同期的にに応じて`FileStream`コンス トラクターが呼び出されます。 使用して、<xref:System.IO.FileStream.IsAsync%2A>プロパティをこのハンドルが非同期的に開かれたかどうかを検出します。 Win32 では、これは、オーバー ラップの IO のハンドルが開かれた、さまざまなパラメーターを必要と意味`ReadFile`と`WriteFile`します。  
  
> [!CAUTION]
>  場合に、データの破損が発生する可能性があります、`FileStream`が作成されると、そのハンドルが渡される、いくつかの操作は、ハンドルのファイル ポインターを移動し、`FileStream`もう一度使用されます。 複数のスレッドことはできません同時に、同じファイルに書き込む安全にし、`FileStream`バッファリング コードには、行うことは想定しています。 `FileStream` スローする可能性を<xref:System.IO.IOException>場合`FileStream`他のプロセスがファイル ポインターを移動したことを検出します。 これを回避するには、書き込みません任意のデータ ファイルの一部にする`FileStream`可能性がありますがバッファーに格納し、ファイル ポインターをしたときにメソッドが呼び出された最後の場所に復元`FileStream`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードにアクセスする機能。 関連付けられた列挙体。<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> セキュリティ アクション:<see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />します。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.FileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="FileStream" /> が非同期的に開かれたか、同期的に開かれたかを示す値を取得します。</summary>
        <value><see langword="FileStream" /> が非同期的に開かれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsAsync`プロパティを検出するかどうか、`FileStream`ハンドルが開かれた非同期的に使用するように有効にすると、<xref:System.IO.FileStream.Handle%2A>プロパティ正しくします。 Win32 では、`IsAsync`ハンドルは、の重複 I/O 用に開かれたおよびそのためにさまざまなパラメーターが必要ですが true にことを意味する`ReadFile`と`WriteFile`します。  
  
 インスタンスを作成するときに、この値を指定する、<xref:System.IO.FileStream>クラスを持つコンス トラクターを使用して、 `isAsync`、 `useAsync`、または`options`パラメーター。 プロパティが`true`ストリームがファイル操作を非同期的に実行する重複 I/O を利用します。 ただし、<xref:System.IO.FileStream.IsAsync%2A>プロパティにあるありません`true`を呼び出す、 <xref:System.IO.FileStream.ReadAsync%2A>、 <xref:System.IO.FileStream.WriteAsync%2A>、または<xref:System.IO.Stream.CopyToAsync%2A>メソッド。 ときに、<xref:System.IO.FileStream.IsAsync%2A>プロパティは`false`書き込み操作および非同期の読み取りを呼び出すと、まだ、UI スレッドはブロックされませんが、実際の I/O 操作が同期的に実行します。  
  
   
  
## Examples  
 このコード例が示されている例の一部、<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>コンス トラクター。  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ストリーム長 (バイト単位) を取得します。</summary>
        <value>ストリーム長 (バイト単位) を表す long 値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
   
  
## Examples  
 次の例では、`Length`と`Position`ファイルの終端状態を確認するプロパティ。  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このストリーム用の <see cref="P:System.IO.FileStream.CanSeek" /> が <see langword="false" /> です。</exception>
        <exception cref="T:System.IO.IOException">ファイルが閉じられているなど、I/O エラーが発生しました。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Lock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Lock : int64 * int64 -&gt; unit&#xA;override this.Lock : int64 * int64 -&gt; unit" Usage="fileStream.Lock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">ロックする範囲の先頭。 このパラメーターの値は、0 (ゼロ) 以上にする必要があります。</param>
        <param name="length">ロックする範囲。</param>
        <summary><see cref="T:System.IO.FileStream" /> に対する他のプロセスからの読み取りまたは書き込みを禁止します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ファイル ストリームの範囲をロックすると、そのファイル ストリームの範囲をロック プロセスの排他アクセスのスレッドが与えられます。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
   
  
## Examples  
 次のコード例では、別のプロセスは、読み取り/書き込みアクセスをファイルにある場合でも、ファイルの部分にアクセスできないように、ファイルの一部をロックする方法を示します。 別のコマンド ウィンドウで、プログラムを同時に実行し、別のコンソールの入力オプションを使用してを調査します。  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" /> または <paramref name="length" /> が負の値です。</exception>
        <exception cref="T:System.ObjectDisposedException">ファイルは閉じられています。</exception>
        <exception cref="T:System.IO.IOException">別のプロセスがファイルの一部をロックしているため、プロセスはこのファイルにアクセスできません。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="FileStream" /> で開かれているファイルの絶対パスを取得します。</summary>
        <value>ファイルの絶対パスである文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

絶対パスが不明の場合このプロパティ文字列を返します「[不明]」に似ています。

 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
   
  
## Examples  
 このコード例が示されている例の一部、<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>コンス トラクター。  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスにアクセスします。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.FileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ストリームの現在位置を取得または設定します。</summary>
        <value>ストリームの現在位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ストリームの長さを超える任意の場所にシークがサポートされています。  ファイルの長さを超えたシークすると、ファイル サイズが大きくなります。  Microsoft Windows NT と新しいファイルの末尾に追加したデータは、0 に設定されます。  Microsoft Windows 98 以前では、ファイルの末尾に追加したデータは以前削除されたデータは 0 に設定されません。 Windows 98 またはそれ以前のストリームの末尾の次の大きな値に、ストリームの位置を設定すると、例外が発生する可能性があります。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
   
  
## Examples  
 次の例では、`Length`と`Position`ファイルの終端状態を確認するプロパティ。  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このストリームはシークをサポートしていません。</exception>
        <exception cref="T:System.IO.IOException">I/O エラーが発生しました。  
  
または 
位置が、Windows 98 またはそれ以前のストリームの末尾を越える非常に大きな値に設定されました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">位置を負の値に設定しようとしました。</exception>
        <exception cref="T:System.IO.EndOfStreamException">サポートされていない、ストリームの末尾を越えるシークをしようとしました。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="fileStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">このメソッドが返されるときに、指定したバイト配列の <paramref name="offset" /> から (<paramref name="offset" /> + <paramref name="count" /> - 1<c>)</c> までの値が、現在のソースから読み取られたバイトに置き換えられます。</param>
        <param name="offset">読み取られるバイトが配置される <paramref name="array" /> 内のバイト オフセット。</param>
        <param name="count">読み取る最大バイト数。</param>
        <summary>ストリームからバイトのブロックを読み取り、そのデータを特定のバッファーに書き込みます。</summary>
        <returns>バッファーに読み取られた合計バイト数。 要求しただけのバイト数を読み取れなかった場合、この値は要求したバイト数より小さくなります。ストリームの末尾に到達した場合は 0 になることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.IO.Stream.Read%2A> をオーバーライドします。  
  
 `offset`パラメーターは内のバイトのオフセット`array`(バッファーのインデックス) 読み取りを開始する位置と`count`パラメーターがこのストリームから読み取るバイトの最大数を示します。 返される値は、ストリームの末尾に達した場合にバイトを読み取り、または 0 の実際の数です。 読み取り操作が成功した場合は、読み取られたバイト数で、ストリームの現在位置が高度な。 例外が発生する場合は、ストリームの現在の位置は変更されません。  
  
 <xref:System.IO.FileStream.Read%2A>メソッドは、ストリームの末尾に到達した後にのみ 0 を返します。 それ以外の場合、<xref:System.IO.FileStream.Read%2A>常に少なくとも 1 バイトを返す前に、ストリームから読み取ります。 データがないかどうかを呼び出すとストリームから<xref:System.IO.FileStream.Read%2A>メソッドは、少なくとも 1 バイトのデータを返すことができるまでブロックされます。 実装は自由に、ストリームの末尾に達していない場合でも、要求されたより少ないバイト数を返します。  
  
 使用<xref:System.IO.BinaryReader>プリミティブ データ型を読み取るためです。  
  
 読み取り操作を実行しているスレッドを中断しません。 スレッドがブロックされた後に正常に実行するアプリケーションが表示されますが、中断は、アプリケーションのパフォーマンスと信頼性を削減できます。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
   
  
## Examples  
 次の例から内容を読み取り、 <xref:System.IO.FileStream> 、別に書き込みます<xref:System.IO.FileStream>します。  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> または <paramref name="count" /> が負の値です。</exception>
        <exception cref="T:System.NotSupportedException">ストリームは読み取りをサポートしません。</exception>
        <exception cref="T:System.IO.IOException">I/O エラーが発生しました。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> と <paramref name="count" /> が <paramref name="array" /> の無効な範囲を示しています。</exception>
        <exception cref="T:System.ObjectDisposedException">ストリームが閉じた後でメソッドが呼び出されました。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">データを書き込むバッファー。</param>
        <param name="offset">ストリームからのデータの書き込み開始位置を示す <paramref name="buffer" /> 内のバイト オフセット。</param>
        <param name="count">読み取る最大バイト数。</param>
        <param name="cancellationToken">キャンセル要求を監視するためのトークン。</param>
        <summary>現在のストリームからバイト シーケンスを非同期に読み取り、読み取ったバイト数だけストリーム内の位置を進め、キャンセル要求を監視します。</summary>
        <returns>非同期の読み取り操作を表すタスク。 <paramref name="TResult" /> パラメーターの値には、バッファーに読み込まれるバイトの合計数が含まれます。 現在使用できるバイト数が要求した数より小さい場合、結果の値は要求したバイト数より小さくなることがあります。また、ストリームの末尾に到達した場合は 0 になることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.ReadAsync%2A>メソッドでは、メイン スレッドをブロックすることがなくリソースを消費するファイル操作を実行することができます。 このパフォーマンスに関する考慮事項は、時間のかかるストリーム操作によって UI スレッドがブロックされ、アプリが動作していないと見なされる可能性がある [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリまたは[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] アプリで特に重要です。 非同期メソッドと組み合わせてで使用される、`async`と`await`Visual Basic および c# のキーワード。  
  
 使用して、<xref:System.IO.FileStream.CanRead%2A>プロパティを現在のインスタンスが読み取りをサポートするかどうかを判断します。  
  
 完了前に、操作が取り消された場合、返されたタスクが含まれています、<xref:System.Threading.Tasks.TaskStatus.Canceled>値、<xref:System.Threading.Tasks.Task.Status%2A>プロパティ。 返されたタスクに含まれるファイルへのハンドルが破棄されている場合、<xref:System.ObjectDisposedException>で例外が発生、<xref:System.Threading.Tasks.Task.Exception%2A>プロパティ。  
  
   
  
## Examples  
 次の例では、非同期的にファイルから読み取る方法を示します。  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> または <paramref name="count" /> が負の値です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> と <paramref name="count" /> の合計が、バッファーの長さよりも大きくなっています。</exception>
        <exception cref="T:System.NotSupportedException">ストリームは読み取りをサポートしません。</exception>
        <exception cref="T:System.ObjectDisposedException">ストリームは破棄されています。</exception>
        <exception cref="T:System.InvalidOperationException">ストリームは、前の読み取り操作によって現在使用されています。</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">キャンセル</related>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="fileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ファイルからバイトを読み取り、読み取り位置を 1 バイト進めます。</summary>
        <returns><see cref="T:System.Int32" /> にキャストしたバイト。ストリームの末尾に達した場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.IO.Stream.ReadByte%2A> をオーバーライドします。  
  
> [!NOTE]
>  使用して、<xref:System.IO.FileStream.CanRead%2A>プロパティを現在のインスタンスが読み取りをサポートするかどうかを判断します。 詳細については、「<xref:System.IO.Stream.CanRead%2A>」を参照してください。  
  
   
  
## Examples  
 次のコード例では、ファイル、1 バイトずつデータを書き込むし、データが正しく書き込まれていることを確認する方法を示します。  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">現在のストリームは読み取りをサポートしません。</exception>
        <exception cref="T:System.ObjectDisposedException">現在のストリームが閉じられます。</exception>
        <block subset="none" type="overrides"><para>既定の実装で<see langword="Stream" />新しい 1 バイトの配列を作成し、呼び出して<see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />します。 これは正式には正しいが、効率的です。 内部バッファーを備えた任意のストリームは、このメソッドをオーバーライドし、バッファーを直接読み込む呼び出しごとに余分な配列の割り当てを回避するはるかに効率的バージョンを提供する必要があります。  
  
一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeFileHandle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.FileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.IO.FileStream" /> オブジェクトによってカプセル化されるファイルのオペレーティング システム ファイル ハンドルを表す <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> オブジェクトを取得します。</summary>
        <value>現在の <see cref="T:System.IO.FileStream" /> オブジェクトによってカプセル化されるファイルのオペレーティング システム ファイル ハンドルを表すオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.SafeFileHandle%2A>プロパティは自動的にストリームをフラッシュし、現在のストリームの位置を 0 に設定します。  これにより、移動するファイルまたは別のストリームを使用してリセットする、ストリームの位置、<xref:System.IO.FileStream.SafeFileHandle%2A>このプロパティによって返されます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出すアクセス許可。  
  
セキュリティ アクション。リンク確認要求 
関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="fileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">シークの開始位置を示す、<paramref name="origin" /> に対する相対ポイント。</param>
        <param name="origin"><see cref="T:System.IO.SeekOrigin" /> 型の値を使用して、<paramref name="offset" /> の参照ポイントとして先頭、末尾、または現在位置を指定します。</param>
        <summary>このストリームの現在位置を特定の値に設定します。</summary>
        <returns>ストリームの新しい位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType> をオーバーライドします。  
  
> [!NOTE]
>  使用して、<xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType>プロパティを現在のインスタンスがシークをサポートしているかどうかを判断します。 詳細については、「<xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>」を参照してください。  
  
 ストリームの長さを超えた位置をシークできます。 ファイルの長さを超えたシークすると、ファイル サイズが大きくなります。 Windows NT とそれ以降のバージョンでは、ファイルの末尾に追加されたデータは、0 に設定されます。 Windows 98 またはそれ以前のバージョンでは、ファイルの末尾に追加されたデータは以前削除されたデータは 0 に設定できません。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
   
  
## Examples  
 次の例では、ファイル、1 バイトずつデータを書き込むし、データが正しく書き込まれていることを確認する方法を示します。  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 次の例は、さまざまなを使用して、ファイルの先頭にファイルの末尾から逆の方向でテキストを読み取ります<xref:System.IO.SeekOrigin>値で、<xref:System.IO.FileStream.Seek%2A>メソッド。  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">I/O エラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">ストリームがシークをサポートしていません。たとえば、<see langword="FileStream" /> がパイプまたはコンソール出力から構築されました。</exception>
        <exception cref="T:System.ArgumentException">シークがストリームの開始前に試行されています。</exception>
        <exception cref="T:System.ObjectDisposedException">ストリームが閉じた後でメソッドが呼び出されました。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileStream.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">現在のファイルに適用する ACL エントリを示すオブジェクト。</param>
        <summary><see cref="T:System.Security.AccessControl.FileSecurity" /> オブジェクトが示すアクセス制御リスト (ACL) エントリを、現在の <see cref="T:System.IO.FileStream" /> オブジェクトが示すファイルに適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中に、<xref:System.IO.FileStream>クラスと<xref:System.IO.FileStream.SetAccessControl%2A>既存のファイルで使用できる、使用を検討して、<xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType>メソッドは簡単に使用します。  
  
 <xref:System.IO.FileStream.SetAccessControl%2A>メソッドが継承されない ACL リストを表すファイルへのアクセス制御リスト (ACL) エントリを適用します。  
  
> [!CAUTION]
>  ACL に指定された、`fileSecurity`パラメーターは、ファイルの既存の ACL を置き換えます。 新しいユーザーのアクセス許可を追加するには、使用、<xref:System.IO.FileStream.GetAccessControl%2A>メソッドを既存の ACL の取得、それを変更してから使用<xref:System.IO.FileStream.SetAccessControl%2A>ファイルに再度適用します。  
  
 ACL には、個人やグループがある、または権限がない、特定のファイルの特定のアクションをユーザーがについて説明します。 詳細については、「[方法: アクセス制御リスト エントリを追加または削除する](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">ファイルは閉じられています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileSecurity" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.SystemException">ファイルを検出または変更できませんでした。</exception>
        <exception cref="T:System.UnauthorizedAccessException">現在のプロセスには、ファイルを開くために必要なアクセス権がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="fileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">ストリームの新しい長さ。</param>
        <summary>ストリーム長を特定の値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.IO.Stream.SetLength%2A> をオーバーライドします。  
  
 指定された値がストリームの現在の長さより小さい場合は、ストリームは切り捨てられます。 このシナリオでは、現在の位置が新しい長さより大きい場合、現在の位置がストリームの最後のバイトに移動されます。 指定された値がストリームの現在の長さより大きい場合は、ストリームを展開すると、および現在の位置は変わりません。 ストリームが展開されている場合、古いと、新しい長さのストリームの内容は未定義です。  
  
 ストリームが書き込みとシークの両方をサポートする必要があります`SetLength`させる。  
  
> [!NOTE]
>  使用、<xref:System.IO.FileStream.CanWrite%2A>プロパティを現在のインスタンスが、書き込みをサポートするかどうかを確認し、<xref:System.IO.FileStream.CanSeek%2A>シークがサポートされているかどうかを決定するプロパティ。 追加情報については、<xref:System.IO.Stream.CanWrite%2A>、および <xref:System.IO.Stream.CanSeek%2A> を参照してください。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">I/O エラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">ストリームでは、書き込みとシークの両方は使用できません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" /> パラメーターを 0 未満の値に設定しようとしました。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Unlock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Unlock : int64 * int64 -&gt; unit&#xA;override this.Unlock : int64 * int64 -&gt; unit" Usage="fileStream.Unlock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">ロックを解除する範囲の先頭。</param>
        <param name="length">ロックを解除する範囲。</param>
        <summary>他のプロセスにより以前にロックされたファイルの全部または一部へのアクセスを許可します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
   
  
## Examples  
 次のコード例では、別のプロセスことはできません、ファイルを読み取り/書き込みのアクセス権がある場合でも、ファイルの部分にアクセスし、ファイルの指定したパーツのロックを解除し、ファイルの一部をロックする方法を示します。 別のコマンド ウィンドウで、プログラムを同時に実行し、別のコンソールの入力オプションを使用してを調査します。  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" /> または <paramref name="length" /> が負の値です。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="fileStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">ストリームに書き込むデータを格納しているバッファー。</param>
        <param name="offset">ストリームへのバイトのコピーを開始する位置を示す <paramref name="array" /> 内のバイト オフセット。インデックス番号は 0 から始まります。</param>
        <param name="count">書き込む最大バイト数。</param>
        <summary>ファイル ストリームにバイトのブロックを書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.IO.Stream.Write%2A> をオーバーライドします。  
  
 `offset`パラメーターは内のバイトのオフセット`array`(バッファーのインデックス) のコピーを開始する位置と`count`パラメーターは、ストリームに書き込まれるバイト数。 書き込み操作が成功した場合、ストリームの現在の位置は書き込まれたバイト数で高度な。 例外が発生する場合は、ストリームの現在の位置は変更されません。  
  
> [!NOTE]
>  使用して、<xref:System.IO.FileStream.CanWrite%2A>プロパティを現在のインスタンスが書き込みをサポートするかどうかを判断します。 詳細については、「<xref:System.IO.Stream.CanWrite%2A>」を参照してください。  
  
 書き込み操作を実行しているスレッドを中断しません。 スレッドがブロックされた後に正常に実行するアプリケーションが表示されますが、中断は、アプリケーションのパフォーマンスと信頼性を削減できます。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。  
  
   
  
## Examples  
 このコード例が示されている例の一部、<xref:System.IO.FileStream.Lock%2A>メソッド。  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> と <paramref name="count" /> が <paramref name="array" /> の無効な範囲を示しています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> または <paramref name="count" /> が負の値です。</exception>
        <exception cref="T:System.IO.IOException">I/O エラーが発生しました。  
  
- または - 
別のスレッドが原因で、オペレーティング システムのファイル ハンドルの位置で予期しない変更が発生した可能性があります。</exception>
        <exception cref="T:System.ObjectDisposedException">ストリームは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">現在のストリームのインスタンスでは、書き込みをサポートしません。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">データの書き込み元となるバッファー。</param>
        <param name="offset">ストリームへのバイトのコピーを開始する位置を示す <paramref name="buffer" /> 内のバイト オフセット。インデックス番号は 0 から始まります。</param>
        <param name="count">書き込む最大バイト数。</param>
        <param name="cancellationToken">キャンセル要求を監視するためのトークン。</param>
        <summary>現在のストリームにバイト シーケンスを非同期に書き込み、書き込んだバイト数だけストリーム内の現在位置を進め、キャンセル要求を監視します。</summary>
        <returns>非同期の書き込み操作を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.WriteAsync%2A>メソッドでは、メイン スレッドをブロックすることがなくリソースを消費するファイル操作を実行することができます。 このパフォーマンスに関する考慮事項は、時間のかかるストリーム操作によって UI スレッドがブロックされ、アプリが動作していないと見なされる可能性がある [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリまたは[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] アプリで特に重要です。 非同期メソッドと組み合わせてで使用される、`async`と`await`Visual Basic および c# のキーワード。  
  
 使用して、<xref:System.IO.FileStream.CanWrite%2A>プロパティを現在のインスタンスが書き込みをサポートするかどうかを判断します。  
  
 完了前に、操作が取り消された場合、返されたタスクが含まれています、<xref:System.Threading.Tasks.TaskStatus.Canceled>値、<xref:System.Threading.Tasks.Task.Status%2A>プロパティ。 返されたタスクに含まれるファイルへのハンドルが破棄されている場合、<xref:System.ObjectDisposedException>で例外が発生、<xref:System.Threading.Tasks.Task.Exception%2A>プロパティ。  
  
   
  
## Examples  
 次の例では、ファイルに非同期的に書き込む方法を示します。  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> または <paramref name="count" /> が負の値です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> と <paramref name="count" /> の合計が、バッファーの長さよりも大きいです。</exception>
        <exception cref="T:System.NotSupportedException">ストリームは書き込みをサポートしません。</exception>
        <exception cref="T:System.ObjectDisposedException">ストリームは破棄されています。</exception>
        <exception cref="T:System.InvalidOperationException">ストリームは、前の書き込み操作によって現在使用されています。</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">キャンセル</related>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="fileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">ストリームに書き込むバイト。</param>
        <summary>ファイル ストリームの現在位置にバイトを書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.IO.Stream.WriteByte%2A> をオーバーライドします。  
  
 使用`WriteByte`バイトを書き込む、`FileStream`効率的にします。 ストリームが閉じているかいない書き込み可能な場合は、例外がスローされます。  
  
> [!NOTE]
>  使用して、<xref:System.IO.FileStream.CanWrite%2A>プロパティを現在のインスタンスが書き込みをサポートするかどうかを判断します。 詳細については、「<xref:System.IO.Stream.CanWrite%2A>」を参照してください。  
  
   
  
## Examples  
 次のコード例では、ファイル、1 バイトずつデータを書き込むし、データが正しく書き込まれていることを確認する方法を示します。  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">ストリームは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">ストリームは書き込みをサポートしません。</exception>
        <block subset="none" type="overrides"><para>既定の実装で<see langword="Stream" />新しい 1 バイトの配列を作成し、呼び出して<see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />します。 これは正式には正しいが、効率的です。 内部バッファーを備えた任意のストリームは、このメソッドをオーバーライドし、バッファーを直接読み込む呼び出しごとに余分な配列の割り当てを回避するはるかに効率的バージョンを提供する必要があります。  
  
一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md)します。</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
  </Members>
</Type>