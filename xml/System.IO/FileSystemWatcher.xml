<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9804627f9162207d228105246faab6e636e6c42c" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58735975" /></Metadata><TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.IO.IODescription("FileSystemWatcherDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>ファイル システムの変更通知を待機し、ディレクトリまたはディレクトリ内のファイルが変更されたときにイベントを発生させます。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.FileSystemWatcher>の指定したディレクトリ内の変更を監視します。 指定したディレクトリのファイルとサブディレクトリ内の変更を確認できます。 ローカル コンピューター、ネットワーク ドライブ、またはリモート コンピューター上のファイルを監視するコンポーネントを作成することができます。  
  
 すべてのファイルの変更をウォッチする、<xref:System.IO.FileSystemWatcher.Filter%2A>プロパティを空の文字列 ("") またはワイルドカードを使用して ("*.\*")。 特定のファイルをウォッチする、<xref:System.IO.FileSystemWatcher.Filter%2A>プロパティをファイル名。 たとえば、MyDoc.txt ファイル内の変更の監視には、次のように設定します。、<xref:System.IO.FileSystemWatcher.Filter%2A>プロパティを"MyDoc.txt"。 特定の種類のファイルの変更について視聴することもできます。 たとえば、テキスト ファイルの変更をウォッチする設定、<xref:System.IO.FileSystemWatcher.Filter%2A>プロパティを"\*.txt"。  
  
 これは、いくつかの種類の変更では、ディレクトリまたはファイルを見ることができます。 などの変化を監視することができます`Attributes`、`LastWrite`日付と時刻、または`Size`のファイルまたはディレクトリ。 これは、設定で、<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>プロパティのいずれかを<xref:System.IO.NotifyFilters>値。 見ることができますの変更の種類の詳細については、次を参照してください。<xref:System.IO.NotifyFilters>します。  
  
 名前変更、削除、またはファイルまたはディレクトリの作成を確認できます。 たとえば、テキスト ファイルの名前を変更するをウォッチする次のように設定します。、<xref:System.IO.FileSystemWatcher.Filter%2A>プロパティ"*.txt"を呼び出し、<xref:System.IO.FileSystemWatcher.WaitForChanged%2A>メソッドを、<xref:System.IO.WatcherChangeTypes.Renamed>そのパラメーターに指定されました。  
  
 Windows オペレーティング システム、コンポーネントによって作成されたバッファー内のファイルの変更の通知、<xref:System.IO.FileSystemWatcher>します。 短時間で多くの変更がある場合、バッファーがオーバーフローすることができます。 これにより、コンポーネントは、ディレクトリの変更の追跡と包括的な通知を提供するだけです。 使用して、バッファーのサイズを増やす、<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>プロパティが高コストで、イベントを変更するすべてのファイルの見落としがないのに十分な大規模な非ページ メモリようにとして小さなバッファーをまだディスクにスワップ アウトできませんから渡される。 バッファー オーバーフローを避けるためには、使用、<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>と<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>フィルターで除外できます不要なため、プロパティ変更通知します。  
  
 インスタンスの初期プロパティ値の一覧については<xref:System.IO.FileSystemWatcher>を参照してください、<xref:System.IO.FileSystemWatcher.%23ctor%2A>コンス トラクター。  
  
 使用する場合は、次に注意してください、<xref:System.IO.FileSystemWatcher>クラス。  
  
-   隠しファイルは無視されません。  
  
-   一部のシステムで<xref:System.IO.FileSystemWatcher>8.3 ファイル名の短い形式を使用してファイルへの変更を報告します。 たとえば、"LongFileName.LongExtension"への変更として報告する"LongFil ~。Lon"。  
  
-   このクラスには、リンク確認要求と、すべてのメンバーに適用されるクラス レベルの継承確認要求が含まれています。 直接の呼び出し元か派生クラスのいずれかに完全信頼アクセス許可がない場合、<xref:System.Security.SecurityException> がスローされます。 セキュリティ要求の詳細については、「[リンク確認要求](~/docs/framework/misc/link-demands.md)」を参照してください。  
  
-   設定できる最大サイズ、<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>ネットワーク経由でディレクトリを監視するためのプロパティは 64 KB です。  
  
> [!NOTE]
>  実行している<xref:System.IO.FileSystemWatcher>Windows 98 ではサポートされていません。  
  
## <a name="copying-and-moving-folders"></a>コピーとフォルダーの移動  
 オペレーティング システムと<xref:System.IO.FileSystemWatcher>オブジェクトは、切り取りと貼り付け操作またはフォルダーとその内容の名前変更アクションとして移動アクションを解釈します。 切り取って、ウォッチ フォルダーにファイルとフォルダーを貼り付ける場合、<xref:System.IO.FileSystemWatcher>オブジェクトをレポートとして、新しいフォルダーのみがその内容はのみ変更は本質的にためです。  
  
 フォルダーの内容が移動またはマークされているフォルダーにコピーされたことの通知、提供<xref:System.IO.FileSystemWatcher.OnChanged%2A>と<xref:System.IO.FileSystemWatcher.OnRenamed%2A>次の表に示したとおり、イベント ハンドラー メソッド。  
  
|イベント ハンドラー|処理されるイベント|実行します|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>、 <xref:System.IO.FileSystemWatcher.Created>、 <xref:System.IO.FileSystemWatcher.Deleted>|ファイル属性、作成されたファイル、および削除されたファイルの変更を報告します。|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|新旧のパス、名前が変更されたファイルとフォルダーを再帰的を展開するために必要な場合を一覧表示します。|  
  
## <a name="events-and-buffer-sizes"></a>イベントとバッファー サイズ  
 次の説明に従って、メモは、ファイル システムのイベントを変更するいくつかの要因に影響を与えることができますが発生します。  
  
-   一般的なファイル システム操作では、1 つ以上のイベントを発生させる可能性があります。 別に、いくつかの 1 つのディレクトリからファイルが移動したときになど<xref:System.IO.FileSystemWatcher.OnChanged%2A>といくつか<xref:System.IO.FileSystemWatcher.OnCreated%2A>と<xref:System.IO.FileSystemWatcher.OnDeleted%2A>イベントが発生する可能性があります。 複数のイベントを発生させるため、ファイルが複数の単純な操作で構成される複雑な操作を移動するには。 同様に、一部のアプリケーション (ウイルス対策ソフトウェアなど) がによって検出された追加のファイル システムのイベントを発生可能性があります<xref:System.IO.FileSystemWatcher>します。  
  
-   <xref:System.IO.FileSystemWatcher>が切り替えまたは削除しない限り、ディスクを見ることができます。 <xref:System.IO.FileSystemWatcher>タイムスタンプとプロパティを変更できないために、Cd および Dvd のイベントを発生させないしません。 リモート コンピューターは正常に機能するコンポーネントのインストールされている必要なプラットフォームのいずれかが必要です。  
  
-   複数<xref:System.IO.FileSystemWatcher>オブジェクトは、Windows xp Service Pack 1 では、前に、同じ UNC パスを試聴している、または Windows 2000 SP2 またはオブジェクトの以前のバージョンのいずれかでイベントが発生します。 マシンでは、Windows XP SP1 を実行していると、新しい Windows 2000 SP3 以降または Windows Server 2003 では、すべて<xref:System.IO.FileSystemWatcher>オブジェクトが適切なイベントを発生させます。  
  
 なお、<xref:System.IO.FileSystemWatcher>バッファー サイズを超えたときにイベントを見落とす場合があります。 イベントの欠落を回避するには、次のガイドラインに従います。  
  
-   設定してバッファー サイズを増やす、<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>プロパティ。  
  
-   長いファイル名が、バッファーがいっぱいに貢献するために、長いファイルの名前を持つファイルの監視をしないでください。 短い名前を使用してこれらのファイルの名前を変更することを検討してください。  
  
-   イベントの処理コードをできるだけ短くしてください。  
  
   
  
## Examples  
 次の例では、作成、<xref:System.IO.FileSystemWatcher>実行時に指定されたディレクトリを監視します。 変化を監視するコンポーネントを設定`LastWrite`と`LastAccess`時に、作成、削除、またはディレクトリ内のテキスト ファイルの名前を変更します。 場合は、ファイルは、変更、作成、または削除は、ファイルへのパスは、コンソールに出力します。 ファイルの名前が変更、新旧のパスは、コンソールに出力します。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">派生させるため、<see cref="T:System.Diagnostics.ProcessStartInfo" />クラス。 要求値: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />;名前付き権限セット:<see langword="FullTrust" />します。</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Using-a-FileSystemWatcher-4bc97af4">Windows フォームで FileSystemWatcher コンポーネントの使用</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.IO.FileSystemWatcher" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.IO.FileSystemWatcher" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows NT または Windows 2000 がないリモート コンピューターを監視することはできません。 Windows NT 4.0 コンピューターからリモートの Windows NT 4.0 コンピューターを監視することはできません。  
  
 次の表のインスタンスの初期プロパティ値<xref:System.IO.FileSystemWatcher>します。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|ビットごとの OR の組み合わせ`LastWrite`、`FileName`と `DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*.\*"(すべてのファイルの監視)。|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|空の文字列 ("")|  
  
> [!NOTE]
>  コンポーネントは、指定されたディレクトリまでまで視聴しません、<xref:System.IO.FileSystemWatcher.Path%2A>が設定されていると<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>は`true`します。  
  
   
  
## Examples  
 次の例では、作成、<xref:System.IO.FileSystemWatcher>実行時に指定されたディレクトリを監視するオブジェクト。 <xref:System.IO.FileSystemWatcher>オブジェクトは変更を監視します`LastWrite`と`LastAccess`削除、またはテキストの名前に変更をディレクトリにファイル、時間と、作成するためです。 ファイルは、変更、作成、または削除は、ファイルへのパスをコンソールに表示します。 ファイルの名前が変更、新旧のパスをコンソールに表示します。  
  
 この例では、<xref:System.Diagnostics>と<xref:System.IO>名前空間。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">標準表記または UNC (Universal Naming Convention) 表記での監視するディレクトリ。</param>
        <summary>監視するディレクトリを指定して、<see cref="T:System.IO.FileSystemWatcher" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  コンポーネントは、指定されたディレクトリまでまで視聴しません、<xref:System.IO.FileSystemWatcher.Path%2A>が設定されていると<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>は`true`します。  
  
 コンポーネントは、パーソナル コンピューター、ネットワーク ドライブ、またはリモート コンピューター上のファイルを確認できます。  
  
 Windows NT または Windows 2000 がないリモート コンピューターを監視することはできません。 Windows NT 4.0 コンピューターからリモートの Windows NT 4.0 コンピューターを監視することはできません。 <xref:System.IO.FileSystemWatcher.Filter%2A>プロパティは、すべてのファイルを監視する既定で設定されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> パラメーターが空の文字列 ("") です。  
  
または 
<paramref name="path" /> パラメーターで指定されたパスが存在しません。</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> が長すぎます。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string * string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher (path, filter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">標準表記または UNC (Universal Naming Convention) 表記での監視するディレクトリ。</param>
        <param name="filter">ウォッチするファイルの種類。 たとえば、すべてのテキスト ファイルの変更をウォッチするには、"*.txt" に設定します。</param>
        <summary><see cref="T:System.IO.FileSystemWatcher" /> クラスの新しいインスタンスを、監視するディレクトリとファイルの種類を指定して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  コンポーネントは、指定されたディレクトリまでまで視聴しません、<xref:System.IO.FileSystemWatcher.Path%2A>が設定されていると<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>は`true`します。  
  
 コンポーネントは、パーソナル コンピューター、ネットワーク ドライブ、またはリモート コンピューター上のファイルを確認できます。  
  
 Windows NT または Windows 2000 がないリモート コンピューターを監視することはできません。 Windows NT 4.0 コンピューターからリモートの Windows NT 4.0 コンピューターを監視することはできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが <see langword="null" /> です。  
  
または 
<paramref name="filter" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> パラメーターが空の文字列 ("") です。  
  
または 
<paramref name="path" /> パラメーターで指定されたパスが存在しません。</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> が長すぎます。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="fileSystemWatcher.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用する <see cref="T:System.IO.FileSystemWatcher" /> の初期化を開始します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]デザイン環境では、このメソッドを使用して、コンポーネントの初期化を開始フォームまたは別のコンポーネントで使用します。 <xref:System.IO.FileSystemWatcher.EndInit%2A>メソッドは、初期化を終了します。 使用して、<xref:System.IO.FileSystemWatcher.BeginInit%2A>と<xref:System.IO.FileSystemWatcher.EndInit%2A>メソッドにより、コントロールは完全に初期化される前に使用されているからです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : System.IO.FileSystemEventHandler " Usage="member this.Changed : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Changed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した <see cref="P:System.IO.FileSystemWatcher.Path" /> のファイルまたはディレクトリが変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.Changed>サイズに変更されたときに、イベントは、システム属性、最終書き込み時刻、最終アクセス時刻、またはファイルまたはディレクトリのセキュリティ アクセス許可で監視されているディレクトリ。  
  
> [!NOTE]
>  一般的なファイル システム操作では、1 つ以上のイベントを発生させる可能性があります。 別に、いくつかの 1 つのディレクトリからファイルが移動したときになど<xref:System.IO.FileSystemWatcher.OnChanged%2A>といくつか<xref:System.IO.FileSystemWatcher.OnCreated%2A>と<xref:System.IO.FileSystemWatcher.OnDeleted%2A>イベントが発生する可能性があります。 複数のイベントを発生させるため、ファイルが複数の単純な操作で構成される複雑な操作を移動するには。 同様に、一部のアプリケーション (ウイルス対策ソフトウェアなど) がによって検出された追加のファイル システムのイベントを発生可能性があります<xref:System.IO.FileSystemWatcher>します。  
  
 使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>このイベントが処理されるときに発生する通知の数を制限します。  
  
> [!NOTE]
>  <xref:System.IO.FileSystemWatcher.Changed>ファイルの名前が変更しますが、ディレクトリの名前が変更されたときに発生しないとき、イベントが予期せず発生します。 名前を変更するをウォッチするを使用して、<xref:System.IO.FileSystemWatcher.Renamed>イベント。  
  
> [!NOTE]
>  順序、<xref:System.IO.FileSystemWatcher.Changed>他の関連イベントが発生した<xref:System.IO.FileSystemWatcher>イベント タイミングを変更する可能性があります、<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>プロパティは`null`します。  
  
   
  
## Examples  
 次の例では、<xref:System.IO.FileSystemWatcher.Changed>イベントをウォッチ対象のファイルが変更されるたびに、ファイルのパスをコンソールに表示します。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberSignature Language="F#" Value="member this.Created : System.IO.FileSystemEventHandler " Usage="member this.Created : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Created")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した <see cref="P:System.IO.FileSystemWatcher.Path" /> のファイルまたはディレクトリが作成されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ファイルまたはディレクトリにコピーまたは移動など、いくつかの一般的な状況は、イベントに直接対応しないが、これらの出来事が発生します。 イベントを発生しないでください。 システム ファイルまたはディレクトリをコピーするときに発生させる、<xref:System.IO.FileSystemWatcher.Created>そのディレクトリがウォッチされている場合に、ファイルがコピーされたディレクトリ内のイベント。 コピー元のディレクトリを別のインスタンスで監視対象がかどうか<xref:System.IO.FileSystemWatcher>イベントは生成されません。 たとえば、2 つのインスタンスを作成する<xref:System.IO.FileSystemWatcher>します。 FileSystemWatcher1 が見る"C:\My Documents"に設定され、FileSystemWatcher2 が"C:\Your Documents"を見るに設定されます。 マイ ドキュメント"から"Your Documents"にファイルをコピーする場合、<xref:System.IO.FileSystemWatcher.Created>イベントが FileSystemWatcher2、によって発生しますが、FileSystemWatcher1 のイベントは生成されません。 コピーするとは異なりは、ファイルまたはディレクトリを移動すると 2 つのイベントが発生します。 「マイ ドキュメント」から"Your Documents"にファイルを移動する場合、前の例から、 <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2 でイベントを発生させると、 <xref:System.IO.FileSystemWatcher.Deleted> FileSystemWatcher1 でイベントを発生させる場合します。  
  
> [!NOTE]
>  一般的なファイル システム操作では、1 つ以上のイベントを発生させる可能性があります。 別に、いくつかの 1 つのディレクトリからファイルが移動したときになど<xref:System.IO.FileSystemWatcher.OnChanged%2A>といくつか<xref:System.IO.FileSystemWatcher.OnCreated%2A>と<xref:System.IO.FileSystemWatcher.OnDeleted%2A>イベントが発生する可能性があります。 複数のイベントを発生させるため、ファイルが複数の単純な操作で構成される複雑な操作を移動するには。 同様に、一部のアプリケーション (ウイルス対策ソフトウェアなど) がによって検出された追加のファイル システムのイベントを発生可能性があります<xref:System.IO.FileSystemWatcher>します。  
  
> [!NOTE]
>  順序、<xref:System.IO.FileSystemWatcher.Created>他の関連イベントが発生した<xref:System.IO.FileSystemWatcher>イベント タイミングを変更する可能性があります、<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>プロパティは`null`します。  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>ファイルを作成するとすぐにイベントが発生します。 ファイルの中の場合はコピーまたは監視対象のディレクトリに転送、<xref:System.IO.FileSystemWatcher.OnCreated%2A>イベントはすぐに、1 つまたは複数続く<xref:System.IO.FileSystemWatcher.OnChanged%2A>イベント。  
  
   
  
## Examples  
 次の例では、<xref:System.IO.FileSystemWatcher.Created>イベントをウォッチ対象のファイルが作成されるたびに、ファイルのパスをコンソールに表示します。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : System.IO.FileSystemEventHandler " Usage="member this.Deleted : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Deleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した <see cref="P:System.IO.FileSystemWatcher.Path" /> のファイルまたはディレクトリが削除されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ファイルまたはディレクトリにコピーまたは移動など、いくつかの一般的な状況は、イベントに直接対応しないが、これらの出来事が発生します。 イベントを発生しないでください。 システム ファイルまたはディレクトリをコピーするときに発生させる、<xref:System.IO.FileSystemWatcher.Created>そのディレクトリがウォッチされている場合に、ファイルがコピーされたディレクトリ内のイベント。 コピー元のディレクトリを別のインスタンスで監視対象がかどうか<xref:System.IO.FileSystemWatcher>イベントは生成されません。 たとえば、2 つのインスタンスを作成する<xref:System.IO.FileSystemWatcher>します。 FileSystemWatcher1 が見る"C:\My Documents"に設定され、FileSystemWatcher2 が"C:\Your Documents"を見るに設定されます。 マイ ドキュメント"から"Your Documents"にファイルをコピーする場合、<xref:System.IO.FileSystemWatcher.Created>イベントが FileSystemWatcher2、によって発生しますが、FileSystemWatcher1 のイベントは生成されません。 コピーするとは異なりは、ファイルまたはディレクトリを移動すると 2 つのイベントが発生します。 「マイ ドキュメント」から"Your Documents"にファイルを移動する場合、前の例から、 <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2 でイベントを発生させると、 <xref:System.IO.FileSystemWatcher.Deleted> FileSystemWatcher1 でイベントを発生させる場合します。  
  
> [!NOTE]
>  一般的なファイル システム操作では、1 つ以上のイベントを発生させる可能性があります。 別に、いくつかの 1 つのディレクトリからファイルが移動したときになど<xref:System.IO.FileSystemWatcher.OnChanged%2A>といくつか<xref:System.IO.FileSystemWatcher.OnCreated%2A>と<xref:System.IO.FileSystemWatcher.OnDeleted%2A>イベントが発生する可能性があります。 複数のイベントを発生させるため、ファイルが複数の単純な操作で構成される複雑な操作を移動するには。 同様に、一部のアプリケーション (ウイルス対策ソフトウェアなど) がによって検出された追加のファイル システムのイベントを発生可能性があります<xref:System.IO.FileSystemWatcher>します。  
  
> [!NOTE]
>  順序、<xref:System.IO.FileSystemWatcher.Deleted>他の関連イベントが発生した<xref:System.IO.FileSystemWatcher>イベント タイミングを変更する可能性があります、<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>プロパティは`null`します。  
  
   
  
## Examples  
 次の例では、<xref:System.IO.FileSystemWatcher.Deleted>イベントをウォッチ対象のファイルが削除されたときに、ファイルのパスをコンソールに表示します。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary><see cref="T:System.IO.FileSystemWatcher" /> によって使用されているアンマネージド リソースを解放し、オプションでマネージド リソースも解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリック<xref:System.ComponentModel.Component.Dispose%2A>メソッドと<xref:System.Object.Finalize%2A>メソッド。 <xref:System.ComponentModel.Component.Dispose%2A> 保護された起動<xref:System.IO.FileSystemWatcher.Dispose%2A>メソッドを`disposing`パラメーターに設定`true`します。 <xref:System.Object.Finalize%2A> 呼び出す<xref:System.IO.FileSystemWatcher.Dispose%2A>で`disposing`に設定`false`します。  
  
 `disposing` パラメーターが `true` の場合、このメソッドは、この <xref:System.IO.Compression.DeflateStream> が参照しているすべてのマネージド オブジェクトによって保持されているリソースをすべて解放します。 このメソッドは、参照される各オブジェクトの <xref:System.ComponentModel.Component.Dispose%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> は、他のオブジェクトから複数回呼び出すことができます。 オーバーライドするときに<see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />の事前に呼び出したで以前破棄されたオブジェクトを参照しないように注意する<see cref="M:System.ComponentModel.Component.Dispose" />します。 実装する方法についての詳細は<see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />を参照してください[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)します。  
  
詳細については<see cref="M:System.ComponentModel.Component.Dispose" />と<see cref="M:System.Object.Finalize" />を参照してください[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)します。</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Enabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コンポーネントが有効かどうかを示す値を取得または設定します。</summary>
        <value>コンポーネントが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] のデザイナーでコンポーネントを使用している場合、既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定しない限り、コンポーネントはイベントを発生させないは<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>に`true`します。  
  
> [!NOTE]
>  コンポーネントは、指定されたディレクトリまでまで視聴しません、<xref:System.IO.FileSystemWatcher.Path%2A>プロパティが設定されていると<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>は`true`します。  
  
 <xref:System.IO.FileSystemWatcher.WaitForChanged%2A>メソッドは、このプロパティ設定されている場合でも、ファイルの変更に応答する呼び出されるイベント ハンドラーを使用する`false`します。  
  
   
  
## Examples  
 次の例では、作成、<xref:System.IO.FileSystemWatcher>実行時に指定されたディレクトリを監視します。 変化を監視するコンポーネントを設定`LastWrite`と`LastAccess`時に、作成、削除、またはディレクトリ内のテキスト ファイルの名前を変更します。 場合は、ファイルは、変更、作成、または削除は、ファイルへのパスは、コンソールに出力します。 ファイルの名前が変更、新旧のパスは、コンソールに出力します。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.IO.FileSystemWatcher" /> オブジェクトは破棄されました。</exception>
        <exception cref="T:System.PlatformNotSupportedException">現在のオペレーティング システムは Microsoft Windows NT 以降ではありません。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><see cref="P:System.IO.FileSystemWatcher.Path" /> で指定したディレクトリが見つかりませんでした。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.IO.FileSystemWatcher.Path" /> が設定されていないか、無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="fileSystemWatcher.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>フォームまたは別のコンポーネントで使用する <see cref="T:System.IO.FileSystemWatcher" /> の初期化を終了します。 初期化は実行時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]デザイン環境では、このメソッドを使用して、コンポーネントの初期化を終了するフォームまたは別のコンポーネントで使用します。 <xref:System.IO.FileSystemWatcher.BeginInit%2A>メソッドは、初期化を開始します。 使用して、<xref:System.IO.FileSystemWatcher.BeginInit%2A>と<xref:System.IO.FileSystemWatcher.EndInit%2A>メソッドにより、コントロールは完全に初期化される前に使用されているからです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.ErrorEventHandler " Usage="member this.Error : System.IO.ErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.IO.FileSystemWatcher" /> のインスタンスが変更の監視を続けられない場合、または内部バッファー オーバーフローの場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 何かできないようにするたびに、このイベントが発生します、<xref:System.IO.FileSystemWatcher>オブジェクトからの変更を監視します。 オブジェクトは、リモート ディレクトリ内の変更の監視と、そのディレクトリへの接続が失われた場合など、<xref:System.IO.FileSystemWatcher.Error>イベントが発生します。  
  
 システムでは、ファイルの変更通知され、コンポーネントを作成し、Api に渡すバッファーにその変更を格納します。 短時間で多くの変更がある場合、バッファーがオーバーフローすることができます。 これにより、コンポーネントは、ディレクトリの変更の追跡と包括的な通知を提供するだけです。 バッファーのサイズを増やすことは高価な以外から来ているためにページは keep、ディスクにスワップ アウトできないメモリ バッファーをできるだけ小さくします。 バッファー オーバーフローを避けるためには、使用、 <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>、 <xref:System.IO.FileSystemWatcher.Filter%2A>、および<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>望ましくないを除外するプロパティ変更通知します。  
  
> [!NOTE]
>  一般的なファイル システム操作では、1 つ以上のイベントを発生させる可能性があります。 別に、いくつかの 1 つのディレクトリからファイルが移動したときになど<xref:System.IO.FileSystemWatcher.OnChanged%2A>といくつか<xref:System.IO.FileSystemWatcher.OnCreated%2A>と<xref:System.IO.FileSystemWatcher.OnDeleted%2A>イベントが発生する可能性があります。 複数のイベントを発生させるため、ファイルが複数の単純な操作で構成される複雑な操作を移動するには。 同様に、一部のアプリケーション (ウイルス対策ソフトウェアなど) がによって検出された追加のファイル システムのイベントを発生可能性があります<xref:System.IO.FileSystemWatcher>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.IO.FileSystemWatcher.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ディレクトリで監視するファイルを決定するために使用するフィルター文字列を取得または設定します。</summary>
        <value>フィルター文字列。 既定値は"*。\*"(すべてのファイルを監視します)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 すべてのファイルの変更をウォッチする、<xref:System.IO.FileSystemWatcher.Filter%2A>プロパティを空の文字列 ("")。 特定のファイルをウォッチする、<xref:System.IO.FileSystemWatcher.Filter%2A>プロパティをファイル名。 たとえば、MyDoc.txt ファイル内の変更の監視には、次のように設定します。、<xref:System.IO.FileSystemWatcher.Filter%2A>プロパティを"MyDoc.txt"。 特定の種類のファイルの変更について視聴することもできます。 たとえば、任意のテキスト ファイルの変更をウォッチする次のように設定します。、<xref:System.IO.FileSystemWatcher.Filter%2A>プロパティを"*.txt"。 などの複数のフィルターの使用"\*.txt&#124;\*.doc"はサポートされていません。  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A>後にプロパティを変更できる、<xref:System.IO.FileSystemWatcher>オブジェクトがイベントの受信を開始します。  
  
 不必要な通知をフィルター処理の詳細については、次を参照してください。、 <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>、 <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>、および<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>プロパティ。  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> 次の例に示すように一致するファイルは、ワイルドカードを受け付けます。  
  
|フィルター文字列|次のファイルを監視します。|  
|-------------------|---------------------------------|  
|*.\*|すべてのファイル (既定値)。 空の文字列 ("") もすべてのファイルを監視します。|  
|*.txt|"Txt"拡張子を持つすべてのファイル。|  
|*recipe.doc|"Doc"拡張機能では、「レシピ」で終わるすべてのファイル。|  
|win*.xml|"Xml"拡張子が"win"で始まるすべてのファイル。|  
|Sales * 200 ですか。xls|次に一致します。<br /><br /> 7 月の売上 2001.xlsSales Aug 2002.xlsSales 年 3 月 2004.xls<br /><br /> 一致しません。<br /><br /> 11 月の売上 1999.xls|  
|MyReport.Doc|MyReport.doc のみを監視します。|  
  
   
  
## Examples  
 次の例では、作成、<xref:System.IO.FileSystemWatcher>実行時に指定されたディレクトリを監視します。 変化を監視するコンポーネントを設定`LastWrite`と`LastAccess`時に、作成、削除、またはディレクトリ内のテキスト ファイルの名前を変更します。 場合は、ファイルは、変更、作成、または削除は、ファイルへのパスは、コンソールに出力します。 ファイルの名前が変更、新旧のパスは、コンソールに出力します。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Filters">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;string&gt; Filters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;string&gt; Filters" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Filters As Collection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ Filters { System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Filters : System.Collections.ObjectModel.Collection&lt;string&gt;" Usage="System.IO.FileSystemWatcher.Filters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileSystemWatcher.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeSubdirectories : bool with get, set" Usage="System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_IncludeSubdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したパスのサブディレクトリを監視するかどうかを示す値を取得または設定します。</summary>
        <value>サブディレクトリを監視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>に`true`ファイルとで指定されたディレクトリ内に含まれるディレクトリの変更通知を監視する場合、<xref:System.IO.FileSystemWatcher.Path%2A>プロパティ、およびそのサブディレクトリ。 設定、<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>プロパティを`false`内部バッファーに送信される通知の数を削減するのに役立ちます。 不必要な通知をフィルター処理の詳細については、次を参照してください。、<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>と<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>プロパティ。  
  
 ときに`true`、<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>は直接の子ディレクトリだけでなく、全体のサブ ツリーを再帰的です。 内のファイルまたはサブツリー内のディレクトリへの相対パスを返します、<xref:System.IO.FileSystemEventArgs.Name%2A>プロパティの<xref:System.IO.FileSystemEventArgs>と<xref:System.IO.RenamedEventArgs.OldName%2A>プロパティの<xref:System.IO.RenamedEventArgs>のウォッチング中の変更に応じて、します。 完全修飾パスを取得できます、<xref:System.IO.FileSystemEventArgs.FullPath%2A>プロパティの<xref:System.IO.FileSystemEventArgs>と<xref:System.IO.RenamedEventArgs.OldFullPath%2A>プロパティの<xref:System.IO.RenamedEventArgs>のウォッチング中の変更に応じて、します。  
  
 ウォッチング中、ディレクトリのサブ ツリーで、ディレクトリを作成する場合と<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>は`true`、そのディレクトリは自動的に監視します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.InternalBufferSize : int with get, set" Usage="System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>内部バッファーのサイズ (バイト単位) を取得または設定します。</summary>
        <value>内部バッファー サイズ (バイト単位)。 既定値は 8192 (8 KB) です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 4 KB 以上では、バッファーを設定できますが、64 KB を超えることはできません。 設定を試行した場合、<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>に 4096 バイト未満で、値プロパティは破棄されます、<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>プロパティは、4096 バイトに設定されます。 最適なパフォーマンスには、Intel ベース コンピューター上で 4 KB の倍数を使用します。  
  
 システム ファイルの変更のコンポーネントに通知し、コンポーネントを作成し、Api に渡すバッファーにその変更を格納します。 各イベントには、最大 16 バイトのメモリ、ファイル名を含まないを使用できます。 短時間で多くの変更がある場合、バッファーがオーバーフローすることができます。 これにより、コンポーネントは、ディレクトリの変更の追跡と包括的な通知を提供するだけです。 バッファーのサイズを増やすことを防ぐことができます変更イベントをファイル システムがありません。 しかし、バッファー サイズを増やすことが高価な非ページ メモリ バッファーをできるだけ小さく維持ようにディスクにスワップ アウトできないからです。 バッファー オーバーフローを避けるためには、使用、<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>と<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>望ましくないを除外するプロパティ変更通知します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyFilter : System.IO.NotifyFilters with get, set" Usage="System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_ChangedFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウォッチする変更の種類を取得または設定します。</summary>
        <value><see cref="T:System.IO.NotifyFilters" /> 値のいずれか。 既定値は <see langword="LastWrite" />、<see langword="FileName" />、および <see langword="DirectoryName" /> のビットごとの OR の組み合わせです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メンバーを組み合わせることができます、<xref:System.IO.NotifyFilters>列挙体を一度に変更の 1 つ以上の種類を監視します。 たとえば、変更と、ファイルのサイズの変更を見ることができます、`LastWrite`時間。 これは、ファイルまたはフォルダーのサイズの変更または変更があるときにいつでもイベントを発生させる、`LastWrite`ファイルまたはフォルダーの時間。  
  
 これは、不必要な通知をフィルター処理する方法の 1 つです。 不必要な通知をフィルター処理の詳細については、次を参照してください。、 <xref:System.IO.FileSystemWatcher.Filter%2A>、 <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>、および<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>プロパティ。  
  
   
  
## Examples  
 次の例では、作成、<xref:System.IO.FileSystemWatcher>実行時に指定されたディレクトリを監視します。 変化を監視するコンポーネントを設定`LastWrite`と`LastAccess`時に、作成、削除、またはディレクトリ内のテキスト ファイルの名前を変更します。 場合は、ファイルは、変更、作成、または削除は、ファイルへのパスは、コンソールに出力します。 ファイルの名前が変更、新旧のパスは、コンソールに出力します。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">値が、<see cref="T:System.IO.NotifyFilters" /> 値の有効なビットごとの OR の組み合わせになっていません。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">設定されようとしている値が無効です。</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.IO.FileSystemEventArgs" />。</param>
        <summary><see cref="E:System.IO.FileSystemWatcher.Changed" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A> サイズ、システム属性、最終書き込み時刻、最終アクセス時刻、またはファイルまたはディレクトリの監視対象のディレクトリのセキュリティ アクセス許可に変更されたときに呼び出されます。  
  
 使用、<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>イベントの数を制限するプロパティが発生したときに、<xref:System.IO.FileSystemWatcher.Changed>イベントを処理します。  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>ファイルを作成するとすぐにイベントが発生します。 ファイルの中の場合はコピーまたは監視対象のディレクトリに転送、<xref:System.IO.FileSystemWatcher.OnCreated%2A>イベントはすぐに、1 つまたは複数続く<xref:System.IO.FileSystemWatcher.OnChanged%2A>イベント。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドするときに<see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />メソッド。</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnCreated : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.IO.FileSystemEventArgs" />。</param>
        <summary><see cref="E:System.IO.FileSystemWatcher.Created" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> ファイルまたはディレクトリが監視されているディレクトリに作成されると呼び出されます。  
  
 ファイルまたはディレクトリにコピーまたは移動など、いくつかの一般的な状況は、イベントに直接対応しないが、これらの出来事が発生します。 イベントを発生しないでください。 システム ファイルまたはディレクトリをコピーするときに発生させる、<xref:System.IO.FileSystemWatcher.Created>そのディレクトリがウォッチされている場合に、ファイルがコピーされたディレクトリ内のイベント。 コピー元のディレクトリを別のインスタンスで監視対象がかどうか<xref:System.IO.FileSystemWatcher>イベントは生成されません。 たとえば、2 つのインスタンスを作成する<xref:System.IO.FileSystemWatcher>します。 FileSystemWatcher1 が見る"C:\My Documents"に設定され、FileSystemWatcher2 が"C:\Your Documents"を見るに設定されます。 [マイ ドキュメント] からファイルをコピーし、"Your Documents"に貼り付けることがある場合、 <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2 に発生するイベントが FileSystemWatcher1 のイベントは生成されません。 コピーするとは異なりファイルまたはディレクトリを移動する 2 つのイベントを発生させます。 「マイ ドキュメント」から"Your Documents"にファイルを移動する場合、前の例から、 <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2 でイベントを発生させると、 <xref:System.IO.FileSystemWatcher.Deleted> FileSystemWatcher1 でイベントを発生させるとします。  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>ファイルを作成するとすぐにイベントが発生します。 ファイルの中の場合はコピーまたは監視対象のディレクトリに転送、<xref:System.IO.FileSystemWatcher.OnCreated%2A>イベントはすぐに、1 つまたは複数続く<xref:System.IO.FileSystemWatcher.OnChanged%2A>イベント。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドするときに<see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />メソッド。</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnDeleted : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.IO.FileSystemEventArgs" />。</param>
        <summary><see cref="E:System.IO.FileSystemWatcher.Deleted" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> ファイルまたは監視されているディレクトリ内のディレクトリが削除されると呼び出されます。  
  
 ファイルまたはディレクトリにコピーまたは移動など、いくつかの一般的な状況は、イベントに直接対応しないが、これらの出来事が発生します。 イベントを発生しないでください。 システム ファイルまたはディレクトリをコピーするときに発生させる、<xref:System.IO.FileSystemWatcher.Created>そのディレクトリがウォッチされている場合に、ファイルがコピーされたディレクトリ内のイベント。 コピー元のディレクトリを別のインスタンスで監視対象がかどうか<xref:System.IO.FileSystemWatcher>イベントは生成されません。 たとえば、2 つのインスタンスを作成する<xref:System.IO.FileSystemWatcher>します。 FileSystemWatcher1 が見る"C:\My Documents"に設定され、FileSystemWatcher2 が"C:\Your Documents"を見るに設定されます。 マイ ドキュメント"から"Your Documents"にファイルをコピーする場合、<xref:System.IO.FileSystemWatcher.Created>イベントが FileSystemWatcher2、によって発生しますが、FileSystemWatcher1 のイベントは生成されません。 コピーするとは異なりファイルまたはディレクトリを移動する 2 つのイベントを発生させます。 「マイ ドキュメント」から"Your Documents"にファイルを移動する場合、前の例から、 <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2 でイベントを発生させると、 <xref:System.IO.FileSystemWatcher.Deleted> FileSystemWatcher1 でイベントを発生させる場合します。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドするときに<see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />メソッド。</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnError : System.IO.ErrorEventArgs -&gt; unit" Usage="fileSystemWatcher.OnError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.IO.ErrorEventArgs" />。</param>
        <summary><see cref="E:System.IO.FileSystemWatcher.Error" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A> エラーが発生すると呼び出されます。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドするときに<see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />メソッド。</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRenamed : System.IO.RenamedEventArgs -&gt; unit" Usage="fileSystemWatcher.OnRenamed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.IO.RenamedEventArgs" />。</param>
        <summary><see cref="E:System.IO.FileSystemWatcher.Renamed" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> ファイルまたは監視されているディレクトリ内のディレクトリの名前を変更すると呼び出されます。 その<xref:System.IO.RenamedEventArgs>引数には、変更、新旧のパス、および新旧の名前の種類など、名前の変更の操作に関する情報が含まれています。 なお、<xref:System.IO.FileSystemEventArgs.Name>プロパティの null にすることがある場合のイベントの名前を変更、<xref:System.IO.FileSystemWatcher>はオペレーティング システムから新旧の名前のイベントの照合を取得できません。 
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドするときに<see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />メソッド。</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IO.FileSystemWatcher.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ウォッチするディレクトリのパスを取得または設定します。</summary>
        <value>監視するパス。 既定値は、空の文字列 ("") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、ディレクトリへの完全修飾パスです。 場合、<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>プロパティは`true`、このディレクトリがルート位置の変更は監視システムは、それ以外の場合はマークされている唯一のディレクトリ。 特定のファイルを見るには、次のように設定します。、<xref:System.IO.FileSystemWatcher.Path%2A>プロパティを、完全修飾、正しいディレクトリと<xref:System.IO.FileSystemWatcher.Filter%2A>プロパティをファイル名。  
  
 <xref:System.IO.FileSystemWatcher.Path%2A>プロパティは、汎用名前付け規則 (UNC) パスをサポートしています。  
  
> [!NOTE]
>  コンポーネントの変更を監視できる前に、このプロパティを設定する必要があります。  
  
 ディレクトリの名前を変更するとき、<xref:System.IO.FileSystemWatcher>自体を自動的に、新しく名前を変更した項目に再アタッチします。 設定する場合など、<xref:System.IO.FileSystemWatcher.Path%2A>プロパティを"C:\My Documents"と"C:\Your Documents"にディレクトリを手動で名前を変更、コンポーネントは、新しく名前を変更したディレクトリの変更通知をリッスンしているが続行されます。 要求するときに、ただし、<xref:System.IO.FileSystemWatcher.Path%2A>プロパティ、古いパスが含まれています。 これは、コンポーネントがウォッチするディレクトリを判断されるため、ディレクトリの名前ではなく、ハンドルに基づきます。 名前を変更しても、ハンドルには影響しません。 そのため、コンポーネントを破棄し、更新することがなく再作成する場合、<xref:System.IO.FileSystemWatcher.Path%2A>プロパティ、アプリケーションは、ディレクトリが存在しないために失敗します。  
  
   
  
## Examples  
 次の例では、作成、<xref:System.IO.FileSystemWatcher>実行時に指定されたディレクトリを監視します。 変化を監視するコンポーネントを設定`LastWrite`と`LastAccess`時に、作成、削除、またはディレクトリ内のテキスト ファイルの名前を変更します。 場合は、ファイルは、変更、作成、または削除は、ファイルへのパスは、コンソールに出力します。 ファイルの名前が変更、新旧のパスは、コンソールに出力します。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定されたパスが存在しないか、見つかりませんでした。  
  
または 
指定したパスにワイルドカード文字が含まれています。  
  
または 
指定したパスに無効なパス文字が含まれています。</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberSignature Language="F#" Value="member this.Renamed : System.IO.RenamedEventHandler " Usage="member this.Renamed : System.IO.RenamedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Renamed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した <see cref="P:System.IO.FileSystemWatcher.Path" /> のファイルまたはディレクトリの名前が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Renamed`イベントは、<xref:System.IO.RenamedEventHandler>を次のシグネチャを持つデリゲート。

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 <xref:System.IO.RenamedEventArgs>オブジェクトは、名前の変更の種類など、名前の変更の操作に関する情報を提供します (、<xref:System.IO.FileSystemEventArgs.ChangeType>プロパティ)、新旧の名前と、新旧のパス。 なお、<xref:System.IO.FileSystemEventArgs.Name>プロパティの null にすることがある場合のイベントの名前を変更、<xref:System.IO.FileSystemWatcher>はオペレーティング システムから新旧の名前のイベントの照合を取得できません。

 ウォッチング中のディレクトリの名前を変更しても、通知は発生しません。 通知は視聴して、ディレクトリ内のエントリのだけ発生します。  
  
   
  
## Examples  
 次の例では、<xref:System.IO.FileSystemWatcher.Renamed>イベントをウォッチ対象のファイルの名前が変更されるたびに、ファイルのパスをコンソールに表示します。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.IO.FileSystemWatcher.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.ComponentModel.ISite" /> の <see cref="T:System.IO.FileSystemWatcher" /> を取得または設定します。</summary>
        <value><see cref="T:System.ComponentModel.ISite" /> の <see cref="T:System.IO.FileSystemWatcher" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サイト バインドを<xref:System.ComponentModel.Component>を<xref:System.ComponentModel.Design.IDesignerHost.Container%2A>と、それらの間の通信を有効にするだけでなく、コンテナーは、そのコンポーネントを管理する方法を提供します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_SynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ディレクトリ変更の結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用するオブジェクトを取得または設定します。</summary>
        <value>ディレクトリ変更の結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用するオブジェクトを表す <see cref="T:System.ComponentModel.ISynchronizeInvoke" />。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>は`null`、メソッドの処理、 <xref:System.IO.FileSystemWatcher.Changed>、 <xref:System.IO.FileSystemWatcher.Created>、 <xref:System.IO.FileSystemWatcher.Deleted>、および<xref:System.IO.FileSystemWatcher.Renamed>イベントが、システム スレッド プールのスレッドで呼び出されます。 システム スレッド プールの詳細については、次を参照してください。<xref:System.Threading.ThreadPool>します。  
  
 ときに、 <xref:System.IO.FileSystemWatcher.Changed>、 <xref:System.IO.FileSystemWatcher.Created>、 <xref:System.IO.FileSystemWatcher.Deleted>、および<xref:System.IO.FileSystemWatcher.Renamed>イベントがなどのビジュアルの Windows フォーム コンポーネントによって処理されます、 <xref:System.Windows.Forms.Button>、システム スレッド プールを介したコンポーネントへのアクセスが機能しないか、例外が発生する可能性があります。 設定してこの問題を回避<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>を処理するメソッドが、Windows フォーム コンポーネントに、 <xref:System.IO.FileSystemWatcher.Changed>、 <xref:System.IO.FileSystemWatcher.Created>、 <xref:System.IO.FileSystemWatcher.Deleted>、および<xref:System.IO.FileSystemWatcher.Renamed>コンポーネントが作成された同じスレッドで呼び出されるイベント。  
  
 場合、<xref:System.IO.FileSystemWatcher>内で使用する[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]Windows フォーム デザイナーで<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>を格納しているコントロールが自動的に設定、<xref:System.IO.FileSystemWatcher>します。 配置する場合など、 <xref:System.IO.FileSystemWatcher> Form1 のデザイナーで (から継承される<xref:System.Windows.Forms.Form>)、<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>プロパティの<xref:System.IO.FileSystemWatcher>Form1 のインスタンスに設定されています。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>発生した変更についての固有な情報を格納する構造体を返す同期メソッド。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged changeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType">ウォッチする <see cref="T:System.IO.WatcherChangeTypes" />。</param>
        <summary>監視する変更の種類を指定して、発生した変更についての固有な情報を格納する構造体を返す同期メソッド。</summary>
        <returns>発生した変更についての固有な情報を格納する <see cref="T:System.IO.WaitForChangedResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、最初の変更が発生し、返しますまで無期限に待機します。 これを使用して同じ<xref:System.IO.FileSystemWatcher.WaitForChanged%2A>で、`timeout`パラメーターが-1 に設定します。  
  
> [!NOTE]
>  このメソッドに応答ファイルの変更の場合でも呼び出されるイベント ハンドラーを使用する、<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>プロパティに設定されて`false`します。  
  
 一部のシステムで<xref:System.IO.FileSystemWatcher>8.3 ファイル名の短い形式を使用してファイルへの変更を報告します。 たとえば、"LongFileName.LongExtension"への変更として報告する"LongFi ~。Lon"。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes * int -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged (changeType, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType">ウォッチする <see cref="T:System.IO.WatcherChangeTypes" />。</param>
        <param name="timeout">タイムアウトまでの待機時間 (ミリ秒単位)。</param>
        <summary>監視する変更の種類とタイムアウトまでの待機時間 (ミリ秒単位) を指定して、発生した変更についての固有な情報を格納する構造体を返す同期メソッド。</summary>
        <returns>発生した変更についての固有な情報を格納する <see cref="T:System.IO.WaitForChangedResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、変更が発生したかがタイムアウトするまで待機します。値-1 を`timeout`パラメーターは、無期限に待機することを意味します。  
  
> [!NOTE]
>  このメソッドに応答ファイルの変更の場合でも呼び出されるイベント ハンドラーを使用する、<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>プロパティに設定されて`false`します。  
  
 一部のシステムで<xref:System.IO.FileSystemWatcher>8.3 ファイル名の短い形式を使用してファイルへの変更を報告します。 たとえば、"LongFileName.LongExtension"への変更として報告する"LongFi ~。Lon"。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>