<Type Name="RouteCollection" FullName="System.Web.Routing.RouteCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2fa0d99f07b7d00dd022180c99797d3bf4d01d85" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37605050" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RouteCollection : System.Collections.ObjectModel.Collection&lt;System.Web.Routing.RouteBase&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RouteCollection extends System.Collections.ObjectModel.Collection`1&lt;class System.Web.Routing.RouteBase&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Web.Routing.RouteCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class RouteCollection&#xA;Inherits Collection(Of RouteBase)" />
  <TypeSignature Language="C++ CLI" Value="public ref class RouteCollection : System::Collections::ObjectModel::Collection&lt;System::Web::Routing::RouteBase ^&gt;" />
  <TypeSignature Language="F#" Value="type RouteCollection = class&#xA;    inherit Collection&lt;RouteBase&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Web.Routing</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;System.Web.Routing.RouteBase&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="!0">System.Web.Routing.RouteBase</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.Web.Routing, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>ASP.NET ルーティングのルートのコレクションを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Routing.RouteCollection>クラスから派生したオブジェクトのコレクションを管理するためのメソッドを提供、<xref:System.Web.Routing.RouteBase>クラス。  
  
 通常、使用する、 `static` <xref:System.Web.Routing.RouteTable.Routes%2A>のプロパティ、<xref:System.Web.Routing.RouteTable>を取得するクラス、<xref:System.Web.Routing.RouteCollection>オブジェクト。 <xref:System.Web.Routing.RouteTable.Routes%2A>プロパティは、ASP.NET アプリケーションのすべてのルートを格納します。 ASP.NET ルーティングでルートを反復処理、 <xref:System.Web.Routing.RouteTable.Routes%2A> URL に一致するルートを検索するプロパティ。  
  
 呼び出す URL を作成する、<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A>メソッドと値のコレクションを渡します。 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A>メソッドは、渡されたし、返します値と一致するパラメーターを持つ最初のルートを検索、<xref:System.Web.Routing.VirtualPathData>一致するルートに関する情報を含むオブジェクト。 使用して URL を取得する、<xref:System.Web.Routing.VirtualPathData.VirtualPath%2A>のプロパティ、<xref:System.Web.Routing.VirtualPathData>オブジェクト。  
  
 名前または名前のないルートを追加することができます。 名を含む、似たようなルートの Url が作成されるときに区別できます。 名前を指定しない場合は、URL を作成する最初の一致するルートをコレクションには ASP.NET ルーティングします。  
  
 名前のないルートを追加すると、<xref:System.Web.Routing.RouteCollection>オブジェクト、コレクションに既に存在するルートを追加することはできません。 名前付きのルートを追加すると、既にコレクション内のルートを識別する名前を使用することはできません。  
  
 使用する、<xref:System.Web.Routing.RouteCollection.GetReadLock%2A>メソッドと<xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>メソッドを他のプロセスから競合することがなくコレクションと対話することを確認します。  
  
 ルート コレクションにルートを追加する方法の詳細については、次を参照してください。 [ASP.NET ルーティング](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)します。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Web.Routing.RouteCollection" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RouteCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RouteCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.Routing.RouteCollection" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RouteCollection (System.Web.Hosting.VirtualPathProvider virtualPathProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.Hosting.VirtualPathProvider virtualPathProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.#ctor(System.Web.Hosting.VirtualPathProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RouteCollection(System::Web::Hosting::VirtualPathProvider ^ virtualPathProvider);" />
      <MemberSignature Language="F#" Value="new System.Web.Routing.RouteCollection : System.Web.Hosting.VirtualPathProvider -&gt; System.Web.Routing.RouteCollection" Usage="new System.Web.Routing.RouteCollection virtualPathProvider" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="virtualPathProvider" Type="System.Web.Hosting.VirtualPathProvider" />
      </Parameters>
      <Docs>
        <param name="virtualPathProvider">仮想ファイル システムからリソースを取得するためのプロバイダーです。</param>
        <summary>指定した仮想パス プロバイダーを使用して、<see cref="T:System.Web.Routing.RouteCollection" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (string name, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(string name, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Add(System.String,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (name As String, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::String ^ name, System::Web::Routing::RouteBase ^ item);" />
      <MemberSignature Language="F#" Value="override this.Add : string * System.Web.Routing.RouteBase -&gt; unit" Usage="routeCollection.Add (name, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="name">ルートを識別する値。 この値を <see langword="null" /> または空の文字列にすることもできます。</param>
        <param name="item">コレクションの末尾に追加するルート。</param>
        <summary>
          <see cref="T:System.Web.Routing.RouteCollection" /> オブジェクトの末尾にルートを追加し、指定の名前をそのルートに割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Routing.RouteCollection.Add%2A>メソッドでは、ルートのコレクションに追加すると、ルートの名前を定義することができます。 ルートの名前を定義することで、URL を作成するルーティングを使用するときに使用する特定のルートを指定できます。 1 つ以上のルートに渡す値に一致する場合、特定のルートを指定することが重要です、<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A>メソッド。 名前付きのルートを指定しない場合、ASP.NET ルーティングと、最初のルートが値に一致するコレクション内で使用されます。 詳細については、次を参照してください。[方法: ルートから Url を構築](http://msdn.microsoft.com/library/1ffd4085-71f6-4822-be8f-f682ca638650)します。  
  
 名前に 1 回だけを使用できます、<xref:System.Web.Routing.RouteCollection>オブジェクト。  
  
 呼び出すことによって、ルートを追加するには、ルートの名前を指定していない場合、<xref:System.Collections.ObjectModel.Collection%601.Add%2A>メソッド。  
  
 使用して、<xref:System.Web.Routing.RouteCollection.GetReadLock%2A>メソッドと<xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>メソッドを他のプロセスから競合することがなくコレクションと対話することを確認します。  
  
   
  
## Examples  
 次の例へのルートを追加する方法を示しています、<xref:System.Web.Routing.RouteCollection>オブジェクトし、ルートに名前を割り当てます。  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#1)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> はコレクション内で既に使用されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendTrailingSlash">
      <MemberSignature Language="C#" Value="public bool AppendTrailingSlash { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AppendTrailingSlash" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.AppendTrailingSlash" />
      <MemberSignature Language="VB.NET" Value="Public Property AppendTrailingSlash As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AppendTrailingSlash { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AppendTrailingSlash : bool with get, set" Usage="System.Web.Routing.RouteCollection.AppendTrailingSlash" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>仮想パスが正規化されるときに後続のスラッシュを追加するかどうかを示す値を取得または設定します。</summary>
        <value>末尾のスラッシュが追加される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberSignature Language="F#" Value="override this.ClearItems : unit -&gt; unit" Usage="routeCollection.ClearItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.Routing.RouteCollection" /> オブジェクトからすべての要素を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.Routing.RouteCollection.GetReadLock%2A>メソッドと<xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>メソッドを他のプロセスから競合することがなくコレクションと対話することを確認します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReadLock">
      <MemberSignature Language="C#" Value="public IDisposable GetReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable GetReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Function GetReadLock () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ GetReadLock();" />
      <MemberSignature Language="F#" Value="member this.GetReadLock : unit -&gt; IDisposable" Usage="routeCollection.GetReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コレクションからオブジェクトを取得する場合に、スレッド セーフを管理するためのオブジェクトを提供します。</summary>
        <returns>スレッド セーフを管理するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Routing.RouteCollection>オブジェクトは、アプリケーションで複数のプロセスに利用できます。 したがって、アプリケーションが実行されているときに、ルートを取得する場合は、使用、<xref:System.Web.Routing.RouteCollection.GetReadLock%2A>メソッドはスレッド セーフを確保するためにします。 ルート コレクションの読み取りロックを取得するには、それを取得しようとしているときに、コレクションは変更されませんを確認します。  
  
 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>メソッドは、スレッドのロックを獲得するまで続行を停止します。 書き込みロックをする場合、スレッドは、更新が完了して、書き込みロックが解放されるまで待機します。 ルート コレクションの読み取りロックが解放されたときに、<xref:System.IDisposable>このメソッドによって返されるオブジェクトを破棄します。  
  
 使用しない場合<xref:System.Web.Routing.RouteCollection.GetReadLock%2A>、中にエラーが発生する可能性があります、<xref:System.Web.Routing.RouteCollection>コレクション。 たとえば、内のオブジェクト内をループして、<xref:System.Web.Routing.RouteCollection>を呼び出さずに、それらを読み取るコレクション<xref:System.Web.Routing.RouteCollection.GetReadLock%2A>します。 別の要求から別のスレッドを呼び出すことができますを行いますが、<xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>し、コレクションにルートを追加します。 最初のスレッドはエラーで失敗します。  
  
 2 つのシナリオでは呼び出しする必要はありませんが<xref:System.Web.Routing.RouteCollection.GetReadLock%2A>:  
  
-   パブリック メソッド、<xref:System.Web.Routing.RouteCollection>などクラス<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A>と<xref:System.Web.Routing.RouteCollection.GetRouteData%2A>呼び出す<xref:System.Web.Routing.RouteCollection.GetReadLock%2A>内部的にします。 したがって、明示的に呼び出す必要はない<xref:System.Web.Routing.RouteCollection.GetReadLock%2A>のパブリック メソッドを呼び出すと、<xref:System.Web.Routing.RouteCollection>コレクションからデータを取得するクラス。  
  
-   アプリケーションが開始およびがまだ要求を処理しないなどの`Application_Start`イベント ハンドラーでは、1 つのスレッドが実行されています。 呼び出していない他のスレッドがその中に、コレクションを更新することがありますがないため、<xref:System.Web.Routing.RouteCollection.GetReadLock%2A>します。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、<xref:System.Web.Routing.RouteCollection.GetReadLock%2A>メソッド、アプリケーションの実行中にルートを取得するとき。 `Using`ステートメントにより、ことを読み込んだとき、コレクションから (コードが正常に完了したか、例外がスローされます) かどうか、実行時に何が起きようとも、ロックは安全に解放の最後に、`Using`コード ブロックです。  
  
  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteData">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteData GetRouteData (System.Web.HttpContextBase httpContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.RouteData GetRouteData(class System.Web.HttpContextBase httpContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetRouteData(System.Web.HttpContextBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteData (httpContext As HttpContextBase) As RouteData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::RouteData ^ GetRouteData(System::Web::HttpContextBase ^ httpContext);" />
      <MemberSignature Language="F#" Value="member this.GetRouteData : System.Web.HttpContextBase -&gt; System.Web.Routing.RouteData" Usage="routeCollection.GetRouteData httpContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="httpContext" Type="System.Web.HttpContextBase" />
      </Parameters>
      <Docs>
        <param name="httpContext">HTTP 要求に関する情報をカプセル化するオブジェクト。</param>
        <summary>指定した値に一致するコレクション内のルートに関する情報を返します。</summary>
        <returns>ルート定義からの値を含むオブジェクト。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="context" /> パラメーターのオブジェクトの <see cref="P:System.Web.HttpContextBase.Request" /> プロパティが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetVirtualPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ルートと関連付けられている URL パスに関する情報を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetVirtualPath">
      <MemberSignature Language="C#" Value="public System.Web.Routing.VirtualPathData GetVirtualPath (System.Web.Routing.RequestContext requestContext, System.Web.Routing.RouteValueDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.VirtualPathData GetVirtualPath(class System.Web.Routing.RequestContext requestContext, class System.Web.Routing.RouteValueDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetVirtualPath(System.Web.Routing.RequestContext,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::VirtualPathData ^ GetVirtualPath(System::Web::Routing::RequestContext ^ requestContext, System::Web::Routing::RouteValueDictionary ^ values);" />
      <MemberSignature Language="F#" Value="member this.GetVirtualPath : System.Web.Routing.RequestContext * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.VirtualPathData" Usage="routeCollection.GetVirtualPath (requestContext, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.VirtualPathData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestContext" Type="System.Web.Routing.RequestContext" />
        <Parameter Name="values" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="requestContext">要求されたルートに関する情報をカプセル化するオブジェクト。</param>
        <param name="values">ルートのパラメーターを格納するオブジェクト。</param>
        <summary>指定のコンテキストとパラメーター値に基づいて、ルートに関連付けられている URL パスに関する情報を返します。</summary>
        <returns>ルートに関連付けられている URL パスに関する情報を格納するオブジェクト。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVirtualPath">
      <MemberSignature Language="C#" Value="public System.Web.Routing.VirtualPathData GetVirtualPath (System.Web.Routing.RequestContext requestContext, string name, System.Web.Routing.RouteValueDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.VirtualPathData GetVirtualPath(class System.Web.Routing.RequestContext requestContext, string name, class System.Web.Routing.RouteValueDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetVirtualPath(System.Web.Routing.RequestContext,System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::VirtualPathData ^ GetVirtualPath(System::Web::Routing::RequestContext ^ requestContext, System::String ^ name, System::Web::Routing::RouteValueDictionary ^ values);" />
      <MemberSignature Language="F#" Value="member this.GetVirtualPath : System.Web.Routing.RequestContext * string * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.VirtualPathData" Usage="routeCollection.GetVirtualPath (requestContext, name, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.VirtualPathData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestContext" Type="System.Web.Routing.RequestContext" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="values" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="requestContext">要求されたルートに関する情報をカプセル化するオブジェクト。</param>
        <param name="name">URL パスに関する情報を取得するときに使用するルートの名前。</param>
        <param name="values">ルートのパラメーターを格納するオブジェクト。</param>
        <summary>指定したコンテキスト、ルート名、およびパラメーター値の条件下で、名前付きのルートに関連付けられている URL パスに関する情報を返します。</summary>
        <returns>ルートに関連付けられている URL パスに関する情報を格納するオブジェクト。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> パラメーターで指定された名前のルートが見つかりませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetWriteLock">
      <MemberSignature Language="C#" Value="public IDisposable GetWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable GetWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWriteLock () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ GetWriteLock();" />
      <MemberSignature Language="F#" Value="member this.GetWriteLock : unit -&gt; IDisposable" Usage="routeCollection.GetWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コレクション内の要素を追加または削除する場合に、スレッド セーフを管理するためのオブジェクトを提供します。</summary>
        <returns>スレッド セーフを管理するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET アプリケーションのルートを定義するための推奨されるアプローチがへのルートを追加するには、<xref:System.Web.Routing.RouteTable.Routes%2A>のイベント ハンドラーのプロパティ、 `Application_Start` Global.asax ファイル内のイベント。 詳細については、「<xref:System.Web.Routing.RouteCollection>」を参照してください。  
  
 使用するアプリケーションを実行するときにルートを追加した場合、<xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>スレッド セーフを確保する方法。 ルート コレクションの書き込みロックが解放されたときに、<xref:System.IDisposable>このメソッドによって返されるオブジェクトを破棄します。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、<xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>場合に、アプリケーションの実行中にルートを追加する方法。  
  
  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ignore">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ルートの照合を行わない URL パターンを定義します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドにマップされているルートの作成、<xref:System.Web.Routing.StopRoutingHandler>ルート ハンドラー。 このメソッドを呼び出した後の要求をルーティングとして指定した URL パターンに一致する要求は処理されません。  
  
 イメージ ファイルなどの物理ファイルと、URL が一致するときに、要求を無視に自動的に ASP.NET ルーティングします。 場合によっては物理ファイルが存在しない場合は、要求を無視するルーティングもすることがあります。 たとえば、ASP.NET は .axd ファイルに対して自動的に作成される要求扱うことはできませんとして要求をルーティング .axd 拡張子に対応する物理ファイルがない場合でもです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public void Ignore (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Ignore(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Ignore(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Ignore (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Ignore(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Ignore : string -&gt; unit" Usage="routeCollection.Ignore url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">無視する URL パターン。</param>
        <summary>ルートの照合を行わない URL パターンを定義します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドにマップされているルートの作成、<xref:System.Web.Routing.StopRoutingHandler>ルート ハンドラー。 このメソッドを呼び出した後の要求をルーティングとして指定した URL パターンに一致する要求は処理されません。  
  
 イメージ ファイルなどの物理ファイルと、URL が一致するときに、要求を無視に自動的に ASP.NET ルーティングします。 場合によっては物理ファイルが存在しない場合は、要求を無視するルーティングもすることがあります。 たとえば、ASP.NET は .axd ファイルに対して自動的に作成される要求扱うことはできませんとして要求をルーティング .axd 拡張子に対応する物理ファイルがない場合でもです。  
  
   
  
## Examples  
 MVC プロジェクトの既定のテンプレートは、次の例に示すように、.axd ファイル、ルーティングから除外するのにこのメソッドを使用します。  
  
 [!code-csharp[MvcDefaultApp#2](~/samples/snippets/csharp/VS_Snippets_WebNet/mvcdefaultapp/cs/global.asax.cs#2)]
 [!code-vb[MvcDefaultApp#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/mvcdefaultapp/vb/global.asax.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public void Ignore (string url, object constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Ignore(string url, object constraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Ignore(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Ignore (url As String, constraints As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Ignore(System::String ^ url, System::Object ^ constraints);" />
      <MemberSignature Language="F#" Value="member this.Ignore : string * obj -&gt; unit" Usage="routeCollection.Ignore (url, constraints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="constraints" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="url">無視する URL パターン。</param>
        <param name="constraints">URL パターンに一致する要求を無視するかどうかを決定する、追加の抽出条件。</param>
        <summary>要求 URL が指定された制約に一致する場合に、ルートの照合を行わない URL パターンを定義します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドにマップされているルートの作成、<xref:System.Web.Routing.StopRoutingHandler>ルート ハンドラー。 このメソッドを呼び出した後の要求をルーティングとして指定した URL パターンに一致する要求は処理されません。  
  
 イメージ ファイルなどの物理ファイルと、URL が一致するときに、要求を無視に自動的に ASP.NET ルーティングします。 場合によっては物理ファイルが存在しない場合は、要求を無視するルーティングもすることがあります。 たとえば、ASP.NET は .axd ファイルに対して自動的に作成される要求扱うことはできませんとして要求をルーティング .axd 拡張子に対応する物理ファイルがない場合でもです。  
  
   
  
## Examples  
 次の例では、このメソッドを使用して、.aspx 拡張子を持つすべての Url を無視する方法を示します。 拡張子".aspx"を持つファイルのすべての Url を処理するためにカスタム HTTP ハンドラーを登録する場合に実行する場合があります。 すべての .aspx 要求と一致する 1 つの URL パターンは 2 つの汎用パラメーターになどが必要です`{*path}.aspx/{*pathinfo}`します。 (このパターンは、クエリ文字列パラメーターを持つものも含め、.aspx で終了する任意の URL を一致と)ただし、ルーティングを使用すると、最後の 1 の汎用パラメーターが 1 つだけができます。 代わりに、URL パターンを持つすべての Url と一致する 1 つの汎用パラメーターを指定し、次の例に示すように、.aspx 拡張機能がないすべてを除外する制約を指定できます。  
  
```vb  
routes.Ignore("{*allaspx}", new With {.allaspx = ".*\.aspx(/.*)?"})  
```  
  
```csharp  
routes.Ignore("{*allaspx}", new {allaspx=@".*\.aspx(/.*)?"});  
```  
  
 前のコード行から呼び出されるメソッドに通常追加される、`Application_Start`メソッドの例で示すように、Global.asax、<xref:System.Web.Routing.RouteCollection.Ignore%28System.String%29>オーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.InsertItem(System.Int32,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, System::Web::Routing::RouteBase ^ item);" />
      <MemberSignature Language="F#" Value="override this.InsertItem : int * System.Web.Routing.RouteBase -&gt; unit" Usage="routeCollection.InsertItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="index">
          <c>item</c> を挿入する位置の 0 から始まるインデックス。</param>
        <param name="item">挿入するルートです。</param>
        <summary>
          <see cref="T:System.Web.Routing.RouteCollection" /> オブジェクト内の指定したインデックス位置に、指定したルートを挿入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名前のないルートを追加すると、<xref:System.Web.Routing.RouteCollection>オブジェクト、コレクションに既に存在するルートを追加することはできません。  
  
 使用して、<xref:System.Web.Routing.RouteCollection.GetReadLock%2A>メソッドと<xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>メソッドを他のプロセスから競合することがなくコレクションと対話することを確認します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> はコレクション内に既に存在します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteBase this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RouteBase Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(name As String) As RouteBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RouteBase ^ default[System::String ^] { System::Web::Routing::RouteBase ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : System.Web.Routing.RouteBase" Usage="System.Web.Routing.RouteCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するルートを識別する値。</param>
        <summary>指定した名前を持つコレクションのルートを取得します。</summary>
        <value>指定した名前を持つオブジェクト。<paramref name="name" /> が <see langword="null" />、空の文字列、またはコレクション内のいずれのルートとも一致しない名前である場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.Routing.RouteCollection.GetReadLock%2A>メソッドと<xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>メソッドを他のプロセスから競合することがなくコレクションと対話することを確認します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LowercaseUrls">
      <MemberSignature Language="C#" Value="public bool LowercaseUrls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LowercaseUrls" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.LowercaseUrls" />
      <MemberSignature Language="VB.NET" Value="Public Property LowercaseUrls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LowercaseUrls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.LowercaseUrls : bool with get, set" Usage="System.Web.Routing.RouteCollection.LowercaseUrls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>仮想パスが正規化されるときに URL を小文字に変換するかどうかを示す値を取得または設定します。</summary>
        <value>小文字に URL を変換する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL にクエリ文字列が含まれる場合、URL の部分は大文字と小文字に変換されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MapPageRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Web フォーム アプリケーションのルートを定義する手段を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、利便性をコーディングするために提供されます。 呼び出すことと同じである、<xref:System.Web.Routing.RouteCollection.Add%2A>メソッドと受け渡しを<xref:System.Web.Routing.Route>を使用して作成されたオブジェクトに、<xref:System.Web.Routing.PageRouteHandler>クラス。  
  
   
  
## Examples  
 次の例では、このメソッドを使用して、Web フォーム アプリケーションのルートを定義する方法を示します。 例では、という名前のメソッドを示しています。`RegisterRoutes`から呼び出される`Application_Start`Global.asax ファイルにします。 メソッドの各オーバー ロードを使用して<xref:System.Web.Routing.RouteCollection.MapPageRoute%2A>アプリケーションにルートを追加します。 Web フォーム アプリケーションのルートを定義する方法の詳細については、次を参照してください。[方法: Web フォーム アプリケーションの定義のルート](http://msdn.microsoft.com/library/200fe812-d0a6-4531-b9b4-cfc4ee83a678)します。  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#122](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#122)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#122](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#122)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前。</param>
        <param name="routeUrl">ルートの URL パターン。</param>
        <param name="physicalFile">ルートの物理的な URL。</param>
        <summary>Web フォーム アプリケーションのルートを定義する手段を提供します。</summary>
        <returns>ルート コレクションに追加されたルート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、利便性をコーディングするために提供されます。 呼び出すことと同じである、<xref:System.Web.Routing.RouteCollection.Add%2A>メソッドと受け渡しを<xref:System.Web.Routing.Route>を使用して作成されたオブジェクトに、<xref:System.Web.Routing.PageRouteHandler>クラス。  
  
   
  
## Examples  
 次の例では、このメソッドを使用してルートを定義する方法を示します。 最初のステートメントでは、名前がないルートを定義します。 2 番目のステートメントでは、名前付きルートを定義します。 この例が記載されている長い例の一部、<xref:System.Web.Routing.RouteCollection.MapPageRoute%2A>メソッドの概要。  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#140](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#140)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#140](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#140)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前。</param>
        <param name="routeUrl">ルートの URL パターン。</param>
        <param name="physicalFile">ルートの物理的な URL。</param>
        <param name="checkPhysicalUrlAccess">物理的な URL にアクセスするための権限をユーザーが持っていることを ASP.NET で確認するかどうかを示す値 (ルート URL は常にチェックされます)。 このパラメーターは、<see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" /> プロパティを設定します。</param>
        <summary>Web フォーム アプリケーションのルートを定義する手段を提供します。</summary>
        <returns>ルート コレクションに追加されたルート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、利便性をコーディングするために提供されます。 呼び出すことと同じである、<xref:System.Web.Routing.RouteCollection.Add%2A>メソッドと受け渡しを<xref:System.Web.Routing.Route>を使用して作成されたオブジェクトに、<xref:System.Web.Routing.PageRouteHandler>クラス。  
  
   
  
## Examples  
 次の例では、このメソッドを使用してルートを定義する方法を示します。 この例が記載されている長い例の一部、<xref:System.Web.Routing.RouteCollection.MapPageRoute%2A>メソッドの概要。  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#145](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#145)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#145](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#145)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess, defaults)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前。</param>
        <param name="routeUrl">ルートの URL パターン。</param>
        <param name="physicalFile">ルートの物理的な URL。</param>
        <param name="checkPhysicalUrlAccess">物理的な URL にアクセスするための権限をユーザーが持っていることを ASP.NET で確認するかどうかを示す値 (ルート URL は常にチェックされます)。 このパラメーターは、<see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" /> プロパティを設定します。</param>
        <param name="defaults">ルート パラメーターの既定値。</param>
        <summary>Web フォーム アプリケーションのルートを定義する手段を提供します。</summary>
        <returns>ルート コレクションに追加されたルート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、利便性をコーディングするために提供されます。 呼び出すことと同じである、<xref:System.Web.Routing.RouteCollection.Add%2A>メソッドと受け渡しを<xref:System.Web.Routing.Route>を使用して作成されたオブジェクトに、<xref:System.Web.Routing.PageRouteHandler>クラス。  
  
   
  
## Examples  
 次の例では、このメソッドを使用してルートを定義する方法を示します。 この例が記載されている長い例の一部、<xref:System.Web.Routing.RouteCollection.MapPageRoute%2A>メソッドの概要。  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#150](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#150)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#150](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#150)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults, System.Web.Routing.RouteValueDictionary constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults, class System.Web.Routing.RouteValueDictionary constraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary, constraints As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults, System::Web::Routing::RouteValueDictionary ^ constraints);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool * System.Web.Routing.RouteValueDictionary * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess, defaults, constraints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="constraints" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前。</param>
        <param name="routeUrl">ルートの URL パターン。</param>
        <param name="physicalFile">ルートの物理的な URL。</param>
        <param name="checkPhysicalUrlAccess">物理的な URL にアクセスするための権限をユーザーが持っていることを ASP.NET で確認するかどうかを示す値 (ルート URL は常にチェックされます)。 このパラメーターは、<see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" /> プロパティを設定します。</param>
        <param name="defaults">ルートの既定値。</param>
        <param name="constraints">このルートとして処理されるために URL 要求で満たす必要がある制約。</param>
        <summary>Web フォーム アプリケーションのルートを定義する手段を提供します。</summary>
        <returns>ルート コレクションに追加されたルート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、利便性をコーディングするために提供されます。 呼び出すことと同じである、<xref:System.Web.Routing.RouteCollection.Add%2A>メソッドと受け渡しを<xref:System.Web.Routing.Route>を使用して作成されたオブジェクトに、<xref:System.Web.Routing.PageRouteHandler>クラス。  
  
   
  
## Examples  
 次の例では、このメソッドを使用してルートを定義する方法を示します。 この例が記載されている長い例の一部、<xref:System.Web.Routing.RouteCollection.MapPageRoute%2A>メソッドの概要。  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#155](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#155)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#155](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#155)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults, System.Web.Routing.RouteValueDictionary constraints, System.Web.Routing.RouteValueDictionary dataTokens);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults, class System.Web.Routing.RouteValueDictionary constraints, class System.Web.Routing.RouteValueDictionary dataTokens) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary, constraints As RouteValueDictionary, dataTokens As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults, System::Web::Routing::RouteValueDictionary ^ constraints, System::Web::Routing::RouteValueDictionary ^ dataTokens);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool * System.Web.Routing.RouteValueDictionary * System.Web.Routing.RouteValueDictionary * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess, defaults, constraints, dataTokens)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="constraints" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="dataTokens" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前。</param>
        <param name="routeUrl">ルートの URL パターン。</param>
        <param name="physicalFile">ルートの物理的な URL。</param>
        <param name="checkPhysicalUrlAccess">物理的な URL にアクセスするための権限をユーザーが持っていることを ASP.NET で確認するかどうかを示す値 (ルート URL は常にチェックされます)。 このパラメーターは、<see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" /> プロパティを設定します。</param>
        <param name="defaults">ルート パラメーターの既定値。</param>
        <param name="constraints">このルートとして処理されるために URL 要求で満たす必要がある制約。</param>
        <param name="dataTokens">ルートに関連付けられているが、ルートが URL パターンに一致するかどうかの判定には使用されない値。</param>
        <summary>Web フォーム アプリケーションのルートを定義する手段を提供します。</summary>
        <returns>ルート コレクションに追加されたルート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、利便性をコーディングするために提供されます。 呼び出すことと同じである、<xref:System.Web.Routing.RouteCollection.Add%2A>メソッドと受け渡しを<xref:System.Web.Routing.Route>を使用して作成されたオブジェクトに、<xref:System.Web.Routing.PageRouteHandler>クラス。  
  
   
  
## Examples  
 次の例では、このメソッドを使用してルートを定義する方法を示します。 この例が記載されている長い例の一部、<xref:System.Web.Routing.RouteCollection.MapPageRoute%2A>メソッドの概要。  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#160](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#160)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#160](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#160)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="routeUrl" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberSignature Language="F#" Value="override this.RemoveItem : int -&gt; unit" Usage="routeCollection.RemoveItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">削除するルートの 0 から始まるインデックス。</param>
        <summary>
          <see cref="T:System.Web.Routing.RouteCollection" /> オブジェクトから指定したインデックス位置にあるルートを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.Routing.RouteCollection.GetReadLock%2A>メソッドと<xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>メソッドを他のプロセスから競合することがなくコレクションと対話することを確認します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RouteExistingFiles">
      <MemberSignature Language="C#" Value="public bool RouteExistingFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RouteExistingFiles" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.RouteExistingFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property RouteExistingFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RouteExistingFiles { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RouteExistingFiles : bool with get, set" Usage="System.Web.Routing.RouteCollection.RouteExistingFiles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既存のファイルと一致する URL を ASP.NET ルーティングが処理するかどうかを示す値を取得または設定します。</summary>
        <value>ASP.NET ルーティングで、既存のファイルと一致する要求も含めすべての要求を処理する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この値を動的に変更することができます、ASP.NET ルーティングの統合を使用する場合、サービスがアクティブになった後に加えた変更は無視されます。 詳細については、次を参照してください。 [ASP.NET ルーティング統合](http://go.microsoft.com/fwlink/?LinkId=195235)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.SetItem(System.Int32,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, System::Web::Routing::RouteBase ^ item);" />
      <MemberSignature Language="F#" Value="override this.SetItem : int * System.Web.Routing.RouteBase -&gt; unit" Usage="routeCollection.SetItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="index">置き換えるルートの 0 から始まるインデックス番号。</param>
        <param name="item">指定したインデックス位置に追加するルート。</param>
        <summary>指定したインデックス位置にあるルートを置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名前のないルートを追加すると、<xref:System.Web.Routing.RouteCollection>オブジェクト、コレクションに既に存在するルートを追加することはできません。  
  
 使用して、<xref:System.Web.Routing.RouteCollection.GetReadLock%2A>メソッドと<xref:System.Web.Routing.RouteCollection.GetWriteLock%2A>メソッドを他のプロセスから競合することがなくコレクションと対話することを確認します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> はコレクション内に既に存在します。</exception>
      </Docs>
    </Member>
  </Members>
</Type>