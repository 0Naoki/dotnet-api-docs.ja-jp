<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c3cea7cb79bd35bfc3544b467a76a8ca2a8133cd" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48649474" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Messaging.MessagingDescription("MessageQueueDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>メッセージ キュー サーバーのキューにアクセスできるようにします。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ キュー技術は、異種ネットワークおよびが一時的にオフラインであるシステム間で通信するためには、さまざまなタイミングで実行されているアプリケーションを使用できます。 アプリケーションは、送信、受信、またはキューからメッセージを (削除せずに読み取る)。 メッセージ キューのオプションのコンポーネントは、[!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)]と Windows NT では、個別にインストールする必要があります。  
  
 <xref:System.Messaging.MessageQueue>クラスはメッセージ キューのラッパーです。 メッセージ キュー、および使用する複数のバージョンがある、<xref:System.Messaging.MessageQueue>クラスは、若干異なる動作になることができます、オペレーティング システムに応じて使用しています。 メッセージ キューの各バージョンの特定の機能については、MSDN のプラットフォーム SDK の「新メッセージ キューで」トピックを参照してください。  
  
 <xref:System.Messaging.MessageQueue>クラスには、メッセージ キューのキューへの参照が用意されています。 パスを指定することができます、<xref:System.Messaging.MessageQueue.%23ctor%2A>するか、既存のリソースに接続するコンス トラクターは、サーバーで新しいキューを作成することができます。 呼び出すには<xref:System.Messaging.MessageQueue.Send%28System.Object%29>、 <xref:System.Messaging.MessageQueue.Peek%2A>、または<xref:System.Messaging.MessageQueue.Receive%2A>の新しいインスタンスを関連付ける必要があります、<xref:System.Messaging.MessageQueue>既存のキューを使用してクラス。 キューのプロパティなどを操作する時点で、<xref:System.Messaging.MessageQueue.Category%2A>と<xref:System.Messaging.MessageQueue.Label%2A>します。  
  
 <xref:System.Messaging.MessageQueue> 2 種類のメッセージの取得をサポートしています。 同期および非同期です。 同期メソッド、<xref:System.Messaging.MessageQueue.Peek%2A>と<xref:System.Messaging.MessageQueue.Receive%2A>、プロセス スレッドを新しいメッセージがキューに到達する指定した時間間隔の待機が発生します。 非同期のメソッドでは、<xref:System.Messaging.MessageQueue.BeginPeek%2A>と<xref:System.Messaging.MessageQueue.BeginReceive%2A>、メイン アプリケーション タスクをキューにメッセージが到着するまで、別のスレッドで続行します。 これらのメソッドは、スレッド間で情報を通信するために、コールバックおよび状態オブジェクトを使用して動作します。  
  
 新しいインスタンスを作成するときに、<xref:System.Messaging.MessageQueue>クラスでは、新しいメッセージ キューのキューを作成しません。 代わりに、使用、 <xref:System.Messaging.MessageQueue.Create%28System.String%29>、 <xref:System.Messaging.MessageQueue.Delete%28System.String%29>、および<xref:System.Messaging.MessageQueue.Purge%2A>サーバー上のキューを管理するメソッド。  
  
 異なり<xref:System.Messaging.MessageQueue.Purge%2A>、<xref:System.Messaging.MessageQueue.Create%28System.String%29>と<xref:System.Messaging.MessageQueue.Delete%28System.String%29>は`static`の新しいインスタンスを作成せずに呼び出しが可能であるため、メンバー、<xref:System.Messaging.MessageQueue>クラス。  
  
 設定することができます、<xref:System.Messaging.MessageQueue>オブジェクトの<xref:System.Messaging.MessageQueue.Path%2A>3 つの名前のいずれかのプロパティ: のフレンドリ名、 <xref:System.Messaging.MessageQueue.FormatName%2A>、または<xref:System.Messaging.MessageQueue.Label%2A>します。 キューのによって定義されるフレンドリ名、<xref:System.Messaging.MessageQueue.MachineName%2A>と<xref:System.Messaging.MessageQueue.QueueName%2A>プロパティは<xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A>パブリック キューの場合と<xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A>の専用キュー。 <xref:System.Messaging.MessageQueue.FormatName%2A>プロパティは、メッセージ キューへのオフライン アクセスを許可します。 最後に、キューを使用することができます<xref:System.Messaging.MessageQueue.Label%2A>プロパティを設定、キューの<xref:System.Messaging.MessageQueue.Path%2A>します。  
  
 インスタンスの初期プロパティ値の一覧については<xref:System.Messaging.MessageQueue>を参照してください、<xref:System.Messaging.MessageQueue.%23ctor%2A>コンス トラクター。  
  
   
  
## Examples  
 次のコード例を新規作成<xref:System.Messaging.MessageQueue>さまざまなパス名の構文型を使用するオブジェクトします。 各ケースでは、パスを持つが、コンス トラクターで定義されているキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 次のコード例は、キューにメッセージを送信しと呼ばれるアプリケーション固有のクラスを使用して、キューからメッセージを受信`Order`します。  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>のみ、<see cref="M:System.Messaging.MessageQueue.GetAllMessages" />メソッドはスレッド セーフであります。</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。 既定のコンストラクターが新しいインスタンスを初期化した後、そのインスタンスを使用する前にインスタンスの <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティを設定する必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して、新しいインスタンスを作成する、<xref:System.Messaging.MessageQueue>すぐにメッセージ キュー サーバー上のキューに関連付けられていないクラス。 このインスタンスを使用する前にする必要がありますに接続する既存のメッセージ キューのキューを設定して、<xref:System.Messaging.MessageQueue.Path%2A>プロパティ。 また、設定、<xref:System.Messaging.MessageQueue>への参照、<xref:System.Messaging.MessageQueue.Create%28System.String%29>メソッドの戻り値、新しいメッセージ キューのキューが作成されます。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>コンス トラクターの新しいインスタンスをインスタンス化、 <xref:System.Messaging.MessageQueue> ; クラスの新しいメッセージ キューのキューは作成されません。  
  
 次の表のインスタンスの初期プロパティ値<xref:System.Messaging.MessageQueue>します。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|既定のコンス トラクターによって設定された値、<xref:System.Messaging.DefaultPropertiesToSend>クラス。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|既定のコンス トラクターによって設定された値、<xref:System.Messaging.MessagePropertyFilter>クラス。 すべてのフィルター値に設定されます`true`します。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 次のコード例を作成する新しい<xref:System.Messaging.MessageQueue>します。  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューの場所。</param>
        <summary>指定したパスのメッセージ キューのキューを参照する <see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しいリンク付けするときに、このオーバー ロードを使用して<xref:System.Messaging.MessageQueue>特定メッセージ キューのキュー、パス、形式名、またはラベルを識別する対象のインスタンス。 キューを参照する最初のアプリケーションへの排他アクセスを許可する場合は、設定する必要があります、<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>プロパティを`true`または読み取りアクセスの制限パラメーターを渡すコンス トラクターを使用します。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>コンス トラクターの新しいインスタンスをインスタンス化、 <xref:System.Messaging.MessageQueue> ; クラスの新しいメッセージ キューのキューは作成されません。 メッセージ キューで新しいキューを作成するには使用<xref:System.Messaging.MessageQueue.Create%28System.String%29>します。  
  
 構文、`path`パラメーターに依存するキューの種類、参照、次の表に示すようにします。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
|コンピューター ジャーナル キュー|`MachineName`\\`Journal$`|  
|コンピューター配信不能キュー|`MachineName`\\`Deadletter$`|  
|コンピューター トランザクション配信不能キュー|`MachineName`\\`XactDeadletter$`|  
  
 また、使用することができます、<xref:System.Messaging.MessageQueue.FormatName%2A>または<xref:System.Messaging.MessageQueue.Label%2A>に次の表に示すように、キューのパスを記述します。  
  
|参照|構文|例|  
|---------------|------------|-------------|  
|形式名|`FormatName:` [*形式名*]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|group1|`Label:` [*ラベル*]|`Label:` とき|  
  
 オフラインで作業するには、コンス トラクターのパス名の構文しない形式名の構文を使用する必要があります。 それ以外の場合、プライマリ ドメイン コント ローラーが形式の名前に、パスを解決するのには使用できないため、例外がスローされます。  
  
 次の表のインスタンスの初期プロパティ値<xref:System.Messaging.MessageQueue>します。 これらの値は、メッセージ キューのキューのプロパティで指定したパスに基づいて、`path`パラメーター。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|既定のコンス トラクターによって設定された値、<xref:System.Messaging.DefaultPropertiesToSend>クラス。|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`、メッセージ キューのキューのプライバシー レベル設定が"Body"; 場合それ以外の場合、`false`します。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|メッセージ キューのキューのコンピューター名プロパティの値。|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|既定のコンス トラクターによって設定された値、<xref:System.Messaging.MessagePropertyFilter>クラス。|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>、コンス トラクターで設定されていない場合。|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>、コンス トラクターで設定されていない場合。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`、は、メッセージ キュー オブジェクトの履歴の設定が有効な場合それ以外の場合、`false`します。|  
  
   
  
## Examples  
 次のコード例を新規作成<xref:System.Messaging.MessageQueue>さまざまなパス名の構文型を使用するオブジェクトします。 各ケースでは、パスを持つが、コンス トラクターで定義されているキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが無効です。プロパティが設定されていないためと考えられます。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューの場所。ローカル コンピューターの場合は "." にできます。</param>
        <param name="sharedModeDenyReceive">キューにアクセスする最初のアプリケーションに排他読み取りアクセス許可を与える場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した読み取りアクセス制限を持つ指定したパスのメッセージ キューのキューを参照する <see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しいリンク付けするときに、このオーバー ロードを使用して<xref:System.Messaging.MessageQueue>特定メッセージ キューのキュー、パス、形式名、またはラベルを識別するのにします。 キューを参照する最初のアプリケーションへの排他アクセスを許可する場合は、設定、`sharedModeDenyReceive`パラメーター`true`します。 それ以外の場合、設定`sharedModeDenyReceive`に`false`のみを持つコンス トラクターを使用して、または、`path`パラメーター。  
  
 設定`sharedModeDenyReceive`に`true`他のアプリケーションなど、メッセージ キューのキューにアクセスするすべてのオブジェクトに影響を与えます。 パラメーターの効果では、このアプリケーションに限定されません。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>コンス トラクターの新しいインスタンスを作成し、<xref:System.Messaging.MessageQueue>クラスです。 新しいメッセージ キューのキューは作成されません。 メッセージ キューで新しいキューを作成するには使用<xref:System.Messaging.MessageQueue.Create%28System.String%29>します。  
  
 構文、`path`パラメーターは、キューの種類によって異なります。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
|コンピューター ジャーナル キュー|`MachineName`\\`Journal$`|  
|コンピューター配信不能キュー|`MachineName`\\`Deadletter$`|  
|コンピューター トランザクション配信不能キュー|`MachineName`\\`XactDeadletter$`|  
  
 または、キューのパスを記述するのに形式の名前またはメッセージ キューのキューのラベルを使用することができます。  
  
|参照|構文|例|  
|---------------|------------|-------------|  
|形式名|`FormatName:` [*形式名*]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|group1|`Label:` [*ラベル*]|`Label:` とき|  
  
 オフラインで作業するには、フレンドリ名の構文ではなく、形式名の構文を使用する必要があります。 それ以外の場合、(Active Directory が存在する)、プライマリ ドメイン コント ローラーが形式の名前に、パスを解決するのには使用できないため、例外がスローされます。  
  
 場合、<xref:System.Messaging.MessageQueue>でキューを開く、`sharedModeDenyReceive`パラメーターに設定`true`、<xref:System.Messaging.MessageQueue>生成する、その後、キューからの読み取りを試みます、<xref:System.Messaging.MessageQueueException>共有違反が原因です。 A<xref:System.Messaging.MessageQueueException>場合にスローされることも、<xref:System.Messaging.MessageQueue>ときに、別の排他モードでキューにアクセスしようとしています。<xref:System.Messaging.MessageQueue>既にキューに非排他的なアクセス。  
  
 次の表のインスタンスの初期プロパティ値<xref:System.Messaging.MessageQueue>します。 これらの値は、メッセージ キューのキューのプロパティで指定したパスに基づいて、`path`パラメーター。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`。|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>。|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|既定のコンス トラクターによって設定された値、<xref:System.Messaging.DefaultPropertiesToSend>クラス。|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`、メッセージ キューのキューのプライバシー レベル設定が"Body"; 場合それ以外の場合、`false`します。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>。|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>。|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|メッセージ キューのキューのコンピューター名プロパティの値。|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>。|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>。|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|既定のコンス トラクターによって設定された値、<xref:System.Messaging.MessagePropertyFilter>クラス。|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>、コンス トラクターで設定されていない場合。|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>、コンス トラクターで設定されていない場合。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`sharedModeDenyReceive` パラメーターの値。|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`、は、メッセージ キュー オブジェクトの履歴の設定が有効な場合それ以外の場合、`false`します。|  
  
   
  
## Examples  
 次のコード例を作成する新しい<xref:System.Messaging.MessageQueue>、排他アクセス権を持つ、そのパスを設定し、キューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが無効です。プロパティが設定されていないためと考えられます。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューの場所。ローカル コンピューターの場合は "." にできます。</param>
        <param name="accessMode">
          <see cref="T:System.Messaging.QueueAccessMode" /> 値のいずれか 1 つ。</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューの場所。ローカル コンピューターの場合は "." にできます。</param>
        <param name="sharedModeDenyReceive">キューにアクセスする最初のアプリケーションに排他読み取りアクセス許可を与える場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="enableCache">接続キャッシュを作成し、使用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例を作成する新しい<xref:System.Messaging.MessageQueue>排他的読み取りアクセスと接続キャッシュを有効にします。  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューの場所。ローカル コンピューターの場合は "." にできます。</param>
        <param name="sharedModeDenyReceive">キューにアクセスする最初のアプリケーションに排他読み取りアクセス許可を与える場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="enableCache">接続キャッシュを作成し、使用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="accessMode">
          <see cref="T:System.Messaging.QueueAccessMode" /> 値のいずれか 1 つ。</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューのアクセス モードを示す値を取得します。</summary>
        <value>
          <see cref="T:System.Messaging.QueueAccessMode" /> 値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューの既定のアクセス モードは`QueueAccessMode.SendAndReceive`コンス トラクターを呼び出すときにそれ以外の場合を指定しない限り、します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューが認証済みメッセージだけを受け入れるかどうかを示す値を取得または設定します。</summary>
        <value>キューが認証済みメッセージだけを受け入れる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージの認証は、メッセージの整合性を確保し、メッセージの送信者を確認する方法を提供します。 認証を要求するには、送信元アプリケーションは、メッセージの認証レベルを設定します。  
  
 設定すると<xref:System.Messaging.MessageQueue.Authenticate%2A>に`true`を制限するだけでなく、サーバー上のキューへのアクセス<xref:System.Messaging.MessageQueue>インスタンス。 同じメッセージ キューのキューに対して作業を行うすべてのクライアントに影響があります。  
  
 認証済みメッセージだけを受け入れるキューでは、認証されていないメッセージを拒否します。 メッセージが拒否通知を要求するには、送信元アプリケーションを設定できます、<xref:System.Messaging.Message.AcknowledgeType%2A>メッセージのプロパティ。 他のメッセージが拒否を示す値が存在しないので、送信元アプリケーションはそれが配信不能キューに送信することを要求しない限り、メッセージを失うことができます。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.Authenticate%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ネットワーク上でパブリック キューのメッセージを送信するためにメッセージ キューが使用する基本優先順位を取得または設定します。</summary>
        <value>パブリック キューに送信されるすべてのメッセージに適用される単一の基本優先順位。 既定値は 0 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ キューの基本優先順位は、メッセージを転送する方法、ネットワークを介してやり取りする際にキューを処理するを指定します。 設定することができます、<xref:System.Messaging.MessageQueue.BasePriority%2A>プロパティを他のキューに送信されるよりも、指定されたキューに送信されるすべてのメッセージを高いまたは低い優先度を確保します。 このプロパティの設定には、メッセージ キューのキューが変更されます。 そのため、他<xref:System.Messaging.MessageQueue>インスタンスは、変更を受けます。  
  
 メッセージ キューの<xref:System.Messaging.MessageQueue.BasePriority%2A>に関係のない、<xref:System.Messaging.Message.Priority%2A>メッセージは、受信メッセージがキューに置かれている順序を指定します。  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> 形式名を使用してあるパスが指定されたパブリックのみにキューに適用されます。 プライベート キューの基本優先順位がゼロ (0) では常にします。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.BasePriority%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">基本優先順位に無効な値が設定されています。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <summary>メッセージのピークを開始し、完了したときにイベント ハンドラーに通知するようにメッセージ キューに指示して、非同期のピーク操作を実行します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>タイムアウトのない非同期のピーク操作を実行します。操作は、キューのメッセージが利用可能になるまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用する非同期処理で<xref:System.Messaging.MessageQueue.BeginPeek%2A>させる、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント メッセージは、キューで使用可能になったとき。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 使用する<xref:System.Messaging.MessageQueue.BeginPeek%2A>、非同期の操作の結果を処理するイベント ハンドラーを作成し、イベントのデリゲートを関連付けます。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 非同期のピーク操作を開始します。<xref:System.Messaging.MessageQueue>通知の発生を通じて、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント、メッセージがキューに到着したとき。 <xref:System.Messaging.MessageQueue>呼び出すことによって、メッセージにアクセスできます<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>またはを使用して結果を取得することによって、<xref:System.Messaging.PeekCompletedEventArgs>します。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>メソッドを即座に返しますが、非同期操作では、イベント ハンドラーが呼び出されるまでを完了していません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>は非同期で呼び出すことができますを現在の実行スレッドをブロックすることがなく、キューをピークします。 同期的に、キューをピークを使用して、<xref:System.Messaging.MessageQueue.Peek%2A>メソッド。  
  
 非同期操作が完了すると、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.IAsyncResult>を<xref:System.Messaging.MessageQueue.BeginPeek%2A>返しますが、メソッドを開始した非同期操作を識別します。 これを使用することができます<xref:System.IAsyncResult>、操作の有効期間全体で通常使用しないことまでは<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>が呼び出されます。 ただし、いくつかの非同期操作を開始した場合は配置する、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作が完了するまで待機するかどうかを指定します。 この場合、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>完了した操作を識別するためにします。  
  
 場合<xref:System.Messaging.MessageQueue.CanRead%2A>は`false`完了イベントが発生しますが、呼び出し時に例外がスローされます、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、名前付きイベント ハンドラーを作成します。 `MyPeekCompleted`、にアタッチします、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント ハンドラーのデリゲート、および呼び出し<xref:System.Messaging.MessageQueue.BeginPeek%2A>パスにあるキューで非同期のピーク操作を開始する"。 \myQueue"。 ときに、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントは、例では、メッセージをピークし、画面に、本文を書き込みます。 例を呼び出して<xref:System.Messaging.MessageQueue.BeginPeek%2A>新しい非同期のピーク操作を開始するには、もう一度です。  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">メッセージを使用できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <summary>指定したタイムアウトのある非同期のピーク操作を実行します。この操作は、メッセージをキューで使用できるようになるか、タイムアウトが発生するまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用する非同期処理で<xref:System.Messaging.MessageQueue.BeginPeek%2A>させる、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント、メッセージがキューまたは指定した期間の有効期限が切れたときに使用できるようになる場合。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 使用する<xref:System.Messaging.MessageQueue.BeginPeek%2A>、非同期の操作の結果を処理するイベント ハンドラーを作成し、イベントのデリゲートを関連付けます。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 非同期のピーク操作を開始します。<xref:System.Messaging.MessageQueue>通知の発生を通じて、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント、メッセージがキューに到着したとき。 <xref:System.Messaging.MessageQueue>呼び出すことによって、メッセージにアクセスできます<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>またはを使用して結果を取得することによって、<xref:System.Messaging.PeekCompletedEventArgs>します。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>メソッドを即座に返しますが、非同期操作では、イベント ハンドラーが呼び出されるまでを完了していません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>は非同期で呼び出すことができますを現在の実行スレッドをブロックすることがなく、キューをピークします。 同期的に、キューをピークを使用して、<xref:System.Messaging.MessageQueue.Peek%2A>メソッド。  
  
 非同期操作が完了すると、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.IAsyncResult>を<xref:System.Messaging.MessageQueue.BeginPeek%2A>返しますが、メソッドを開始した非同期操作を識別します。 これを使用することができます<xref:System.IAsyncResult>、操作の有効期間全体で通常使用しないことまでは<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>が呼び出されます。 ただし、いくつかの非同期操作を開始した場合は配置する、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作が完了するまで待機するかどうかを指定します。 この場合、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>完了した操作を識別するためにします。  
  
 このオーバー ロードでは、タイムアウトを指定します。間隔が指定されている場合、`timeout`パラメーターの有効期限が切れる、このコンポーネントが発生、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント。 メッセージが存在しないため、後続の呼び出し<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>例外がスローされます。  
  
 場合<xref:System.Messaging.MessageQueue.CanRead%2A>は`false`完了イベントが発生しますが、呼び出し時に例外がスローされます、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、キューのパスを使用して、非同期のピーク操作を作成します。"。 \myQueue"。 イベント ハンドラーを作成します`MyPeekCompleted`にアタッチします、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント ハンドラーのデリゲート。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 非同期のピーク操作を開始する 1 分のタイムアウトで呼び出されます。 ときに、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントが発生しますまたは、タイムアウトになると、1 つが存在し、その本文が画面に書き込まれる場合、メッセージを取得します。 <xref:System.Messaging.MessageQueue.BeginPeek%2A>同じタイムアウトと新しい非同期のピーク操作を開始する再び呼び出されます。  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定された値が無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">メッセージを使用できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="stateObject">非同期操作に関連付けられている情報を保持する状態オブジェクト。アプリケーションで指定します。</param>
        <summary>指定したタイムアウトと指定した状態オブジェクトを持つ非同期のピーク操作を実行します。状態オブジェクトは、操作の有効期間を通じて関連付けられた情報を提供します。 この操作は、メッセージをキューで使用できるようになるか、タイムアウトが発生するまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用する非同期処理で<xref:System.Messaging.MessageQueue.BeginPeek%2A>させる、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント、メッセージがキューまたは指定した期間の有効期限が切れたときに使用できるようになる場合。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 このオーバー ロードを使用して、操作の有効期間全体にわたって保持するがある操作と情報を関連付けます。 イベント ハンドラーを見てこの情報にアクセスできる、<xref:System.IAsyncResult.AsyncState%2A>のプロパティ、<xref:System.IAsyncResult>操作に関連付けられています。  
  
 使用する<xref:System.Messaging.MessageQueue.BeginPeek%2A>、非同期の操作の結果を処理するイベント ハンドラーを作成し、イベントのデリゲートを関連付けます。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 非同期のピーク操作を開始します。<xref:System.Messaging.MessageQueue>通知の発生を通じて、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント、メッセージがキューに到着したとき。 <xref:System.Messaging.MessageQueue>呼び出すことによって、メッセージにアクセスできます<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>またはを使用して結果を取得することによって、<xref:System.Messaging.PeekCompletedEventArgs>します。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>メソッドを即座に返しますが、非同期操作では、イベント ハンドラーが呼び出されるまでを完了していません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>は非同期で呼び出すことができますを現在の実行スレッドをブロックすることがなく、キューをピークします。 同期的に、キューをピークを使用して、<xref:System.Messaging.MessageQueue.Peek%2A>メソッド。  
  
 非同期操作が完了すると、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 返します、<xref:System.IAsyncResult>メソッドを開始した非同期操作を識別します。 これを使用することができます<xref:System.IAsyncResult>、操作の有効期間全体で通常使用しないことまでは<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>が呼び出されます。 ただし、いくつかの非同期操作を開始した場合は配置する、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作が完了するまで待機するかどうかを指定します。 この場合、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>完了した操作を識別するためにします。  
  
 このオーバー ロードでは、タイムアウトと状態オブジェクトを指定します。 間隔が指定されている場合、`timeout`パラメーターの有効期限が切れる、このコンポーネントが発生、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント。 メッセージが存在しないため、後続の呼び出し<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>例外がスローされます。  
  
 状態オブジェクトは、状態情報を操作に関連付けます。 呼び出す場合など、<xref:System.Messaging.MessageQueue.BeginPeek%2A>複数の操作の開始を複数回、各操作を定義する別の状態オブジェクトを識別できます。 このシナリオの図解は、「使用例」を参照してください。  
  
 プロセス スレッドを越えて情報を渡す状態オブジェクトを使用することもできます。 場合は、スレッドの開始、コールバックが非同期のシナリオで別のスレッドで、状態オブジェクトがマーシャ リングし、イベントからの情報と共に返されます。  
  
 場合<xref:System.Messaging.MessageQueue.CanRead%2A>は`false`完了イベントが発生しますが、呼び出し時に例外がスローされます、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、キューのパスを使用して、非同期のピーク操作を作成します。"。 \myQueue"。 イベント ハンドラーを作成します`MyPeekCompleted`にアタッチします、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント ハンドラーのデリゲート。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 呼び出されると、1 分のタイムアウト。 呼び出しごとに<xref:System.Messaging.MessageQueue.BeginPeek%2A>がその特定の操作を識別する一意の関連付けられている整数。 ときに、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントが発生したか、タイムアウトの期限が切れたメッセージが存在する場合が取得され、その本文と操作に固有の整数識別子は、画面に書き込まれます。 <xref:System.Messaging.MessageQueue.BeginPeek%2A>同じタイムアウトと、関連付けられている整数だけ完了した操作の新しい非同期のピーク操作を開始する再び呼び出されます。  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定された値が無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">メッセージを使用できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="stateObject">非同期操作に関連付けられている情報を保持する状態オブジェクト。アプリケーションで指定します。</param>
        <param name="callback">非同期操作の完了通知を受信する <see cref="T:System.AsyncCallback" />。</param>
        <summary>指定したタイムアウトと指定した状態オブジェクトを持つ非同期のピーク操作を実行します。状態オブジェクトは、操作の有効期間を通じて関連付けられた情報を提供します。 このオーバーロードは、コールバックを通じて操作のイベント ハンドラー ID の通知を受信します。 この操作は、メッセージをキューで使用できるようになるか、タイムアウトが発生するまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コールバック パラメーターで指定されたコールバックが、メッセージがキューまたは指定した期間が切れたときに使用できるようになるときに直接呼び出されるこのオーバー ロードを使用する場合<xref:System.Messaging.MessageQueue.PeekCompleted>イベントは発生しません。 その他のオーバー ロード<xref:System.Messaging.MessageQueue.BeginPeek%2A>させるには、このコンポーネントに依存、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>メソッドを即座に返しますが、非同期操作では、イベント ハンドラーが呼び出されるまでを完了していません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>は非同期で呼び出すことができますを現在の実行スレッドをブロックすることがなく、キューをピークします。 同期的に、キューをピークを使用して、<xref:System.Messaging.MessageQueue.Peek%2A>メソッド。  
  
 非同期操作が完了すると、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 返します、<xref:System.IAsyncResult>メソッドを開始した非同期操作を識別します。 これを使用することができます<xref:System.IAsyncResult>、操作の有効期間全体で通常使用しないことまでは<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>が呼び出されます。 ただし、いくつかの非同期操作を開始した場合は配置する、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作が完了するまで待機するかどうかを指定します。 この場合、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>完了した操作を識別するためにします。  
  
 状態オブジェクトは、状態情報を操作に関連付けます。 呼び出す場合など、<xref:System.Messaging.MessageQueue.BeginPeek%2A>複数の操作の開始を複数回、各操作を定義する別の状態オブジェクトを識別できます。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、非同期のピーク操作を作成します。 ローカルのメッセージ キューにメッセージをコードの例の送信を呼び出して<xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>で渡し: 10 秒のタイムアウト値はその特定のメッセージとの新しいインスタンスを識別する一意の整数<xref:System.AsyncCallback>イベント ハンドラーを識別する`MyPeekCompleted`. ときに、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントが発生した場合、イベント ハンドラーは、メッセージをピークします。 画面にメッセージ本文とメッセージの整数識別子を書き込みます。  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定された値が無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">メッセージを使用できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="cursor">メッセージ キュー内の特定の位置を維持する <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="action">
          <see cref="T:System.Messaging.PeekAction" /> 値のいずれか 1 つ。 キュー内の現在のメッセージと次のメッセージのどちらをピークするかを示します。</param>
        <param name="state">非同期操作に関連付けられている情報を保持する状態オブジェクト。アプリケーションで指定します。</param>
        <param name="callback">非同期操作の完了通知を受信する <see cref="T:System.AsyncCallback" />。</param>
        <summary>指定したタイムアウトがあり、指定したカーソル、ピーク処理、および状態オブジェクトを使用する非同期のピーク操作を実行します。 状態オブジェクトは、操作の有効期間を通じて、関連付けられた情報を提供します。 このオーバーロードは、コールバックを通じて操作のイベント ハンドラー ID の通知を受信します。 この操作は、メッセージをキューで使用できるようになるか、タイムアウトが発生するまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、コールバック パラメーターで指定されたコールバックが呼び出されます直接メッセージはキューまたは指定した期間の有効期限が切れたときに使用できなくなります。 <xref:System.Messaging.MessageQueue.PeekCompleted>イベントは発生しません。 その他のオーバー ロード<xref:System.Messaging.MessageQueue.BeginPeek%2A>させるには、このコンポーネントに依存、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>メソッドを即座に返しますが、非同期操作では、イベント ハンドラーが呼び出されるまでを完了していません。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>は非同期で呼び出すことができますを現在の実行スレッドをブロックすることがなく、キューをピークします。 同期的に、キューをピークを使用して、<xref:System.Messaging.MessageQueue.Peek%2A>メソッド。  
  
 非同期操作が完了すると、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 返します、<xref:System.IAsyncResult>メソッドによって開始された非同期操作を識別します。 これを使用することができます<xref:System.IAsyncResult>、操作の有効期間全体で通常使用しないことまでは<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>が呼び出されます。 ただし、いくつかの非同期操作を開始した場合は配置する、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作が完了するまで待機するかどうかを指定します。 ここでは、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>完了した操作を識別するためにします。  
  
 状態オブジェクトは、状態情報を操作に関連付けます。 呼び出す場合など、<xref:System.Messaging.MessageQueue.BeginPeek%2A>複数の操作の開始を複数回、各操作を定義する別の状態オブジェクトを識別できます。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="action" /> パラメーターに <see langword="PeekAction.Current" /> または <see langword="PeekAction.Next" /> 以外の値が指定されました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定された値が無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <summary>メッセージの受信を開始し、完了したときにイベント ハンドラーに通知するようにメッセージ キューに指示して、非同期の受信操作を実行します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>タイムアウトのない非同期の受信操作を実行します。操作は、キューのメッセージが利用可能になるまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用する非同期処理で<xref:System.Messaging.MessageQueue.BeginReceive%2A>させる、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント メッセージがキューから削除されたとき。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 使用する<xref:System.Messaging.MessageQueue.BeginReceive%2A>、非同期操作の結果を処理するイベント ハンドラーを作成し、イベント デリゲートを関連付けます。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 非同期の受信操作です。<xref:System.Messaging.MessageQueue>通知の発生を通じて、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント、メッセージがキューに到着したとき。 <xref:System.Messaging.MessageQueue>呼び出すことによって、メッセージにアクセスできます<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>します。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>メソッドを即座に返しますが、非同期操作では、イベント ハンドラーが呼び出されるまでを完了していません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>は非同期で呼び出すことができます、現在の実行スレッドをブロックすることがなく、キューからメッセージを受信します。 同期的にメッセージを受信するには、使用、<xref:System.Messaging.MessageQueue.Receive%2A>メソッド。  
  
 非同期操作が完了すると、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.IAsyncResult>を<xref:System.Messaging.MessageQueue.BeginReceive%2A>返しますが、メソッドを開始した非同期操作を識別します。 これを使用することができます<xref:System.IAsyncResult>、操作の有効期間全体で通常使用しないことまでは<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>が呼び出されます。 ただし、いくつかの非同期操作を開始した場合は配置する、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作が完了するまで待機するかどうかを指定します。 この場合、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>完了した操作を識別するためにします。  
  
 場合<xref:System.Messaging.MessageQueue.CanRead%2A>は`false`完了イベントが発生しますが、呼び出し時に例外がスローされます、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>します。  
  
 非同期呼び出しを使用しないでください<xref:System.Messaging.MessageQueue.BeginReceive%2A>トランザクション。 トランザクションの非同期操作を実行する場合は、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>、トランザクション、および (同期) を配置および<xref:System.Messaging.MessageQueue.Receive%2A>のピーク操作を作成するイベント ハンドラー内でのメソッド。 次の c# コードに示すように、イベント ハンドラーには機能が含まれます。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例では、非同期要求をチェインします。 これは、"myQueue"と呼ばれる、ローカル コンピューター上のキューがあると仮定します。 `Main`関数によって処理される非同期操作を開始する、`MyReceiveCompleted`ルーチン。 `MyReceiveCompleted` 現在のメッセージを処理し、新しい開始非同期操作を受信します。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 次のコード例では、非同期要求をキューします。 呼び出し<xref:System.Messaging.MessageQueue.BeginReceive%2A>を使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>の戻り値にします。 `Main`ルーチンは、すべての非同期操作を終了する前に完了するが待機します。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">メッセージを使用できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <summary>指定したタイムアウトのある非同期の受信操作を実行します。この操作は、メッセージをキューで使用できるようになるか、タイムアウトが発生するまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用する非同期処理で<xref:System.Messaging.MessageQueue.BeginReceive%2A>させる、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント、メッセージがキューまたは指定した期間の有効期限が切れたときに使用できるようになる場合。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 使用する<xref:System.Messaging.MessageQueue.BeginReceive%2A>、非同期操作の結果を処理するイベント ハンドラーを作成し、イベント デリゲートを関連付けます。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 非同期の受信操作です。<xref:System.Messaging.MessageQueue>通知の発生を通じて、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント、メッセージがキューに到着したとき。 <xref:System.Messaging.MessageQueue>呼び出すことによって、メッセージにアクセスできます<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>またはを使用して結果を取得、<xref:System.Messaging.ReceiveCompletedEventArgs>します。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>メソッドを即座に返しますが、非同期操作では、イベント ハンドラーが呼び出されるまでを完了していません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>は非同期で呼び出すことができます、現在の実行スレッドをブロックすることがなく、キューからメッセージを受信します。 同期的にメッセージを受信するには、使用、<xref:System.Messaging.MessageQueue.Receive%2A>メソッド。  
  
 非同期操作が完了すると、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 場合<xref:System.Messaging.MessageQueue.CanRead%2A>は`false`完了イベントが発生しますが、呼び出し時に例外がスローされます、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>します。  
  
 <xref:System.IAsyncResult>を<xref:System.Messaging.MessageQueue.BeginReceive%2A>返しますが、メソッドを開始した非同期操作を識別します。 これを使用することができます<xref:System.IAsyncResult>、操作の有効期間全体で通常使用しないことまでは<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>が呼び出されます。 ただし、いくつかの非同期操作を開始した場合は配置する、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作が完了するまで待機するかどうかを指定します。 この場合、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>完了した操作を識別するためにします。  
  
 このオーバー ロードでは、タイムアウトを指定します。間隔が指定されている場合、`timeout`パラメーターの有効期限が切れる、このコンポーネントが発生、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント。 メッセージが存在しないため、後続の呼び出し<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>例外がスローされます。  
  
 非同期呼び出しを使用しないでください<xref:System.Messaging.MessageQueue.BeginReceive%2A>トランザクション。 トランザクションの非同期操作を実行する場合は、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>、トランザクション、および (同期) を配置および<xref:System.Messaging.MessageQueue.Receive%2A>のピーク操作を作成するイベント ハンドラー内でのメソッド。 次の c# コードに示すように、イベント ハンドラーには機能が含まれます。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例を作成する非同期操作を受信します。 このコード例は、イベント ハンドラーを作成`MyReceiveCompleted`にアタッチします、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント ハンドラーのデリゲート。 ローカル メッセージ キューにメッセージ コードの例の送信を呼び出して<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>、10 秒のタイムアウト値を渡します。 ときに、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントは、イベント ハンドラーは、メッセージを受信し、画面にメッセージ本文を書き込みます。  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定された値が無効です。負数の可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">メッセージを使用できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="stateObject">非同期操作に関連付けられている情報を保持する状態オブジェクト。アプリケーションで指定します。</param>
        <summary>指定したタイムアウトと指定した状態オブジェクトを持つ非同期の受信操作を実行します。状態オブジェクトは、操作の有効期間を通じて関連付けられた情報を提供します。 この操作は、メッセージをキューで使用できるようになるか、タイムアウトが発生するまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用する非同期処理で<xref:System.Messaging.MessageQueue.BeginReceive%2A>させる、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント、メッセージがキューまたは指定した期間の有効期限が切れたときに使用できるようになる場合。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 このオーバー ロードを使用して、操作の有効期間全体にわたって保持するがある操作と情報を関連付けます。 イベント ハンドラーを見てこの情報を検出できます、<xref:System.IAsyncResult.AsyncState%2A>のプロパティ、<xref:System.IAsyncResult>操作に関連付けられています。  
  
 使用する<xref:System.Messaging.MessageQueue.BeginReceive%2A>、非同期操作の結果を処理するイベント ハンドラーを作成し、イベント デリゲートを関連付けます。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 非同期の受信操作です。<xref:System.Messaging.MessageQueue>通知の発生を通じて、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント、メッセージがキューに到着したとき。 <xref:System.Messaging.MessageQueue>呼び出すことによって、メッセージにアクセスできます<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>またはを使用して結果を取得、<xref:System.Messaging.ReceiveCompletedEventArgs>します。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>メソッドを即座に返しますが、非同期操作では、イベント ハンドラーが呼び出されるまでを完了していません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>は非同期で呼び出すことができます、現在の実行スレッドをブロックすることがなく、キューからメッセージを受信します。 同期的にメッセージを受信するには、使用、<xref:System.Messaging.MessageQueue.Receive%2A>メソッド。  
  
 非同期操作が完了すると、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.IAsyncResult>を<xref:System.Messaging.MessageQueue.BeginReceive%2A>返しますが、メソッドを開始した非同期操作を識別します。 これを使用することができます<xref:System.IAsyncResult>、操作の有効期間全体で通常使用しないことまでは<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>が呼び出されます。 ただし、いくつかの非同期操作を開始した場合は配置する、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作が完了するまで待機するかどうかを指定します。 この場合、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>完了した操作を識別するためにします。  
  
 このオーバー ロードでは、タイムアウトと状態オブジェクトを指定します。 間隔が指定されている場合、`timeout`パラメーターの有効期限が切れる、このコンポーネントが発生、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント。 メッセージが存在しないため、後続の呼び出し<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>例外がスローされます。  
  
 状態オブジェクトは、状態情報を操作に関連付けます。 呼び出す場合など、<xref:System.Messaging.MessageQueue.BeginReceive%2A>複数の操作の開始を複数回、各操作を定義する別の状態オブジェクトを識別できます。  
  
 プロセス スレッドを越えて情報を渡す状態オブジェクトを使用することもできます。 場合は、スレッドの開始、コールバックが非同期のシナリオで別のスレッドで、状態オブジェクトがマーシャ リングし、イベントからの情報と共に返されます。  
  
 非同期呼び出しを使用しないでください<xref:System.Messaging.MessageQueue.BeginReceive%2A>トランザクション。 トランザクションの非同期操作を実行する場合は、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>、トランザクション、および (同期) を配置および<xref:System.Messaging.MessageQueue.Receive%2A>のピーク操作を作成するイベント ハンドラー内でのメソッド。 次の c# コードに示すように、イベント ハンドラーには機能が含まれます。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例を作成する非同期操作を受信します。 このコード例は、イベント ハンドラーを作成`MyReceiveCompleted`にアタッチします、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント ハンドラーのデリゲート。 ローカルのメッセージ キューにメッセージのコード例の送信を呼び出して<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>、その特定のメッセージを識別する一意の整数、10 秒のタイムアウト値を渡します。 ときに、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントは、イベント ハンドラーは、メッセージを受信し、画面にメッセージ本文とメッセージの整数識別子を書き込みます。  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定された値が無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">メッセージを使用できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="stateObject">非同期操作に関連付けられている情報を保持する状態オブジェクト。アプリケーションで指定します。</param>
        <param name="callback">非同期操作の完了通知を受信する <see cref="T:System.AsyncCallback" />。</param>
        <summary>指定したタイムアウトと指定した状態オブジェクトを持つ非同期の受信操作を実行します。状態オブジェクトは、操作の有効期間を通じて関連付けられた情報を提供します。 このオーバーロードは、コールバックを通じて操作のイベント ハンドラー ID の通知を受信します。 この操作は、メッセージをキューで使用できるようになるか、タイムアウトが発生するまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コールバック パラメーターで指定されたコールバックが、メッセージがキューまたは指定した期間が切れたときに使用できるようになるときに直接呼び出されるこのオーバー ロードを使用する場合<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントは発生しません。 その他のオーバー ロード<xref:System.Messaging.MessageQueue.BeginReceive%2A>させるには、このコンポーネントに依存、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 使用する<xref:System.Messaging.MessageQueue.BeginReceive%2A>、非同期操作の結果を処理するイベント ハンドラーを作成し、イベント デリゲートを関連付けます。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 非同期の受信操作です。<xref:System.Messaging.MessageQueue>通知の発生を通じて、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント、メッセージがキューに到着したとき。 <xref:System.Messaging.MessageQueue>呼び出すことによって、メッセージにアクセスできます<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>またはを使用して結果を取得、<xref:System.Messaging.ReceiveCompletedEventArgs>します。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>メソッドを即座に返しますが、非同期操作では、イベント ハンドラーが呼び出されるまでを完了していません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>は非同期で呼び出すことができます、現在の実行スレッドをブロックすることがなく、キューからメッセージを受信します。 同期的にメッセージを受信するには、使用、<xref:System.Messaging.MessageQueue.Receive%2A>メソッド。  
  
 非同期操作が完了すると、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.IAsyncResult>を<xref:System.Messaging.MessageQueue.BeginReceive%2A>返しますが、メソッドを開始した非同期操作を識別します。 これを使用することができます<xref:System.IAsyncResult>、操作の有効期間全体で通常使用しないことまでは<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>が呼び出されます。 ただし、いくつかの非同期操作を開始した場合は配置する、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作が完了するまで待機するかどうかを指定します。 この場合、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>完了した操作を識別するためにします。  
  
 状態オブジェクトは、状態情報を操作に関連付けます。 呼び出す場合など、<xref:System.Messaging.MessageQueue.BeginReceive%2A>複数の操作の開始を複数回、各操作を定義する別の状態オブジェクトを識別できます。  
  
 プロセス スレッドを越えて情報を渡す状態オブジェクトを使用することもできます。 場合は、スレッドの開始、コールバックが非同期のシナリオで別のスレッドで、状態オブジェクトがマーシャ リングし、イベントからの情報と共に返されます。  
  
 非同期呼び出しを使用しないでください<xref:System.Messaging.MessageQueue.BeginReceive%2A>トランザクション。 トランザクションの非同期操作を実行する場合は、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>、トランザクション、および (同期) を配置および<xref:System.Messaging.MessageQueue.Receive%2A>のピーク操作を作成するイベント ハンドラー内でのメソッド。 次の c# コードに示すように、イベント ハンドラーには機能が含まれます。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例を作成する非同期操作を受信します。 ローカルのメッセージ キューにメッセージをコードの例の送信を呼び出して<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>で渡し: 10 秒のタイムアウト値はその特定のメッセージとの新しいインスタンスを識別する一意の整数<xref:System.AsyncCallback>イベント ハンドラーを識別する`MyReceiveCompleted`. ときに、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントは、イベント ハンドラーは、メッセージを受信し、画面にメッセージ本文とメッセージの整数識別子を書き込みます。  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定された値が無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">メッセージを使用できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="cursor">メッセージ キュー内の特定の位置を維持する <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="state">非同期操作に関連付けられている情報を保持する状態オブジェクト。アプリケーションで指定します。</param>
        <param name="callback">非同期操作の完了通知を受信する <see cref="T:System.AsyncCallback" />。</param>
        <summary>指定したタイムアウトがあり、指定したカーソルおよび状態オブジェクトを使用する非同期の受信操作を実行します。 状態オブジェクトは、操作の有効期間を通じて、関連付けられた情報を提供します。 このオーバーロードは、コールバックを通じて操作のイベント ハンドラー ID の通知を受信します。 この操作は、メッセージをキューで使用できるようになるか、タイムアウトが発生するまで完了しません。</summary>
        <returns>ポストされた非同期要求を識別する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コールバック パラメーターで指定されたコールバックが、メッセージがキューまたは指定した期間が切れたときに使用できるようになるときに直接呼び出されるこのオーバー ロードを使用する場合<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントは発生しません。 その他のオーバー ロード<xref:System.Messaging.MessageQueue.BeginReceive%2A>させるには、このコンポーネントに依存、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> キューにメッセージが既に存在する場合も発生します。  
  
 使用する<xref:System.Messaging.MessageQueue.BeginReceive%2A>、非同期操作の結果を処理するイベント ハンドラーを作成し、イベント デリゲートを関連付けます。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 非同期の受信操作です。<xref:System.Messaging.MessageQueue>通知の発生を通じて、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント、メッセージがキューに到着したとき。 <xref:System.Messaging.MessageQueue>呼び出すことによって、メッセージにアクセスできます<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>またはを使用して結果を取得、<xref:System.Messaging.ReceiveCompletedEventArgs>します。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>メソッドを即座に返しますが、非同期操作では、イベント ハンドラーが呼び出されるまでを完了していません。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>は非同期で呼び出すことができます、現在の実行スレッドをブロックすることがなく、キューからメッセージを受信します。 同期的にメッセージを受信するには、使用、<xref:System.Messaging.MessageQueue.Receive%2A>メソッド。  
  
 非同期操作が完了すると、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>または<xref:System.Messaging.MessageQueue.BeginReceive%2A>通知の受信を保持するイベント ハンドラーにもう一度です。  
  
 <xref:System.IAsyncResult>を<xref:System.Messaging.MessageQueue.BeginReceive%2A>返しますが、メソッドを開始した非同期操作を識別します。 これを使用することができます<xref:System.IAsyncResult>、操作の有効期間全体で通常使用しないことまでは<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>が呼び出されます。 ただし、いくつかの非同期操作を開始した場合は配置する、<xref:System.IAsyncResult>配列内の値し、すべての操作または任意の操作が完了するまで待機するかどうかを指定します。 ここでは、使用して、<xref:System.IAsyncResult.AsyncWaitHandle%2A>のプロパティ、<xref:System.IAsyncResult>完了した操作を識別するためにします。  
  
 状態オブジェクトは、状態情報を操作に関連付けます。 呼び出す場合など、<xref:System.Messaging.MessageQueue.BeginReceive%2A>複数の操作の開始を複数回、各操作を定義する別の状態オブジェクトを識別できます。  
  
 プロセス スレッドを越えて情報を渡す状態オブジェクトを使用することもできます。 場合は、スレッドの開始、コールバックが非同期のシナリオで別のスレッドで、状態オブジェクトがマーシャ リングし、イベントからの情報と共に返されます。  
  
 非同期呼び出しを使用しないでください<xref:System.Messaging.MessageQueue.BeginReceive%2A>トランザクション。 トランザクションの非同期操作を実行する場合は、呼び出す<xref:System.Messaging.MessageQueue.BeginPeek%2A>、トランザクション、および (同期) を配置および<xref:System.Messaging.MessageQueue.Receive%2A>のピーク操作を作成するイベント ハンドラー内でのメソッド。 次の c# コードに示すように、イベント ハンドラーには機能が含まれます。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定された値が無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> を読み取ることができるかどうかを示す値を取得します。</summary>
        <value>
          <see cref="T:System.Messaging.MessageQueue" /> が存在し、アプリケーションが読み取ることができる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> アプリケーションがここに表示したり、キューからメッセージを受信できるかどうかを示します。 場合<xref:System.Messaging.MessageQueue.CanRead%2A>は`true`、<xref:System.Messaging.MessageQueue>受信したり、キューからメッセージをピークします。 それ以外の場合、そのことはできません。  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> `false`キューが既に排他的読み取りアクセスで開く場合 (これの非排他的なアクセスと開いている場合、または<xref:System.Messaging.MessageQueue>排他アクセスを要求)、またはアプリケーションにアクセスする十分な権限があるない場合。 アプリケーション キューから読み取るしようとする場合と<xref:System.Messaging.MessageQueue.CanRead%2A>は`false`アクセスが拒否されました。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、メッセージ キューの値を表示します。<xref:System.Messaging.MessageQueue.CanRead%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> に書き込むことができるかどうかを示す値を取得します。</summary>
        <value>
          <see cref="T:System.Messaging.MessageQueue" /> が存在し、アプリケーションが書き込むことができる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> アプリケーションがキューにメッセージを送信できるかどうかを示します。 場合<xref:System.Messaging.MessageQueue.CanWrite%2A>は`true`、<xref:System.Messaging.MessageQueue>をキューにメッセージを送信できます。 それ以外の場合、そのことはできません。  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> `false`キューが既に排他的書き込みアクセスで開く場合 (これの非排他的なアクセスと開いている場合、または<xref:System.Messaging.MessageQueue>排他アクセスを要求)、またはアプリケーションにアクセスする十分な権限があるない場合。 アプリケーションが、キューへの書き込みを試みるととき<xref:System.Messaging.MessageQueue.CanWrite%2A>は`false`アクセスが拒否されました。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、メッセージ キューの値を表示します。<xref:System.Messaging.MessageQueue.CanWrite%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キュー カテゴリを取得または設定します。</summary>
        <value>キュー カテゴリを表す <see cref="T:System.Guid" /> (メッセージ キュー タイプ ID)。これによって、アプリケーションはキューを分類できます。 既定値は、<see langword="Guid.empty" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キュー カテゴリは、アプリケーションのキューを分類できます。 たとえばの 1 つのカテゴリと他のすべての注文キュー課金のすべてのキューを配置できます。  
  
 <xref:System.Messaging.MessageQueue.Category%2A>プロパティ (つまり読み取り/書き込み)、メッセージ キュー タイプ ID プロパティにアクセスできますからアクセスできる、**キュー プロパティ**コンピューターの管理コンソールで、ダイアログ ボックス。 新しいカテゴリを定義することができます。 使用できますが、<xref:System.Guid.NewGuid%2A>すべてにわたって一意であるカテゴリ値を作成する<xref:System.Guid>値は、このようなアクションは必要はありません。 カテゴリの値がないから他のすべての他のカテゴリ別にする必要があります<xref:System.Guid>値。 たとえば、割り当てることができます{00000000-0000-0000-0000-000000000001}として、<xref:System.Messaging.MessageQueue.Category%2A>のキューの 1 つのセットと{00000000-0000-0000-0000-000000000002}として、<xref:System.Messaging.MessageQueue.Category%2A>を別のセット。  
  
 設定する必要はありません、<xref:System.Messaging.MessageQueue.Category%2A>します。 値として `null` を指定できます。  
  
 このプロパティの設定には、メッセージ キューのキューが変更されます。 そのため、他<xref:System.Messaging.MessageQueue>インスタンスは、変更を受けます。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.Category%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">キュー カテゴリに無効な値が設定されています。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>接続キャッシュを消去します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すと<xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>キャッシュに格納されている形式名が削除され、開かれ、キャッシュに格納されているハンドルは閉じられます。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|[はい]|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A> を呼び出すコード例を次に示します。  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> で割り当てられたすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> 関連付けられているすべてのリソースを解放する<xref:System.Messaging.MessageQueue>、該当する場合、共有のリソースを含むです。 システムを再度取得これらのリソースに自動的に引き続き使用でき、たとえば呼び出している場合、<xref:System.Messaging.MessageQueue.Send%28System.Object%29>メソッドは、次の c# コードのようにします。  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 呼び出すと<xref:System.Messaging.MessageQueue.Close%2A>すべて、<xref:System.Messaging.MessageQueue>メッセージ キューのキューに直接アクセスするプロパティが解除されます。<xref:System.Messaging.MessageQueue.Path%2A>、 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>、 <xref:System.Messaging.MessageQueue.Formatter%2A>、および<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>すべて元のままです。  
  
 <xref:System.Messaging.MessageQueue.Close%2A> 常にではありません無料の読み取りと書き込みハンドルをキューが共有されるためです。 いることを確認するには、次の手順のいずれかを実行できる<xref:System.Messaging.MessageQueue.Close%2A>キューへの読み取りと書き込みハンドルを解放します。  
  
-   作成、<xref:System.Messaging.MessageQueue>排他アクセス権を持つ。 これを行うには、呼び出し、<xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29>または<xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>コンス トラクター、およびセット、`sharedModeDenyReceive`パラメーター`true`します。  
  
-   作成、<xref:System.Messaging.MessageQueue>接続キャッシュを無効になっています。 これを行うには、呼び出し、<xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>コンス トラクターとセット、`enableConnectionCache`パラメーター`false`します。  
  
-   接続のキャッシュを無効にします。 これを行うには、設定、<xref:System.Messaging.MessageQueue.EnableConnectionCache%2A>プロパティを`false`します。  
  
 呼び出す必要があります<xref:System.Messaging.MessageQueue.Close%2A>キューのキューにメッセージ キュー サーバーを削除する前にします。 それ以外の場合、キューに送信されるメッセージは、例外をスローまたは配信不能キューに表示されます。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|[はい]|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例では、メッセージ キューのキューを閉じます。  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>メッセージ キュー サーバーの指定したパスに新しいキューを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">作成するキューのパス。</param>
        <summary>指定したパスに非トランザクション メッセージ キューのキューを作成します。</summary>
        <returns>新しいキューを表す <see cref="T:System.Messaging.MessageQueue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非トランザクション メッセージ キューのキューを作成するのにには、このオーバー ロードを使用します。  
  
 新しいインスタンスを作成する、<xref:System.Messaging.MessageQueue>クラスのアプリケーションで、既存のキューにバインドするには、使用、<xref:System.Messaging.MessageQueue.%23ctor%2A>コンス トラクター。 メッセージ キューで新しいキューを作成するには、呼び出す<xref:System.Messaging.MessageQueue.Create%28System.String%29>します。  
  
 構文、`path`パラメーターに依存するキューの種類、参照、次の表に示すようにします。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
  
 使用して"."ローカル コンピューターの。 構文の詳細を参照してください、<xref:System.Messaging.MessageQueue.Path%2A>プロパティ。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例では、パブリック キューと専用キューを作成します。 選択したキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> パラメーターが <see langword="null" /> または空の文字列 ("") です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定したパスには既にキューが存在します。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">作成するキューのパス。</param>
        <param name="transactional">トランザクション キューを作成する場合は <see langword="true" />。非トランザクション キューを作成する場合は <see langword="false" />。</param>
        <summary>指定したパスに、トランザクション メッセージ キューのキューまたは非トランザクション メッセージ キューのキューを作成します。</summary>
        <returns>新しいキューを表す <see cref="T:System.Messaging.MessageQueue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して、メッセージ キューでトランザクション キューを作成することができます。 設定して、非トランザクション キューを作成することができます、`transactional`パラメーターを`false`の他のオーバー ロードを呼び出すことによって、または<xref:System.Messaging.MessageQueue.Create%28System.String%29>します。  
  
 新しいインスタンスを作成する、<xref:System.Messaging.MessageQueue>クラスのアプリケーションで、既存のキューにバインドするには、使用、<xref:System.Messaging.MessageQueue.%23ctor%2A>コンス トラクター。 メッセージ キューで新しいキューを作成するには、呼び出す<xref:System.Messaging.MessageQueue.Create%28System.String%29>します。  
  
 構文、`path`パラメーターに依存するキューの種類、参照、次の表に示すようにします。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
  
 使用して"."ローカル コンピューターの。 構文の詳細を参照してください、<xref:System.Messaging.MessageQueue.Path%2A>プロパティ。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例では、パブリックおよびプライベートのトランザクション キューを作成します。 選択したキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> パラメーターが <see langword="null" /> または空の文字列 ("") です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定したパスには既にキューが存在します。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のメッセージ キューの新しい <see cref="T:System.Messaging.Cursor" /> を作成します。</summary>
        <returns>現在のメッセージ キューの新しい <see cref="T:System.Messaging.Cursor" />。 このカーソルは、キューのメッセージを読み取るときに、キュー内の特定の場所を維持するために使用されます。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューがメッセージ キューに作成された時刻と日付を取得します。</summary>
        <value>キューが作成された日付と時刻を表す <see cref="T:System.DateTime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> メッセージ キュー サーバー上のキューに参照、<xref:System.Messaging.MessageQueue>インスタンス。  
  
 キューが存在する場合、このプロパティは、キューが存在するサーバーのローカル時刻に調整、キューが作成された時刻を表します。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例は、メッセージ キューの値を表示します。<xref:System.Messaging.MessageQueue.CreateTime%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションがメッセージをキューに送信するときに既定で使用されるメッセージ プロパティ値を取得または設定します。</summary>
        <value>アプリケーションが <see cref="T:System.Messaging.DefaultPropertiesToSend" /> インスタンス以外のオブジェクトをキューに送信するときに使用する既定のメッセージ キューのメッセージ プロパティ値を含む <see cref="T:System.Messaging.Message" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型が任意のオブジェクトを送信するときに<xref:System.Messaging.Message>、キューに、<xref:System.Messaging.MessageQueue>メッセージ キューのメッセージに、オブジェクトを挿入します。 その時点で、<xref:System.Messaging.MessageQueue>メッセージで指定したプロパティの値に適用されます、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>プロパティ。 逆に、送信する場合、 <xref:System.Messaging.Message> 、キューにこれらのプロパティが既に指定されて、自体のインスタンスのため<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>は無視されます、<xref:System.Messaging.Message>します。  
  
 プロパティを設定しても、<xref:System.Messaging.MessageQueue>オブジェクト、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>キュー自体は、キューに送信されるメッセージのプロパティを参照します。  
  
 プロパティの既定値は、次の表に表示されます。  
  
|プロパティ|既定値|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|ゼロ (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|バイトの長さ 0 の配列|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|空の文字列 ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|[はい]|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例では、メッセージの優先順位を使用して、メッセージを送信する既定のプロパティを決定します。  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">既定のプロパティをキューに設定できませんでした。いずれかのプロパティが無効であることが原因である可能性があります。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">削除するキューの場所。</param>
        <summary>メッセージ キュー サーバーのキューを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 構文、`path`パラメーターは、キューの種類によって異なります。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
  
 構文の詳細を参照してください、<xref:System.Messaging.MessageQueue.Path%2A>プロパティ。  
  
 また、使用することができます、<xref:System.Messaging.MessageQueue.FormatName%2A>または<xref:System.Messaging.MessageQueue.Label%2A>キューのパスを記述します。  
  
|参照|構文|  
|---------------|------------|  
|形式名|形式名: [*形式名*]|  
|group1|ラベル: [*ラベル*]|  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例は、存在する場合、メッセージ キューのキューを削除します。  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> パラメーターが <see langword="null" /> または空の文字列 ("") です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <paramref name="path" /> パラメーターの構文が無効です。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> に、メッセージ キューのキューからメッセージを受信する排他アクセス許可が与えられているかどうかを示す値を取得または設定します。</summary>
        <value>この <see cref="T:System.Messaging.MessageQueue" /> に、キューからメッセージを受信する排他アクセス許可が与えられている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> これで参照されるキューの共有モードを示す<xref:System.Messaging.MessageQueue>します。 設定<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>に`true`をだけを示すためにこの<xref:System.Messaging.MessageQueue>をピークまたは指定したキューからメッセージを受信へのアクセス権<xref:System.Messaging.MessageQueue.Path%2A>。 もう 1 つ場合<xref:System.Messaging.MessageQueue>別のアプリケーションが同じキュー リソース、そのインスタンスに関連付けられてまたはまたはアプリケーションはピークまたはメッセージを受信できませんが、引き続き送信そのことができます。  
  
 場合<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>は`false`キューが複数のアプリケーションの送信、ピーク、またはメッセージの受信に使用できます。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|[はい]|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> で使用されていたリソース (メモリを除く) を解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> を使い終わったら <xref:System.Messaging.MessageQueue> を呼び出します。 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> メソッドによって、<xref:System.Messaging.MessageQueue> は使用不可の状態になります。 呼び出した後<xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>へのすべての参照を解放する必要があります、<xref:System.Messaging.MessageQueue>によって占有されていたメモリをガベージ コレクションによってクリアできるようにします。  
  
 呼び出す必要があります<xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>への参照を解放する前に、<xref:System.Messaging.MessageQueue>します。 それ以外の場合、リソース、<xref:System.Messaging.MessageQueue>を使用して解放されませんガベージ コレクションの呼び出すまで、<xref:System.Messaging.MessageQueue>オブジェクトのデストラクター。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>接続のキャッシュをアプリケーションで維持するかどうかを示す値を取得または設定します。</summary>
        <value>接続キャッシュを作成し、使用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続キャッシュは、読み取りを含めたり、キューへのハンドルを記述する構造体への参照の一覧を示します。 ときに<xref:System.Messaging.MessageQueue.EnableConnectionCache%2A>は`true`、<xref:System.Messaging.MessageQueue>を呼び出すたびに、キャッシュからのハンドルをそのまま利用<xref:System.Messaging.MessageQueue.Send%28System.Object%29>、 <xref:System.Messaging.MessageQueue.Peek%2A>、または<xref:System.Messaging.MessageQueue.Receive%2A>、新しいハンドルを開くのではなく。 これにより、パフォーマンスが向上することができます。 接続キャッシュを使用しても影響を受けないように、<xref:System.Messaging.MessageQueue>ネットワーク トポロジの変更から。  
  
 接続のキャッシュがいっぱいの場合、キューへの新しい接続を作成する場合、<xref:System.Messaging.MessageQueue>新しい接続で、最近アクセスした少なくとも構造を上書きします。 キャッシュを消去するには呼び出すことによって完全<xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>、たとえば、以前のバージョンの読み取りし、書き込みハンドルが無効になったように使用するキューの形式名が変更された場合。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|[はい]|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.EnableConnectionCache%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューが非プライベート (暗号化されていない) メッセージだけを受け入れるかどうかを示す値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Messaging.EncryptionRequired" /> 値のいずれか 1 つ。 既定値は、<see langword="None" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 暗号化が必要、キューに送信されたメッセージを指定する場合は、メッセージの本文のみが暗号化されます。 他のメンバー (たとえば、<xref:System.Messaging.Message.Label%2A>と<xref:System.Messaging.Message.SenderId%2A>プロパティ) を暗号化することはできません。  
  
 このプロパティの設定には、メッセージ キューのキューが変更されます。 そのため、他<xref:System.Messaging.MessageQueue>インスタンスは、変更を受けます。  
  
 プライベート メッセージは、メッセージを暗号化します。 キューの暗号化要件を指定できます`None`、 `Body`、または`Optional`を設定して、<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>プロパティ適切にします。 <xref:System.Messaging.Message.UseEncryption%2A>メッセージの設定は、キューの暗号化の要件に対応する必要があります。 かどうか、メッセージが暗号化されていないが、キューを指定します`Body`、メッセージが暗号化されていますが、キューを指定する場合または`None`、キューによって、メッセージは拒否されます。 送信元アプリケーションは、このイベントに否定受信確認メッセージを要求している場合に、送信元アプリケーションにメッセージの拒否メッセージ キューを示します。 場合、<xref:System.Messaging.Message.UseDeadLetterQueue%2A>プロパティは`true`暗号化に失敗したメッセージが配信不能キューに送信します。 それ以外の場合、メッセージは失われます。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">完了する非同期のピーク操作を識別する <see cref="T:System.IAsyncResult" />。ここから最終結果が取得されます。</param>
        <summary>指定した非同期のピーク操作を完了します。</summary>
        <returns>完了した非同期操作に関連付けられた <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントが発生すると、<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>によって開始された操作が完了すると、<xref:System.Messaging.MessageQueue.BeginPeek%2A>呼び出します。 これを行うに<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>メッセージをピークします。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> これにより、タイムアウトを指定することができます、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント キューにメッセージを表示する前にタイムアウトが発生した場合に発生します。 後続の呼び出し、キューに到達したメッセージを表示せず、タイムアウトの発生時<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>例外をスローします。  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 原因となったメッセージの読み取りに使用、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントが発生します。  
  
 もう一度呼び出すことができますを非同期的にメッセージをピークする続行する場合は、<xref:System.Messaging.MessageQueue.BeginPeek%2A>呼び出した後<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、名前付きイベント ハンドラーを作成します。 `MyPeekCompleted`、にアタッチします、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント ハンドラーのデリゲート、および呼び出し<xref:System.Messaging.MessageQueue.BeginPeek%2A>パスにあるキューで非同期のピーク操作を開始する"。 \myQueue"。 ときに、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントは、例では、メッセージをピークし、画面に、本文を書き込みます。 例を呼び出して<xref:System.Messaging.MessageQueue.BeginPeek%2A>新しい非同期のピーク操作を開始するには、もう一度です。  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> パラメーターの構文が無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">完了する非同期の受信操作を識別する <see cref="T:System.IAsyncResult" />。ここから最終結果が取得されます。</param>
        <summary>指定した非同期の受信操作を完了します。</summary>
        <returns>完了した非同期操作に関連付けられた <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントが発生すると、<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>によって開始された操作が完了すると、<xref:System.Messaging.MessageQueue.BeginReceive%2A>呼び出します。 これを行うに<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>メッセージを受信します。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> これにより、タイムアウトを指定することができます、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント キューにメッセージを表示する前にタイムアウトが発生した場合に発生します。 後続の呼び出し、キューに到達したメッセージを表示せず、タイムアウトの発生時<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>例外をスローします。  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 原因となったメッセージを (キューから削除する) を確認するために使用、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントが発生します。  
  
 もう一度呼び出すことができますを非同期的にメッセージを受信する続行する場合は、<xref:System.Messaging.MessageQueue.BeginReceive%2A>呼び出した後<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例では、非同期要求をチェインします。 これは、"myQueue"と呼ばれる、ローカル コンピューター上のキューがあると仮定します。 `Main`関数によって処理される非同期操作を開始する、`MyReceiveCompleted`ルーチン。 `MyReceiveCompleted` 現在のメッセージを処理し、新しい開始非同期操作を受信します。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> パラメーターの構文が無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">検索するキューの場所。</param>
        <summary>指定したパスにメッセージ キューのキューが存在するかどうかを判断します。</summary>
        <returns>指定したパスにキューが存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29>メソッドは、メッセージ キューのキューが指定されたパスに存在するかどうかを判断します。 指定した形式の名前を持つキューが存在するかどうかを判断するメソッドが存在しません。 形式名の構文とその他のパスの構文形式の詳細については、次を参照してください、<xref:System.Messaging.MessageQueue.Path%2A>プロパティです。)。  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 高価な操作です。 アプリケーション内で必要な場合にのみに使用します。  
  
> [!NOTE]
>  <xref:System.Messaging.MessageQueue.Exists%28System.String%29>方法がサポートされていません、<xref:System.Messaging.MessageQueue.FormatName%2A>プレフィックス。  
  
 構文、`path`パラメーターは、次の表に示すように、キューの種類に依存します。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> リモート プライベート キューの存在の確認を呼び出すことはできません。  
  
 構文の詳細を参照してください、<xref:System.Messaging.MessageQueue.Path%2A>プロパティ。  
  
 また、使用することができます、<xref:System.Messaging.MessageQueue.Label%2A>キューのパスを記述します。  
  
|参照|構文|  
|---------------|------------|  
|group1|ラベル: [ `label` ]|  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|×|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例では、メッセージ キューのキューが存在し、それを削除するかどうかを確認します。  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 構文が無効です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。  
  
- または - 
<see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> メソッドがリモート プライベート キューで呼び出されています。</exception>
        <exception cref="T:System.InvalidOperationException">キューの存在を確認するときに、アプリケーションが書式名構文を使用しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューの作成時にメッセージ キューが生成した一意のキュー名を取得します。</summary>
        <value>ネットワークで一意なキューの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.FormatName%2A>プロパティには、キューの形式名が含まれています。 メッセージ キューは、どのキューを開くとそのアクセス方法を識別するために、形式名を使用します。 キューの特性のほとんどとは異なり、形式名がメッセージ キュー アプリケーション キュー プロパティのためにメッセージ キューの管理ツールを使ってアクセスすることはできません。 形式名は一意の名前をキューに単に、キュー、または後で、アプリケーションを生成する作成時にメッセージ キューが生成します。  
  
 パス名の構文を使用して、パスを指定するかどうか (など`myComputer\myQueue`) (Active Directory を使用) するプライマリ ドメイン コント ローラーが変換形式名の構文を使用して、キューを読み書きするときではなく、<xref:System.Messaging.MessageQueue.Path%2A>に関連付けられている<xref:System.Messaging.MessageQueue.FormatName%2A> 、キューにアクセスする前にします。 書式名構文; を使用する場合は、アプリケーションはオフラインで作業する必要があります。それ以外の場合、プライマリ ドメイン コント ローラーはパスの変換を実行できません。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|[はい]|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、メッセージ キューの値を表示します。<xref:System.Messaging.MessageQueue.FormatName%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> が設定されていません。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューから読み取られるメッセージまたはキューに書き込まれるメッセージの本文とオブジェクトとの間でシリアル化または逆シリアル化を行うために使用する書式指定子を取得または設定します。</summary>
        <value>メッセージ本文に書き込むストリーム、またはメッセージ本文から読み取るストリームを生成する <see cref="T:System.Messaging.IMessageFormatter" />。 既定値は、<see cref="T:System.Messaging.XmlMessageFormatter" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Formatter%2A>プロパティにはと、アプリケーションの読み取りまたは書き込みをキューにメッセージを変換するフォーマッタ オブジェクトのインスタンスが含まれています。  
  
 アプリケーションがキューにメッセージを送信、フォーマッタは、オブジェクトをストリームにシリアル化し、メッセージの本文に挿入します。 キューから読み取る場合、フォーマッタのメッセージ データを<xref:System.Messaging.Message.Body%2A>のプロパティを<xref:System.Messaging.Message>します。  
  
 <xref:System.Messaging.XmlMessageFormatter> 、疎結合と同じオブジェクトをこの形式を使用する場合、送信者と受信者を入力する必要はありませんので。 <xref:System.Messaging.ActiveXMessageFormatter>と<xref:System.Messaging.BinaryMessageFormatter>バイナリ表現にデータをシリアル化します。 <xref:System.Messaging.ActiveXMessageFormatter> COM コンポーネントを送受信する際に使用します。  
  
 <xref:System.Messaging.BinaryMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>よりも高速なスループットを提供、<xref:System.Messaging.XmlMessageFormatter>します。 <xref:System.Messaging.ActiveXMessageFormatter> Visual Basic 6.0 のメッセージ キュー アプリケーションとの相互運用を許可します。  
  
 アプリケーションがキューにメッセージを送信するとき、<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>既定のメッセージ プロパティを使用して、それらのメッセージにのみ適用されます<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>します。 送信した場合、 <xref:System.Messaging.Message> 、キューにメッセージ キューで定義されているフォーマッタが使用、<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>代わりに、本文をシリアル化するプロパティ。  
  
 <xref:System.Messaging.MessageQueue>クラスは常に使用する<xref:System.Messaging.Message>受信するか、キューからメッセージをピークします。 使用して、メッセージに逆シリアル化、<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>プロパティ。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例に示しますを使用してメッセージ本文の書式設定<xref:System.Messaging.BinaryMessageFormatter>します。  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 次のコード例に示しますを使用してメッセージ本文の書式設定<xref:System.Messaging.XmlMessageFormatter>します。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キューにあるすべてのメッセージを返します。</summary>
        <returns>キューにあるすべてのメッセージを表す <see cref="T:System.Messaging.Message" /> 型の配列。配列の順序は、メッセージがメッセージ キューのキューに存在する順序と同じです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> これらのメッセージをキュー内のメッセージ、ダイナミックではなくリンクの静的なスナップショットを返します。 そのため、キュー内のメッセージを変更するのに、配列を使用することはできません。 (メッセージを削除する機能) など、キューを使ったリアルタイムの動的な相互作用する場合は、呼び出し、<xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>メソッドで、キュー内のメッセージの動的な一覧を返します。  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>メソッドが呼び出された時点で、キュー内のメッセージのコピーを返します、配列は、キューに到着する新しいメッセージまたはメッセージをキューから削除されますが反映されません。  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 除外されないプロパティのみを取得、<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>プロパティ。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.GetAllMessages%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キューに格納されているメッセージを列挙します。 <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> は使用されなくなりました。 代わりに <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> を使用します。</summary>
        <returns>キュー内のメッセージへの動的な接続を提供する <see cref="T:System.Collections.IEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.GetEnumerator%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">キューを含むコンピューターの名前。先頭に 2 つの円記号 (\\\\) を付けません。</param>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューが存在するコンピューターの ID を取得します。</summary>
        <returns>キューが存在するコンピューターの一意の ID を表す <see cref="T:System.Guid" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 その他の 2 つの目的のコンピューターの識別子を使用することができます。 コンピューター ジャーナルを読み、セキュリティ証明書を設定します。 ただし、呼び出すことはできません<xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>リモート コンピューターのドメイン コント ローラーで、アプリケーションにはディレクトリ サービスへのアクセスが必要なためオフライン作業する場合。  
  
 コンピューターの識別子 (またはコンピューターの識別子) が、<xref:System.Guid>コンピューターが企業に追加されたときにメッセージ キューを作成します。 メッセージ キューを持つコンピューターの id を組み合わせて、`Machine`と`Journal`構文は、コンピューターの履歴の形式の名前を作成するためのキーワード`Machine=<computeridentifier>;Journal`します。 ジャーナル キュー、としては、コピーを格納するシステム キュー アプリケーションによって生成されるも呼ばれるコンピューターの履歴メッセージ、<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>プロパティは`true`します。  
  
 ジャーナルは、この構文は、キューの形式名を構築するときにのみ有効です。 パス名の構文は`MachineName` \\`Journal$`します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|×|  
|ローカル コンピューターと直接形式名|×|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> を呼び出すコード例を次に示します。  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">コンピューターの ID を取得できません。オフラインで作業しているなど、ディレクトリ サービスが利用できないことが原因である可能性があります。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キューにあるすべてのメッセージに対して列挙子オブジェクトを作成します。 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> は使用されなくなりました。 代わりに <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> を使用します。</summary>
        <returns>キューに含まれるメッセージを保持する <see cref="T:System.Messaging.MessageEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> キュー内のすべてのメッセージの動的リストを作成します。 削除できますキュー、列挙子の現在位置にあるメッセージを呼び出して<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>の<xref:System.Messaging.MessageEnumerator>を<xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A>を返します。  
  
 カーソルがキュー内のメッセージの動的リストに関連付けられるため、列挙体は、メッセージが現在のカーソル位置を超える場合、キュー内のメッセージに対して行った変更を反映します。 たとえば、カーソルの現在の位置より後ろに配置されて優先順位の低いメッセージが優先順位の高いメッセージの位置の前に挿入できません、列挙子は自動的にアクセスします。 ただし、するはリセットできます、列挙、カーソル戻り、一覧の先頭に呼び出すことによって<xref:System.Messaging.MessageEnumerator.Reset%2A>の<xref:System.Messaging.MessageEnumerator>します。  
  
 列挙に含まれるメッセージの順序では、優先順位の低いものの前に優先順位の高いメッセージが表示されるように、キュー内の順序が反映されます。  
  
 静的なスナップショットには、動的な接続ではなく、キュー内のメッセージの場合は、呼び出す<xref:System.Messaging.MessageQueue.GetAllMessages%2A>します。 このメソッドの配列を返します<xref:System.Messaging.Message>メソッドが呼び出された時点で、メッセージを表すオブジェクト。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|[はい]|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例がキューにメッセージの動的リストを取得およびですべてのメッセージのカウント、<xref:System.Messaging.Message.Priority%2A>プロパティに設定<xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>します。  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キューにあるすべてのメッセージに対して列挙子オブジェクトを作成します。</summary>
        <returns>キューに含まれるメッセージを保持する <see cref="T:System.Messaging.MessageEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> キュー内のすべてのメッセージの動的リストを作成します。 削除できますキュー、列挙子の現在位置にあるメッセージを呼び出して<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>の<xref:System.Messaging.MessageEnumerator>を<xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>を返します。  
  
 カーソルがキュー内のメッセージの動的リストに関連付けられるため、列挙体は、メッセージが現在のカーソル位置を超える場合、キュー内のメッセージに対して行った変更を反映します。 たとえば、カーソルの現在の位置より後ろに配置されて優先順位の低いメッセージが優先順位の高いメッセージの位置の前に挿入できません、列挙子は自動的にアクセスします。 ただし、するはリセットできます、列挙、カーソル戻り、一覧の先頭に呼び出すことによって<xref:System.Messaging.MessageEnumerator.Reset%2A>の<xref:System.Messaging.MessageEnumerator>します。  
  
 列挙に含まれるメッセージの順序では、優先順位の低いものの前に優先順位の高いメッセージが表示されるように、キュー内の順序が反映されます。  
  
 静的なスナップショットには、動的な接続ではなく、キュー内のメッセージの場合は、呼び出す<xref:System.Messaging.MessageQueue.GetAllMessages%2A>します。 このメソッドの配列を返します<xref:System.Messaging.Message>メソッドが呼び出された時点で、メッセージを表すオブジェクト。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|[はい]|  
|リモート コンピューターと直接形式名|[はい]|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>列挙子オブジェクトを作成し、ネットワーク上のパブリック キューの動的リストを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ネットワーク上のすべてのパブリック キューを列挙するための順方向専用カーソル セマンティクスをサポートします。</summary>
        <returns>ネットワーク上のすべてのパブリックメッセージ キューの動的リストを作成する <see cref="T:System.Messaging.MessageQueueEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロード<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>ネットワーク上にあるすべてのパブリック キューの列挙を返します。  
  
 カーソルは動的リストに関連付けられているため、列挙体には、削除またはカーソルの現在位置を超える追加のキューのキューに対して行った変更が反映されます。 現在のカーソル位置の前にあるキューが追加または削除は反映されません。 たとえば、カーソルの位置より後に追加キューしますが、ない 1 つの位置の前に挿入、列挙子は自動的にアクセスします。 ただし、するはリセットできます、列挙、カーソル戻り、一覧の先頭に呼び出すことによって<xref:System.Messaging.MessageQueueEnumerator.Reset%2A>の<xref:System.Messaging.MessageQueueEnumerator>します。  
  
 ネットワークでのキューの順序は定義はありません。 列挙子はない順序をたとえば、コンピューター、ラベル、パブリックまたはプライベートの状態、またはその他のアクセス可能な条件で。  
  
 静的なスナップショットに動的な接続ではなく、ネットワーク上のキューの場合は、呼び出す<xref:System.Messaging.MessageQueue.GetPublicQueues%2A>または<xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>します。 配列を返します 2 つのメソッドの各<xref:System.Messaging.MessageQueue>メソッドが呼び出された時点で、キューを表すオブジェクト。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|×|  
|ローカル コンピューターと直接形式名|×|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例は、ネットワーク内のすべてのメッセージ キューを反復処理し、各キューのパスを検査します。 最後に、ネットワーク上のパブリック キューの数が表示されます。  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">利用できるメッセージ キューのフィルター処理に使用する基準が格納されている <see cref="T:System.Messaging.MessageQueueCriteria" />。</param>
        <summary>指定した基準を満たすネットワーク上のすべてのパブリック キューを列挙するための順方向専用カーソル セマンティクスをサポートします。</summary>
        <returns>
          <paramref name="criteria" /> パラメーターで指定された制約を満たすネットワーク上のパブリックメッセージ キューの動的リストを作成する <see cref="T:System.Messaging.MessageQueueEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロード<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>アプリケーション条件で定義されている条件を満たすネットワーク上のすべてのパブリック キューの一覧を返します。 含めるには、条件、キューの作成や変更時、コンピューター名、ラベル、カテゴリ、またはその任意の組み合わせを指定することができます。  
  
 カーソルが動的リストに関連付けられているために、列挙体には、カーソルの現在の位置以降に発生するキューに対して行った変更が反映されます。 現在のカーソル位置の前にあるキューへの変更は反映されません。 たとえば、カーソルの位置より後に追加キューしますが、ない 1 つの位置の前に挿入、列挙子は自動的にアクセスします。 ただし、するはリセットできます、列挙、カーソル戻り、一覧の先頭に呼び出すことによって<xref:System.Messaging.MessageQueueEnumerator.Reset%2A>の<xref:System.Messaging.MessageQueueEnumerator>します。  
  
 ネットワークでのキューの順序は定義はありません。 列挙子はない順序をたとえば、コンピューター、ラベル、パブリックまたはプライベートの状態、またはその他のアクセス可能な条件で。  
  
 静的なスナップショットに動的な接続ではなく、ネットワーク上のキューの場合は、指定の条件<xref:System.Messaging.MessageQueue.GetPublicQueues%2A>呼び出したり<xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>します。 配列を返します 2 つのメソッドの各<xref:System.Messaging.MessageQueue>メソッドが呼び出された時点で、キューを表すオブジェクト。 呼び出す<xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>、 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>、または<xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>呼び出すことと同じ結果を提供します<xref:System.Messaging.MessageQueue.GetPublicQueues%2A>のフィルター条件を持つ<xref:System.Messaging.MessageQueue.Category%2A>、 <xref:System.Messaging.MessageQueue.Label%2A>、および<xref:System.Messaging.MessageQueue.MachineName%2A>、それぞれします。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|×|  
|ローカル コンピューターと直接形式名|×|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例では、メッセージ キューを反復処理し、"mycomputer という"コンピューター上に存在する最後の日で作成したキューのパスを表示します。  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">プライベート キューを取得するコンピューター。</param>
        <summary>指定したコンピューターにあるすべてのプライベート キューを取得します。</summary>
        <returns>取得されたプライベート キューを参照する <see cref="T:System.Messaging.MessageQueue" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> 指定したコンピューター上のキューの静的なスナップショットを取得します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|[はい]|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> パラメーターが <see langword="null" /> または空の文字列 ("") です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ネットワーク上のすべてのパブリック キューを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ネットワーク上のすべてのパブリック キューを取得します。</summary>
        <returns>取得したパブリック キューを参照する <see cref="T:System.Messaging.MessageQueue" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ネットワーク上のすべてのパブリック キューの完全な一覧が必要な場合は、このオーバー ロードを使用します。 など、特定の条件によって、一覧を制限する<xref:System.Messaging.MessageQueue.MachineName%2A>、 <xref:System.Messaging.MessageQueue.Category%2A>、または最終更新時刻は、このメソッドの別のオーバー ロードを使用します。 (また、使用することができます<xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>、 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>、または<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>)。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> キューの静的なスナップショットを取得します。 使用して、キューの動的リストをやり取りする<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|×|  
|ローカル コンピューターと直接形式名|×|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">キューのフィルター処理に使用する基準が格納されている <see cref="T:System.Messaging.MessageQueueCriteria" />。</param>
        <summary>指定した基準を満たすネットワーク上のすべてのパブリック キューを取得します。</summary>
        <returns>取得したパブリック キューを参照する <see cref="T:System.Messaging.MessageQueue" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ラベル、カテゴリ、またはコンピューターの名前で、ネットワーク上のすべてのパブリック キューをフィルター処理する場合、<xref:System.Messaging.MessageQueue>クラスには、その機能を提供する特定のメソッドが含まれています (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>、 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>、および<xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>、それぞれ)。 (たとえば、ラベルとカテゴリの両方を指定する) 場合は、これらの条件の 1 つ以上を満たすネットワーク上のすべてのパブリック キューの一覧を取得するのにには、このオーバー ロードを使用します。 以外のメッセージの条件でフィルターすることができますもする<xref:System.Messaging.MessageQueue.Label%2A>、 <xref:System.Messaging.MessageQueue.Category%2A>、および<xref:System.Messaging.MessageQueue.MachineName%2A>します。 たとえば、このオーバー ロードを使用して、キューの最終更新時刻でフィルター処理します。 新しいインスタンスを作成するだけです、<xref:System.Messaging.MessageQueueCriteria>クラス、インスタンスで、適切なプロパティを設定およびとしてインスタンスを渡して、`criteria`パラメーター。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> キューの静的なスナップショットを取得します。 使用して、キューの動的リストをやり取りする<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|×|  
|ローカル コンピューターと直接形式名|×|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">取得するキューのセットをグループ化する <see cref="T:System.Guid" />。</param>
        <summary>指定したカテゴリに属するネットワーク上のすべてのパブリック キューを取得します。</summary>
        <returns>取得したパブリック キューを参照する <see cref="T:System.Messaging.MessageQueue" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カテゴリ別のパブリック キューをフィルター処理するのにには、このメソッドを使用します。 <xref:System.Messaging.MessageQueue.Category%2A>プロパティは、メッセージ キュー タイプ ID プロパティ (読み取り/書き込み) の特定のキューへのアクセスを提供します。 使用できますが、<xref:System.Guid.NewGuid%2A>すべてにわたって一意であるカテゴリ値を作成する<xref:System.Guid>値必要はありません。 カテゴリの値がないから他のすべての他のカテゴリ別にする必要があります<xref:System.Guid>値。 たとえば、割り当てることができます{00000000-0000-0000-0000-000000000001}として、<xref:System.Messaging.MessageQueue.Category%2A>のキューの 1 つのセットと{00000000-0000-0000-0000-000000000002}として、<xref:System.Messaging.MessageQueue.Category%2A>を別のセット。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> キューの静的なスナップショットを取得します。 使用して、キューの動的リストをやり取りする<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>します。 一部として、カテゴリを指定することができます、<xref:System.Messaging.MessageQueueCriteria>メソッドに渡します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|×|  
|ローカル コンピューターと直接形式名|×|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">取得するキューのセットをグループ化するラベル。</param>
        <summary>指定したラベルが設定されているネットワーク上のすべてのパブリック キューを取得します。</summary>
        <returns>取得したパブリック キューを参照する <see cref="T:System.Messaging.MessageQueue" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、パブリック キューのラベルによってフィルター処理します。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> キューの静的なスナップショットを取得します。 使用して、キューの動的リストをやり取りする<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>します。 一部として、ラベルを指定することができます、<xref:System.Messaging.MessageQueueCriteria>メソッドに渡します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|×|  
|ローカル コンピューターと直接形式名|×|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> パラメーターが <see langword="null" /> です。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">取得するパブリック キューのセットが含まれているコンピューターの名前。</param>
        <summary>指定したコンピューターにあるすべてのパブリック キューを取得します。</summary>
        <returns>コンピューターのパブリック キューを参照する <see cref="T:System.Messaging.MessageQueue" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、コンピューターでのパブリック キューをフィルター処理します。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> キューの静的なスナップショットを取得します。 使用して、キューの動的リストをやり取りする<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>します。 一部としてコンピューター名を指定することができます、<xref:System.Messaging.MessageQueueCriteria>メソッドに渡します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|×|  
|ローカル コンピューターと直接形式名|×|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例では、キューの一覧を取得します。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> パラメーターの構文が正しくありません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この呼び出しの時点で現在のユーザーが MSMQ によって関連付けられているセキュリティ コンテキスト (スレッド ID) を取得します。</summary>
        <returns>セキュリティ コンテキストを格納している <see cref="T:System.Messaging.SecurityContext" /> オブジェクト。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューの一意なメッセージ キュー ID を取得します。</summary>
        <value>メッセージ キュー アプリケーションが生成したメッセージ ID を表す <see cref="P:System.Messaging.MessageQueue.Id" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ キューのセット、<xref:System.Messaging.MessageQueue.Id%2A>プロパティ、キューの作成時にします。 このプロパティでは、パブリック キューの使用のみです。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例は、メッセージ キューの値を表示します。<xref:System.Messaging.MessageQueue.Id%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューにサイズ制限が存在しないことを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定するときに、このメンバーは頻繁に使用<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>または<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>します。  
  
   
  
## Examples  
 次のコード例は、の使用を示します、<xref:System.Messaging.MessageQueue.InfiniteQueueSize>メンバー。  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージをピークまたは受信するメソッドにタイムアウトが存在しないことを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> 2 種類のメッセージの取得をサポートしています。 同期および非同期です。 同期メソッド、<xref:System.Messaging.MessageQueue.Peek%2A>と<xref:System.Messaging.MessageQueue.Receive%2A>、プロセス スレッドを新しいメッセージがキューに到達する指定した時間間隔の待機が発生します。 指定した時間間隔が場合<xref:System.Messaging.MessageQueue.InfiniteTimeout>、新しいメッセージが利用可能になるまで、プロセスのスレッドがブロックされたままです。 その一方で、<xref:System.Messaging.MessageQueue.BeginPeek%2A>と<xref:System.Messaging.MessageQueue.BeginReceive%2A>(非同期のメソッド) が、メイン アプリケーション タスクのキューにメッセージが到着するまで、別のスレッドで続行を許可します。  
  
   
  
## Examples  
 次のコード例は、の使用を示します、<xref:System.Messaging.MessageQueue.InfiniteTimeout>メンバー。  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューの説明を取得または設定します。</summary>
        <value>メッセージ キューのラベル。 既定値は、空の文字列 ("") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ キューのラベルの最大長は 124 文字です。  
  
 <xref:System.Messaging.MessageQueue.Label%2A>プロパティはすべてのキューで一意である必要はありません。 ただし、複数のキューの共有と同じ場合<xref:System.Messaging.MessageQueue.Label%2A>、使用することはできません、<xref:System.Messaging.MessageQueue.Send%28System.Object%29>にすべてのメッセージをブロードキャストする方法。 ラベルの構文を使用する場合、<xref:System.Messaging.MessageQueue.Path%2A>プロパティ、メッセージを送信するときに場合、例外がスローされます、<xref:System.Messaging.MessageQueue.Label%2A>一意ではありません。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.Label%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ラベルが無効な値が設定されています。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューのプロパティが最後に変更された時刻を取得します。</summary>
        <value>キューのプロパティが最後に変更された時刻を示す <see cref="T:System.DateTime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューが作成されたときの最終更新時刻が含まれていますと<xref:System.Messaging.MessageQueue>など、メッセージ キューのキューを変更するプロパティ<xref:System.Messaging.MessageQueue.BasePriority%2A>。 値、<xref:System.Messaging.MessageQueue.LastModifyTime%2A>プロパティは、ローカル コンピューターのシステム時刻を表します。  
  
 呼び出す必要があります<xref:System.Messaging.MessageQueue.Refresh%2A>取得する前に、<xref:System.Messaging.MessageQueue.LastModifyTime%2A>プロパティ。 それ以外の場合、変更時刻は、これに関連付けられている。<xref:System.Messaging.MessageQueue>最新でない可能性があります。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例は、メッセージ キューの値を表示します。<xref:System.Messaging.MessageQueue.LastModifyTime%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージ キューのキューが存在するコンピューターの名前を取得または設定します。</summary>
        <value>キューが存在するコンピューターの名前。 メッセージ キューの既定値は、ローカル コンピューターを表す "." です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MachineName%2A>キューのフレンドリ名の構文に不可欠なコンポーネントは、<xref:System.Messaging.MessageQueue.Path%2A>します。 次の表では、フレンドリ名を使用するキューのパスを特定するときに指定した種類のキューを使用する構文を示します。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
|コンピューター ジャーナル キュー|`MachineName`\\`Journal$`|  
|コンピューター配信不能キュー|`MachineName`\\`Deadletter$`|  
|コンピューター トランザクション配信不能キュー|`MachineName`\\`XactDeadletter$`|  
  
 使用して"."を指定する場合は、ローカル コンピューターの<xref:System.Messaging.MessageQueue.MachineName%2A>します。 たとえば、コンピューター名のみが、このプロパティに認識`Server0`します。 <xref:System.Messaging.MessageQueue.MachineName%2A>プロパティは、IP アドレスの形式をサポートしていません。  
  
 定義する場合、<xref:System.Messaging.MessageQueue.Path%2A>の観点で、<xref:System.Messaging.MessageQueue.MachineName%2A>アプリケーションは、ドメイン コント ローラーが必要なパスの変換のためにオフライン作業中に例外をスローします。 したがって、使用する必要があります、<xref:System.Messaging.MessageQueue.FormatName%2A>の<xref:System.Messaging.MessageQueue.Path%2A>オフラインで作業する場合は構文。  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>、 <xref:System.Messaging.MessageQueue.Path%2A>、および<xref:System.Messaging.MessageQueue.QueueName%2A>プロパティに関連します。 変更、<xref:System.Messaging.MessageQueue.MachineName%2A>プロパティ原因、<xref:System.Messaging.MessageQueue.Path%2A>プロパティを変更します。 新しいから構築される<xref:System.Messaging.MessageQueue.MachineName%2A>、<xref:System.Messaging.MessageQueue.QueueName%2A>します。 変更、 <xref:System.Messaging.MessageQueue.Path%2A> (たとえば、形式名の構文を使用する場合など) をリセット、<xref:System.Messaging.MessageQueue.MachineName%2A>と<xref:System.Messaging.MessageQueue.QueueName%2A>プロパティを新しいキューを参照してください。 場合、<xref:System.Messaging.MessageQueue.QueueName%2A>プロパティが空の場合、<xref:System.Messaging.MessageQueue.Path%2A>が指定したコンピューターのジャーナル キューに設定します。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|[はい]|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.MachineName%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">コンピューター名が無効です。構文が間違っているためと考えられます。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>履歴キューの最大サイズを取得または設定します。</summary>
        <value>履歴キューの最大サイズ。単位は KB です。 メッセージ キューの既定値は、制限なしです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> メッセージ キュー ジャーナルの記憶域制限へのアクセスを提供します。 関連する場合にのみが<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>は`true`します。 このプロパティの設定には、メッセージ キューのキューが変更されます。 そのため、他<xref:System.Messaging.MessageQueue>インスタンスが、変更によって影響を受ける  
  
 ジャーナルや配信不能キューにメッセージを格納する場合は、不要なメッセージを削除するキューを定期的に消去する必要があります。 このようなキュー内のメッセージはキューが存在するコンピューターのメッセージ クォータにカウントします。 (管理者は、コンピューター クォータを設定します)。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">最大履歴キューサイズに無効な値が設定されています。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューの最大サイズを取得または設定します。</summary>
        <value>キューの最大サイズ。単位は KB です。 メッセージ キューの既定値は、制限なしです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>メッセージ キュー メッセージ ストレージの上限には、管理者が定義する、コンピューターのメッセージ クォータから別のアクセスを提供します。 メッセージ クォータの詳細については、次を参照してください。<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>します。  
  
 このプロパティの設定には、メッセージ キューのキューが変更されます。 そのため、他<xref:System.Messaging.MessageQueue>インスタンスが、変更によって影響を受ける  
  
 最大キュー サイズまたはコンピューターのメッセージ クォータを超えたしようとすると、メッセージが失われる可能性があります。 キューのクォータに達すると、メッセージ キュー、否定受信確認メッセージを返すことによって、キューがいっぱいであることを示す、送信元アプリケーションの管理キューに通知します。 メッセージ キューは、キュー内のメッセージの合計サイズが制限を下回るまで、否定受信確認応答を送信し続けます。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">最大キューサイズに負の値が含まれています。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージの受信またはピークに使用するプロパティ フィルターを取得または設定します。</summary>
        <value>メッセージごとに受信またはピークするプロパティのセットをフィルター処理するためにキューが使用する <see cref="T:System.Messaging.MessagePropertyFilter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィルターは、一連のメッセージのプロパティを制限するブール値を<xref:System.Messaging.MessageQueue>受信またはピークします。 ときに、<xref:System.Messaging.MessageQueue>メッセージをピークまたは受信対象のプロパティのみを取得、サーバーのキューから、<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>値は`true`します。  
  
 初期プロパティ値を次に示します、<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>プロパティ。 これらの設定を呼び出すことと同じ<xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A>上、<xref:System.Messaging.MessagePropertyFilter>します。  
  
|プロパティ|既定値|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 バイト|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 バイト|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 バイト|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|[はい]|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例では、<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>受信したメッセージ プロパティを制限します。  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">フィルターが <see langword="null" /> です。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>MSMQ 3.0 で導入されました。 キューに関連付けられているマルチキャスト アドレスを取得または設定します。</summary>
        <value>有効なマルチキャスト アドレス (次に示す形式) を格納している <see cref="T:System.String" />、またはキューがマルチキャスト アドレスに関連付けられていないことを示す <see langword="null" />。  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MulticastAddress%2A>に非トランザクション キューにメッセージを送信するときに使用できるマルチキャスト アドレスを関連付けるプロパティを使用します。 トランザクション キューはマルチキャスト アドレスを関連付けることはできません。 送信元アプリケーションは、マルチキャスト アドレスにメッセージを送信、するときは、そのアドレスに関連付けられているすべてのキューにメッセージのコピーを送信するメッセージ キューします。  
  
 IP マルチキャスト アドレスは、クラス D 範囲 224.0.0.0 から 239.255.255.255 の範囲、最初の 4 つの上位ビットが 1110 を等しく設定に対応するである必要があります。 ただし、この範囲のアドレスの特定の範囲にのみ予約されておらず、マルチキャストのメッセージを送信するために使用できます。 マルチキャスト アドレスの予約済みの最新の一覧については、[インターネット割り当て番号機関 (IANA) のインターネットのマルチキャスト アドレス](http://go.microsoft.com/fwlink/?linkid=3859)Web ページ。 ポート数に制限はありません。  
  
 複数のソース コンピューターがマルチキャストのメッセージを送信する、特定のキューに 1 つだけのソース コンピューターからメッセージを受信したい場合は、各ソース コンピューターは、IP アドレスとポート番号のさまざまな組み合わせにメッセージを送信する必要があります。  
  
 マルチキャスト アドレスからのキューの関連付けを解除するには、設定、<xref:System.Messaging.MessageQueue.MulticastAddress%2A>プロパティを長さ 0 の文字列にします。 設定しないで`null`、これで、結果として、<xref:System.ArgumentNullException>します。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューのパスを取得または設定します。 <see cref="P:System.Messaging.MessageQueue.Path" /> を設定すると、<see cref="T:System.Messaging.MessageQueue" /> は新しいキューを指します。</summary>
        <value>
          <see cref="T:System.Messaging.MessageQueue" /> が参照するキュー。 既定値は、使用する <see cref="M:System.Messaging.MessageQueue.#ctor" /> コンストラクターによって異なり、<see langword="null" /> かコンストラクターの <paramref name="path" /> パラメーターで指定された値になります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 構文、<xref:System.Messaging.MessageQueue.Path%2A>プロパティに依存するキューの種類がポイントに、次の表に示すようにします。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
|コンピューター ジャーナル キュー|`MachineName`\\`Journal$`|  
|コンピューター配信不能キュー|`MachineName`\\`Deadletter$`|  
|コンピューター トランザクション配信不能キュー|`MachineName`\\`XactDeadletter$`|  
  
 使用して"."ローカル コンピューターを表す。  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>、 <xref:System.Messaging.MessageQueue.Path%2A>、および<xref:System.Messaging.MessageQueue.QueueName%2A>プロパティに関連します。 変更、<xref:System.Messaging.MessageQueue.MachineName%2A>プロパティ原因、<xref:System.Messaging.MessageQueue.Path%2A>プロパティを変更します。 新しいから構築される<xref:System.Messaging.MessageQueue.MachineName%2A>、<xref:System.Messaging.MessageQueue.QueueName%2A>します。 変更、 <xref:System.Messaging.MessageQueue.Path%2A> (たとえば、形式名の構文を使用する場合など) をリセット、<xref:System.Messaging.MessageQueue.MachineName%2A>と<xref:System.Messaging.MessageQueue.QueueName%2A>プロパティを新しいキューを参照してください。  
  
 また、使用することができます、<xref:System.Messaging.MessageQueue.FormatName%2A>または<xref:System.Messaging.MessageQueue.Label%2A>に次の表に示すように、キューのパスを記述します。  
  
|参照|構文|例|  
|---------------|------------|-------------|  
|形式名|`FormatName:` [*形式名*]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|group1|`Label:` [*ラベル*]|`Label:` とき|  
  
 ラベルの構文を使用する場合、<xref:System.Messaging.MessageQueue.Path%2A>プロパティ、メッセージを送信するときに場合、例外がスローされます、<xref:System.Messaging.MessageQueue.Label%2A>一意ではありません。  
  
 オフラインで作業するには、最初のテーブルの表示名の構文ではなく、形式名の構文を使用する必要があります。 それ以外の場合、(Active Directory が存在する)、プライマリ ドメイン コント ローラーが形式の名前に、パスを解決するのには使用できないため、例外がスローされます。  
  
 新しいパスを設定し、メッセージ キューを閉じ、すべてのハンドルを解放します。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|[はい]|  
|リモート コンピューターと直接形式名|[はい]|  
  
> [!NOTE]
>  ワークグループ モードでは、専用キューのみ使用できます。 専用キューの構文を使用してパスを指定する`MachineName` \\ `Private$` \\`QueueName`します。  
  
   
  
## Examples  
 次のコード例を新規作成<xref:System.Messaging.MessageQueue>さまざまなパス名の構文型を使用するオブジェクトします。 各ケースでは、パスを持つが、コンス トラクターで定義されているキューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">パスが無効です。構文が無効であるためと考えられます。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <summary>キューにある最初のメッセージのコピーを返します。メッセージはキューから削除されません。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューにある最初のメッセージを、削除せずに返します (ピークします)。 <see cref="M:System.Messaging.MessageQueue.Peek" /> メソッドは同期メソッドであるため、メッセージが利用可能になるまで、現在のスレッドをブロックします。</summary>
        <returns>キューの最初のメッセージを表す <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューをピークするメッセージがキューに到達するまで待機するか、このオーバー ロードを使用します。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドは、読み取りが、削除する最初のメッセージ キューから。 そのためへの呼び出しを繰り返す<xref:System.Messaging.MessageQueue.Peek%2A>より高い優先度のメッセージがキューに到着しない限り、同じメッセージを返します。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッド、その一方で、両方を読み取り、最初のメッセージをキューから削除します。 繰り返し呼び出す<xref:System.Messaging.MessageQueue.Receive%2A>、したがって、さまざまなメッセージを返します。  
  
 メッセージ キューは、優先順位と到着時刻に従ってキューにメッセージを並べ替えます。 優先度が高いは場合にのみ、新しいメッセージは古いものの前に配置されます。  
  
 キューにメッセージが到達するまで待機する間、現在のスレッドがブロックされてもいい場合は、<xref:System.Messaging.MessageQueue.Peek%2A> を使用します。 このオーバー ロードでは、タイムアウトを指定しないため、アプリケーションが無期限に待機する可能性があります。 待機せずにアプリケーションの処理を継続する必要がある場合は、非同期の <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドを使用します。 オーバー ロードを使用して、キューに到着するメッセージのタイムアウトを指定する代わりに、<xref:System.Messaging.MessageQueue.Peek%2A>タイムアウトを指定します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次の例を使用して、<xref:System.Messaging.MessageQueue.Peek%2A>キューのメソッド。  
  
 最初の例では、アプリケーションは、メッセージが、キューで利用できるようになるまで待機します。 最初の例が; に到着したメッセージをアクセスしていないことに注意してください。メッセージが到着するまで処理だけで一時停止します。 かどうか、キューにメッセージが既に存在します、すぐに戻ります。  
  
 2 番目の例では、アプリケーション定義を含むメッセージを`Order`クラスは、キューに送信され、キューからピークします。  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">キューにメッセージが格納されるまで待機する最大時間を示す <see cref="T:System.TimeSpan" />。</param>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューにある最初のメッセージを、削除せずに返します (ピークします)。 <see cref="M:System.Messaging.MessageQueue.Peek" /> メソッドは同期メソッドであるため、メッセージが利用可能になるか、指定したタイムアウトが発生するまで、現在のスレッドをブロックします。</summary>
        <returns>キューの最初のメッセージを表す <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューをピークするメッセージがキューに到達するまでの指定した期間を待機したり、このオーバー ロードを使用します。 メソッドは、キューにメッセージが既に存在するかどうかにすぐに返します。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドは、読み取りが、削除する最初のメッセージ キューから。 そのためへの呼び出しを繰り返す<xref:System.Messaging.MessageQueue.Peek%2A>より高い優先度のメッセージがキューに到着しない限り、同じメッセージを返します。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッド、その一方で、両方を読み取り、最初のメッセージをキューから削除します。 繰り返し呼び出す<xref:System.Messaging.MessageQueue.Receive%2A>、したがって、さまざまなメッセージを返します。  
  
 メッセージ キューは、優先順位と到着時刻に従ってキューにメッセージを並べ替えます。 優先度が高いは場合にのみ、新しいメッセージは古いものの前に配置されます。  
  
 キューにメッセージが到達するまで待機する間、現在のスレッドがブロックされてもいい場合は、<xref:System.Messaging.MessageQueue.Peek%2A> を使用します。 指定した期間、または最大スレッドはブロックされる場合、指定した<xref:System.Messaging.MessageQueue.InfiniteTimeout>します。 待機せずにアプリケーションの処理を継続する必要がある場合は、非同期の <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドを使用します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例では、<xref:System.Messaging.MessageQueue.Peek%2A>キューが空かどうかを確認する 0 のタイムアウトを持つメソッド。  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">キューにメッセージが格納されるまで待機する最大時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="cursor">メッセージ キュー内の特定の位置を維持する <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="action">
          <see cref="T:System.Messaging.PeekAction" /> 値のいずれか 1 つ。 キュー内の現在のメッセージと次のメッセージのどちらをピークするかを示します。</param>
        <summary>指定されたカーソルを使用して、キュー内の現在のメッセージまたは次のメッセージを、削除せずに返します (ピークします)。 <see cref="M:System.Messaging.MessageQueue.Peek" /> メソッドは同期メソッドであるため、メッセージが利用可能になるか、指定したタイムアウトが発生するまで、現在のスレッドをブロックします。</summary>
        <returns>キュー内のメッセージを表す <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューをピークするメッセージがキューに到達するまでの指定した期間を待機したり、このオーバー ロードを使用します。 メソッドは、キューにメッセージが既に存在するかどうかにすぐに返します。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドは、読み取りが、削除するキューからのメッセージ。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッド、その一方で、両方を読み取って、キューからメッセージを削除します。  
  
 キューにメッセージが到達するまで待機する間、現在のスレッドがブロックされてもいい場合は、<xref:System.Messaging.MessageQueue.Peek%2A> を使用します。 指定した期間、または最大スレッドがブロックされている場合、指定した<xref:System.Messaging.MessageQueue.InfiniteTimeout>します。 待機せずにアプリケーションの処理を継続する必要がある場合は、非同期の <xref:System.Messaging.MessageQueue.BeginPeek%2A> メソッドを使用します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="action" /> パラメーターに <see langword="PeekAction.Current" /> または <see langword="PeekAction.Next" /> 以外の値が指定されました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定された値が無効です。 <paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> より小さい値か、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> より大きい値である可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した相関 ID と一致するメッセージをピークします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">ピークするメッセージの <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <summary>指定した相関 ID と一致するメッセージをピークします。現在、指定した相関 ID と一致するメッセージがキューに存在しない場合は、すぐに例外を発生させます。</summary>
        <returns>渡された <paramref name="correlationId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.CorrelationId" /> を持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドで参照されるキューは、<xref:System.Messaging.MessageQueue>メッセージが<xref:System.Messaging.Message.CorrelationId%2A>、指定された一致`correlationId`パラメーター。 一致するメッセージがない場合、`correlationID`パラメーター、例外がスローされます。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>に関連する応答、レポート、または受信確認メッセージをキューに送信されるメッセージを関連付けるプロパティを使用します。  
  
 その他の 2 つのメソッドを使用すると、キューにメッセージをピークできます。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドは、キュー内の最初のメッセージを返します、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドを使用して、その一意の識別子を指定することで、メッセージを取得します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、して、キューから注文を含むメッセージを送受信します。 元のメッセージに達したかと具体的には肯定受信確認を要求がキューから取得します。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="correlationId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">ピークするメッセージの <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <summary>指定した相関 ID と一致するメッセージをピークします。指定した相関 ID のメッセージがキューで利用可能になるか、タイムアウトが経過するまで待機します。</summary>
        <returns>渡された <paramref name="correlationId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.CorrelationId" /> を持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドで参照されるキューは、<xref:System.Messaging.MessageQueue>メッセージが<xref:System.Messaging.Message.CorrelationId%2A>、指定された一致`correlationId`パラメーター。 一致するメッセージがない場合、`correlationID`パラメーター、および新しいメッセージ、によって指定された期間内でキューに到着、`timeout`パラメーター、例外がスローされます。  
  
 `timeout`パラメーターでこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、<xref:System.Messaging.Message.CorrelationId%2A>と一致している新しいメッセージの`correlationId`パラメーター。 されていない場合、このメソッドは、経由でタイムアウト期間を開始し、もう 1 つの新しいメッセージが到着するを待ちます。 そのため、タイムアウト期間内に到着する新しいメッセージが引き続き、あるせず、新しいメッセージが到着すると、タイムアウト期間が経過するまで、またはそのメッセージが到着するまで無期限に実行を続行するには、このメソッドの考えられる<xref:System.Messaging.Message.CorrelationId%2A>一致する、`correlationId`パラメーター。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>に関連する応答、レポート、または受信確認メッセージをキューに送信されるメッセージを関連付けるプロパティを使用します。  
  
 その他の 2 つのメソッドを使用すると、キューにメッセージをピークできます。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドは、キュー内の最初のメッセージを返します、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドを使用して、その一意の識別子を指定することで、メッセージを取得します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="correlationId" /> を持つメッセージがキューに存在せず、タイムアウトが経過する前にキューに到達することもありませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前にメッセージが到達しませんでした。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したメッセージ ID を持つメッセージのコピーを返します。メッセージはキューから削除されません。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">ピークするメッセージの <see cref="P:System.Messaging.Message.Id" />。</param>
        <summary>メッセージ ID が <paramref name="id" /> パラメーターと一致するメッセージをピークします。</summary>
        <returns>
          <paramref name="id" /> パラメーターと一致する <see cref="P:System.Messaging.Message.Id" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>キューから削除せずに、読み取るに認識されているメッセージの識別子を持つメッセージ。 あるため最大で 1 つのメッセージと一致するキューでメッセージの識別子がメッセージ キュー エンタープライズ全体で一意では、指定された`id`パラメーター。 このオーバー ロードは、現在、キューにメッセージが含まれていない場合に例外をスローします。  
  
 2 つの追加メソッドは、キューのメッセージをピーク:<xref:System.Messaging.MessageQueue.Peek%2A>と<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>します。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドは、キューで最初のメッセージを返します<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを返します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="id" /> を持つメッセージが存在しません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">ピークするメッセージの <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <summary>メッセージ ID が <paramref name="id" /> パラメーターと一致するメッセージをピークします。 メッセージがキューに出現するか、タイムアウトが発生するまで待機します。</summary>
        <returns>
          <paramref name="id" /> パラメーターと一致する <see cref="P:System.Messaging.Message.Id" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>キューから削除せずに、読み取るに認識されているメッセージの識別子を持つメッセージ。 あるため最大で 1 つのメッセージと一致するキューでメッセージの識別子がメッセージ キュー エンタープライズ全体で一意では、指定された`id`パラメーター。 このオーバー ロードは、現在、キューにメッセージが含まれていないと、タイムアウトが発生する前に、新しいメッセージが到着しない場合に例外をスローします。  
  
 `timeout`パラメーターでこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、<xref:System.Messaging.Message.Id%2A>と一致している新しいメッセージの`id`パラメーター。 されていない場合、このメソッドは、経由でタイムアウト期間を開始し、もう 1 つの新しいメッセージが到着するを待ちます。 そのため、タイムアウト期間内に到着する新しいメッセージが引き続き、あるせず、新しいメッセージが到着すると、タイムアウト期間が経過するまで、またはそのメッセージが到着するまで無期限に実行を続行するには、このメソッドの考えられる<xref:System.Messaging.Message.Id%2A>一致する、`id`パラメーター。  
  
 2 つの追加メソッドは、キューのメッセージをピーク:<xref:System.Messaging.MessageQueue.Peek%2A>と<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>します。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドは、キューで最初のメッセージを返します<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを返します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="id" /> のメッセージがキューに存在せず、<paramref name="timeout" /> パラメーターで指定した時間が経過する前にキューに到達しませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>MSMQ 3.0 で導入されました。 キュー内の特定のメッセージをピークします。 メッセージは、参照識別子で指定することも、キューの前後の位置関係で指定することもできます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">ピークするメッセージの <see cref="P:System.Messaging.Message.LookupId" />。</param>
        <summary>MSMQ 3.0 で導入されました。 非トランザクション キュー内の指定した参照識別子に一致するメッセージをピークします。</summary>
        <returns>渡された <paramref name="lookupId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.LookupId" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、キューから削除せず、既知の参照識別子を持つメッセージを読み取る。 このメソッドは、キューにメッセージがない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.LookupId%2A>メッセージのプロパティは一意のキューにメッセージが存在するがあるため最大で 1 つのメッセージと一致するキューで、指定された`lookupId`パラメーター。  
  
 指定した参照 id を持つメッセージをキューから削除は、使用、<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>メソッド。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="lookupId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">キュー内のメッセージを読み取る方法を指定する <see cref="T:System.Messaging.MessageLookupAction" /> のいずれか 1 つ。 次のいずれかを指定します。 
 <see langword="MessageLookupAction.Current" />: <c>lookupId</c> で指定されたメッセージをピークします。  
  
 <see langword="MessageLookupAction.Next" />: <c>lookupId</c> で指定されたメッセージの次のメッセージをピークします。  
  
 <see langword="MessageLookupAction.Previous" />: <c>lookupId</c> で指定されたメッセージの前のメッセージをピークします。  
  
 <see langword="MessageLookupAction.First" />: キューの最初のメッセージをピークします。 <c>lookupId</c> パラメーターは 0 に設定する必要があります。  
  
 <see langword="MessageLookupAction.Last" />: キューの最後のメッセージをピークします。 <c>lookupId</c> パラメーターは 0 に設定する必要があります。</param>
        <param name="lookupId">ピークするメッセージの <see cref="P:System.Messaging.Message.LookupId" /> か、0。 キューの最初または最後のメッセージにアクセスする場合は 0 を使用します。</param>
        <summary>MSMQ 3.0 で導入されました。 キュー内の特定のメッセージをピークします。 メッセージは、参照識別子で指定することも、キューの前後の位置関係で指定することもできます。</summary>
        <returns>渡された <paramref name="action" /> パラメーターおよび <paramref name="lookupId" /> パラメーターで指定された <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、キューから削除せず、既知の参照識別子を持つメッセージを読み取る。 このメソッドは、キューにメッセージがない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.LookupId%2A>メッセージのプロパティは一意のキューにメッセージが存在するがあるため最大で 1 つのメッセージと一致するキューで、指定された`lookupId`パラメーター。  
  
 指定した識別子を持つメッセージをキューから削除は、使用、<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>メソッド。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="lookupId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> パラメーターが、<see cref="T:System.Messaging.MessageLookupAction" /> メンバーの 1 つではありません。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューから削除せずにメッセージを読み取ると発生します。 この発生は、非同期操作 <see cref="M:System.Messaging.MessageQueue.BeginPeek" /> の結果です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 非同期処理で発生させるために使用、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント メッセージが、キューで利用できるとします。  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 呼び出しによって開始された操作を完了するために使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>とメッセージをピーク時に、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントが発生します。  
  
 <xref:System.Messaging.PeekCompletedEventHandler> デリゲートを作成する場合は、イベントを処理するメソッドを指定します。 イベントをイベント ハンドラーに関連付けるには、デリゲートのインスタンスをイベントに追加します。 デリゲートを削除しない限り、そのイベントが発生すると常にイベント ハンドラーが呼び出されます。 イベント ハンドラー デリゲートの詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
   
  
## Examples  
 次のコード例は、名前付きイベント ハンドラーを作成します。 `MyPeekCompleted`、にアタッチします、<xref:System.Messaging.MessageQueue.PeekCompleted>イベント ハンドラーのデリゲート、および呼び出し<xref:System.Messaging.MessageQueue.BeginPeek%2A>パスにあるキューで非同期のピーク操作を開始する"。 \myQueue"。 ときに、<xref:System.Messaging.MessageQueue.PeekCompleted>イベントは、例では、メッセージをピークし、画面に、本文を書き込みます。 例を呼び出して<xref:System.Messaging.MessageQueue.BeginPeek%2A>新しい非同期のピーク操作を開始するには、もう一度  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キューに含まれるすべてのメッセージを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューを削除すると、メッセージ キューに影響するキューの変更フラグを設定、<xref:System.Messaging.MessageQueue.LastModifyTime%2A>プロパティ。 キューから削除されたメッセージは失われます。配信不能キューまたはジャーナル キューには送信されません。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Purge%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューを識別する表示名を取得または設定します。</summary>
        <value>この <see cref="T:System.Messaging.MessageQueue" /> が参照するキューを識別する名前。 値を <see langword="null" /> にすることはできません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組み合わせることができます、<xref:System.Messaging.MessageQueue.QueueName%2A>で、 <xref:System.Messaging.MessageQueue.MachineName%2A> 、わかりやすいを作成する<xref:System.Messaging.MessageQueue.Path%2A>キューの名前。 フレンドリ名のバリエーションの構文、<xref:System.Messaging.MessageQueue.Path%2A>プロパティは、次の表に示すように、キューの種類に依存します。  
  
|キューの種類|構文|  
|----------------|------------|  
|パブリック キュー|`MachineName`\\`QueueName`|  
|専用キュー|`MachineName`\\`Private$`\\`QueueName`|  
|ジャーナル キュー|`MachineName`\\`QueueName`\\`Journal$`|  
  
 使用して"."ローカル コンピューターを表す。  
  
 変更、<xref:System.Messaging.MessageQueue.QueueName%2A>プロパティに影響、<xref:System.Messaging.MessageQueue.Path%2A>プロパティ。 設定した場合、<xref:System.Messaging.MessageQueue.QueueName%2A>設定がない場合、<xref:System.Messaging.MessageQueue.MachineName%2A>プロパティ、<xref:System.Messaging.MessageQueue.Path%2A>プロパティになります\\。`QueueName` それ以外の場合、<xref:System.Messaging.MessageQueue.Path%2A>なります`MachineName` \\`QueueName`します。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|[はい]|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.QueueName%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">キュー名が <see langword="null" /> です。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージ キューからメッセージを読み取るときに使用するネイティブ ハンドルを取得します。</summary>
        <value>キューからメッセージをピークおよび受信するときに使用するネイティブ キューオブジェクトへのハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReadHandle%2A>をピークおよびキューからメッセージを受信するために使用するメッセージ キュー オブジェクトへのネイティブ Windows ハンドルを提供します。 キューのパスを変更する場合、ハンドルを閉じて、新しい値。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <summary>キューにある最初のメッセージを受信し、キューから削除します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> で参照されるキューで利用できる最初のメッセージを受信します。 この呼び出しは同期呼び出しであるため、メッセージが利用可能になるまで、現在のスレッドの実行をブロックします。</summary>
        <returns>キューで利用できる最初のメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、キューからメッセージを受信またはキューにメッセージがあるまで待機します。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>キューから削除され、メッセージの同期読み取りメソッドを使用します。 後続の呼び出し<xref:System.Messaging.MessageQueue.Receive%2A>に従う、キュー、または新しいより高い優先度のメッセージをメッセージが返されます。  
  
 キューから削除することがなく、キューの最初のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.Peek%2A>メソッド。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドがメソッドに対する後続の呼び出しより高い優先度のメッセージがキューに到着しない限り、同じメッセージが返されるように、キューで最初のメッセージが常を返します。  
  
 呼び出しを使用して、<xref:System.Messaging.MessageQueue.Receive%2A>の現在のスレッドが、メッセージがキューに到達するを待っている間にブロックされてもかまわない場合します。 このオーバー ロードはのため、<xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、無限のタイムアウトを指定します、アプリケーションが無期限に待機する可能性があります。 アプリケーションの処理は、メッセージを待たずに続行する必要がある場合、非同期メソッドの使用を検討<xref:System.Messaging.MessageQueue.BeginReceive%2A>します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例では、キューからメッセージを受信し、画面には、そのメッセージに関する情報を出力します。  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> で参照されるトランザクション キューで利用できる最初のメッセージを受信します。 この呼び出しは同期呼び出しであるため、メッセージが利用可能になるまで、現在のスレッドの実行をブロックします。</summary>
        <returns>キューで利用できる最初のメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して定義されている内部トランザクション コンテキストを使用してトランザクション キューからメッセージを受信する、`transaction`パラメーター、またはキューにメッセージがあるまで待機します。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>キューから削除され、メッセージの同期読み取りメソッドを使用します。 後続の呼び出し<xref:System.Messaging.MessageQueue.Receive%2A>キュー内のメッセージが返されます。  
  
 トランザクション キューでこのメソッドを呼び出したため、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 キューから削除することがなく、キューの最初のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.Peek%2A>メソッド。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドがメソッドに対する後続の呼び出しより高い優先度のメッセージがキューに到着しない限り、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.Peek%2A>します。 <xref:System.Messaging.MessageQueue.Peek%2A>キューにメッセージは削除されませんが、nothing への呼び出しでロールバックするはず<xref:System.Messaging.MessageQueueTransaction.Abort%2A>します。  
  
 呼び出しを使用して、<xref:System.Messaging.MessageQueue.Receive%2A>の現在のスレッドが、メッセージがキューに到達するを待っている間にブロックされてもかまわない場合します。 このオーバー ロードはのため、<xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、無限のタイムアウトを指定します、アプリケーションが無期限に待機する可能性があります。 アプリケーションの処理は、メッセージを待たずに続行する必要がある場合、非同期メソッドの使用を検討<xref:System.Messaging.MessageQueue.BeginReceive%2A>します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例では、ローカル コンピューター上のトランザクション キューに接続し、キューにメッセージを送信します。 注文を含むメッセージを受信します。 非トランザクション キューを検出するがスローされ、例外、トランザクションをロールバックします。  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。  
  
- または - 
キューが非トランザクション キューです。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> で参照されるキューで利用できる最初のメッセージを受信します。 この呼び出しは同期呼び出しであるため、メッセージが利用可能になるまで、現在のスレッドの実行をブロックします。</summary>
        <returns>キューで利用できる最初のメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して、定義されたトランザクションのコンテキストを使用してキューからメッセージを受信する、`transactionType`パラメーター、またはキューにメッセージがあるまで待機します。  
  
 指定`Automatic`の`transactionType`外部トランザクション コンテキストが既に存在する場合は、パラメーターを使用してメッセージを受信する必要のあるスレッドにアタッチされています。 指定`Single`として 1 つの内部トランザクション メッセージを受信したい場合。 指定できる`None`トランザクション コンテキストの外でトランザクション キューからメッセージを受信する場合。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>キューから削除され、メッセージの同期読み取りメソッドを使用します。 後続の呼び出し<xref:System.Messaging.MessageQueue.Receive%2A>キュー内のメッセージが返されます。  
  
 トランザクション キューからメッセージを受信するこのメソッドが呼び出されると、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 キューから削除することがなく、キューの最初のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.Peek%2A>メソッド。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドがメソッドに対する後続の呼び出しより高い優先度のメッセージがキューに到着しない限り、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.Peek%2A>します。 <xref:System.Messaging.MessageQueue.Peek%2A>キューにメッセージは削除されませんが、nothing への呼び出しでロールバックするはず<xref:System.Messaging.MessageQueueTransaction.Abort%2A>します。  
  
 呼び出しを使用して、<xref:System.Messaging.MessageQueue.Receive%2A>の現在のスレッドが、メッセージがキューに到達するを待っている間にブロックされてもかまわない場合します。 このオーバー ロードはのため、<xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、無限のタイムアウトを指定します、アプリケーションが無期限に待機する可能性があります。 アプリケーションの処理は、メッセージを待たずに続行する必要がある場合、非同期メソッドの使用を検討<xref:System.Messaging.MessageQueue.BeginReceive%2A>します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> が参照するキューで利用できる最初のメッセージを受信します。キューでメッセージが利用可能になるか、タイムアウトの時間が経過するまで待機します。</summary>
        <returns>キューで利用できる最初のメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードを使用して、キューからメッセージを受信します。キューにメッセージがない場合は、指定した時間が経過した後で制御が戻ります。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドで、メッセージの同期読み取りキューから削除します。 後続の呼び出し<xref:System.Messaging.MessageQueue.Receive%2A>に従う、キュー、または新しいより高い優先度のメッセージをメッセージが返されます。  
  
 キューから削除することがなく、キューの最初のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.Peek%2A>メソッド。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドがメソッドに対する後続の呼び出しより高い優先度のメッセージがキューに到着しない限り、同じメッセージが返されるように、キューで最初のメッセージが常を返します。  
  
 呼び出しを使用して、<xref:System.Messaging.MessageQueue.Receive%2A>の現在のスレッドが、メッセージがキューに到達するを待っている間にブロックされてもかまわない場合します。 、または指定された期間のスレッドをブロックは、値が指定されている場合<xref:System.Messaging.MessageQueue.InfiniteTimeout>の、`timeout`パラメーター。 アプリケーションの処理は、メッセージを待たずに続行する必要がある場合、非同期メソッドの使用を検討<xref:System.Messaging.MessageQueue.BeginReceive%2A>します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例では、キューからメッセージを受信し、画面には、そのメッセージに関する情報を出力します。 例には、メッセージがキューに到達するを待機中に最大 5 秒間実行が一時停止します。  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、キューにメッセージが到達しませんでした。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="cursor">メッセージ キュー内の特定の位置を維持する <see cref="T:System.Messaging.Cursor" />。</param>
        <summary>指定したカーソルを使用して、キューの現在のメッセージを受信します。 利用可能なメッセージがない場合、このメソッドは、メッセージが利用可能になるまで、またはタイムアウトが発生するまで待機します。</summary>
        <returns>キューで利用できる最初のメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、キューにメッセージが到達しませんでした。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。 
このオーバーロードを使用して、キューからメッセージを受信します。キューにメッセージがない場合は、指定した時間が経過した後で制御が戻ります。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> が参照するトランザクション キューで利用できる最初のメッセージを受信します。キューでメッセージが利用可能になるか、タイムアウトの時間が経過するまで待機します。</summary>
        <returns>キューで利用できる最初のメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して定義されている内部トランザクション コンテキストを使用してトランザクション キューからメッセージを受信する、`transaction`パラメーター、およびキューにメッセージがない場合は、時間の指定した期間内の戻り値。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>キューから削除され、メッセージの同期読み取りメソッドを使用します。 後続の呼び出し<xref:System.Messaging.MessageQueue.Receive%2A>キュー内のメッセージが返されます。  
  
 トランザクション キューでこのメソッドを呼び出したため、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 キューから削除することがなく、キューの最初のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.Peek%2A>メソッド。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドがメソッドに対する後続の呼び出しより高い優先度のメッセージがキューに到着しない限り、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.Peek%2A>します。 <xref:System.Messaging.MessageQueue.Peek%2A>キューにメッセージは削除されませんが、nothing への呼び出しでロールバックするはず<xref:System.Messaging.MessageQueueTransaction.Abort%2A>します。  
  
 呼び出しを使用して、<xref:System.Messaging.MessageQueue.Receive%2A>の現在のスレッドが、メッセージがキューに到達するを待っている間にブロックされてもかまわない場合します。 、または指定された期間のスレッドをブロックは、値が指定されている場合<xref:System.Messaging.MessageQueue.InfiniteTimeout>の、`timeout`パラメーター。 アプリケーションの処理は、メッセージを待たずに続行する必要がある場合、非同期メソッドの使用を検討<xref:System.Messaging.MessageQueue.BeginReceive%2A>します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例では、このメソッドの使用を示します。  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、キューにメッセージが到達しませんでした。  
  
- または - 
キューが非トランザクション キューです。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> で参照されるキューで利用できる最初のメッセージを受信します。 この呼び出しは同期的に実行され、メッセージがキューで使用できるようになるか、タイムアウトが経過するまで待機します。</summary>
        <returns>キューで利用できる最初のメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して、定義されたトランザクションのコンテキストを使用してキューからメッセージを受信する、`transactionType`パラメーター、およびキューにメッセージがない場合は、時間の指定した期間の戻り値。  
  
 指定`Automatic`の`transactionType`外部トランザクション コンテキストが既に存在する場合は、パラメーターを使用してメッセージを受信する必要のあるスレッドにアタッチされています。 指定`Single`として 1 つの内部トランザクション メッセージを受信したい場合。 指定できる`None`トランザクション コンテキストの外でトランザクション キューからメッセージを受信する場合。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>キューから削除され、メッセージの同期読み取りメソッドを使用します。 後続の呼び出し<xref:System.Messaging.MessageQueue.Receive%2A>キュー内のメッセージが返されます。  
  
 トランザクション キューからメッセージを受信するこのメソッドが呼び出されると、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 キューから削除することがなく、キューの最初のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.Peek%2A>メソッド。 <xref:System.Messaging.MessageQueue.Peek%2A>メソッドがメソッドに対する後続の呼び出しより高い優先度のメッセージがキューに到着しない限り、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.Peek%2A>します。 <xref:System.Messaging.MessageQueue.Peek%2A>キューにメッセージは削除されませんが、nothing への呼び出しでロールバックするはず<xref:System.Messaging.MessageQueueTransaction.Abort%2A>します。  
  
 呼び出しを使用して、<xref:System.Messaging.MessageQueue.Receive%2A>の現在のスレッドが、メッセージがキューに到達するを待っている間にブロックされてもかまわない場合します。 、または指定された期間のスレッドをブロックは、値が指定されている場合<xref:System.Messaging.MessageQueue.InfiniteTimeout>の、`timeout`パラメーター。 アプリケーションの処理は、メッセージを待たずに続行する必要がある場合、非同期メソッドの使用を検討<xref:System.Messaging.MessageQueue.BeginReceive%2A>します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例では、このメソッドの使用を示します。  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、キューにメッセージが到達しませんでした。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="cursor">メッセージ キュー内の特定の位置を維持する <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>指定したカーソルを使用して、キューの現在のメッセージを受信します。 利用可能なメッセージがない場合、このメソッドは、メッセージが利用可能になるまで、またはタイムアウトが発生するまで待機します。</summary>
        <returns>キューのメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して定義されている内部トランザクション コンテキストを使用してトランザクション キューからメッセージを受信する、`transaction`パラメーター、およびキューにメッセージがない場合は、時間の指定した期間内の戻り値。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>キューから削除され、メッセージの同期読み取りメソッドを使用します。 後続の呼び出し<xref:System.Messaging.MessageQueue.Receive%2A>キューに続くメッセージを返します。  
  
 トランザクション キューでこのメソッドを呼び出すため、トランザクションが中止された場合、キューに受信したメッセージが返されます。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 キューから削除することがなくキュー内のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.Peek%2A>メソッド。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.Peek%2A>します。 <xref:System.Messaging.MessageQueue.Peek%2A>キューにメッセージは削除されませんへの呼び出しでロールバックを何もない<xref:System.Messaging.MessageQueueTransaction.Abort%2A>します。  
  
 呼び出しを使用して、<xref:System.Messaging.MessageQueue.Receive%2A>の現在のスレッドが、メッセージがキューに到達するを待っている間にブロックされてもかまわない場合します。 、または指定された期間のスレッドがブロックされている場合は、値を指定した<xref:System.Messaging.MessageQueue.InfiniteTimeout>の、`timeout`パラメーター。 アプリケーションの処理は、メッセージを待たずに続行する必要がある場合、非同期メソッドの使用を検討<xref:System.Messaging.MessageQueue.BeginReceive%2A>します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> パラメーターが <see langword="null" /> です。  
  
- または - 
<paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定された値が無効です。 <paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> より小さい値か、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> より大きい値である可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、キューにメッセージが到達しませんでした。  
  
- または - 
キューが非トランザクション キューです。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="cursor">メッセージ キュー内の特定の位置を維持する <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>指定したカーソルを使用して、キューの現在のメッセージを受信します。 利用可能なメッセージがない場合、このメソッドは、メッセージが利用可能になるまで、またはタイムアウトが発生するまで待機します。</summary>
        <returns>キューのメッセージを参照する <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して、定義されたトランザクションのコンテキストを使用してキューからメッセージを受信する、`transactionType`パラメーター、およびキューにメッセージがない場合は、時間の指定した期間の戻り値。  
  
 指定`Automatic`の`transactionType`外部トランザクション コンテキストが既に存在する場合は、パラメーターを使用してメッセージを受信する必要のあるスレッドにアタッチされています。 指定`Single`として 1 つの内部トランザクション メッセージを受信したい場合。 指定できる`None`トランザクション コンテキストの外でトランザクション キューからメッセージを受信する場合。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>キューから削除され、メッセージの同期読み取りメソッドを使用します。 後続の呼び出し<xref:System.Messaging.MessageQueue.Receive%2A>キューに続くメッセージを返します。  
  
 トランザクション キューからメッセージを受信するこのメソッドが呼び出されると、トランザクションが中止された場合、キューに受信したメッセージが返されます。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 キューから削除することがなくキュー内のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.Peek%2A>メソッド。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.Peek%2A>します。 <xref:System.Messaging.MessageQueue.Peek%2A>キューにメッセージは削除されませんへの呼び出しでロールバックを何もない<xref:System.Messaging.MessageQueueTransaction.Abort%2A>します。  
  
 呼び出しを使用して、<xref:System.Messaging.MessageQueue.Receive%2A>の現在のスレッドが、メッセージがキューに到達するを待っている間にブロックされてもかまわない場合します。 、または指定された期間のスレッドがブロックされている場合は、値を指定した<xref:System.Messaging.MessageQueue.InfiniteTimeout>の、`timeout`パラメーター。 アプリケーションの処理は、メッセージを待たずに続行する必要がある場合、非同期メソッドの使用を検討<xref:System.Messaging.MessageQueue.BeginReceive%2A>します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定された値が無効です。 <paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> より小さい値か、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> より大きい値である可能性があります。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、キューにメッセージが到達しませんでした。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <threadsafe>メソッドはスレッド セーフではありません。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した相関 ID と一致するメッセージを受信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">受信するメッセージの <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <summary>指定した相関 ID と一致するメッセージを (非トランザクション キューから) 受信します。現在、指定した相関 ID と一致するメッセージがキューに存在しない場合は、すぐに例外を発生させます。</summary>
        <returns>渡された <paramref name="correlationId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.CorrelationId" /> を持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドで参照される非トランザクション キューは、<xref:System.Messaging.MessageQueue>メッセージが<xref:System.Messaging.Message.CorrelationId%2A>、指定された一致`correlationId`パラメーター。 一致するメッセージがない場合、`correlationID`パラメーター、例外がスローされます。 それ以外の場合、メッセージがキューから削除し、アプリケーションに返されます。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>に関連する応答、レポート、または受信確認メッセージをキューに送信されるメッセージを関連付けるプロパティを使用します。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キュー内の最初のメッセージを返します、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>メソッドの一意の識別子を指定することで、メッセージを取得します。  
  
 キューから削除せずに指定した相関 id のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッド。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドがメソッドに対する後続の呼び出しより高い優先度のメッセージがキューに到着しない限り、同じメッセージが返されるように、キューで最初のメッセージが常を返します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、して、キューから注文を含むメッセージを送受信します。 元のメッセージに達したかと具体的には肯定受信確認を要求がキューから取得します。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="correlationId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">受信するメッセージの <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>指定した相関 ID と一致するメッセージを (トランザクション キューから) 受信します。現在、指定した相関 ID と一致するメッセージがキューに存在しない場合は、すぐに例外を発生させます。</summary>
        <returns>渡された <paramref name="correlationId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.CorrelationId" /> を持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドで参照されるトランザクション キューは、<xref:System.Messaging.MessageQueue>メッセージが<xref:System.Messaging.Message.CorrelationId%2A>、指定された一致`correlationId`パラメーター。 一致するメッセージがない場合、`correlationID`パラメーター、例外がスローされます。 メッセージがそれ以外の場合、キューから削除し、で定義された内部トランザクション コンテキストを使用してアプリケーションに返される、`transaction`パラメーター。  
  
 トランザクション キューでこのメソッドを呼び出したため、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>に関連する応答、レポート、または受信確認メッセージをキューに送信されるメッセージを関連付けるプロパティを使用します。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キュー内の最初のメッセージを返します、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>メソッドを使用して、その一意の識別子を指定することで、メッセージを取得します。  
  
 キューから削除せずに指定した相関 id のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッド。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドがメソッドに対する後続の呼び出しより高い優先度のメッセージがキューに到着しない限り、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>します。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>キューにメッセージは削除されませんがあるトランザクションが中止された場合はロールバックするものがありません。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> パラメーターが <see langword="null" /> です。  
  
- または - 
<paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="correlationId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">キューが非トランザクション キューです。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">受信するメッセージの <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>指定した相関 ID と一致するメッセージを受信します。現在、指定した相関 ID と一致するメッセージがキューに存在しない場合は、すぐに例外を発生させます。</summary>
        <returns>渡された <paramref name="correlationId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.CorrelationId" /> を持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドで参照されるキューは、<xref:System.Messaging.MessageQueue>メッセージが<xref:System.Messaging.Message.CorrelationId%2A>、指定された一致`correlationId`パラメーター。 一致するメッセージがない場合、`correlationID`パラメーター、例外がスローされます。 メッセージがそれ以外の場合、キューから削除し、で定義されたトランザクションのコンテキストを使用してアプリケーションに返される、`transactionType`パラメーター。  
  
 指定`Automatic`の`transactionType`外部トランザクション コンテキストが既に存在する場合は、パラメーターを使用してメッセージを受信する必要のあるスレッドにアタッチされています。 指定`Single`として 1 つの内部トランザクション メッセージを受信したい場合。 指定できる`None`トランザクション コンテキストの外でトランザクション キューからメッセージを受信する場合。  
  
 トランザクション キューからメッセージを受信するこのメソッドが呼び出されると、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>に関連する応答、レポート、または受信確認メッセージをキューに送信されるメッセージを関連付けるプロパティを使用します。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キュー内の最初のメッセージを返します、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>メソッドを使用して、その一意の識別子を指定することで、メッセージを取得します。  
  
 キューから削除せずに指定した相関 id のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッド。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドがメソッドに対する後続の呼び出しより高い優先度のメッセージがキューに到着しない限り、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>します。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>キューにメッセージは削除されませんがあるトランザクションが中止された場合はロールバックするものがありません。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="correlationId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">受信するメッセージの <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <summary>指定した相関 ID と一致するメッセージを (非トランザクション キューから) 受信します。指定した相関 ID のメッセージがキューで利用可能になるか、タイムアウトの時間が経過するまで待機します。</summary>
        <returns>渡された <paramref name="correlationId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.CorrelationId" /> を持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドで参照される非トランザクション キューは、<xref:System.Messaging.MessageQueue>メッセージが<xref:System.Messaging.Message.CorrelationId%2A>、指定された一致`correlationId`パラメーター。 このメソッドは、相関 id を持つメッセージがで指定されたかどうかを返しますすぐに、`correlationId`パラメーターが、キュー内にします。 それ以外の場合、メソッドは、新しいメッセージが到着する時間の指定された期間を待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが到達しませんが、例外がスローされます。  
  
 `timeout`パラメーターでこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、<xref:System.Messaging.Message.CorrelationId%2A>と一致している新しいメッセージの`correlationId`パラメーター。 されていない場合、このメソッドは、経由でタイムアウト期間を開始し、もう 1 つの新しいメッセージが到着するを待ちます。 そのため、タイムアウト期間内に到着する新しいメッセージが引き続き、あるせず、新しいメッセージが到着すると、タイムアウト期間が経過するまで、またはそのメッセージが到着するまで無期限に実行を続行するには、このメソッドの考えられる<xref:System.Messaging.Message.CorrelationId%2A>一致する、`correlationId`パラメーター。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>に関連する応答、レポート、または受信確認メッセージをキューに送信されるメッセージを関連付けるプロパティを使用します。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キュー内の最初のメッセージを返します、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>メソッドを使用して、その一意の識別子を指定することで、メッセージを取得します。  
  
 キューから削除せずに指定した相関 id のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッド。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドがメソッドに対する後続の呼び出しより高い優先度のメッセージがキューに到着しない限り、同じメッセージが返されるように、キューで最初のメッセージが常を返します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定した <paramref name="correlationId" /> を持つメッセージがキューに存在せず、タイムアウトが経過する前にキューに到達することもありませんでした。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">受信するメッセージの <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>指定した相関 ID と一致するメッセージを (トランザクション キューから) 受信します。指定した相関 ID のメッセージがキューで利用可能になるか、タイムアウトの時間が経過するまで待機します。</summary>
        <returns>渡された <paramref name="correlationId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.CorrelationId" /> を持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドで参照されるトランザクション キューは、<xref:System.Messaging.MessageQueue>メッセージが<xref:System.Messaging.Message.CorrelationId%2A>、指定された一致`correlationId`パラメーター。 このメソッドは、相関 id を持つメッセージがで指定されたかどうかを返しますすぐに、`correlationId`で定義された内部トランザクション コンテキストを使用して、キュー内のパラメーターは、`transaction`パラメーター。 それ以外の場合、メソッドは、新しいメッセージが到着する時間の指定された期間を待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが到達しませんが、例外がスローされます。  
  
 `timeout`パラメーターでこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、<xref:System.Messaging.Message.CorrelationId%2A>と一致している新しいメッセージの`correlationId`パラメーター。 されていない場合、このメソッドは、経由でタイムアウト期間を開始し、もう 1 つの新しいメッセージが到着するを待ちます。 そのため、タイムアウト期間内に到着する新しいメッセージが引き続き、あるせず、新しいメッセージが到着すると、タイムアウト期間が経過するまで、またはそのメッセージが到着するまで無期限に実行を続行するには、このメソッドの考えられる<xref:System.Messaging.Message.CorrelationId%2A>一致する、`correlationId`パラメーター。  
  
 トランザクション キューでこのメソッドを呼び出したため、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>に関連する応答、レポート、または受信確認メッセージをキューに送信されるメッセージを関連付けるプロパティを使用します。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キュー内の最初のメッセージを返します、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>メソッドを使用して、その一意の識別子を指定することで、メッセージを取得します。  
  
 キューから削除せずに指定した相関 id のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッド。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドがメソッドに対する後続の呼び出しより高い優先度のメッセージがキューに到着しない限り、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>します。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>キューにメッセージは削除されませんがあるトランザクションが中止された場合はロールバックするものがありません。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> パラメーターが <see langword="null" /> です。  
  
- または - 
<paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定した <paramref name="correlationId" /> を持つメッセージがキューに存在せず、タイムアウトが経過する前にキューに到達することもありませんでした。  
  
- または - 
キューが非トランザクション キューです。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">受信するメッセージの <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>指定した相関 ID と一致するメッセージを受信します。指定した相関 ID のメッセージがキューで利用可能になるか、タイムアウトの時間が経過するまで待機します。</summary>
        <returns>渡された <paramref name="correlationId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.CorrelationId" /> を持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドで参照されるキューは、<xref:System.Messaging.MessageQueue>メッセージが<xref:System.Messaging.Message.CorrelationId%2A>、指定された一致`correlationId`パラメーター。 このメソッドは、相関 id を持つメッセージがで指定されたかどうかを返しますすぐに、`correlationId`で定義されたトランザクションのコンテキストを使用して、キュー内のパラメーターは、`transactionType`パラメーター。 それ以外の場合、メソッドは、新しいメッセージが到着する時間の指定された期間を待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが到達しませんが、例外がスローされます。  
  
 `timeout`パラメーターでこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、<xref:System.Messaging.Message.CorrelationId%2A>と一致している新しいメッセージの`correlationId`パラメーター。 されていない場合、このメソッドは、経由でタイムアウト期間を開始し、もう 1 つの新しいメッセージが到着するを待ちます。 そのため、タイムアウト期間内に到着する新しいメッセージが引き続き、あるせず、新しいメッセージが到着すると、タイムアウト期間が経過するまで、またはそのメッセージが到着するまで無期限に実行を続行するには、このメソッドの考えられる<xref:System.Messaging.Message.CorrelationId%2A>一致する、`correlationId`パラメーター。 指定`Automatic`の`transactionType`外部トランザクション コンテキストが既に存在する場合は、パラメーターを使用してメッセージを受信する必要のあるスレッドにアタッチされています。 指定`Single`として 1 つの内部トランザクション メッセージを受信したい場合。 指定できる`None`トランザクション コンテキストの外でトランザクション キューからメッセージを受信する場合。  
  
 トランザクション キューからメッセージを受信するこのメソッドが呼び出されると、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>に関連する応答、レポート、または受信確認メッセージをキューに送信されるメッセージを関連付けるプロパティを使用します。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キュー内の最初のメッセージを返します、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>メソッドを使用して、その一意の識別子を指定することで、メッセージを取得します。  
  
 キューから削除せずに指定した相関 id のメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッド。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>メソッドがメソッドに対する後続の呼び出しより高い優先度のメッセージがキューに到着しない限り、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>します。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>キューにメッセージは削除されませんがあるトランザクションが中止された場合はロールバックするものがありません。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="correlationId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定した <paramref name="correlationId" /> を持つメッセージがキューに存在せず、タイムアウトが経過する前にキューに到達することもありませんでした。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した ID と一致するメッセージを受信し、キューから削除します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">受信するメッセージの <see cref="P:System.Messaging.Message.Id" />。</param>
        <summary>指定した ID と一致するメッセージを非トランザクション キューから受信します。現在、指定した ID と一致するメッセージがキューに存在しない場合は、すぐに例外を発生させます。</summary>
        <returns>渡された <paramref name="id" /> パラメーターと一致する <see cref="P:System.Messaging.Message.Id" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既知の識別子を持つメッセージを読み取り、キューから削除するには、このメソッドを使用します。 このメソッドは、キューにメッセージがない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.Id%2A>があるため最大で 1 つのメッセージと一致するキューでメッセージのプロパティがメッセージ キュー エンタープライズ全体で一意では、指定された`id`パラメーター。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キュー内の最初のメッセージを返します、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>メソッドの使用を受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得します。  
  
 キューから削除せずには、指定した識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッド。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドがメソッドに対する後続の呼び出しより高い優先度のメッセージがキューに到着しない限り、同じメッセージが返されるように、キューで最初のメッセージが常を返します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="id" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">受信するメッセージの <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>指定した ID と一致するメッセージを (トランザクション キューから) 受信します。現在、指定した ID と一致するメッセージがキューに存在しない場合は、すぐに例外を発生させます。</summary>
        <returns>渡された <paramref name="id" /> パラメーターと一致する <see cref="P:System.Messaging.Message.Id" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、既知の識別子を持つメッセージを読み取り、によって定義された内部トランザクション コンテキストを使用して、キューから削除する、`transaction`パラメーター。 このメソッド例外をスローすぐにキューにメッセージがない場合  
  
 <xref:System.Messaging.Message.Id%2A>があるため最大で 1 つのメッセージと一致するキューでメッセージのプロパティがメッセージ キュー エンタープライズ全体で一意では、指定された`id`パラメーター。  
  
 トランザクション キューでこのメソッドを呼び出したため、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キュー内の最初のメッセージを返します、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>メソッドの使用を受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得します。  
  
 キューから削除せずには、指定した識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッド。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドがメソッドに対する後続の呼び出しより高い優先度のメッセージがキューに到着しない限り、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>します。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>キューにメッセージは削除されませんがあるトランザクションが中止された場合はロールバックするものがありません。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> パラメーターが <see langword="null" /> です。  
  
- または - 
<paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="id" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">キューが非トランザクション キューです。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">受信するメッセージの <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>指定した ID と一致するメッセージを受信します。現在、指定した ID と一致するメッセージがキューに存在しない場合は、すぐに例外を発生させます。</summary>
        <returns>渡された <paramref name="id" /> パラメーターと一致する <see cref="P:System.Messaging.Message.Id" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既知の識別子を持つメッセージを読み取り、キューから削除するには、このメソッドを使用します。 このメソッドは、キューにメッセージがない場合は、すぐに例外をスローします。 メッセージがそれ以外の場合、キューから削除し、で定義されたトランザクションのコンテキストを使用してアプリケーションに返される、`transactionType`パラメーター。  
  
 指定`Automatic`の`transactionType`外部トランザクション コンテキストが既に存在する場合は、パラメーターを使用してメッセージを受信する必要のあるスレッドにアタッチされています。 指定`Single`として 1 つの内部トランザクション メッセージを受信したい場合。 指定できる`None`トランザクション コンテキストの外でトランザクション キューからメッセージを受信する場合。  
  
 <xref:System.Messaging.Message.Id%2A>があるため最大で 1 つのメッセージと一致するキューでメッセージのプロパティがメッセージ キュー エンタープライズ全体で一意では、指定された`id`パラメーター。 指定した識別子を持つメッセージが関連付けられているもの以外のキューの場合<xref:System.Messaging.MessageQueue>インスタンス、メッセージが見つかりません。  
  
 トランザクション キューからメッセージを受信するこのメソッドが呼び出されると、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キュー内の最初のメッセージを返します、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>メソッドの使用を受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得します。  
  
 キューから削除せずには、指定した識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッド。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドがメソッドに対する後続の呼び出しより高い優先度のメッセージがキューに到着しない限り、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>します。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>キューにメッセージは削除されませんがあるトランザクションが中止された場合はロールバックするものがありません。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="id" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">受信するメッセージの <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <summary>指定した ID と一致するメッセージを (非トランザクション キューから) 受信します。指定した ID のメッセージがキューで利用可能になるか、タイムアウトの時間が経過するまで待機します。</summary>
        <returns>渡された <paramref name="id" /> パラメーターと一致する <see cref="P:System.Messaging.Message.Id" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既知の識別子を持つメッセージを読み取り、キューから削除するには、このメソッドを使用します。 このメソッドはで指定した id のメッセージをすぐに返します、`id`パラメーターが、キュー内にします。 それ以外の場合、メソッドは、新しいメッセージが到着する時間の指定された期間を待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが到達しませんが、例外がスローされます。  
  
 `timeout`パラメーターでこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、<xref:System.Messaging.Message.Id%2A>と一致している新しいメッセージの`id`パラメーター。 されていない場合、このメソッドは、経由でタイムアウト期間を開始し、もう 1 つの新しいメッセージが到着するを待ちます。 そのため、タイムアウト期間内に到着する新しいメッセージが引き続き、あるせず、新しいメッセージが到着すると、タイムアウト期間が経過するまで、またはそのメッセージが到着するまで無期限に実行を続行するには、このメソッドの考えられる<xref:System.Messaging.Message.Id%2A>一致する、`id`パラメーター。  
  
 <xref:System.Messaging.Message.Id%2A>があるため最大で 1 つのメッセージと一致するキューでメッセージのプロパティがメッセージ キュー エンタープライズ全体で一意では、指定された`id`パラメーター。  
  
 このオーバー ロードを使用して、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>の現在のスレッドが、によって指定されたタイムアウト期間内にキューに到着する新しいメッセージが引き続き限りにブロックされてもかまわない場合、`timeout`パラメーター。 スレッドはブロックされますを少なくとも指定した期間、または値が指定されている場合<xref:System.Messaging.MessageQueue.InfiniteTimeout>の`timeout`パラメーター、または新しいメッセージが引き続きによって指定されたタイムアウト期間内にキューに到着する場合、 `timeout`パラメーター。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キュー内の最初のメッセージを返します、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>メソッドの使用を受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得します。  
  
 キューから削除せずには、指定した識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッド。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドがメソッドに対する後続の呼び出しより高い優先度のメッセージがキューに到着しない限り、同じメッセージが返されるように、キューで最初のメッセージが常を返します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、指定された <paramref name="id" /> を持つメッセージがキューに到達しませんでした。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">受信するメッセージの <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>指定した ID と一致するメッセージを (トランザクション キューから) 受信します。指定した ID のメッセージがキューで利用可能になるか、タイムアウトの時間が経過するまで待機します。</summary>
        <returns>渡された <paramref name="id" /> パラメーターと一致する <see cref="P:System.Messaging.Message.Id" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、既知の識別子を持つメッセージを読み取り、によって定義された内部トランザクション コンテキストを使用して、キューから削除する、`transaction`パラメーター。 このメソッドはで指定した id のメッセージをすぐに返します、`id`パラメーターが、キュー内にします。 それ以外の場合、メソッドは、新しいメッセージが到着する時間の指定された期間を待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが到達しませんが、例外がスローされます。  
  
 `timeout`パラメーターでこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、<xref:System.Messaging.Message.Id%2A>と一致している新しいメッセージの`id`パラメーター。 されていない場合、このメソッドは、経由でタイムアウト期間を開始し、もう 1 つの新しいメッセージが到着するを待ちます。 そのため、タイムアウト期間内に到着する新しいメッセージが引き続き、あるせず、新しいメッセージが到着すると、タイムアウト期間が経過するまで、またはそのメッセージが到着するまで無期限に実行を続行するには、このメソッドの考えられる<xref:System.Messaging.Message.Id%2A>一致する、`id`パラメーター。  
  
 <xref:System.Messaging.Message.Id%2A>があるため最大で 1 つのメッセージと一致するキューでメッセージのプロパティがメッセージ キュー エンタープライズ全体で一意では、指定された`id`パラメーター。  
  
 このオーバー ロードを使用して、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>の現在のスレッドが、によって指定されたタイムアウト期間内にキューに到着する新しいメッセージが引き続き限りにブロックされてもかまわない場合、`timeout`パラメーター。 スレッドはブロックされますを少なくとも指定した期間、または値が指定されている場合<xref:System.Messaging.MessageQueue.InfiniteTimeout>の`timeout`パラメーター、または新しいメッセージが引き続きで指定されたタイムアウト期間内にキューに到着する場合、 `timeout`パラメーター。  
  
 トランザクション キューでこのメソッドを呼び出したため、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キュー内の最初のメッセージを返します、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>メソッドの使用を受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得します。  
  
 キューから削除せずには、指定した識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッド。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドがより高い優先度のメッセージがキューに到着しない限り、メソッドに対する後続の呼び出しは、同じメッセージを返すために、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>します。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>キューにメッセージは削除されませんがあるトランザクションが中止された場合はロールバックするものがありません。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> パラメーターが <see langword="null" /> です。  
  
- または - 
<paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、指定された <paramref name="id" /> を持つメッセージがキューに到達しませんでした。  
  
- または - 
キューが非トランザクション キューです。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">受信するメッセージの <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">新しいメッセージを検査できるようになるまでの待機時間を示す <see cref="T:System.TimeSpan" />。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>指定した ID と一致するメッセージを受信します。指定した ID のメッセージがキューで利用可能になるか、タイムアウトの時間が経過するまで待機します。</summary>
        <returns>渡された <paramref name="id" /> パラメーターと一致する <see cref="P:System.Messaging.Message.Id" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既知の識別子を持つメッセージを読み取り、キューから削除するには、このメソッドを使用します。 このメソッドはで指定した id のメッセージをすぐに返します、`id`で定義されたトランザクションのコンテキストを使用して、キュー内のパラメーターは、`transactionType`パラメーター。 それ以外の場合、メソッドは、新しいメッセージが到着する時間の指定された期間を待機します。 タイムアウトの有効期限が切れる前に、新しいメッセージが到達しませんが、例外がスローされます。  
  
 `timeout`パラメーターでこのメソッドの実行時間の合計が指定されていません。 代わりに、新しいメッセージがキューに到達するまで待機する時間を指定します。 新しいメッセージが到着するたびに、このメソッドは、検査、<xref:System.Messaging.Message.Id%2A>と一致している新しいメッセージの`id`パラメーター。 されていない場合、このメソッドは、経由でタイムアウト期間を開始し、もう 1 つの新しいメッセージが到着するを待ちます。 そのため、タイムアウト期間内に到着する新しいメッセージが引き続き、あるせず、新しいメッセージが到着すると、タイムアウト期間が経過するまで、またはそのメッセージが到着するまで無期限に実行を続行するには、このメソッドの考えられる<xref:System.Messaging.Message.Id%2A>一致する、`id`パラメーター。  
  
 指定`Automatic`の`transactionType`外部トランザクション コンテキストが既に存在する場合は、パラメーターを使用してメッセージを受信する必要のあるスレッドにアタッチされています。 指定`Single`として 1 つの内部トランザクション メッセージを受信したい場合。 指定できる`None`トランザクション コンテキストの外でトランザクション キューからメッセージを受信する場合。  
  
 <xref:System.Messaging.Message.Id%2A>があるため最大で 1 つのメッセージと一致するキューでメッセージのプロパティがメッセージ キュー エンタープライズ全体で一意では、指定された`id`パラメーター。 指定した識別子を持つメッセージが関連付けられているもの以外のキューの場合<xref:System.Messaging.MessageQueue>インスタンス、メッセージが見つかりません。  
  
 このオーバー ロードを使用して、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>の現在のスレッドが、によって指定されたタイムアウト期間内にキューに到着する新しいメッセージが引き続き限りにブロックされてもかまわない場合、`timeout`パラメーター。 スレッドはブロックされますを少なくとも指定した期間、または値が指定されている場合<xref:System.Messaging.MessageQueue.InfiniteTimeout>の`timeout`パラメーター、または新しいメッセージが引き続きによって指定されたタイムアウト期間内にキューに到着する場合、 `timeout`パラメーター。  
  
 トランザクション キューからメッセージを受信するこのメソッドが呼び出されると、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 その他の 2 つのメソッドを使用すると、キューからメッセージを受信できます。 <xref:System.Messaging.MessageQueue.Receive%2A>メソッドは、キュー内の最初のメッセージを返します、<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>メソッドの使用を受信確認、レポート、またはキューに送信されるメッセージの結果として作成されたアプリケーションによって生成される応答メッセージを取得します。  
  
 キューから削除せずには、指定した識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッド。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>メソッドがメソッドに対する後続の呼び出しより高い優先度のメッセージがキューに到着しない限り、同じメッセージが返されるように、キューで最初のメッセージが常を返します。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>します。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>キューにメッセージは削除されませんがあるトランザクションが中止された場合はロールバックするものがありません。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> パラメーターに指定した値が無効です。<paramref name="timeout" /> が <see cref="F:System.TimeSpan.Zero" /> よりも小さいか、<see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /> よりも大きい可能性があります。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">タイムアウトが経過する前に、指定された <paramref name="id" /> を持つメッセージがキューに到達しませんでした。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>MSMQ 3.0 で導入されました。 特定のメッセージをキューから受信します。 メッセージは、参照識別子で指定することも、キューの前後の位置関係で指定することもできます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">受信するメッセージの <see cref="P:System.Messaging.Message.LookupId" />。</param>
        <summary>MSMQ 3.0 で導入されました。 非トランザクション キュー内の指定した参照識別子に一致するメッセージを受信します。</summary>
        <returns>渡された <paramref name="lookupId" /> パラメーターと一致する <see cref="P:System.Messaging.Message.LookupId" /> プロパティを持つ <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既知の参照識別子を持つメッセージを読み取り、キューから削除するには、このメソッドを使用します。 このメソッドは、キューにメッセージがない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.LookupId%2A>メッセージのプロパティは一意のキューにメッセージが存在するがあるため最大で 1 つのメッセージと一致するキューで、指定された`lookupId`パラメーター。  
  
 キューから削除せずには、指定した参照識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>メソッド。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="lookupId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">キュー内のメッセージを読み取る方法を指定する <see cref="T:System.Messaging.MessageLookupAction" /> のいずれか 1 つ。 次のいずれかを指定します。 
 <see langword="MessageLookupAction.Current" />: <c>lookupId</c> で指定されたメッセージを受信し、キューから削除します。  
  
 <see langword="MessageLookupAction.Next" />: <c>lookupId</c> で指定されたメッセージの次のメッセージを受信し、キューから削除します。  
  
 <see langword="MessageLookupAction.Previous" />: <c>lookupId</c> で指定されたメッセージの前のメッセージを受信し、キューから削除します。  
  
 <see langword="MessageLookupAction.First" />: キューの最初のメッセージを受信し、キューから削除します。 <c>lookupId</c> パラメーターは 0 に設定する必要があります。  
  
 <see langword="MessageLookupAction.Last" />: キューの最後のメッセージを受信し、キューから削除します。 <c>lookupId</c> パラメーターは 0 に設定する必要があります。</param>
        <param name="lookupId">受信するメッセージの <see cref="P:System.Messaging.Message.LookupId" /> か、0。 キューの最初または最後のメッセージにアクセスする場合は 0 を使用します。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>MSMQ 3.0 で導入されました。 特定のメッセージをトランザクション キューから受信します。 メッセージは、参照識別子で指定することも、キューの前後の位置関係で指定することもできます。</summary>
        <returns>渡された <paramref name="lookupId" /> パラメーターおよび <paramref name="action" /> パラメーターで指定された <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、既知の参照識別子を持つメッセージを読み取り、によって定義されたトランザクションのコンテキストを使用して、キューから削除する、`transaction`パラメーター。 このメソッドは、キューにメッセージがない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.LookupId%2A>メッセージのプロパティは一意のキューにメッセージが存在するがあるため最大で 1 つのメッセージと一致するキューで、指定された`lookupId`パラメーター。  
  
 トランザクション キューでこのメソッドを呼び出したため、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 キューから削除せずには、指定した識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>メソッド。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>します。 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>キューからメッセージは削除されませんがあるトランザクションが中止された場合はロールバックするものがありません。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="lookupId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。  
  
- または - 
キューが非トランザクション キューです。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> パラメーターが、<see cref="T:System.Messaging.MessageLookupAction" /> メンバーの 1 つではありません。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">キュー内のメッセージを読み取る方法を指定する <see cref="T:System.Messaging.MessageLookupAction" /> のいずれか 1 つ。 次のいずれかを指定します。 
 <see langword="MessageLookupAction.Current" />: <c>lookupId</c> で指定されたメッセージを受信し、キューから削除します。  
  
 <see langword="MessageLookupAction.Next" />: <c>lookupId</c> で指定されたメッセージの次のメッセージを受信し、キューから削除します。  
  
 <see langword="MessageLookupAction.Previous" />: <c>lookupId</c> で指定されたメッセージの前のメッセージを受信し、キューから削除します。  
  
 <see langword="MessageLookupAction.First" />: キューの最初のメッセージを受信し、キューから削除します。 <c>lookupId</c> パラメーターは 0 に設定する必要があります。  
  
 <see langword="MessageLookupAction.Last" />: キューの最後のメッセージを受信し、キューから削除します。 <c>lookupId</c> パラメーターは 0 に設定する必要があります。</param>
        <param name="lookupId">受信するメッセージの <see cref="P:System.Messaging.Message.LookupId" /> か、0。 キューの最初または最後のメッセージにアクセスする場合は 0 を使用します。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>MSMQ 3.0 で導入されました。 トランザクション コンテキストを指定して、特定のメッセージをキューから受信します。 メッセージは、参照識別子で指定することも、キューの前後の位置関係で指定することもできます。</summary>
        <returns>渡された <paramref name="action" /> パラメーターおよび <paramref name="lookupId" /> パラメーターで指定された <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、既知の参照識別子を持つメッセージを読み取り、によって定義されたトランザクションのコンテキストを使用して、キューから削除する、`transactionType`パラメーター。 このメソッドは、キューにメッセージがない場合は、すぐに例外をスローします。  
  
 <xref:System.Messaging.Message.LookupId%2A>メッセージのプロパティは一意のキューにメッセージが存在するがあるため最大で 1 つのメッセージと一致するキューで、指定された`lookupId`パラメーター。  
  
 キューから削除せずには、指定した識別子を持つメッセージを読み取り、使用、<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>メソッド。 呼び出しによって返されるメッセージに関連付けられたトランザクション コンテキストがない<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>します。 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>キューからメッセージは削除されませんがあるトランザクションが中止された場合はロールバックするものがありません。  
  
 指定`Automatic`の`transactionType`外部トランザクション コンテキストが既に存在する場合は、パラメーターを使用してメッセージを受信する必要のあるスレッドにアタッチされています。 指定`Single`として 1 つの内部トランザクション メッセージを受信したい場合。 指定できる`None`トランザクション コンテキストの外でトランザクション キューからメッセージを受信する場合。  
  
 トランザクション キューからメッセージを受信するこのメソッドが呼び出されると、受信したメッセージが返されます、キューにトランザクションが中止された場合。 メッセージは完全に削除されません、キューから、トランザクションがコミットされるまで。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">指定した <paramref name="lookupId" /> を持つメッセージは見つかりませんでした。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> パラメーターが、<see cref="T:System.Messaging.MessageLookupAction" /> メンバーの 1 つではありません。  
  
- または - 
<paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージがキューから削除されると発生します。 このイベントは、非同期操作 <see cref="M:System.Messaging.MessageQueue.BeginReceive" /> によって発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 非同期処理で発生させるために使用、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント メッセージが、キューで利用できるとします。  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 呼び出しによって開始された操作を完了するために使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>とメッセージをピーク時に、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントが発生します。  
  
 <xref:System.Messaging.ReceiveCompletedEventHandler> デリゲートを作成する場合は、イベントを処理するメソッドを指定します。 イベントをイベント ハンドラーに関連付けるには、デリゲートのインスタンスをイベントに追加します。 デリゲートを削除しない限り、そのイベントが発生すると常にイベント ハンドラーが呼び出されます。 イベント ハンドラー デリゲートの詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
   
  
## Examples  
 次のコード例は、名前付きイベント ハンドラーを作成します。 `MyReceiveCompleted`、にアタッチします、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベント ハンドラーのデリゲート、および呼び出し<xref:System.Messaging.MessageQueue.BeginReceive%2A>を開始する非同期の受信操作は、パスにあるキューで"。 \myQueue"。 ときに、<xref:System.Messaging.MessageQueue.ReceiveCompleted>イベントは、例では、メッセージを受信し、画面に、本文を書き込みます。 例を呼び出して<xref:System.Messaging.MessageQueue.BeginReceive%2A>に新しい非同期受信操作。  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>リソースの現在の状態を反映するには、<see cref="T:System.Messaging.MessageQueue" /> で表されるプロパティを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> 同期のプロパティを<xref:System.Messaging.MessageQueue>その関連付けられているメッセージ キュー サーバー リソース。 場合、任意のプロパティなど<xref:System.Messaging.MessageQueue.Label%2A>または<xref:System.Messaging.MessageQueue.Category%2A>後、に、サーバー上で変更が、<xref:System.Messaging.MessageQueue>が作成された<xref:System.Messaging.MessageQueue.Refresh%2A>更新プログラム、<xref:System.Messaging.MessageQueue>新しい情報を使用します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Refresh%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アクセス許可リストをオペレーティング システムの既定値にリセットします。 既定のリストに追加したキューのアクセス許可を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すと<xref:System.Messaging.MessageQueue.ResetPermissions%2A>、その既定値にアクセス許可の一覧を返します。 一般に、このキューの作成者は、すべてのアクセス許可を付与され、すべてのユーザー、グループは、次の権限。  
  
-   キューのプロパティを取得します。  
  
-   キューのアクセス許可を取得します。  
  
-   キューに書き込みます。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.ResetPermissions%2A> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>キューにオブジェクトを送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> で参照される非トランザクション キューにオブジェクトを送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用してを含むメッセージを送信する、`obj`パラメーターで参照されるキューを<xref:System.Messaging.MessageQueue>します。 キューに送信するオブジェクトは、<xref:System.Messaging.Message>または任意のマネージ オブジェクト。 以外の任意のオブジェクトを送信する場合、<xref:System.Messaging.Message>オブジェクトをシリアル化され、メッセージの本文に挿入します。  
  
 このオーバー ロードを使用して、トランザクション キューにメッセージを送信する場合は、配信不能キューに送信されます。 メッセージを他のメッセージを含むトランザクションの一部にする場合を受け取るオーバー ロードを使用して、<xref:System.Messaging.MessageQueueTransaction>または<xref:System.Messaging.MessageQueueTransactionType>をパラメーターとして。  
  
 設定しない場合、<xref:System.Messaging.MessageQueue.Formatter%2A>プロパティを呼び出す前に<xref:System.Messaging.MessageQueue.Send%28System.Object%29>、フォーマッタの既定値は、<xref:System.Messaging.XmlMessageFormatter>します。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>プロパティが以外の任意のオブジェクトに適用される、<xref:System.Messaging.Message>します。 または指定した場合、たとえば、ラベルを使用して、優先度、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>メンバー、これらの値がない型のオブジェクトを含むメッセージに適用<xref:System.Messaging.Message>送信すると、アプリケーションがキューにします。 送信するときに、 <xref:System.Messaging.Message>、プロパティ値を設定、<xref:System.Messaging.Message>優先<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>とメッセージの<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>プロパティは、キューの優先順位<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>プロパティ。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例では、メッセージ キューに接続し、キューにメッセージを送信します。  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 次のコード例は、アプリケーション定義を送信`Order`キュー クラスし、そのキューからメッセージを受信します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> で参照されるトランザクション キューにオブジェクトを送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用してを含むメッセージを送信する、`obj`パラメーターで参照されるトランザクション キューを<xref:System.Messaging.MessageQueue>で定義された内部トランザクション コンテキストを使用して、`transaction`パラメーター。 キューに送信するオブジェクトは、<xref:System.Messaging.Message>または任意のマネージ オブジェクト。 以外の任意のオブジェクトを送信する場合、<xref:System.Messaging.Message>オブジェクトをシリアル化され、メッセージの本文に挿入します。  
  
 このオーバー ロードを使用して非トランザクション キューにメッセージを送信する場合は、例外をスローせず、配信不能キューにメッセージが送信可能性があります。  
  
 設定しない場合、<xref:System.Messaging.MessageQueue.Formatter%2A>プロパティを呼び出す前に<xref:System.Messaging.MessageQueue.Send%28System.Object%29>、フォーマッタの既定値は、<xref:System.Messaging.XmlMessageFormatter>します。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>プロパティが以外の任意のオブジェクトに適用される、<xref:System.Messaging.Message>します。 または指定した場合、たとえば、ラベルを使用して、優先度、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>メンバー、これらの値がない型のオブジェクトを含むメッセージに適用<xref:System.Messaging.Message>送信すると、アプリケーションがキューにします。 送信するときに、 <xref:System.Messaging.Message>、プロパティ値を設定、<xref:System.Messaging.Message>優先<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>とメッセージの<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>プロパティは、キューの優先順位<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>プロパティ。  
  
 <xref:System.Messaging.MessageQueueTransaction> スレッドのアパートメントに対応して、アパートメントの状態の場合、 `STA`、複数のスレッドでトランザクションを使用することはできません。 Visual Basic にメイン スレッドの状態を設定する`STA`適用する必要がありますので、<xref:System.MTAThreadAttribute>で、`Main`サブルーチンです。 適用しない場合、別のスレッドを使用してトランザクション メッセージを送信すると、<xref:System.Messaging.MessageQueueException> 例外がスローされます。 適用する、<xref:System.MTAThreadAttribute>次のフラグメントを使用しています。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例では、トランザクション キューに文字列を送信し、そのキューからメッセージを受信します。  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
- または - 
メッセージ キュー アプリケーションが、トランザクションの使用が正しくないことを示しました。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> で参照されるキューにオブジェクトを送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用してを含むメッセージを送信する、`obj`パラメーターで参照されるキューを<xref:System.Messaging.MessageQueue>で定義されたトランザクションのコンテキストを使用して、`transactionType`パラメーター。 指定`Automatic`の`transactionType`外部トランザクション コンテキストが既に存在する場合は、パラメーターを使用して、メッセージを送信する必要のあるスレッドにアタッチされています。 指定`Single`として 1 つの内部トランザクション メッセージを送信する場合。 指定できる`None`トランザクションではないスレッドへトランザクション メッセージを送信する場合。  
  
 キューに送信するオブジェクトは、<xref:System.Messaging.Message>または任意のマネージ オブジェクト。 以外の任意のオブジェクトを送信する場合、<xref:System.Messaging.Message>オブジェクトをシリアル化され、メッセージの本文に挿入します。  
  
 設定しない場合、<xref:System.Messaging.MessageQueue.Formatter%2A>プロパティを呼び出す前に<xref:System.Messaging.MessageQueue.Send%28System.Object%29>、フォーマッタの既定値は、<xref:System.Messaging.XmlMessageFormatter>します。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>プロパティが以外の任意のオブジェクトに適用される、<xref:System.Messaging.Message>します。 または指定した場合、たとえば、ラベルを使用して、優先度、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>メンバー、これらの値がない型のオブジェクトを含むメッセージに適用<xref:System.Messaging.Message>送信すると、アプリケーションがキューにします。 送信するときに、 <xref:System.Messaging.Message>、プロパティ値を設定、<xref:System.Messaging.Message>優先<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>とメッセージの<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>プロパティは、キューの優先順位<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>プロパティ。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="label">メッセージのラベル。</param>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> で参照される非トランザクション キューにオブジェクトを送信し、メッセージのラベルを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用してを含むメッセージを送信する、`obj`パラメーターで参照されるキューを<xref:System.Messaging.MessageQueue>します。 このオーバー ロードで、メッセージを識別する文字列のラベルを指定できます。 キューに送信するオブジェクトは、 <xref:System.Messaging.Message>、構造体、データ オブジェクト、または任意のマネージ オブジェクト。 以外の任意のオブジェクトを送信する場合、<xref:System.Messaging.Message>オブジェクトをシリアル化され、メッセージの本文に挿入します。  
  
 メッセージ ラベルはメッセージ キューのラベルとは異なりますが、両方はアプリケーションに依存して、継承にキューにメッセージの意味のないです。  
  
 このオーバー ロードを使用して、トランザクション キューにメッセージを送信する場合は、配信不能キューに送信されます。 メッセージを他のメッセージを含むトランザクションの一部にする場合を受け取るオーバー ロードを使用して、<xref:System.Messaging.MessageQueueTransaction>または<xref:System.Messaging.MessageQueueTransactionType>をパラメーターとして。  
  
 <xref:System.Messaging.MessageQueue.Path%2A>プロパティをこの<xref:System.Messaging.MessageQueue>メッセージを送信する前に、インスタンスを指定する必要があります。 設定しない場合、<xref:System.Messaging.MessageQueue.Formatter%2A>プロパティを呼び出す前に<xref:System.Messaging.MessageQueue.Send%28System.Object%29>、フォーマッタの既定値は、<xref:System.Messaging.XmlMessageFormatter>します。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>プロパティが以外の任意のオブジェクトに適用される、<xref:System.Messaging.Message>します。 または指定した場合、たとえば、ラベルを使用して、優先度、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>メンバー、これらの値がない型のオブジェクトを含むメッセージに適用<xref:System.Messaging.Message>送信すると、アプリケーションがキューにします。 送信するときに、 <xref:System.Messaging.Message>、プロパティ値を設定、<xref:System.Messaging.Message>優先<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>とメッセージの<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>プロパティは、キューの優先順位<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>プロパティ。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="label">メッセージのラベル。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> オブジェクト。</param>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> で参照されるトランザクション キューにオブジェクトを送信し、メッセージのラベルを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用してを含むメッセージを送信する、`obj`パラメーターで参照されるトランザクション キューを<xref:System.Messaging.MessageQueue>で定義された内部トランザクション コンテキストを使用して、`transaction`パラメーター。 このオーバー ロードで、メッセージを識別する文字列のラベルを指定できます。 キューに送信するオブジェクトは、 <xref:System.Messaging.Message>、構造体、データ オブジェクト、または任意のマネージ オブジェクト。 以外の任意のオブジェクトを送信する場合、<xref:System.Messaging.Message>オブジェクトをシリアル化され、メッセージの本文に挿入します。  
  
 メッセージ ラベルはメッセージ キューのラベルとは異なりますが、両方はアプリケーションに依存して、継承にキューにメッセージの意味のないです。  
  
 このオーバー ロードを使用して非トランザクション キューにメッセージを送信する場合は、例外をスローせず、配信不能キューにメッセージが送信可能性があります。  
  
 設定しない場合、<xref:System.Messaging.MessageQueue.Formatter%2A>プロパティを呼び出す前に<xref:System.Messaging.MessageQueue.Send%28System.Object%29>、フォーマッタの既定値は、<xref:System.Messaging.XmlMessageFormatter>します。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>プロパティが以外の任意のオブジェクトに適用される、<xref:System.Messaging.Message>します。 または指定した場合、たとえば、ラベルを使用して、優先度、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>メンバー、これらの値がない型のオブジェクトを含むメッセージに適用<xref:System.Messaging.Message>送信すると、アプリケーションがキューにします。 送信するときに、 <xref:System.Messaging.Message>、プロパティ値を設定、<xref:System.Messaging.Message>優先<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>とメッセージの<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>プロパティは、キューの優先順位<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>プロパティ  
  
 <xref:System.Messaging.MessageQueueTransaction> スレッドのアパートメントに対応して、アパートメントの状態の場合、 `STA`、複数のスレッドでトランザクションを使用することはできません。 Visual Basic にメイン スレッドの状態を設定する`STA`適用する必要がありますので、<xref:System.MTAThreadAttribute>で、`Main`サブルーチンです。 適用しない場合、別のスレッドを使用してトランザクション メッセージを送信すると、<xref:System.Messaging.MessageQueueException> 例外がスローされます。 適用する、<xref:System.MTAThreadAttribute>次のフラグメントを使用しています。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> パラメーターが <see langword="null" /> です。  
  
- または - 
<paramref name="transaction" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
- または - 
メッセージ キュー アプリケーションが、トランザクションの使用方法が間違っていることを示しました。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">キューに送信するオブジェクト。</param>
        <param name="label">メッセージのラベル。</param>
        <param name="transactionType">メッセージと関連付けるトランザクション コンテキストの種類を示す、<see cref="T:System.Messaging.MessageQueueTransactionType" /> 値の 1 つ。</param>
        <summary>この <see cref="T:System.Messaging.MessageQueue" /> で参照されるキューにオブジェクトを送信し、メッセージのラベルを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用してを含むメッセージを送信する、`obj`パラメーターで参照されるキューを<xref:System.Messaging.MessageQueue>で定義されたトランザクションのコンテキストを使用して、`transactionType`パラメーター。 指定`Automatic`の`transactionType`外部トランザクション コンテキストが既に存在する場合は、パラメーターを使用して、メッセージを送信する必要のあるスレッドにアタッチされています。 指定`Single`として 1 つの内部トランザクション メッセージを送信する場合。 指定できる`None`トランザクションではないスレッドへトランザクション メッセージを送信する場合。  
  
 キューに送信するオブジェクトは、<xref:System.Messaging.Message>または任意のマネージ オブジェクト。 以外の任意のオブジェクトを送信する場合、<xref:System.Messaging.Message>オブジェクトをシリアル化され、メッセージの本文に挿入します。 このオーバー ロードで、メッセージを識別する文字列のラベルを指定できます。  
  
 メッセージ ラベルはメッセージ キューのラベルとは異なりますが、両方はアプリケーションに依存して、継承にキューにメッセージの意味のないです。  
  
 設定しない場合、<xref:System.Messaging.MessageQueue.Formatter%2A>プロパティを呼び出す前に<xref:System.Messaging.MessageQueue.Send%28System.Object%29>、フォーマッタの既定値は、<xref:System.Messaging.XmlMessageFormatter>します。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>プロパティが以外の任意のオブジェクトに適用される、<xref:System.Messaging.Message>します。 または指定した場合、たとえば、ラベルを使用して、優先度、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>メンバー、これらの値がない型のオブジェクトを含むメッセージに適用<xref:System.Messaging.Message>送信すると、アプリケーションがキューにします。 送信するときに、 <xref:System.Messaging.Message>、プロパティ値を設定、<xref:System.Messaging.Message>よりも優先<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>、およびメッセージの<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>プロパティは、キューの優先順位<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>プロパティ。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">メッセージ キュー アプリケーションが、トランザクションの使用方法が間違っていることを示しました。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> パラメーターが、<see cref="T:System.Messaging.MessageQueueTransactionType" /> メンバーの 1 つではありません。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> プロパティが設定されていません。  
  
- または - 
メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のセットにアクセス許可を追加します。 キューのプロパティとキューのメッセージにアクセスできるユーザーを制御します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">トラスティと付与するアクセス許可を指定する 1 つ以上のアクセス制御エントリを含む <see cref="T:System.Messaging.AccessControlList" />。</param>
        <summary>アクセス制御リストの内容に基づいてアクセス権をキューに割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 許可、拒否、またはデータ保護受託者とアクセス許可の情報を指定するアクセス制御エントリのコレクションを使用して権限を取り消すには、このオーバー ロードを使用します。 これは、使用して、たとえば、同時に複数のユーザーに許可します。  
  
 構築する際に指定したトラスティ、`ace`パラメーターは、個々 のユーザー、ユーザーのグループまたはコンピューターを指定できます。 トラスティが、個人の場合は、形式を使用して、 `DOMAIN` \\`user`します。 指定することができます"."トラスティがローカル コンピューターを指定します。  
  
 アクセス許可を割り当てる<xref:System.Messaging.MessageQueue.SetPermissions%2A>既存のリストに権限を追加します。 既定では、パブリックまたはプライベート キューの作成者がフル コントロール、およびキューのプロパティを取得し、アクセス許可を取得し、キューへの書き込みアクセス許可を持つすべてのユーザー、ドメイン グループです。 呼び出すと<xref:System.Messaging.MessageQueue.SetPermissions%2A>、既存の一覧の一番下に、ユーザーとアクセス許可の情報が追加されます。  
  
 システムは、各検証<xref:System.Messaging.AccessControlEntry>で、次のイベントのいずれかが発生するまでのシーケンス。  
  
-   アクセス拒否<xref:System.Messaging.AccessControlEntry>スレッドのアクセス トークンのトラスティのいずれかに要求されたアクセス権のいずれかを明示的に拒否されます。  
  
-   1 つまたは複数のアクセス許可<xref:System.Messaging.AccessControlEntry>項目のスレッドのアクセス トークンを明示的に記載のトラスティがすべての要求されたアクセス権を付与します。  
  
-   すべて<xref:System.Messaging.AccessControlEntry>項目がチェックされが少なくとも 1 つ要求されたアクセス権が許可されていない明示的に、アクセスが暗黙的に拒否される場合があります。  
  
 構築する際に、`dacl`パラメーターを追加する<xref:System.Messaging.AccessControlEntry>インスタンスを<xref:System.Messaging.AccessControlList>コレクション。 各アクセス制御エントリを作成する場合は、ジェネリック、または標準のアクセス権を指定できます。 キューの権限は、次の任意の組み合わせを指定できます。  
  
-   削除  
  
-   セキュリティの読み取り  
  
-   セキュリティを書き込み  
  
-   同期  
  
-   所有者を変更します。  
  
-   読み取り  
  
-   Write  
  
-   実行  
  
-   必須  
  
-   すべて  
  
-   なし  
  
 これらの権限は、ビットごとの OR 演算子を使用して組み合わせることができますのビット フラグのセットです。  
  
-   フル コントロール  
  
-   メッセージを削除します。  
  
-   メッセージが表示されます。  
  
-   メッセージをピークします。  
  
-   ジャーナル メッセージを受信します。  
  
-   キューのプロパティを取得します。  
  
-   キューのプロパティを設定します。  
  
-   アクセス許可を取得します。  
  
-   アクセス許可を設定  
  
-   キューの所有権を取得します。  
  
-   メッセージを書き込み  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29> の使用方法を示します。      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">ユーザー、アクセスの種類、およびアクセス許可の種類を指定する <see cref="T:System.Messaging.MessageQueueAccessControlEntry" />。</param>
        <summary>アクセス制御エントリの内容に基づいてアクセス権をキューに割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 許可、拒否、またはデータ保護受託者と権利の情報を指定するアクセス制御エントリを使用して権限を取り消すには、このオーバー ロードを使用します。  
  
 構築する際に指定したトラスティ、`ace`パラメーターは、個々 のユーザー、ユーザーのグループまたはコンピューターを指定できます。 トラスティが、個人の場合は、形式を使用して、 `DOMAIN` \\`user`します。 指定することができます"."トラスティがローカル コンピューターを指定します。  
  
 アクセス許可を割り当てる<xref:System.Messaging.MessageQueue.SetPermissions%2A>既存のリストに権限を追加します。 既定では、パブリックまたはプライベート キューの作成者がフル コントロール、およびキューのプロパティを取得し、アクセス許可を取得し、キューへの書き込みアクセス許可を持つすべてのユーザー、ドメイン グループです。 呼び出すと<xref:System.Messaging.MessageQueue.SetPermissions%2A>、既存の一覧の一番下に、ユーザーとアクセス許可の情報が追加されます。  
  
 システムは、各検証<xref:System.Messaging.AccessControlEntry>で、次のイベントのいずれかが発生するまでのシーケンス。  
  
-   アクセス拒否<xref:System.Messaging.AccessControlEntry>スレッドのアクセス トークンのトラスティのいずれかに要求されたアクセス権のいずれかを明示的に拒否されます。  
  
-   1 つまたは複数のアクセス許可<xref:System.Messaging.AccessControlEntry>項目のスレッドのアクセス トークンを明示的に記載のトラスティがすべての要求されたアクセス権を付与します。  
  
-   すべて<xref:System.Messaging.AccessControlEntry>項目がチェックされが少なくとも 1 つ要求されたアクセス権が許可されていない明示的に、アクセスが暗黙的に拒否される場合があります。  
  
 指定すると、キューの権限、`rights`パラメーターを作成するとき、<xref:System.Messaging.MessageQueueAccessControlEntry>次の任意の組み合わせを指定できます。  
  
-   フル コントロール  
  
-   メッセージを削除します。  
  
-   メッセージが表示されます。  
  
-   メッセージをピークします。  
  
-   ジャーナル メッセージを受信します。  
  
-   キューのプロパティを取得します。  
  
-   キューのプロパティを設定します。  
  
-   アクセス許可を取得します。  
  
-   アクセス許可を設定  
  
-   キューの所有権を取得します。  
  
-   メッセージを書き込み  
  
 `rights`のコンス トラクターで指定したパラメーター、`ace`パラメーターがのフラグ、<xref:System.Messaging.MessageQueueAccessRights>列挙体。 ビットごとの演算子を使用して組み合わせることができます、ビット フラグのセットを表す構築するときに、`rights`パラメーター。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">キューに対する追加のアクセス権を取得するそれぞれのユーザー、グループ、またはコンピューター。</param>
        <param name="rights">メッセージ キューが <c>user</c> に割り当てるキューに対するアクセス権のセットを示す <see cref="T:System.Messaging.MessageQueueAccessRights" />。</param>
        <summary>コンピューター、グループ、またはユーザーに指定したアクセス権を与えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、個々 のユーザーに指定された権限を付与できます。 ユーザーは、個々 のユーザー、ユーザー、グループ、またはコンピュータを含む任意の有効なトラスティであることができます。 ユーザーが個人の場合、形式を使用して、 `DOMAIN` \\ `user`の`user`パラメーター。 指定することができます"."の`user`パラメーターをローカル コンピューターを指定します。  
  
 アクセス許可を割り当てる<xref:System.Messaging.MessageQueue.SetPermissions%2A>既存のリストに権限を追加します。 既定では、パブリックまたはプライベート キューの作成者がフル コントロール、およびキューのプロパティを取得し、アクセス許可を取得し、キューへの書き込みアクセス許可を持つすべてのユーザー、ドメイン グループです。 呼び出すと<xref:System.Messaging.MessageQueue.SetPermissions%2A>、既存の一覧の一番下に、ユーザーとアクセス許可の情報が追加されます。  
  
 システムは、各検証<xref:System.Messaging.AccessControlEntry>で、次のイベントのいずれかが発生するまでのシーケンス。  
  
-   アクセス拒否<xref:System.Messaging.AccessControlEntry>スレッドのアクセス トークンのトラスティのいずれかに要求されたアクセス権のいずれかを明示的に拒否されます。  
  
-   1 つまたは複数のアクセス許可<xref:System.Messaging.AccessControlEntry>項目のスレッドのアクセス トークンを明示的に記載のトラスティがすべての要求されたアクセス権を付与します。  
  
-   すべて<xref:System.Messaging.AccessControlEntry>項目がチェックされが少なくとも 1 つ要求されたアクセス権が許可されていない明示的に、アクセスが暗黙的に拒否される場合があります。  
  
 指定された、キューの権限、`rights`パラメーターは、次の任意の組み合わせにすることができます。  
  
-   フル コントロール  
  
-   メッセージを削除します。  
  
-   メッセージが表示されます。  
  
-   メッセージをピークします。  
  
-   ジャーナル メッセージを受信します。  
  
-   キューのプロパティを取得します。  
  
-   キューのプロパティを設定します。  
  
-   アクセス許可を取得します。  
  
-   アクセス許可を設定  
  
-   キューの所有権を取得します。  
  
-   メッセージを書き込み  
  
 <xref:System.Messaging.MessageQueueAccessRights>列挙体は、ビルドをビットごとの演算子を使用して組み合わせることができますのビット フラグのセットを表します、`rights`パラメーター。  
  
 このオーバー ロードで使用、; のアクセス許可を付与することができますのみ失効または拒否することはできません。 別のオーバー ロードを使用すると、いずれかを明示的に付与する必要があります<xref:System.Messaging.AccessControlEntryType>以外`Allow`します。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="user" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">キューに対する追加のアクセス権を取得するそれぞれのユーザー、グループ、またはコンピューター。</param>
        <param name="rights">メッセージ キューが <c>user</c> に割り当てるキューに対するアクセス権のセットを示す <see cref="T:System.Messaging.MessageQueueAccessRights" />。</param>
        <param name="entryType">
          <c>rights</c> パラメーターで指定したアクセス許可で、付与、拒否、取り消しのどの操作を実行するかを指定する <see cref="T:System.Messaging.AccessControlEntryType" />。</param>
        <summary>アクセス制御の種類 (許可、拒否、取り消し、またはセット) からいずれかを指定して、コンピューター、グループ、またはユーザーに指定したアクセス権を付与します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 許可、拒否、または個々 のユーザーに対して指定された権限を取り消すには、このオーバー ロードを使用します。 ユーザーは、個々 のユーザー、ユーザー、グループ、またはコンピュータを含む任意の有効なトラスティであることができます。 ユーザーが個人の場合、形式を使用して、 `DOMAIN` \\ `user`の`user`パラメーター。 指定することができます"."の`user`パラメーターをローカル コンピューターを指定します。  
  
 アクセス許可を割り当てる<xref:System.Messaging.MessageQueue.SetPermissions%2A>既存のリストに権限を追加します。 既定では、パブリックまたはプライベート キューの作成者がフル コントロール、およびキューのプロパティを取得し、アクセス許可を取得し、キューへの書き込みアクセス許可を持つすべてのユーザー、ドメイン グループです。 呼び出すと<xref:System.Messaging.MessageQueue.SetPermissions%2A>、既存の一覧の一番下に、ユーザーとアクセス許可の情報が追加されます。  
  
 システムは、各検証<xref:System.Messaging.AccessControlEntry>で、次のイベントのいずれかが発生するまでのシーケンス。  
  
-   アクセス拒否<xref:System.Messaging.AccessControlEntry>スレッドのアクセス トークンのトラスティのいずれかに要求されたアクセス権のいずれかを明示的に拒否されます。  
  
-   1 つまたは複数のアクセス許可<xref:System.Messaging.AccessControlEntry>項目のスレッドのアクセス トークンを明示的に記載のトラスティがすべての要求されたアクセス権を付与します。  
  
-   すべて<xref:System.Messaging.AccessControlEntry>項目がチェックされが少なくとも 1 つ要求されたアクセス権が許可されていない明示的に、アクセスが暗黙的に拒否される場合があります。  
  
 指定された、キューの権限、`rights`パラメーターは、次の任意の組み合わせにすることができます。  
  
-   フル コントロール  
  
-   メッセージを削除します。  
  
-   メッセージが表示されます。  
  
-   メッセージをピークします。  
  
-   ジャーナル メッセージを受信します。  
  
-   キューのプロパティを取得します。  
  
-   キューのプロパティを設定します。  
  
-   アクセス許可を取得します。  
  
-   アクセス許可を設定  
  
-   キューの所有権を取得します。  
  
-   メッセージを書き込み  
  
 <xref:System.Messaging.MessageQueueAccessRights>列挙体は、ビルドをビットごとの演算子を使用して組み合わせることができますのビット フラグのセットを表します、`rights`パラメーター。  
  
 次の表では、このメソッドは、さまざまなワークグループ モードで使用するかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例は、<xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29> の使用方法を示します。  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> イベントまたは <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> イベントによって発生したイベント ハンドラー呼び出しをマーシャリングするオブジェクトを取得または設定します。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> イベントまたは <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> イベントによって発生したイベント ハンドラー呼び出しをマーシャリングするオブジェクトを表す <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Messaging.MessageQueue.ReceiveCompleted>または<xref:System.Messaging.MessageQueue.PeekCompleted>イベントの結果から、<xref:System.Messaging.MessageQueue.BeginReceive%2A>または<xref:System.Messaging.MessageQueue.BeginPeek%2A>要求、それぞれ、特定のスレッドにします。 通常、<xref:System.Messaging.MessageQueue.SynchronizingObject%2A>これらのコンポーネントは、特定のスレッドにバインドされるため、その関連コンポーネントが、コントロールまたはフォーム内に配置時に設定されます。  
  
 通常、同期オブジェクトでは、1 つのスレッドにメソッドの呼び出しをマーシャ リングします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キューがトランザクションだけを受け入れるかどうかを示す値を取得します。</summary>
        <value>キューがトランザクションの一部として送信されるメッセージだけを受け入れる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 トランザクション メッセージングは単一のトランザクションに関連するメッセージがいくつかの結合を表します。 順番にメッセージが配信されたことにより、トランザクションの一部としてメッセージを送信する、1 回だけ配信され、送信先のキューから正常に取得します。  
  
 キューがトランザクションの場合は、トランザクションの一部として送信されるメッセージだけを受け入れます。 非トランザクション メッセージを送信または明示的にトランザクションを使用せずにローカル トランザクション キューから受信した、 <xref:System.Messaging.MessageQueueTransaction.Begin%2A>、 <xref:System.Messaging.MessageQueueTransaction.Commit%2A>、および<xref:System.Messaging.MessageQueueTransaction.Abort%2A>構文。 非トランザクション メッセージをトランザクション キューに送信する場合このコンポーネントを作成します単一メッセージ トランザクション、以外を直接形式名を使用してリモート コンピューター上のキューを参照している場合。 このような状況での 1 つは作成されません、メッセージを送信するときに、トランザクション コンテキストを指定しない場合と、メッセージが配信不能キューに送信します。  
  
 トランザクション キューに非トランザクション メッセージを送信する場合、例外が発生した場合、メッセージをロールバックすることができなきます。  
  
 <xref:System.Messaging.MessageQueueTransaction> スレッドのアパートメントに対応して、アパートメントの状態の場合、 `STA`、複数のスレッドでトランザクションを使用することはできません。 Visual Basic にメイン スレッドの状態を設定する`STA`適用する必要がありますので、<xref:System.MTAThreadAttribute>で、`Main`サブルーチンです。 適用しない場合、別のスレッドを使用してトランザクション メッセージを送信すると、<xref:System.Messaging.MessageQueueException> 例外がスローされます。 適用する、<xref:System.MTAThreadAttribute>次のフラグメントを使用しています。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例は、メッセージ キューの値を表示します。<xref:System.Messaging.MessageQueue.Transactional%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_UseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>受信したメッセージを履歴キューにコピーするかどうかを示す値を取得または設定します。</summary>
        <value>キューから受信したメッセージを履歴キューにコピーする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ キュー アプリケーションでは、新しいアプリケーションのキューを作成するときに自動的に、同じ場所に、関連付けられたジャーナル キューを作成します。 ジャーナル キューを使用すると、キューから削除されたメッセージを追跡します。 このプロパティの設定には、メッセージ キューのキューが変更されます。 そのため、他<xref:System.Messaging.MessageQueue>インスタンスは、変更を受けます。  
  
 ジャーナル キューには、その時間---受信するタイマーの期限が切れても、(インフォメーション ストアまたは Active Directory) にメッセージ キュー ディレクトリ サービスを使用して、キューから削除されたメッセージは追跡のために、キューから削除されたメッセージは追跡しません。  
  
 アプリケーションは履歴キューにメッセージを送信することはできません。これらのキューの読み取り専用アクセスに限定されます。 さらに、メッセージ キュー メッセージを削除しませんジャーナル キューから。 受信するか、キューを削除することで、キューを使用して、アプリケーションはこれらのメッセージをクリアする必要があります。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|×|  
  
   
  
## Examples  
 次のコード例を取得し、メッセージ キューの値を設定<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>プロパティ。  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">メッセージ キューのメソッドにアクセスしたときにエラーが発生しました。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージ キューにメッセージを送信するときに使用するネイティブ ハンドルを取得します。</summary>
        <value>キューにメッセージを送信するときに使用するネイティブ キューオブジェクトへのハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.WriteHandle%2A>キューにメッセージを送信するために使用されるメッセージ キュー オブジェクトへのネイティブ Windows ハンドルを提供します。 キューのパスを変更する場合、ハンドルを閉じて、新しい値。  
  
 次の表では、このプロパティは、さまざまなワークグループ モードで使用できるかどうかを示します。  
  
|ワークグループ モード|使用可能|  
|--------------------|---------------|  
|ローカル コンピューター|[はい]|  
|ローカル コンピューターと直接形式名|[はい]|  
|リモート コンピューター|×|  
|リモート コンピューターと直接形式名|[はい]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">このメッセージ キューには書き込みができません。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>