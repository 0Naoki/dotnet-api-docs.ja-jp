<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="452b72d229254f13a5d2827bfeca0ec97c6f6675" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30461096" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>メッセージ キューのメッセージを定義するのに必要なプロパティへのアクセスを実現します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Messaging.Message>クラス、キューからメッセージをピークまたはまたはキューにメッセージを送信するときにメッセージのプロパティを細かく制御します。  
  
 <xref:System.Messaging.MessageQueue> 使用して、<xref:System.Messaging.Message>クラスをピークします。 または、キューからメッセージを受信ため両方、<xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType>と<xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType>メソッドの新しいインスタンスを作成する、<xref:System.Messaging.Message>クラスおよびインスタンスのプロパティを設定します。 <xref:System.Messaging.Message>クラスの読み取り専用プロパティを送信し、メッセージを取得する読み取り/書き込みプロパティを適用中に、キューからメッセージを取得するのには適用します。 ときに<xref:System.Messaging.MessageQueue>をピークします。 または、キューからメッセージを受信、<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>プロパティを取得するメッセージのプロパティを決定します。  
  
 <xref:System.Messaging.MessageQueue>クラスの<xref:System.Messaging.MessageQueue.Send%2A>メソッドでは、そのキューに送信されるメッセージの任意のオブジェクト型を指定することができます。 使用することができます、<xref:System.Messaging.MessageQueue>インスタンスの<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>プロパティはキューに送信される一般的なメッセージの設定を指定します。 設定の種類には、フォーマッタ、ラベル、暗号化、および認証が含まれます。 適切な値を指定することも<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>メンバーを確認してレポートのメッセージに応答するメッセージング アプリケーションを調整するときにします。 使用して、<xref:System.Messaging.Message>のインスタンスをキューにメッセージを送信する柔軟性にアクセスして、これらのプロパティの多くを変更する — 1 つのメッセージまたはメッセージのメッセージによってごとにします。 <xref:System.Messaging.Message> プロパティよりも優先<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>です。  
  
 メッセージ データが格納されている、<xref:System.Messaging.Message.Body%2A>プロパティと、いずれか小さいほうの範囲、<xref:System.Messaging.Message.AppSpecific%2A>と<xref:System.Messaging.Message.Extension%2A>プロパティです。 ときにメッセージ データが暗号化、シリアル化、または逆シリアル化の内容のみ、<xref:System.Messaging.Message.Body%2A>プロパティ影響を受けます。  
  
 内容、<xref:System.Messaging.Message.Body%2A>を使用して、メッセージを送信するときに、プロパティはシリアル化、<xref:System.Messaging.Message.Formatter%2A>プロパティを指定します。 シリアル化された内容は、<xref:System.Messaging.Message.BodyStream%2A>プロパティです。 設定することも、<xref:System.Messaging.Message.BodyStream%2A>プロパティを直接例については、メッセージの内容がデータ ファイルを送信します。 変更することができます、<xref:System.Messaging.Message.Body%2A>または<xref:System.Messaging.Message.Formatter%2A>を呼び出すときに、メッセージ、およびデータを送信する前にいつでもプロパティを適切にシリアル化される<xref:System.Messaging.MessageQueue.Send%2A>です。  
  
 によって定義されたプロパティ、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType>プロパティはない型のメッセージにのみ適用<xref:System.Messaging.Message>です。 指定した場合、<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>プロパティを<xref:System.Messaging.MessageQueue>では、同じ名前のプロパティで、<xref:System.Messaging.Message>インスタンスがそのキューの原因を無視するようにこれらの既定プロパティを送信します。  
  
 インスタンスの初期プロパティ値の一覧については<xref:System.Messaging.Message>を参照してください、<xref:System.Messaging.Message.%23ctor%2A>コンス トラクターです。  
  
   
  
## Examples  
 次のコード例では、メッセージ本文を使用して、書式設定を示しています<xref:System.Messaging.BinaryMessageFormatter>です。  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 次のコード例では、メッセージ本文を使用して、書式設定を示しています<xref:System.Messaging.XmlMessageFormatter>です。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Messaging.Message" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Messaging.Message" /> クラスの新しいインスタンスを空の本文で初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して、新しいインスタンスを作成する、<xref:System.Messaging.Message>空の本文を持つクラスであります。  
  
 いずれかを指定、<xref:System.Messaging.Message.Body%2A>プロパティまたは<xref:System.Messaging.Message.BodyStream%2A>を送信する前に、プロパティ、<xref:System.Messaging.Message>オブジェクト。 <xref:System.Messaging.Message.Body%2A>プロパティをテキスト文字列、構造体オブジェクト、クラスのインスタンスまたは埋め込みオブジェクトなど、シリアル化可能な任意のオブジェクトにすることができます。  
  
 直接メッセージの内容を記述しない限り、<xref:System.Messaging.Message.BodyStream%2A>プロパティ、設定、<xref:System.Messaging.Message.Formatter%2A>プロパティ、メッセージを送信する前にします。 使用して、本文がシリアル化、<xref:System.Messaging.Message.Formatter%2A>時のプロパティの値、<xref:System.Messaging.MessageQueue.Send%2A>メソッドが、<xref:System.Messaging.MessageQueue>インスタンス。  
  
 <xref:System.Messaging.XmlMessageFormatter> 、疎結合できるので、同じオブジェクトをこの形式を使用する場合、送信者と受信者を入力する必要はありません。 <xref:System.Messaging.ActiveXMessageFormatter>と<xref:System.Messaging.BinaryMessageFormatter>のバイナリ表現にデータをシリアル化します。 <xref:System.Messaging.ActiveXMessageFormatter> COM コンポーネントを送受信する際に使用します。  
  
 次の表は、のインスタンスの初期プロパティ値を示しています。<xref:System.Messaging.Message>です。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft ベース暗号化プロバイダーのバージョン 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|空の文字列 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|バイトの長さ 0 の配列|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|バイトの長さ 0 の配列|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|バイトの長さ 0 の配列|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|空の文字列 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|バイトの長さ 0 の配列|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 次のコード例では、キューに優先度が異なる 2 つのメッセージを送信し、順番に取得します。  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">メッセージの本文にシリアル化されるオブジェクト。</param>
        <summary>指定したオブジェクトをメッセージの本文にシリアル化するために <see cref="T:System.Messaging.XmlMessageFormatter" /> を使用して、<see cref="T:System.Messaging.Message" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して、新しいインスタンスを作成する、<xref:System.Messaging.Message>クラスを含む、<xref:System.Messaging.Message.Body%2A>によって指定された、`body`パラメーター。 `body`パラメーターは、文字列、構造体オブジェクト、クラスのインスタンスまたは埋め込みオブジェクトなど、シリアル化可能な任意のオブジェクトを指定できます。 使用して、本文がシリアル化、<xref:System.Messaging.XmlMessageFormatter>を変更しない限り、<xref:System.Messaging.Message.Formatter%2A>前に、プロパティ、<xref:System.Messaging.Message>送信します。 変更した場合、<xref:System.Messaging.Message.Body%2A>または<xref:System.Messaging.Message.Formatter%2A>プロパティを呼び出す前にいつでも<xref:System.Messaging.MessageQueue.Send%2A>、新しいプロパティ値に従ってメッセージをシリアル化されます。  
  
 <xref:System.Messaging.XmlMessageFormatter> 、疎結合できるので、同じオブジェクトをこの形式を使用する場合、送信者と受信者を入力する必要はありません。 <xref:System.Messaging.ActiveXMessageFormatter>と<xref:System.Messaging.BinaryMessageFormatter>のバイナリ表現にデータをシリアル化します。 <xref:System.Messaging.ActiveXMessageFormatter> COM コンポーネントを送受信する際に使用します。  
  
 次の表は、のインスタンスの初期プロパティ値を示しています。<xref:System.Messaging.Message>です。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft ベース暗号化プロバイダーのバージョン 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` パラメーター。|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|空の文字列 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|バイトの長さ 0 の配列|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|バイトの長さ 0 の配列|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|バイトの長さ 0 の配列|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|空の文字列 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|バイトの長さ 0 の配列|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 次のコード例を使用する、新しいキューを作成、注文が含まれており、それを取得するメッセージを送信します。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">メッセージの本文にシリアル化されるオブジェクト。</param>
        <param name="formatter">メッセージ本文をシリアル化するときに使うフォーマッタを指定する <see cref="T:System.Messaging.IMessageFormatter" />。</param>
        <summary>指定したオブジェクトをメッセージの本文にシリアル化するために指定したフォーマッタを使用して、<see cref="T:System.Messaging.Message" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して、新しいインスタンスを作成する、<xref:System.Messaging.Message>クラスを含む、<xref:System.Messaging.Message.Body%2A>によって指定された、`body`パラメーターを任意の有効なフォーマッタを使用して、本文をシリアル化します。 `body`パラメーターは文字列、構造体オブジェクト、クラスのインスタンスまたは埋め込みオブジェクトなど、シリアル化可能な任意のオブジェクト。 変更した場合、<xref:System.Messaging.Message.Body%2A>または<xref:System.Messaging.Message.Formatter%2A>プロパティを呼び出す前にいつでも<xref:System.Messaging.MessageQueue.Send%2A>、新しいプロパティ値に従ってメッセージをシリアル化されます。  
  
 <xref:System.Messaging.XmlMessageFormatter> 、疎結合できるので、同じオブジェクトをこの形式を使用する場合、送信者と受信者を入力する必要はありません。 <xref:System.Messaging.ActiveXMessageFormatter>と<xref:System.Messaging.BinaryMessageFormatter>のバイナリ表現にデータをシリアル化します。 <xref:System.Messaging.ActiveXMessageFormatter> COM コンポーネントを送受信する際に使用します。  
  
 次の表は、のインスタンスの初期プロパティ値を示しています。<xref:System.Messaging.Message>です。  
  
|プロパティ|初期値|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft ベース暗号化プロバイダーのバージョン 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` パラメーター。|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|空の文字列 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|バイトの長さ 0 の配列|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|バイトの長さ 0 の配列|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|バイトの長さ 0 の配列|  
|<xref:System.Messaging.Message.Formatter%2A>|`formatter` パラメーター。|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|空の文字列 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|バイトの長さ 0 の配列|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>送信元アプリケーションに返す受信確認メッセージのタイプを取得または設定します。</summary>
        <value>
          <see cref="T:System.Messaging.AcknowledgeTypes" /> 値の 1 つ。この値は、システムによって管理キューにポストされる受信確認メッセージのタイプと、送信元のアプリケーションに受信確認メッセージを返すときの条件を表します。 既定値は、<see langword="None" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AcknowledgeType%2A>プロパティは、送信元アプリケーションによって要求された受信確認メッセージの種類を指定します。 設定、<xref:System.Messaging.Message.AcknowledgeType%2A>特定の状況の通知を要求するメッセージを送信する前にプロパティ — など、メッセージ送信先キューに到達、取得されるメッセージまたはによりメッセージに到達するか、送信先キューから取得されているタイムアウトします。  
  
 メッセージ キューは受信確認メッセージを送信することで通知を返します、<xref:System.Messaging.Message.AdministrationQueue%2A>元のメッセージで指定されたプロパティ。 受信確認メッセージの<xref:System.Messaging.Message.Acknowledgment%2A>プロパティが表す受信確認の種類を示します。 たとえば、メッセージにする前に、変換先に到達しないため、受信確認メッセージが送信された場合、<xref:System.Messaging.Message.TimeToReachQueue%2A>間隔が経過した、<xref:System.Messaging.Message.Acknowledgment%2A>受信確認メッセージのプロパティの値が格納`ReachQueueTimeout`です。  
  
   
  
## Examples  
 次のコード例は、キューから注文を含むメッセージを送受信します。 元のメッセージが達した場合または具体的には、肯定受信確認の要求がキューから取得します。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージがフィルター処理され、<see cref="P:System.Messaging.Message.AcknowledgeType" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメッセージが表す受信確認の分類を取得します。</summary>
        <value>
          <see cref="T:System.Messaging.Acknowledgment" /> 列挙値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 管理キューからメッセージを受信するときに読み取り、<xref:System.Messaging.Message.Acknowledgment%2A>プロパティを元のメッセージの状態を確認します。  
  
 メッセージが送信先キューに送信されると、受信確認メッセージを投稿するメッセージ キューを要求できます。 このようなメッセージかなど、かどうか、指定されたタイムアウトは、内に取得されたメッセージに到着したどの配信に失敗した場合に発生したことを示していることができます。 送信先キューがメッセージを確認して、元のメッセージで指定される管理キューに送信を返します<xref:System.Messaging.Message.AdministrationQueue%2A>プロパティです。 <xref:System.Messaging.Message.Id%2A>受信確認メッセージのプロパティは、元のメッセージではなく、受信確認メッセージを識別します。 受信確認で元のメッセージの id を見つけることができます<xref:System.Messaging.Message>インスタンスの<xref:System.Messaging.Message.CorrelationId%2A>プロパティです。  
  
 この場合<xref:System.Messaging.Message>インスタンスが、受信確認メッセージを表す、<xref:System.Messaging.Message.Acknowledgment%2A>プロパティが受信確認の種類を指定します。 それ以外の場合、<xref:System.Messaging.Message.Acknowledgment%2A>プロパティ値を格納`Normal`です。  
  
 使用して、<xref:System.Messaging.Message.AcknowledgeType%2A>プロパティは、元のメッセージの受信確認が返されます状況を指定します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージは送信されていません。 このプロパティは、キューから取得したメッセージでだけ読み込むことができます。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージ キューによって生成される受信確認メッセージを受け取るキューを取得または設定します。</summary>
        <value>システムによって生成される受信確認メッセージ用の管理キューを指定する <see cref="T:System.Messaging.MessageQueue" />。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定されたキュー、<xref:System.Messaging.Message.AdministrationQueue%2A>プロパティは、任意の非トランザクション キューを使用できます。 管理キューに送信される受信確認メッセージは、元のメッセージが送信先キューに到達したかどうか、メッセージがキューから削除されたかどうかを示すことができます。  
  
 ときに、<xref:System.Messaging.Message.AcknowledgeType%2A>プロパティ以外の任意の値を持つ`None`、送信元アプリケーションは、管理キューとして使用するキューを指定する必要があります。  
  
   
  
## Examples  
 次のコード例は、キューから注文を含むメッセージを送受信します。 元のメッセージが達した場合または具体的には、肯定受信確認の要求がキューから取得します。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.AdministrationQueue" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション固有の追加情報を取得または設定します。</summary>
        <value>アプリケーションに固有の情報。 既定値は 0 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AppSpecific%2A>プロパティには、メッセージのさまざまな種類の編成に使用できるアプリケーション固有の情報が含まれています。 たとえば、アプリケーション固有のインデックスを使用できます。 解釈は、アプリケーションの責任である<xref:System.Messaging.Message.AppSpecific%2A>プロパティ情報です。  
  
 メッセージの本文でメッセージ データを含める必要があります、可能な限りではなく、<xref:System.Messaging.Message.AppSpecific%2A>プロパティです。  
  
 外部のキューを使用するときに使用して、<xref:System.Messaging.Message.Extension%2A>メッセージ キューの存在しないメッセージのプロパティを指定するプロパティです。 同様、<xref:System.Messaging.Message.AppSpecific%2A>のコンテンツを理解してアプリケーションの役割は、プロパティ、<xref:System.Messaging.Message.Extension%2A>プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.AppSpecific" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージが送信先キューに到達した時刻を取得します。</summary>
        <value>メッセージが送信先キューに到達した時刻を表す <see cref="T:System.DateTime" />。 この時刻は、グリニッジ平均時から、送信先キューが存在するコンピューターのローカル時間に調整されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージの<xref:System.Messaging.Message.TimeToBeReceived%2A>プロパティは、送信先キューからメッセージを受け取る必要がどの程度の速度を示します。 <xref:System.Messaging.Message.TimeToBeReceived%2A>メッセージがキューに到着したときではなく、メッセージが送信されるときに、プロパティのタイマーが開始します。  
  
   
  
## Examples  
 次のコード例には、メッセージの値が表示されます。<xref:System.Messaging.Message.ArrivedTime%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージは送信されていません。 このプロパティは、キューから取得したメッセージでだけ読み込むことができます。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.ArrivedTime" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージに送信者 ID を結び付ける必要があるかどうかを示す値を取得または設定します。</summary>
        <value>
          <see cref="P:System.Messaging.Message.SenderId" /> をメッセージに結び付ける場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderId%2A>プロパティを送信しているユーザーの識別子を表すバイトの配列です。 送信者 ID はメッセージ キューによって設定されているし、は、受信側キュー マネージャーによって使用送信者が、キューへのアクセス権を持つかどうかを確認します。  
  
 ID が示しているメッセージ キュー メッセージの送信者を検証やは避けてください送信者のアクセスの確認の送信元アプリケーションによって、送信者がない場合は、受信側のキューに権限です。 <xref:System.Messaging.Message.SenderId%2A>が信頼できるは、メッセージが送信先キューに達したときに認証された場合にのみです。 キューが認証されたメッセージのみとするかを受け入れる場合、送信先キューに達すると、メッセージが拒否された、<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>または<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>プロパティは`false`します。  
  
> [!CAUTION]
>  配信不能キューに送信するか、メッセージが拒否された場合は (場合<xref:System.Messaging.Message.UseDeadLetterQueue%2A>は`true`)、または無視されます。 メッセージがキューに到達できないときに、受信確認を要求できます。 それ以外の場合、when<xref:System.Messaging.Message.UseDeadLetterQueue%2A>は`false`メッセージは警告なし失われる可能性があります。  
  
   
  
## Examples  
 次のコード例を取得し、メッセージの値を設定<xref:System.Messaging.Message.AttachSenderId%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.AttachSenderId" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージが認証されたかどうかを示す値を取得します。</summary>
        <value>
          メッセージがキューに格納されたときにメッセージの認証が要求された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Authenticated%2A>メッセージと対話し、認証が要求されたかどうかの判断を行うには、中には、プロパティをアプリケーションでのみ使用します。 メッセージがキュー内にある場合は、メッセージが認証されました。 逆に場合、<xref:System.Messaging.Message.Authenticated%2A>プロパティは`true`、そのメッセージを受信すると、受信側キュー マネージャーがメッセージを認証します。  
  
 メッセージのプロパティを調べることで認証に失敗したかどうかを判断できません。 メッセージ キューは、キューに配信される前に認証に失敗したメッセージを破棄します。 ただし、配信の失敗が原因で、メッセージがキューに到着した場合に、受信確認メッセージを送信することを要求することができます。  
  
   
  
## Examples  
 次のコード例には、メッセージの値が表示されます。<xref:System.Messaging.Message.Authenticated%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージは送信されていません。 このプロパティは、キューから取得したメッセージでだけ読み込むことができます。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.Authenticated" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージのデジタル署名を生成するのに使われる暗号化プロバイダーの名前を取得または設定します。</summary>
        <value>メッセージのデジタル署名を生成するのに使われる暗号化プロバイダーの名前。 既定値は Microsoft ベース暗号化プロバイダー Version 1.0 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常使用する、<xref:System.Messaging.Message.AuthenticationProviderName%2A>外部キューを使用する場合。 メッセージ キューは、暗号化サービス プロバイダーを外部のキューに送信されたメッセージと外部のキューからメッセージ キューに渡されるメッセージの両方のデジタル署名を検証する (認証プロバイダー) の認証プロバイダーの種類と認証プロバイダーの名前が必要です。  
  
 メッセージを送信するときは常に設定、<xref:System.Messaging.Message.AuthenticationProviderName%2A>と<xref:System.Messaging.Message.ConnectorType%2A>プロパティを同時にします。 コネクタの種類にも設定されていない場合、メッセージ キュー メッセージを送信するときに認証のプロバイダー名を無視します。  
  
 <xref:System.Messaging.Message.AuthenticationProviderName%2A>プロパティは、`null`が空の文字列を指定できます ("") です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> プロパティを設定できませんでした。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.AuthenticationProviderName" /> プロパティを無視します。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> が <see langword="null" /> に設定されました。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージのデジタル署名を生成するのに使われる暗号化プロバイダーの種類を取得または設定します。</summary>
        <value>
          <see cref="T:System.Messaging.CryptographicProviderType" /> 値のいずれか 1 つ。 既定値は、<see langword="RSA_FULL" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常使用する、<xref:System.Messaging.Message.AuthenticationProviderType%2A>プロパティを指定する暗号化サービス プロバイダーは、メッセージに関連付けられた外部のキューを使用する場合。 メッセージ キューは、暗号化サービス プロバイダーを外部のキューに送信されたメッセージと外部のキューからメッセージ キューに渡されるメッセージの両方のデジタル署名を検証する (認証プロバイダー) の認証プロバイダーの種類と認証プロバイダーの名前が必要です。  
  
 のみ`RsaFull`メッセージングで使用するためのものでは、します。  
  
 メッセージを送信するときは常に設定、<xref:System.Messaging.Message.AuthenticationProviderType%2A>と<xref:System.Messaging.Message.ConnectorType%2A>プロパティを同時にします。 コネクタの種類にも設定されていない場合、メッセージ キュー メッセージを送信するときに認証プロバイダーの種類を無視します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> プロパティを設定できませんでした。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.AuthenticationProviderType" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージの内容を取得または設定します。</summary>
        <value>メッセージの内容を指定するオブジェクト。 オブジェクトとして使用できるのは、文字列、日付、通貨、数値、バイト配列、または任意のマネージ オブジェクトです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージの<xref:System.Messaging.Message.Body%2A>プロパティには、通常、メッセージに関連付けられているデータが含まれます。 アプリケーション固有のデータを送信することもできますが、<xref:System.Messaging.Message.AppSpecific%2A>と<xref:System.Messaging.Message.Extension%2A>プロパティ内のメッセージ データを含める必要があります、<xref:System.Messaging.Message.Body%2A>可能な限り、メッセージのです。 のみ、<xref:System.Messaging.Message.Body%2A>プロパティの内容がシリアル化または暗号化します。  
  
 <xref:System.Messaging.Message.Body%2A>プロパティは、そのサイズが 4 MB を超えない任意のオブジェクトを含めることができます。 使用する場合<xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType>れていない型の任意のオブジェクトを送信する<xref:System.Messaging.Message>を<xref:System.Messaging.MessageQueue>、そのオブジェクトに配置されます、<xref:System.Messaging.Message.Body%2A>のプロパティ、<xref:System.Messaging.Message>によって返されるインスタンス<xref:System.Messaging.MessageQueue.Peek%2A>または<xref:System.Messaging.MessageQueue.Receive%2A>です。  
  
 文字列の引数`MessageQueue.Send("hello.")`このような汎用オブジェクトの例に示します。  
  
 <xref:System.Messaging.Message.BodyType%2A>プロパティは、メッセージ本文に格納されている情報の種類を示します。 メッセージ キューでは、この情報を使用して、特定の種類、<xref:System.Messaging.Message.Body%2A>プロパティの内容。  
  
 いずれかを指定、<xref:System.Messaging.Message.Body%2A>プロパティまたは<xref:System.Messaging.Message.BodyStream%2A>を送信する前に、プロパティ、<xref:System.Messaging.Message>オブジェクト。 <xref:System.Messaging.Message.Body%2A>プロパティは、任意のテキスト文字列などのシリアル化可能なオブジェクト、構造体オブジェクト、クラスのインスタンスまたは埋め込みオブジェクトを指定できます。  
  
 直接メッセージの内容を記述しない限り、<xref:System.Messaging.Message.BodyStream%2A>プロパティ、設定、<xref:System.Messaging.Message.Formatter%2A>プロパティ、メッセージを送信する前にします。 ときに、<xref:System.Messaging.MessageQueue.Send%2A>メソッドが、<xref:System.Messaging.MessageQueue>に含まれているフォーマッタを使用して、インスタンス、本文がシリアル化、<xref:System.Messaging.Message.Formatter%2A>プロパティです。 値を指定せず、メッセージを送信するかどうか、<xref:System.Messaging.Message.Formatter%2A>プロパティ、フォーマッタの既定値<xref:System.Messaging.XmlMessageFormatter>です。  
  
> [!NOTE]
>  メッセージの本文を設定しようとしています。<xref:System.Decimal.MaxValue>により、<xref:System.OverflowException>ときに、`Send`のメソッド、<xref:System.Messaging.MessageQueue>クラスが呼び出されますと<xref:System.Messaging.ActiveXMessageFormatter>を使用します。  
  
   
  
## Examples  
 次のコード例では、キューに優先度が異なる 2 つのメッセージを送信し、順番に取得します。  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Messaging.Message.Formatter" /> プロパティが <see langword="null" /> です。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.Body" /> プロパティを無視します。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージの本文の情報を取得または設定します。</summary>
        <value>メッセージの <see cref="T:System.IO.Stream" /> に含まれるシリアル化された情報を格納する <see cref="P:System.Messaging.Message.Body" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージの本文がどの型の情報で構成できます: 文字列、日付、通貨、数値、(バイト単位) の配列または任意のマネージ オブジェクトなどです。 この情報がシリアル化、<xref:System.IO.Stream>キューに渡されます。  
  
 いずれかを指定、<xref:System.Messaging.Message.Body%2A>プロパティまたは<xref:System.Messaging.Message.BodyStream%2A>を送信する前に、プロパティ、<xref:System.Messaging.Message>オブジェクト。 設定した場合、<xref:System.Messaging.Message.Body%2A>プロパティ、内容がシリアル化するのには<xref:System.Messaging.Message.BodyStream%2A>プロパティです。 ただし、書き込みを選択できます、<xref:System.Messaging.Message.BodyStream%2A>プロパティを直接です。 これはファイルへの接続を開くし、メッセージの本文としてその内容をストリーム配信するときに便利です。  
  
 直接メッセージの内容を記述しない限り、<xref:System.Messaging.Message.BodyStream%2A>プロパティ、設定、<xref:System.Messaging.Message.Formatter%2A>プロパティ、メッセージを送信する前にします。 ときに、<xref:System.Messaging.MessageQueue.Send%2A>メソッドが、<xref:System.Messaging.MessageQueue>に含まれているフォーマッタを使用して、インスタンス、本文がシリアル化、<xref:System.Messaging.Message.Formatter%2A>プロパティです。 値を指定せず、メッセージを送信するかどうか、<xref:System.Messaging.Message.Formatter%2A>プロパティ、フォーマッタの既定値<xref:System.Messaging.XmlMessageFormatter>です。  
  
 設定した場合、<xref:System.Messaging.Message.UseEncryption%2A>プロパティを`true`送信されるとき、設定するときではなく、このメッセージの本文のメッセージが暗号化する、<xref:System.Messaging.Message.Body%2A>プロパティです。 したがって、<xref:System.Messaging.Message.BodyStream%2A>プロパティは暗号化されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.Body" /> プロパティを無視します。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージ本文に含まれるデータ型を取得または設定します。</summary>
        <value>文字列、日付、通貨、数値など、メッセージ本文の実際の型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ キューはオブジェクトまたはシリアル化されたストリームとして、本文の内容を認識します。 <xref:System.Messaging.Message.BodyType%2A>プロパティ内のオブジェクトの種類を示します、<xref:System.Messaging.Message.Body%2A>メッセージのプロパティです。  
  
 <xref:System.Messaging.XmlMessageFormatter>メッセージ本文内でネイティブ型とオブジェクトの間のバインドを実行します。 使用する場合、 <xref:System.Messaging.XmlMessageFormatter>、フォーマッタのセット、<xref:System.Messaging.Message.BodyType%2A>するプロパティです。  
  
 その他のフォーマッタは、バインディング機能をさらに、次の c# コードに示すように提供できます。  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 次のコード例には、メッセージの値が表示されます。<xref:System.Messaging.Message.BodyType%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.Body" /> プロパティを無視します。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>通常ではメッセージ キューによって設定されるメッセージ プロパティが、実際には送信元アプリケーションによって設定されたことを示す値を取得または設定します。</summary>
        <value>アプリケーションによって定義され、コネクタ アプリケーションまたはメッセージ暗号方式と共に使われる <see cref="T:System.Guid" />。 この <see cref="T:System.Guid" /> を使うと、受信側アプリケーションは、通常はメッセージ キューによって設定されますが、実際には送信元アプリケーションによって設定されたメッセージ プロパティを解釈できます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ キューが必要です、<xref:System.Messaging.Message.ConnectorType%2A>プロパティは、アプリケーションは通常、メッセージ キューによって設定されるメッセージ プロパティを設定するときに設定します。 アプリケーションは、<xref:System.Messaging.Message.ConnectorType%2A>次の 2 つの場合。  
  
-   ときに、コネクタ アプリケーションは、メッセージを渡します。 <xref:System.Messaging.Message.ConnectorType%2A>送信側と受信側のアプリケーション メッセージのセキュリティおよび受信確認プロパティを解釈する方法について説明します。  
  
-   ときに、送信元アプリケーションではなく、メッセージ キューがメッセージを暗号化します。 <xref:System.Messaging.Message.ConnectorType%2A>メッセージがキューを使用するように指示、<xref:System.Messaging.Message.DestinationSymmetricKey%2A>プロパティの値をメッセージの暗号化を解除します。  
  
 設定する必要があります、<xref:System.Messaging.Message.ConnectorType%2A>プロパティ、次のプロパティを設定した場合 (それ以外の場合、キューを無視するこれらのプロパティ、メッセージの送信時)。  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.ConnectorType" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>元のメッセージを参照するために、受信確認メッセージ、レポート メッセージ、応答メッセージによって使われるメッセージ ID を取得または設定します。</summary>
        <value>元のメッセージの <see cref="P:System.Messaging.Message.Id" /> プロパティによって指定されるメッセージ ID。 相関関係 ID は、メッセージ キューが受信確認メッセージまたはレポート メッセージを生成するときにメッセージ キューによって、またアプリケーションが応答メッセージを生成するときにアプリケーションによってそれぞれ使用されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ キュー、受信確認メッセージまたはレポート メッセージを生成するときの相関関係の識別子プロパティを使用して、元のメッセージのメッセージ識別子を指定します。 その結果、相関 ID によってレポート メッセージまたは受信確認メッセージが、元のメッセージに結び付けられます。  
  
 送信元アプリケーションと照合受信確認メッセージまたは元のメッセージを含むレポートを使用して、 <xref:System.Messaging.Message.CorrelationId%2A> 、元のメッセージを識別するプロパティ<xref:System.Messaging.Message.Id%2A>プロパティです。  
  
 またコネクタ アプリケーションを設定する必要があります、<xref:System.Messaging.Message.CorrelationId%2A>元のメッセージのメッセージ id を確認し、レポート メッセージのプロパティです。  
  
 アプリケーションは、送信元アプリケーションに応答メッセージを送信する場合は、設定、<xref:System.Messaging.Message.CorrelationId%2A>元のメッセージのメッセージ id への応答メッセージのプロパティです。 送信元アプリケーションは、送信されたメッセージに応答メッセージを適合できます。  
  
   
  
## Examples  
 次のコード例は、キューから注文を含むメッセージを送受信します。 元のメッセージが達した場合または具体的には、肯定受信確認の要求がキューから取得します。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.CorrelationId" /> プロパティを無視します。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.CorrelationId" /> が <see langword="null" /> です。</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージの目的の送信先キューを取得します。</summary>
        <value>メッセージの送信先キューを指定する <see cref="T:System.Messaging.MessageQueue" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.DestinationQueue%2A>プロパティは、ジャーナルや配信不能キューに到達したメッセージの元の送信先を判断する最もよく使用します。 通常、する必要はありません、このプロパティを確認するメッセージが送信先キューから取得するため。  
  
   
  
## Examples  
 次のコード例には、メッセージの値が表示されます。<xref:System.Messaging.Message.DestinationQueue%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージは送信されていません。 このプロパティは、キューから取得したメッセージでだけ読み込むことができます。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.DestinationQueue" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションによって暗号化されるメッセージ、または外部キューに送信されるメッセージを暗号化するために使用する対称キーを取得または設定します。</summary>
        <value>メッセージを暗号化するために使用される送信先対称キーを指定するバイト値配列。 既定値は長さ 0 の配列です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 2 つのシナリオでは、使用する必要があります、<xref:System.Messaging.Message.DestinationSymmetricKey%2A>プロパティです。 最初は、アプリケーションではなく、メッセージ キュー、メッセージを暗号化するときです。 2 つ目は、メッセージ キュー以外のキュー システムに暗号化されたメッセージを送信する場合です。  
  
 このプロパティを設定する前に、受信側キュー マネージャーの公開キーで対称キーを暗号化する必要があります。 アプリケーションで暗号化されたメッセージを送信するときに、受信側キュー マネージャーは、送信先キューに送信する前に、メッセージの暗号化を解除するのに対称キーを使用します。  
  
 外部のキューにメッセージを送信する場合、メッセージはまず、受信側アプリケーションに接続されている対称キーで暗号化されたメッセージを転送する適切なコネクタ アプリケーションによって受信されます。 対称キーを使用して、メッセージの暗号化を解除する受信側のアプリケーションの役割です。  
  
 設定すると、<xref:System.Messaging.Message.DestinationSymmetricKey%2A>プロパティを設定する必要も、<xref:System.Messaging.Message.ConnectorType%2A>プロパティです。 メッセージが送信されると、メッセージ キューは無視、<xref:System.Messaging.Message.DestinationSymmetricKey%2A>プロパティ場合、<xref:System.Messaging.Message.ConnectorType%2A>プロパティも設定されていません。  
  
 <xref:System.Messaging.Message.DestinationSymmetricKey%2A>プロパティが 256 の配列の最大サイズ。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> プロパティを無視します。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> が <see langword="null" /> です。</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージ キューがメッセージの認証に使用するデジタル署名を取得または設定します。</summary>
        <value>メッセージを認証するのに使われるメッセージ キュー 1.0 デジタル署名を指定するバイト値配列。 既定値は長さ 0 の配列です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ キューは、メッセージは、バージョン 1.0 をキューから送信されたメッセージを認証するときにデジタル署名を使用します。 ほとんどの場合、メッセージ キューを生成し、設定、<xref:System.Messaging.Message.DigitalSignature%2A>プロパティ、送信元アプリケーションは認証を要求したときにします。 受信側のアプリケーションでは、このプロパティを使用して、メッセージに添付したデジタル署名を取得します。  
  
 のみ使用できます、<xref:System.Messaging.Message.DigitalSignature%2A>プロパティ メッセージ キュー 2.0 を実行するときにします。 送信アプリケーションは、認証を要求するときに、バージョン 1.0 の署名をメッセージ キューを指定する必要があります。 送信側のアプリケーションでは、メッセージ キュー 2.0 署名を送信する場合、このプロパティは、次の 4 つ (バイト単位) を含む各 0 のバッファーを表します。  
  
 <xref:System.Messaging.Message.DigitalSignature%2A>と連携して、プロパティ、<xref:System.Messaging.Message.SenderCertificate%2A>プロパティは、メッセージが送信されるときもコネクタ アプリケーションによって使用されます。 このシナリオでは、コネクタ アプリケーションで、メッセージ キューではなく — に基づいてメッセージを送信したユーザーの証明書をデジタル署名を生成します。  
  
 <xref:System.Messaging.Message.DigitalSignature%2A>プロパティが 256 の配列の最大サイズ。  
  
 設定すると、<xref:System.Messaging.Message.DigitalSignature%2A>プロパティを設定する必要も、<xref:System.Messaging.Message.ConnectorType%2A>プロパティです。 メッセージが送信されると、メッセージ キューは無視、<xref:System.Messaging.Message.DigitalSignature%2A>プロパティ場合、<xref:System.Messaging.Message.ConnectorType%2A>プロパティも設定されていません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.DigitalSignature" /> プロパティを無視します。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.DigitalSignature" /> プロパティが <see langword="null" /> です。</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プライベート メッセージの本文を暗号化するのに使われる暗号化アルゴリズムを取得または設定します。</summary>
        <value>
          <see cref="T:System.Messaging.EncryptionAlgorithm" /> 列挙値のいずれか。 既定値は、<see langword="RC2" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プライベートの場合、メッセージ (暗号化)、送信および受信時に暗号化を解除する前に暗号化されます。 <xref:System.Messaging.Message.EncryptionAlgorithm%2A>プロパティは、プライベート メッセージのメッセージ本文を暗号化するためのアルゴリズムを指定します。  
  
 キューは、その受信を要求できますメッセージを暗号化します。 アプリケーションでは、プライベート メッセージだけを受け取るキューに暗号化されていない (非プライベート) メッセージを送信、または非プライベート メッセージのみを受け入れるキューにプライベート メッセージを送信する場合、キューはメッセージを拒否します。 送信元アプリケーションは、否定受信確認メッセージがこのようなケースで返されることを要求できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.EncryptionAlgorithm" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージに関連付けられているアプリケーション定義の追加情報を取得または設定します。</summary>
        <value>メッセージに関連付けられているアプリケーション定義の情報を提供するバイト値配列。 既定値は長さ 0 の配列です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Extension%2A>プロパティをメッセージに関連付けられているラージ バイナリ オブジェクトと同様に、アプリケーション定義の情報を提供します。 受信側アプリケーションの内容を解釈するの機能により、<xref:System.Messaging.Message.Extension%2A>プロパティです。  
  
 内のメッセージ データを含める必要があります、可能な限り、 <xref:System.Messaging.Message.Body%2A> 、メッセージのプロパティではなく、<xref:System.Messaging.Message.Extension%2A>プロパティです。  
  
 外部のキューを使用するときに使用して、<xref:System.Messaging.Message.Extension%2A>メッセージ キューの存在しないメッセージのプロパティを指定するプロパティです。  
  
 外部のキューは、Microsoft メッセージ キュー以外のキュー システムに存在します。 メッセージ キューは、コネクタ アプリケーションを使用してこのようなキューと通信します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.Extension" /> プロパティを無視します。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.Extension" /> プロパティが <see langword="null" /> です。</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクトをメッセージ本文にシリアル化する、またはメッセージ本文からオブジェクトを逆シリアル化するのに使用する書式指定子を取得または設定します。</summary>
        <value>メッセージ本文に書き込むストリーム、またはメッセージ本文から読み取るストリームを生成する <see cref="T:System.Messaging.IMessageFormatter" />。 既定値は、<see cref="T:System.Messaging.XmlMessageFormatter" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Messaging.Message.Formatter%2A>プロパティ、メッセージを読み書きするときにします。 メッセージがキューに送信されると、フォーマッタがシリアル化、<xref:System.Messaging.Message.Body%2A>プロパティをメッセージ キューに送信可能なストリームにします。 キューから読み取る場合、フォーマッタのメッセージ データを<xref:System.Messaging.Message.Body%2A>プロパティです。  
  
 直接メッセージの内容を記述しない限り、<xref:System.Messaging.Message.BodyStream%2A>プロパティ、設定、<xref:System.Messaging.Message.Formatter%2A>プロパティ、メッセージを送信する前にします。 ときに、<xref:System.Messaging.MessageQueue.Send%2A>メソッドが、<xref:System.Messaging.MessageQueue>に含まれているフォーマッタを使用して、インスタンス、本文がシリアル化、<xref:System.Messaging.Message.Formatter%2A>プロパティです。 値を指定せず、メッセージを送信するかどうか、<xref:System.Messaging.Message.Formatter%2A>プロパティ、フォーマッタの既定値<xref:System.Messaging.XmlMessageFormatter>です。  
  
 <xref:System.Messaging.XmlMessageFormatter> 、疎結合できるので、同じオブジェクトをこの形式を使用する場合、送信者と受信者を入力する必要はありません。 <xref:System.Messaging.ActiveXMessageFormatter>と<xref:System.Messaging.BinaryMessageFormatter>のバイナリ表現にデータをシリアル化します。 <xref:System.Messaging.ActiveXMessageFormatter> COM コンポーネントを送受信する際に使用します。  
  
   
  
## Examples  
 次のコード例では、メッセージ本文を使用して、書式設定を示しています<xref:System.Messaging.BinaryMessageFormatter>です。  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 次のコード例では、メッセージ本文を使用して、書式設定を示しています<xref:System.Messaging.XmlMessageFormatter>です。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.Formatter" /> プロパティが <see langword="null" /> です。</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ハッシュ アルゴリズムを取得または設定します。メッセージ キューは、メッセージを認証するとき、またはメッセージのデジタル署名を作成するときに、ハッシュ アルゴリズムを使用します。</summary>
        <value>
          <see cref="T:System.Messaging.HashAlgorithm" /> 列挙値のいずれか。 Windows XP の場合、既定値は <see langword="SHA" /> です。 それ以外の場合、既定値は <see langword="MD5" /> になります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージのデジタル署名を作成するときに、ソース コンピューターでは、ハッシュ アルゴリズムを使用メッセージ キューします。 ターゲット キュー マネージャーは、同じハッシュ アルゴリズムを使用して、受信されるときにメッセージを認証します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.HashAlgorithm" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージの ID を取得します。</summary>
        <value>メッセージの一意識別子。メッセージ キューによって生成されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ キューは、メッセージが送信されるときに、メッセージ id を生成します。 識別子は 20 バイトで構成され、2 つの項目が含まれています: マシン<xref:System.Guid>送信元コンピューターと、コンピューター上のメッセージの一意の識別子。 この 2 つの項目の組み合わせにより、ネットワーク上で一意のメッセージ ID が生成されます。  
  
 メッセージ キューはすべてのメッセージについてメッセージ id を生成-メッセージ受信確認やレポート メッセージなどです。 受信確認メッセージは通常、メッセージ キューが到着時または失敗したか、送信元のメッセージに反応に送信しました。 検索することができます、<xref:System.Messaging.Message.Id%2A>の元のメッセージのプロパティの値、<xref:System.Messaging.Message.CorrelationId%2A>受信確認メッセージのプロパティです。  
  
 使用することも、<xref:System.Messaging.Message.Id%2A>プロパティ応答キューを応答メッセージを送信するときにします。 応答メッセージに、元のメッセージの識別子を含める、設定、<xref:System.Messaging.Message.CorrelationId%2A>への応答メッセージのプロパティ、<xref:System.Messaging.Message.Id%2A>元のメッセージのプロパティです。 応答メッセージを読み取って、アプリケーションは、元のメッセージを識別するのに応答メッセージの相関 id を使用できます。  
  
   
  
## Examples  
 次のコード例は、キューから注文を含むメッセージを送受信します。 元のメッセージが達した場合または具体的には、肯定受信確認の要求がキューから取得します。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージは送信されていません。 このプロパティは、キューから取得したメッセージでだけ読み込むことができます。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.Id" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タイムアウトが存在しないことを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> および<xref:System.Messaging.Message.TimeToReachQueue%2A>タイムアウトを指定する値を必要とします。以前のタイムアウトは、キューから受信するメッセージの許容最大時間。 後者のタイムアウトは、キューに到達するメッセージの許容時間です。 どちらの場合、タイムアウトを秒数として指定したり、使用<xref:System.Messaging.Message.InfiniteTimeout>タイムアウトが存在しないことを示すためにします。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Messaging.Message.InfiniteTimeout>フィールドです。  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>そのメッセージがトランザクションで送信された最初のメッセージかどうかを示す値を取得します。</summary>
        <value>
          そのメッセージがトランザクションで送信された最初のメッセージである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーション使用の受信、<xref:System.Messaging.Message.IsFirstInTransaction%2A>プロパティをそのメッセージが 1 つのキューに 1 つのトランザクションで送信される最初のメッセージを確認してください。  
  
 このプロパティは、メッセージ キューのバージョン 2.0 でのみ使用可能およびそれ以降です。  
  
 トランザクションの境界を確認するに使用することができます、<xref:System.Messaging.Message.IsFirstInTransaction%2A>プロパティとその他の 2 つのプロパティ:<xref:System.Messaging.Message.IsLastInTransaction%2A>と<xref:System.Messaging.Message.TransactionId%2A>です。 前者は、メッセージがトランザクション内で送信された最後のメッセージかどうかを確認し、後者を使用して、トランザクションの識別子を取得する場合に使用します。  
  
 トランザクションでは、1 つのメッセージが送信されるだけの場合、<xref:System.Messaging.Message.IsFirstInTransaction%2A>と<xref:System.Messaging.Message.IsLastInTransaction%2A>プロパティに設定されて`true`です。  
  
   
  
## Examples  
 次のコード例には、メッセージの値が表示されます。<xref:System.Messaging.Message.IsFirstInTransaction%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージは送信されていません。 このプロパティは、キューから取得したメッセージでだけ読み込むことができます。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.IsFirstInTransaction" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージがトランザクションで送信された最後のメッセージかどうかを示す値を取得します。</summary>
        <value>
          そのメッセージがトランザクションで送信された最後のメッセージである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーション使用の受信、<xref:System.Messaging.Message.IsLastInTransaction%2A>プロパティをそのメッセージが 1 つのキューに 1 つのトランザクションで送信された最後のメッセージを確認してください。  
  
 このプロパティは、メッセージ キューのバージョン 2.0 でのみ使用可能およびそれ以降です。  
  
 トランザクションの境界を確認するに使用することができます、<xref:System.Messaging.Message.IsLastInTransaction%2A>プロパティとその他の 2 つのプロパティ:<xref:System.Messaging.Message.IsFirstInTransaction%2A>と<xref:System.Messaging.Message.TransactionId%2A>です。 前者は、メッセージがトランザクション内で送信された最初のメッセージかどうかを確認し、後者を使用して、トランザクションの識別子を取得する場合に使用します。  
  
 トランザクションでは、1 つのメッセージが送信されるだけの場合、<xref:System.Messaging.Message.IsFirstInTransaction%2A>と<xref:System.Messaging.Message.IsLastInTransaction%2A>プロパティに設定されて`true`です。  
  
   
  
## Examples  
 次のコード例には、メッセージの値が表示されます。<xref:System.Messaging.Message.IsLastInTransaction%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージは送信されていません。 このプロパティは、キューから取得したメッセージでだけ読み込むことができます。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.IsLastInTransaction" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージを記述するアプリケーション定義の Unicode 文字列を取得または設定します。</summary>
        <value>メッセージのラベル。 既定値は、空の文字列 ("") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ ラベルを使用する目的はいくつか考えられます。 メッセージ ラベルは、表示目的で使用できます。たとえば、ラベルの値に基づいてメッセージを選択的に処理するために使用できます。 ラベルは、メッセージで一意である必要はありません。  
  
 メッセージ キュー ラベルとメッセージ ラベルは、アプリケーション定義の値を表します。これらのラベルは、ユーザーの判読できる単語などを使用して、キューやメッセージを識別するのに便利です。 メッセージ キュー アプリケーションに特別な意味がないラベルの内容を解釈するアプリケーションの役割です。  
  
   
  
## Examples  
 次のコード例を取得し、メッセージの値を設定<xref:System.Messaging.Message.Label%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.Label" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>MSMQ 3.0 で導入されました。 メッセージの参照識別子を取得します。</summary>
        <value>メッセージ キューによって生成され、そのメッセージが存在するキューに対して一意であるメッセージの参照識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.LookupId%2A>プロパティは、メッセージの参照識別子に読み取り専用のアクセスを提供します。 MSMQ 3.0 で導入された、参照 id は、メッセージ キューによって生成され、メッセージがキューに配置されると、各メッセージに割り当てられているされる 64 ビット識別子です。 参照識別子は、メッセージが送信されたときに生成されるメッセージ識別子と同じではありません。  
  
 メッセージ キューは、コネクタ、および発信キューは、システムによって生成されたジャーナル、配信不能に加え、移行先のアプリケーションによって生成された、管理、およびレポート キューを含む、すべてのキューに配置されているすべてのメッセージの参照 id を生成します。 つまり、メッセージ キューと送信元アプリケーションによって送信の両方のメッセージが含まれます。 参照識別子は、キューに対して一意キュー以外の意味を持ちません。  
  
 複数の送信先キューにメッセージが送信された場合、またはコンピューター ジャーナル キューのジャーナルにメッセージのコピーが格納されている場合は、メッセージの各コピーは、それぞれのキューに置かれている場合、独自の参照 id があります。  
  
 <xref:System.Messaging.Message.LookupId%2A>プロパティはキューから取得したメッセージでのみ読み取ることができます。  
  
 参照識別子は、キュー内の特定のメッセージの読み取りに使用します。 受信側のアプリケーションが呼び出すことができます、メッセージの参照識別子が認識されたら、<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>または<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>そのメッセージに直接アクセスし、ピークまたはキューの先頭から開始し、キューの末尾に移動する必要があるカーソルとは異なり、キューから取得する関数  
  
 アプリケーションの役割は、キュー内のメッセージの参照識別子を取得します。 参照識別子を取得する方法の 1 つでは、送信先のキューをキューに配置されるように、各メッセージの識別子をキャッシュするコンポーネントを呼び出すためのトリガーを作成します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 がインストールされていません。</exception>
        <exception cref="T:System.InvalidOperationException">メッセージは送信されていません。 このプロパティは、キューから取得したメッセージでだけ読み込むことができます。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.LookupId" /> プロパティを無視します。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージの種類 (<see langword="Normal" />、<see langword="Acknowledgment" />、または <see langword="Report" /> のいずれか) を取得します。</summary>
        <value>
          <see cref="P:System.Messaging.Message.MessageType" /> 値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ キューは、メッセージを送信するときに通常このプロパティを設定します。 メッセージ キューのメッセージには、次のタイプがあります。  
  
-   `Normal`、は、いずれかの一般的なメッセージの送信がアプリケーションからキューにまたは送信アプリケーションに応答メッセージが返されます。  
  
-   `Acknowledgement`、、送信元アプリケーションによって要求されるたびにメッセージ キューが生成します。 たとえば、メッセージ キューは、元のメッセージが到達したかまたは読み取られたことを示すために肯定受信確認メッセージまたは否定受信確認メッセージを生成できます。 メッセージ キューは、送信元アプリケーションによって指定される管理キューに適切な受信確認メッセージを返します。  
  
-   `Report`、レポート キューは送信元キュー マネージャーで定義されるたびにメッセージ キューが生成します。 トレースが有効である場合、メッセージ キューは、メッセージ キュー サーバーで元のメッセージの入出力が発生するたびに、レポート メッセージをメッセージ キュー レポート キューに送信します。  
  
   
  
## Examples  
 次のコード例には、メッセージの値が表示されます。<xref:System.Messaging.Message.MessageType%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージは送信されていません。 このプロパティは、キューから取得したメッセージでだけ読み込むことができます。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.MessageType" /> プロパティを無視します。</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キュー内でのメッセージの格納場所を決定するのに使われる、メッセージの優先順位を取得または設定します。</summary>
        <value>非トランザクション メッセージの優先順位を表す <see cref="T:System.Messaging.MessagePriority" /> 値の 1 つ。 既定値は、<see langword="Normal" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Priority%2A>プロパティは、メッセージ キュー メッセージの処理方法両方途中になっていると、その送信先に到達した後に影響します。 優先順位の高いメッセージほど、送信中に優先権が与えられ、送信先キューの中の先頭近くに挿入されます。 優先順位の同じメッセージは、到達時刻に応じてキュー内に配置されます。  
  
 非トランザクション メッセージに対してのみ意味のある優先順位を設定することができます。 メッセージ キューへトランザクション メッセージの優先度を自動的に設定する`Lowest`、それが原因でトランザクション メッセージの優先度が無視されます。  
  
   
  
## Examples  
 次のコード例では、キューに優先度が異なる 2 つのメッセージを送信し、順番に取得します。  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.Priority" /> プロパティを無視します。</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コンピューターの障害やネットワークの問題が発生したときにメッセージの配信が保証されるかどうかを示す値を取得または設定します。</summary>
        <value>
          送信中にメッセージをディスクに保存することによって配信が保証される場合は <see langword="true" />、配信が保証されない場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Recoverable%2A>プロパティは、メッセージの配信が保証されるかどうかを示します: メッセージが送信先キューに向かって中に、コンピューターがクラッシュした場合でもです。  
  
 メッセージの配信が保証される場合メッセージは格納ローカル ルート、上のすべてのステップで、メッセージは次のコンピューターに正常に転送されるまでです。 設定、<xref:System.Messaging.Message.Recoverable%2A>プロパティを`true`スループットに影響を与える可能性があります。  
  
 メッセージがトランザクションの場合は、メッセージ キューとして自動的に処理、メッセージの値に関係なく、回復可能な<xref:System.Messaging.Message.Recoverable%2A>プロパティです。  
  
   
  
## Examples  
 次のコード例を取得し、メッセージの値を設定<xref:System.Messaging.Message.Recoverable%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.Recoverable" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションによって生成される応答メッセージを受け取るキューを取得または設定します。</summary>
        <value>アプリケーションによって生成される応答メッセージが返される <see cref="T:System.Messaging.MessageQueue" />。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.ResponseQueue%2A>プロパティは、受信側アプリケーションが、送信元アプリケーションに戻るアプリケーションによって生成される応答メッセージを受信するキューを識別します。 送信元アプリケーションは、メッセージを送信するときに応答キューを指定します。 使用できる任意のキューを応答キューとして指定できます。  
  
 応答キューに対して返されるメッセージは、アプリケーション固有です。 アプリケーションは、メッセージの内容と、メッセージの受信時に実行するアクションを定義する必要があります。  
  
   
  
## Examples  
 次のコード例を取得し、メッセージの値を設定<xref:System.Messaging.Message.ResponseQueue%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.ResponseQueue" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージのセキュリティ コンテキストを取得または設定します。</summary>
        <value>このプロパティが設定済みの場合、<see cref="T:System.Messaging.SecurityContext" /> オブジェクトにはメッセージのセキュリティ コンテキストが含まれます。それ以外の場合は NULL になります。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージを認証するのに使うセキュリティ証明書を取得または設定します。</summary>
        <value>メッセージの差出人を確認するのにメッセージ キューが使うセキュリティ証明書を表すバイト値配列。 既定値は長さ 0 の配列です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 受信側のアプリケーションを使用して、<xref:System.Messaging.Message.SenderCertificate%2A>プロパティ、メッセージには、外部のセキュリティ証明書が含まれている場合。  
  
 メッセージ キューは、いずれかを使用してメッセージを内部または外部のセキュリティ証明書を認証できます。 メッセージ キューは、メッセージの整合性の確認に使用される内部の証明書を提供します。 証明機関は、外部証明書を使用してアクセスできる<xref:System.Messaging.Message.SenderCertificate%2A>メッセージのプロパティです。 メッセージ キュー メッセージの認証を許可すると、に加えては、外部の証明書は、さらに、送信者を検証する受信側のアプリケーションをできます。 内部の証明書には、受信アプリケーションに使用可能な値がありません。  
  
 外部の証明書は、メッセージ キュー システムのディレクトリ サービスに登録する必要があります。 外部の証明書には、証明機関、証明書ユーザー、証明書の有効期間が、証明書ユーザー、および証明機関の署名の公開キーに関する情報が含まれています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.SenderCertificate" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>送信元ユーザーの ID を取得します。</summary>
        <value>差出人を識別するバイト値配列。 受信側キュー マネージャーは、メッセージを認証するときにこの ID を使って、メッセージの差出人と差出人のキューへのアクセス権とを確認します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Messaging.Message.AttachSenderId%2A>プロパティは`false`で指定した送信者の識別子、<xref:System.Messaging.Message.SenderId%2A>プロパティにアタッチされていないメッセージが送信されるとします。 これを示しますにキューにメッセージが送信先キューにメッセージを送信するときは、送信者を検証できません必要があります。 場合、<xref:System.Messaging.Message.AttachSenderId%2A>プロパティは`true`、<xref:System.Messaging.Message.SenderId%2A>プロパティの値が信頼できるは、メッセージが認証された場合にのみです。 使用して、<xref:System.Messaging.Message.Authenticated%2A>プロパティと組み合わせて、<xref:System.Messaging.Message.SenderId%2A>プロパティを送信者のアクセス権を確認します。  
  
 コネクタ アプリケーションは、コネクタ サーバーを使用して、メッセージ キューとその他のキュー システム間の通信を提供するアプリケーションです。 メッセージ キューでは、コネクタ アプリケーション送信者 id を提供する必要があります。 設定する必要があります、<xref:System.Messaging.Message.ConnectorType%2A>プロパティ、コネクタ アプリケーションを介してメッセージを送信するときにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージは送信されていません。 このプロパティは、キューから取得したメッセージでだけ読み込むことができます。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.SenderId" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージを送信するのに使われるメッセージ キューのバージョンを取得します。</summary>
        <value>メッセージを送信するのに使われるメッセージ キューのバージョン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderVersion%2A>プロパティは、特定の機能にとって重要です。 たとえば、のみがメッセージ キュー 2.0 以降では、トランザクション処理がサポートされてし、デジタル署名が MSMQ 1.0 によって送信されるメッセージの認証に使用されます。  
  
 送信側キュー マネージャーを設定、<xref:System.Messaging.Message.SenderVersion%2A>プロパティ、メッセージが送信されるとします。  
  
   
  
## Examples  
 次のコード例には、メッセージの値が表示されます。<xref:System.Messaging.Message.SenderVersion%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージは送信されていません。 このプロパティは、キューから取得したメッセージでだけ読み込むことができます。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.SenderVersion" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージが送信元キュー マネージャーによって送信されたときの、送信元コンピューター上の日付と時刻を取得します。</summary>
        <value>メッセージが送信された日時を表す <see cref="T:System.DateTime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SentTime%2A>プロパティはこのコンピューターのローカル時刻に調整のインスタンス、<xref:System.Messaging.Message>クラスを作成します。 このタイム ゾーンは、送信元と送信先のキューのものと異なる可能性があります。  
  
   
  
## Examples  
 次のコード例には、メッセージの値が表示されます。<xref:System.Messaging.Message.SentTime%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージは送信されていません。 このプロパティは、キューから取得したメッセージでだけ読み込むことができます。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.SentTime" /> プロパティを無視します。</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージの送信元のコンピューターを取得します。</summary>
        <value>メッセージの送信元のコンピューターの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 形式、<xref:System.Messaging.Message.SourceMachine%2A>プロパティでは、2 つのスラッシュの前は含まれません (\\\\)。 たとえば、`myServer`は有効な<xref:System.Messaging.Message.SourceMachine%2A>します。  
  
   
  
## Examples  
 次のコード例には、メッセージの値が表示されます。<xref:System.Messaging.Message.SourceMachine%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージは送信されていません。 このプロパティは、キューから取得したメッセージでだけ読み込むことができます。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.SourceMachine" /> プロパティを無視します。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">コンピューターの情報またはディレクトリ サービスにアクセスできません。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージが送信先キューから受信されるまでの最大時間を取得または設定します。</summary>
        <value>送信されたメッセージが送信先キューから受信されるまでの合計時間。 既定値は、<see cref="F:System.Messaging.Message.InfiniteTimeout" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A>プロパティが送信されたメッセージが送信先キューから受信されるまでの時間の合計を指定します。 制限時間には、送信先キューおよびメッセージを受信する前に、キューで待機する時間に費やされた時間が含まれています。  
  
> [!CAUTION]
>  依存型クライアント コンピューターを使用する場合は、クライアント コンピューターのクロックがメッセージ キューを実行しているサーバー上のクロックと同期されていることを確認します。 メッセージを送信するときに予期しない動作をそれ以外の場合、発生する可能性がありますが<xref:System.Messaging.Message.TimeToBeReceived%2A>プロパティは使用されません<xref:System.Messaging.Message.InfiniteTimeout>です。  
  
 間隔が指定されている場合、<xref:System.Messaging.Message.TimeToBeReceived%2A>プロパティでは、キューからメッセージを削除する前に有効期限が切れる、メッセージ キューは 2 つの方法のいずれかでメッセージを破棄します。 メッセージの <xref:System.Messaging.Message.UseDeadLetterQueue%2A> プロパティが `true` の場合、メッセージは配信不能キューに送信されます。 場合<xref:System.Messaging.Message.UseDeadLetterQueue%2A>は`false`メッセージは無視されます。  
  
 メッセージを設定することができます<xref:System.Messaging.Message.AcknowledgeType%2A>タイマーの有効期限が切れる前に、メッセージが取得されない場合に、メッセージ キュー、否定受信確認メッセージを送信を要求するプロパティが送信アプリケーションにバックアップします。  
  
 値が指定されている場合、<xref:System.Messaging.Message.TimeToBeReceived%2A>プロパティがで指定された値より小さい、<xref:System.Messaging.Message.TimeToReachQueue%2A>プロパティ、<xref:System.Messaging.Message.TimeToBeReceived%2A>が優先されます。  
  
 単一のトランザクションで複数のメッセージが送信されると、メッセージ キューは、<xref:System.Messaging.Message.TimeToBeReceived%2A>最初のメッセージのプロパティです。  
  
   
  
## Examples  
 次のコード例を取得し、メッセージの値を設定<xref:System.Messaging.Message.TimeToBeReceived%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.TimeToBeReceived" /> プロパティを無視します。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.TimeToBeReceived" /> に指定された値が無効です。</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージがキューに到達するまでの最大許容時間を取得または設定します。</summary>
        <value>メッセージが送信されてから送信先キューに到達するまでのタイム リミット。 既定値は、<see cref="F:System.Messaging.Message.InfiniteTimeout" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 間隔が指定されている場合、<xref:System.Messaging.Message.TimeToReachQueue%2A>プロパティでは、メッセージが宛先に到達する前に有効期限が切れる、メッセージ キューは 2 つの方法のいずれかでメッセージを破棄します。 メッセージの <xref:System.Messaging.Message.UseDeadLetterQueue%2A> プロパティが `true` の場合、メッセージは配信不能キューに送信されます。 場合<xref:System.Messaging.Message.UseDeadLetterQueue%2A>は`false`メッセージは無視されます  
  
 彼はメッセージを設定することができます<xref:System.Messaging.Message.AcknowledgeType%2A>タイマーの有効期限が切れる前に、メッセージが到着しない場合、送信元アプリケーションにメッセージ キュー、否定受信確認メッセージを送信を要求するプロパティがバックアップされます。  
  
 場合、<xref:System.Messaging.Message.TimeToReachQueue%2A>プロパティが 0 秒に設定されて、メッセージ キューは 1 回、送信先にメッセージを送信、キューがメッセージを待機している場合。 キューがローカルの場合は、メッセージ常に到達します。  
  
 値が指定されている場合、<xref:System.Messaging.Message.TimeToReachQueue%2A>プロパティがで指定された値より大きい、<xref:System.Messaging.Message.TimeToBeReceived%2A>プロパティ、<xref:System.Messaging.Message.TimeToBeReceived%2A>が優先されます。  
  
 単一のトランザクションで複数のメッセージが送信されると、メッセージ キューは、<xref:System.Messaging.Message.TimeToReachQueue%2A>最初のメッセージのプロパティです。  
  
   
  
## Examples  
 次のコード例を取得し、メッセージの値を設定<xref:System.Messaging.Message.TimeToReachQueue%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.TimeToReachQueue" /> プロパティを無視します。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.TimeToReachQueue" /> に指定された値が無効です。 負数を表している可能性があります。</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>一部にメッセージを含むトランザクションの ID を取得します。</summary>
        <value>メッセージに関連付けられているトランザクションの ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーション使用の受信、<xref:System.Messaging.Message.TransactionId%2A>プロパティを特定のトランザクションの一部としてメッセージが送信されたことを確認してください。 トランザクションの識別子には、4 バイトのトランザクション シーケンス番号の後に、送信元コンピューター (最初の 16 ビット) の識別子が含まれています。  
  
 このプロパティは以降のバージョンのメッセージ キュー 2.0 にのみ利用可能です。  
  
 トランザクション id がトランザクション シーケンス番号は、永続的なと再び経由で 2 ために、一意である保証はありません<sup>20</sup>です。 メッセージ キューは、後続のトランザクションが別のトランザクション シーケンス番号を持つのみ保証されます。  
  
 使用することができます、<xref:System.Messaging.Message.TransactionId%2A>プロパティと共に、<xref:System.Messaging.Message.IsFirstInTransaction%2A>と<xref:System.Messaging.Message.IsLastInTransaction%2A>プロパティをトランザクションの境界を確認します。  
  
   
  
## Examples  
 次のコード例には、メッセージの値が表示されます。<xref:System.Messaging.Message.TransactionId%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージは送信されていません。 このプロパティは、キューから取得したメッセージでだけ読み込むことができます。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.TransactionId" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>送信元コンピューター上のトランザクション ステータス キューを取得します。</summary>
        <value>送信元コンピューター上のトランザクション ステータス キュー。送信元アプリケーションに受信確認メッセージを返すときに使われます。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TransactionStatusQueue%2A>プロパティは、コネクタ アプリケーションから読み取り受信確認を受信するソース コンピューター上のトランザクション キューを識別します。 メッセージ キューは、プロパティを設定し、外部キューに送信されるトランザクション メッセージを取得するときに、コネクタ アプリケーションはプロパティを使用します。  
  
 外部のキューは、Microsoft メッセージ キュー以外のキュー システムに存在します。 メッセージ キューは、コネクタ アプリケーションを使用してこのようなキューと通信します。  
  
 コネクタ アプリケーションは、トランザクション状態キューを使用して、受信確認メッセージを送信元アプリケーションに送信することができます。 トランザクション状態キューは、送信元アプリケーションが別の受信確認を要求していない場合でも、これらの確認を受信する必要があります。  
  
   
  
## Examples  
 次のコード例には、メッセージの値が表示されます。<xref:System.Messaging.Message.TransactionStatusQueue%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージは送信されていません。 このプロパティは、キューから取得したメッセージでだけ読み込むことができます。  
  
 - または -  
  
 メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.TransactionStatusQueue" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージが送信前に認証された (または認証される必要がある) かどうかを示す値を取得または設定します。</summary>
        <value>
          送信元アプリケーションがメッセージの認証を要求した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseAuthentication%2A>プロパティは、メッセージを認証する必要があるかどうかを指定します。 送信元アプリケーションは、認証を要求している場合はメッセージ キュー、デジタル署名を作成しが送信されるメッセージに署名し、メッセージの認証を受信したときに使用します。  
  
 場合<xref:System.Messaging.Message.UseAuthentication%2A>は`false`を認証されたメッセージのみを受け取るキューにメッセージが送信されると、キューになったときに、メッセージは拒否されます。  
  
 メッセージのプロパティを調べることで認証に失敗したかどうかを判断できません。 メッセージ キューは、キューに配信される前に、このようなメッセージを破棄します。 ただし、配信の失敗が原因でメッセージがキューに到着した場合に、受信確認メッセージを送信することを要求することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.UseAuthentication" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>配信できなかったメッセージのコピーを配信不能キューに送信するかどうかを示す値を取得または設定します。</summary>
        <value>
          メッセージが配信できなかったときにそのメッセージのコピーを配信不能キューに送信する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A>と<xref:System.Messaging.Message.UseDeadLetterQueue%2A>プロパティは、メッセージ キューがメッセージには追跡を指定します。 場合<xref:System.Messaging.Message.UseDeadLetterQueue%2A>は`true`メッセージが配信できなかったコンピューターの非トランザクション配信不能キューに送信されるメッセージは生成 (非トランザクション メッセージの場合) の配信が失敗します。 配信の失敗は、期限切れのメッセージのタイマーが原因と考えられます。  
  
 トランザクション メッセージの配信失敗した場合、メッセージ キューとすべての負の値と、状態が不明の場合、ソース マシン上のトランザクション配信不能キューにも、メッセージを送信します。  
  
 配信不能キューにメッセージを格納する際は、不要になったメッセージを削除するには、定期的にキューをクリアする必要があります。 キューが存在するコンピューターのサイズ クォータに対して配信不能キューに格納されたメッセージ。 コンピューターのクォータは、管理者が設定されているし、1 つのキューではなく、コンピューター全体にメッセージを格納するために割り当てられているサイズを示します。  
  
 ジャーナルや配信不能キューを作成しません。 これらは、メッセージ キューによって生成される両方のシステム キューです。  
  
   
  
## Examples  
 次のコード例を取得し、メッセージの値を設定<xref:System.Messaging.Message.UseDeadLetterQueue%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.UseDeadLetterQueue" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージをプライベートにするかどうかを示す値を取得または設定します。</summary>
        <value>
          メッセージ キューにメッセージを暗号化するように要求する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージがプライベートの場合は、送信および受信したときに暗号化を解除する前に、本文は暗号化されます。 その暗号化を使用するプライベート メッセージを送信する送信元のアプリケーションを指定する必要がありますと、必要に応じて、暗号化アルゴリズムです。  
  
 プライベート メッセージを送信するときに、アプリケーションがメッセージの暗号化を実行する必要はありません。 メッセージ キューは、アプリケーションがディレクトリ サービスへのアクセス権を持つ Microsoft Windows 2000 エンタープライズ内のメッセージを送信する場合のメッセージ本文を暗号化できます。 プライベート メッセージを受信するときに受信キュー マネージャで、メッセージ本文が常に暗号化解除します。  
  
   
  
## Examples  
 次のコード例を取得し、メッセージの値を設定<xref:System.Messaging.Message.UseEncryption%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.UseEncryption" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>送信元のコンピューターの履歴にメッセージのコピーを保持するかどうかを示す値を取得または設定します。</summary>
        <value>
          メッセージが (送信元のコンピューターから次のサーバーに) 正常に送信された後に送信元コンピューターの履歴にメッセージのコピーを保持するように要求する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A>と<xref:System.Messaging.Message.UseDeadLetterQueue%2A>プロパティは、メッセージ キューがメッセージには追跡を指定します。 場合<xref:System.Messaging.Message.UseJournalQueue%2A>は`true`はコンピューター ジャーナル メッセージを送信する各ステップでは、発信元のコンピューターにコピーを保持し、します。  
  
 送信したメッセージは、送信先キューがリモート コンピューター上にある場合にのみ、ジャーナル キューにコピーされます。 メッセージがキューに直接送信される先がローカル コンピューター上にある場合は、履歴を必要とする中間の手順はありません。  
  
 ジャーナル キューにメッセージを格納する際は、不要になったメッセージを削除するには、定期的にキューをクリアします。 キューが存在するコンピューターのクォータに照らし合わせてジャーナル キューに格納されているメッセージです。 (コンピューターのクォータは、管理者によって設定します。)  
  
 ジャーナルや配信不能キューを作成しません。 これらは、メッセージ キューによって生成される両方のシステム キューです。  
  
   
  
## Examples  
 次のコード例を取得し、メッセージの値を設定<xref:System.Messaging.Message.UseJournalQueue%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.UseJournalQueue" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メッセージが送信先キューに移動していく途中でメッセージをトレースするかどうかを示す値を取得または設定します。</summary>
        <value>
          元のメッセージが送信先キューに到達するまでに発生する各中間ステップごとにレポートを生成して、システムのレポート キューに送信する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseTracing%2A>プロパティでは、送信先キューに移動するときに、メッセージの経路を追跡するかどうかを指定します。 場合`true`、(メッセージ キューによって生成される)、レポート メッセージは、メッセージがメッセージ キューのルーティング サーバーを通過するたびにレポート キューに送信します。 レポート キューは、送信元キュー マネージャーによって指定されます。 レポート キューにメッセージがキュー; によって生成されたメッセージをレポートに限定されていませんアプリケーションによって生成されたメッセージは、レポート キューに送信することもできます。  
  
 トレースを使用するには、Active Directory を設定して、メッセージ キュー エンタープライズ レポート キューを指定することが含まれます。 管理者は、これらの設定を構成します。  
  
   
  
## Examples  
 次のコード例を取得し、メッセージの値を設定<xref:System.Messaging.Message.UseTracing%2A>プロパティです。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メッセージ キューがフィルター処理され、<see cref="P:System.Messaging.Message.UseTracing" /> プロパティを無視します。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>