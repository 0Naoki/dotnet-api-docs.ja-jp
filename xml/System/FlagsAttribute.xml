<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FlagsAttribute.xml" source-language="en-US" target-language="ja-JP">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b4a43daf94141e166fdacae6f0ba6f4be584c7b5.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b4a43daf94141e166fdacae6f0ba6f4be584c7b5</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.FlagsAttribute">
          <source>Indicates that an enumeration can be treated as a bit field; that is, a set of flags.</source>
          <target state="translated">列挙体をビット フィールド、つまりフラグのセットとして扱えることを示します。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Bit fields are generally used for lists of elements that might occur in combination, whereas enumeration constants are generally used for lists of mutually exclusive elements.</source>
          <target state="translated">ビット フィールドは、相互に排他的な要素の一覧の列挙定数が使用される一般に対しの組み合わせで発生する可能性が要素のリスト通常使用されます。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Therefore, bit fields are designed to be combined with a bitwise OR operation to generate unnamed values, whereas enumerated constants are not.</source>
          <target state="translated">そのため、ビット フィールドは、列挙型定数はない、名前のない値を生成するビットごとの OR 演算と組み合わせるに設計されています。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Languages vary in their use of bit fields compared to enumeration constants.</source>
          <target state="translated">言語は、列挙型定数と比較して、ビット フィールドの使用によって異なります。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Attributes of the FlagsAttribute</source>
          <target state="translated">FlagsAttribute 属性</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source><ph id="ph1">&lt;xref:System.AttributeUsageAttribute&gt;</ph> is applied to this class, and its <ph id="ph2">&lt;xref:System.AttributeUsageAttribute.Inherited%2A&gt;</ph> property specifies <ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AttributeUsageAttribute&gt;</ph> このクラスに適用されると、その<ph id="ph2">&lt;xref:System.AttributeUsageAttribute.Inherited%2A&gt;</ph>プロパティを指定<ph id="ph3">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>This attribute can only be applied to enumerations.</source>
          <target state="translated">この属性は、列挙型にのみ適用できます。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Guidelines for FlagsAttribute and Enum</source>
          <target state="translated">FlagsAttribute 列挙型のガイドライン</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Use the <ph id="ph1">&lt;xref:System.FlagsAttribute&gt;</ph> custom attribute for an enumeration only if a bitwise operation (AND, OR, EXCLUSIVE OR) is to be performed on a numeric value.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.FlagsAttribute&gt;</ph>ビットごとの演算 (AND、OR の排他的 OR) は、数値の値に対して実行する場合にのみ列挙型のカスタム属性です。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Define enumeration constants in powers of two, that is, 1, 2, 4, 8, and so on.</source>
          <target state="translated">つまり、1、2、4、8、およびよびな 2 の累乗で列挙定数を定義します。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>This means the individual flags in combined enumeration constants do not overlap.</source>
          <target state="translated">これは、結合された列挙定数の各フラグが重複しないことを意味します。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Consider creating an enumerated constant for commonly used flag combinations.</source>
          <target state="translated">一般的に使用されるフラグの組み合わせに対して列挙定数を作成することを検討します。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>For example, if you have an enumeration used for file I/O operations that contains the enumerated constants <ph id="ph1">`Read = 1`</ph> and <ph id="ph2">`Write = 2`</ph>, consider creating the enumerated constant <ph id="ph3">`ReadWrite = Read OR Write`</ph>, which combines the <ph id="ph4">`Read`</ph> and <ph id="ph5">`Write`</ph> flags.</source>
          <target state="translated">たとえば、ファイル I/O 操作に使用する列挙体がある場合を含む列挙型定数<ph id="ph1">`Read = 1`</ph>と<ph id="ph2">`Write = 2`</ph>、列挙型定数の作成を検討して<ph id="ph3">`ReadWrite = Read OR Write`</ph>、どの結合、<ph id="ph4">`Read`</ph>と<ph id="ph5">`Write`</ph>フラグ。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>In addition, the bitwise OR operation used to combine the flags might be considered an advanced concept in some circumstances that should not be required for simple tasks.</source>
          <target state="translated">さらに、フラグの組み合わせに使用されるビットごとの OR 演算することはできません、単純なタスクをいくつかの状況での高度な概念と見なされる可能性があります。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Use caution if you define a negative number as a flag enumerated constant because many flag positions might be set to 1, which might make your code confusing and encourage coding errors.</source>
          <target state="translated">多くのフラグの位置は 1 では、可能性があります、コードが複雑になる場合容易させ、コーディング エラーに設定する可能性がありますので、フラグの列挙定数として負の数を定義する場合は、注意を使用します。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>A convenient way to test whether a flag is set in a numeric value is to perform a bitwise AND operation between the numeric value and the flag enumerated constant, which sets all bits in the numeric value to zero that do not correspond to the flag, then test whether the result of that operation is equal to the flag enumerated constant.</source>
          <target state="translated">数値の値で、フラグが設定されているかどうかをテストする便利な方法は、演算を実行して、数値の値とすべてのビットを設定すると、フラグに対応していないゼロに対応する数値で、フラグ列挙型定数の間での操作をテストし、その操作の結果がフラグの列挙型定数と等しいかどうか。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Use <ph id="ph1">`None`</ph> as the name of the flag enumerated constant whose value is zero.</source>
          <target state="translated">使用して<ph id="ph1">`None`</ph>フラグの名前は列挙定数の値が 0 として。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>You cannot use the <ph id="ph1">`None`</ph> enumerated constant in a bitwise AND operation to test for a flag because the result is always zero.</source>
          <target state="translated">使用することはできません、<ph id="ph1">`None`</ph>のため、結果は常に 0 フラグをテストするビットごとの AND 演算で列挙型定数。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>However, you can perform a logical, not a bitwise, comparison between the numeric value and the <ph id="ph1">`None`</ph> enumerated constant to determine whether any bits in the numeric value are set.</source>
          <target state="translated">ただし、行うことができます、論理、数値の値の間でビット演算子、比較ではありません、<ph id="ph1">`None`</ph>数値の値のビットを設定するかどうかを決定する列挙型定数。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If you create a value enumeration instead of a flags enumeration, it is still worthwhile to create a <ph id="ph1">`None`</ph> enumerated constant.</source>
          <target state="translated">作成するには有用ですフラグ列挙体ではなく値の列挙体を作成する場合、<ph id="ph1">`None`</ph>列挙型定数。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The reason is that by default the memory used for the enumeration is initialized to zero by the common language runtime.</source>
          <target state="translated">その理由は、既定では、列挙に使用されるメモリは 0 に初期化は、共通言語ランタイムによってです。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Consequently, if you do not define a constant whose value is zero, the enumeration will contain an illegal value when it is created.</source>
          <target state="translated">その結果、値が 0 の定数を定義していない場合が作成されるとき、列挙体は値が無効含まれます。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If there is an obvious default case your application needs to represent, consider using an enumerated constant whose value is zero to represent the default.</source>
          <target state="translated">アプリケーションを表す必要がある、明確な既定のケースがある場合は、値が既定値を表す 0 列挙定数の使用を検討してください。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If there is no default case, consider using an enumerated constant whose value is zero that means the case that is not represented by any of the other enumerated constants.</source>
          <target state="translated">既定のケースがない場合は、他の列挙定数のいずれかで表されないケースを意味の値は 0 です。 列挙定数の使用を検討してください。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Do not define an enumeration value solely to mirror the state of the enumeration itself.</source>
          <target state="translated">列挙体自体の状態を反映するだけの列挙値を定義しません。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>For example, do not define an enumerated constant that merely marks the end of the enumeration.</source>
          <target state="translated">たとえば、列挙の終了をマークするだけの列挙定数を定義してください。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If you need to determine the last value of the enumeration, check for that value explicitly.</source>
          <target state="translated">列挙体の最後の値を決定する必要がある場合は、その値を明示的に確認します。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>In addition, you can perform a range check for the first and last enumerated constant if all values within the range are valid.</source>
          <target state="translated">さらに、範囲内のすべての値は有効な場合は、最初と最後の列挙型定数の範囲チェックを実行できます。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Do not specify enumerated constants that are reserved for future use.</source>
          <target state="translated">将来使用するために予約されている列挙型定数は指定しません。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>When you define a method or property that takes an enumerated constant as a value, consider validating the value.</source>
          <target state="translated">メソッドまたは値として列挙型定数は、プロパティを定義するときは、値の検証を検討してください。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The reason is that you can cast a numeric value to the enumeration type even if that numeric value is not defined in the enumeration.</source>
          <target state="translated">理由は、その数値の値が列挙体で定義されていない場合でも、列挙型の数値にキャストすることです。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The following example illustrates the use of the <ph id="ph1">`FlagsAttribute`</ph> attribute and shows the effect on the <ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph> method of using <ph id="ph3">`FlagsAttribute`</ph> on an <ph id="ph4">&lt;xref:System.Enum&gt;</ph> declaration.</source>
          <target state="translated">次の例では、使用、<ph id="ph1">`FlagsAttribute`</ph>属性し、の効果を示しています、<ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph>メソッドを使用する<ph id="ph3">`FlagsAttribute`</ph>上、<ph id="ph4">&lt;xref:System.Enum&gt;</ph>宣言します。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The following example defines two color-related enumerations, <ph id="ph1">`SingleHue`</ph> and <ph id="ph2">`MultiHue`</ph>.</source>
          <target state="translated">次の例では、次の 2 つの色関連列挙体、<ph id="ph1">`SingleHue`</ph>と<ph id="ph2">`MultiHue`</ph>です。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The latter has the <ph id="ph1">`FlagsAttribute`</ph> attribute; the former does not.</source>
          <target state="translated">後者は、<ph id="ph1">`FlagsAttribute`</ph>属性です。 前者はありません。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The example shows the difference in behavior when a range of integers, including integers that do not represent underlying values of the enumeration type, are cast to the enumeration type and their string representations displayed.</source>
          <target state="translated">例は、列挙型の基になる値ではない整数を含む整数の範囲は、列挙型と表示される、それぞれの文字列表現にキャストするときの動作の違いを示します。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>For example, note that 3 cannot be represented as a <ph id="ph1">`SingleHue`</ph> value because 3 is not the underlying value of any <ph id="ph2">`SingleHue`</ph> member, whereas the <ph id="ph3">`FlagsAttribute`</ph> attribute makes it possible to represent 3 as a <ph id="ph4">`MultiHue`</ph> value of <ph id="ph5">`Black, Red`</ph>.</source>
          <target state="translated">たとえば、3 として表すことができないことに注意してください、<ph id="ph1">`SingleHue`</ph>値 3 がいずれかの基になる値ではないため<ph id="ph2">`SingleHue`</ph>メンバー、一方、<ph id="ph3">`FlagsAttribute`</ph>属性では、3 として表すことが、<ph id="ph4">`MultiHue`</ph>の値<ph id="ph5">`Black, Red`</ph>です。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.FlagsAttribute.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.FlagsAttribute" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.FlagsAttribute" /&gt;</ph> クラスの新しいインスタンスを初期化します。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>The following example defines a <ph id="ph1">`PhoneService`</ph> enumeration that represents forms of communication provided by a telephone company.</source>
          <target state="translated">次の例では定義、<ph id="ph1">`PhoneService`</ph>電話会社によって提供されている通信のフォームを表す列挙体です。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>It initializes three variables representing the service provided to three different households, and then indicates which households have no service, which households have only cell phone service, and which households have both cell phone and land line service.</source>
          <target state="translated">次の 3 つの異なる家庭に提供されるサービスを表す 3 つの変数を初期化し、し、どの家庭にサービス、どの家庭携帯電話サービスのみがありどの家庭携帯電話と土地の両方の回線サービスが含まれていないことを示します。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>Finally, it implicitly calls the <ph id="ph1">&lt;xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> method to display the types of service provided to each household.</source>
          <target state="translated">最後に、暗黙的に呼び出す、<ph id="ph1">&lt;xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph>各世帯に提供されるサービスの種類を表示するメソッド。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>The following example illustrates the use of the <ph id="ph1">`FlagsAttribute`</ph> attribute and shows the effect on the <ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph> method of using <ph id="ph3">`FlagsAttribute`</ph> on an <ph id="ph4">&lt;xref:System.Enum&gt;</ph> declaration.</source>
          <target state="translated">次の例では、使用、<ph id="ph1">`FlagsAttribute`</ph>属性し、の効果を示しています、<ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph>メソッドを使用する<ph id="ph3">`FlagsAttribute`</ph>上、<ph id="ph4">&lt;xref:System.Enum&gt;</ph>宣言します。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>