<Type Name="FlagsAttribute" FullName="System.FlagsAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="256a8e1f7566a6086b2a27e90205cc00814561ff" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39917148" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FlagsAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit FlagsAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.FlagsAttribute" />
  <TypeSignature Language="VB.NET" Value="Public Class FlagsAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class FlagsAttribute : Attribute" />
  <TypeSignature Language="F#" Value="type FlagsAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Enum, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="0a436-101">列挙体をビット フィールド、つまりフラグのセットとして扱えることを示します。</span>
      <span class="sxs-lookup">
        <span data-stu-id="0a436-101">Indicates that an enumeration can be treated as a bit field; that is, a set of flags.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a436-102">ビット フィールドは、相互に排他的な要素の一覧の列挙定数が使用される一般に対しを組み合わせて、要素の一覧については通常使用されます。</span><span class="sxs-lookup"><span data-stu-id="0a436-102">Bit fields are generally used for lists of elements that might occur in combination, whereas enumeration constants are generally used for lists of mutually exclusive elements.</span></span> <span data-ttu-id="0a436-103">そのため、ビット フィールドは、列挙定数でないが、名前のない値を生成するビットごとの OR 演算と組み合わせるに設計されています。</span><span class="sxs-lookup"><span data-stu-id="0a436-103">Therefore, bit fields are designed to be combined with a bitwise OR operation to generate unnamed values, whereas enumerated constants are not.</span></span> <span data-ttu-id="0a436-104">言語は、列挙定数と比較して、ビット フィールドの使用によって異なります。</span><span class="sxs-lookup"><span data-stu-id="0a436-104">Languages vary in their use of bit fields compared to enumeration constants.</span></span>  
  
## <a name="attributes-of-the-flagsattribute"></a><span data-ttu-id="0a436-105">FlagsAttribute 属性</span><span class="sxs-lookup"><span data-stu-id="0a436-105">Attributes of the FlagsAttribute</span></span>  
 <span data-ttu-id="0a436-106"><xref:System.AttributeUsageAttribute> このクラスに適用し、その<xref:System.AttributeUsageAttribute.Inherited%2A>プロパティを指定します`false`します。</span><span class="sxs-lookup"><span data-stu-id="0a436-106"><xref:System.AttributeUsageAttribute> is applied to this class, and its <xref:System.AttributeUsageAttribute.Inherited%2A> property specifies `false`.</span></span> <span data-ttu-id="0a436-107">この属性は、列挙型にのみ適用できます。</span><span class="sxs-lookup"><span data-stu-id="0a436-107">This attribute can only be applied to enumerations.</span></span>  
  
## <a name="guidelines-for-flagsattribute-and-enum"></a><span data-ttu-id="0a436-108">FlagsAttribute 列挙型のガイドライン</span><span class="sxs-lookup"><span data-stu-id="0a436-108">Guidelines for FlagsAttribute and Enum</span></span>  
  
-   <span data-ttu-id="0a436-109">使用して、<xref:System.FlagsAttribute>列挙体はビットごとの演算 (AND、OR の排他的 OR) は、数値に対して実行する場合にのみカスタム属性。</span><span class="sxs-lookup"><span data-stu-id="0a436-109">Use the <xref:System.FlagsAttribute> custom attribute for an enumeration only if a bitwise operation (AND, OR, EXCLUSIVE OR) is to be performed on a numeric value.</span></span>  
  
-   <span data-ttu-id="0a436-110">つまり、1、2、4、8、および具合 2 の累乗で、列挙定数を定義します。</span><span class="sxs-lookup"><span data-stu-id="0a436-110">Define enumeration constants in powers of two, that is, 1, 2, 4, 8, and so on.</span></span> <span data-ttu-id="0a436-111">これは、結合された列挙定数の個々 のフラグが重複しないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="0a436-111">This means the individual flags in combined enumeration constants do not overlap.</span></span>  
  
-   <span data-ttu-id="0a436-112">一般的に使用されるフラグの組み合わせの列挙型の定数を作成することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="0a436-112">Consider creating an enumerated constant for commonly used flag combinations.</span></span> <span data-ttu-id="0a436-113">たとえば、ファイル I/O 操作のための列挙体がある場合を含む列挙型定数`Read = 1`と`Write = 2`、列挙型の定数を作成すること検討`ReadWrite = Read OR Write`を組み合わせる、`Read`と`Write`フラグ。</span><span class="sxs-lookup"><span data-stu-id="0a436-113">For example, if you have an enumeration used for file I/O operations that contains the enumerated constants `Read = 1` and `Write = 2`, consider creating the enumerated constant `ReadWrite = Read OR Write`, which combines the `Read` and `Write` flags.</span></span> <span data-ttu-id="0a436-114">さらに、フラグの組み合わせに使用されるビットごとの OR 演算に単純なタスクに必要なすべきいくつかの状況での高度な概念を考慮することがあります。</span><span class="sxs-lookup"><span data-stu-id="0a436-114">In addition, the bitwise OR operation used to combine the flags might be considered an advanced concept in some circumstances that should not be required for simple tasks.</span></span>  
  
-   <span data-ttu-id="0a436-115">多くのフラグの位置は 1 では、コードに混乱する可能性がありますし、コーディング エラーに設定する可能性がありますので、フラグ列挙型定数として負の数を定義する場合は、注意を使用します。</span><span class="sxs-lookup"><span data-stu-id="0a436-115">Use caution if you define a negative number as a flag enumerated constant because many flag positions might be set to 1, which might make your code confusing and encourage coding errors.</span></span>  
  
-   <span data-ttu-id="0a436-116">数値の値で、フラグが設定されているかどうかをテストする便利な方法は、数値の値と、フラグに対応していないゼロを数値にすべてのビットを設定するフラグの列挙型定数のビットごとの AND 演算を実行するには、し、その操作の結果がフラグ列挙型定数と等しいかどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="0a436-116">A convenient way to test whether a flag is set in a numeric value is to perform a bitwise AND operation between the numeric value and the flag enumerated constant, which sets all bits in the numeric value to zero that do not correspond to the flag, then test whether the result of that operation is equal to the flag enumerated constant.</span></span>  
  
-   <span data-ttu-id="0a436-117">使用`None`フラグの名前は列挙定数の値が 0 として。</span><span class="sxs-lookup"><span data-stu-id="0a436-117">Use `None` as the name of the flag enumerated constant whose value is zero.</span></span> <span data-ttu-id="0a436-118">使用することはできません、`None`のため、結果は常に 0 フラグをテストするビットごとの AND 演算の列挙型定数。</span><span class="sxs-lookup"><span data-stu-id="0a436-118">You cannot use the `None` enumerated constant in a bitwise AND operation to test for a flag because the result is always zero.</span></span> <span data-ttu-id="0a436-119">ただし、行うことができます、論理、数値の間で、ビットごとの比較しないと、`None`数値の値のビットが設定されているかどうかを決定する列挙型定数。</span><span class="sxs-lookup"><span data-stu-id="0a436-119">However, you can perform a logical, not a bitwise, comparison between the numeric value and the `None` enumerated constant to determine whether any bits in the numeric value are set.</span></span>  
  
     <span data-ttu-id="0a436-120">作成するには有用ですフラグ列挙体ではなく値の列挙体を作成する場合、`None`列挙型定数。</span><span class="sxs-lookup"><span data-stu-id="0a436-120">If you create a value enumeration instead of a flags enumeration, it is still worthwhile to create a `None` enumerated constant.</span></span> <span data-ttu-id="0a436-121">理由は、既定では、列挙に使用されるメモリは 0 に初期化は、共通言語ランタイムによって。</span><span class="sxs-lookup"><span data-stu-id="0a436-121">The reason is that by default the memory used for the enumeration is initialized to zero by the common language runtime.</span></span> <span data-ttu-id="0a436-122">そのため、値が 0 の定数を定義していない場合、作成時に、列挙体は値が無効含まれます。</span><span class="sxs-lookup"><span data-stu-id="0a436-122">Consequently, if you do not define a constant whose value is zero, the enumeration will contain an illegal value when it is created.</span></span>  
  
     <span data-ttu-id="0a436-123">アプリケーションを表す必要がある、明確な既定のケースがある場合は、値がゼロを既定値を表す列挙定数の使用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="0a436-123">If there is an obvious default case your application needs to represent, consider using an enumerated constant whose value is zero to represent the default.</span></span> <span data-ttu-id="0a436-124">既定のケースがない場合、他の列挙定数のいずれかで表されないケースの値は 0 です。 列挙型の定数を使用することを意味を検討してください。</span><span class="sxs-lookup"><span data-stu-id="0a436-124">If there is no default case, consider using an enumerated constant whose value is zero that means the case that is not represented by any of the other enumerated constants.</span></span>  
  
-   <span data-ttu-id="0a436-125">列挙型自体の状態を反映するためだけにする列挙値を定義しません。</span><span class="sxs-lookup"><span data-stu-id="0a436-125">Do not define an enumeration value solely to mirror the state of the enumeration itself.</span></span> <span data-ttu-id="0a436-126">たとえば、単なる列挙体の末尾を示す列挙型の定数を定義してください。</span><span class="sxs-lookup"><span data-stu-id="0a436-126">For example, do not define an enumerated constant that merely marks the end of the enumeration.</span></span> <span data-ttu-id="0a436-127">列挙体の最後の値を決定する必要がある場合は、その値を明示的にチェックします。</span><span class="sxs-lookup"><span data-stu-id="0a436-127">If you need to determine the last value of the enumeration, check for that value explicitly.</span></span> <span data-ttu-id="0a436-128">さらに、範囲内のすべての値が有効な場合は、最初と最後の列挙型定数の範囲チェックを実行できます。</span><span class="sxs-lookup"><span data-stu-id="0a436-128">In addition, you can perform a range check for the first and last enumerated constant if all values within the range are valid.</span></span>  
  
-   <span data-ttu-id="0a436-129">将来使用するために予約されている列挙型定数は指定しません。</span><span class="sxs-lookup"><span data-stu-id="0a436-129">Do not specify enumerated constants that are reserved for future use.</span></span>  
  
-   <span data-ttu-id="0a436-130">メソッドまたは列挙型定数の値を受け取るプロパティを定義するときに、値の検証を検討してください。</span><span class="sxs-lookup"><span data-stu-id="0a436-130">When you define a method or property that takes an enumerated constant as a value, consider validating the value.</span></span> <span data-ttu-id="0a436-131">理由は、その数値の値が列挙体で定義されていない場合でも、数値の値を列挙型にキャストすることです。</span><span class="sxs-lookup"><span data-stu-id="0a436-131">The reason is that you can cast a numeric value to the enumeration type even if that numeric value is not defined in the enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a436-132">使用例を次に示します、`FlagsAttribute`属性し、に対する効果を示します、<xref:System.Enum.ToString%2A>メソッドを使用しての`FlagsAttribute`上、<xref:System.Enum>宣言します。</span><span class="sxs-lookup"><span data-stu-id="0a436-132">The following example illustrates the use of the `FlagsAttribute` attribute and shows the effect on the <xref:System.Enum.ToString%2A> method of using `FlagsAttribute` on an <xref:System.Enum> declaration.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 <span data-ttu-id="0a436-133">次の例は、2 つの色関連の列挙を定義します。`SingleHue`と`MultiHue`します。</span><span class="sxs-lookup"><span data-stu-id="0a436-133">The following example defines two color-related enumerations, `SingleHue` and `MultiHue`.</span></span> <span data-ttu-id="0a436-134">後者の場合は、`FlagsAttribute`属性。 前者はありません。</span><span class="sxs-lookup"><span data-stu-id="0a436-134">The latter has the `FlagsAttribute` attribute; the former does not.</span></span> <span data-ttu-id="0a436-135">列挙型の基になる値ではない整数を含む整数の範囲は、列挙型、および表示文字列表現にキャストするときは、動作の違いを示します。</span><span class="sxs-lookup"><span data-stu-id="0a436-135">The example shows the difference in behavior when a range of integers, including integers that do not represent underlying values of the enumeration type, are cast to the enumeration type and their string representations displayed.</span></span>   <span data-ttu-id="0a436-136">たとえば、3 として表すことができないことに注意してください、 `SingleHue` 3 は、いずれかの基になる値ではないため、その値`SingleHue`メンバー、一方、`FlagsAttribute`属性では、3 として表すことが、`MultiHue`の値`Black, Red`。</span><span class="sxs-lookup"><span data-stu-id="0a436-136">For example, note that 3 cannot be represented as a `SingleHue` value because 3 is not the underlying value of any `SingleHue` member, whereas the `FlagsAttribute` attribute makes it possible to represent 3 as a `MultiHue` value of `Black, Red`.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FlagsAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FlagsAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FlagsAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0a436-137">
            <see cref="T:System.FlagsAttribute" /> クラスの新しいインスタンスを初期化します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a436-137">Initializes a new instance of the <see cref="T:System.FlagsAttribute" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a436-138">次の例では、定義、`PhoneService`電話会社によって提供される通信のフォームを表す列挙体。</span><span class="sxs-lookup"><span data-stu-id="0a436-138">The following example defines a `PhoneService` enumeration that represents forms of communication provided by a telephone company.</span></span> <span data-ttu-id="0a436-139">次の 3 つの異なる家庭に提供されるサービスを表す 3 つの変数を初期化し、し、どの家庭には、どの家庭、携帯電話サービスのみがありどの家庭携帯電話と land の両方の行のサービスのサービスがないことを示します。</span><span class="sxs-lookup"><span data-stu-id="0a436-139">It initializes three variables representing the service provided to three different households, and then indicates which households have no service, which households have only cell phone service, and which households have both cell phone and land line service.</span></span> <span data-ttu-id="0a436-140">最後に、暗黙的に呼び出す、<xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType>各世帯に提供されるサービスの種類を表示するメソッド。</span><span class="sxs-lookup"><span data-stu-id="0a436-140">Finally, it implicitly calls the <xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType> method to display the types of service provided to each household.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 <span data-ttu-id="0a436-141">使用例を次に示します、`FlagsAttribute`属性し、に対する効果を示します、<xref:System.Enum.ToString%2A>メソッドを使用しての`FlagsAttribute`上、<xref:System.Enum>宣言します。</span><span class="sxs-lookup"><span data-stu-id="0a436-141">The following example illustrates the use of the `FlagsAttribute` attribute and shows the effect on the <xref:System.Enum.ToString%2A> method of using `FlagsAttribute` on an <xref:System.Enum> declaration.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>