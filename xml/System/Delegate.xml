<Type Name="Delegate" FullName="System.Delegate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3d9b1839ccedabbb705da25899027acccda6a8a3" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53233121" /></Metadata><TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>静的メソッドまたはクラス インスタンスとそのクラスのインスタンス メソッドを参照するデータ構造体であるデリゲートを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Delegate>クラスはデリゲート型の基本クラスです。 ただし、システムとコンパイラから派生できる明示的に、<xref:System.Delegate>クラスから、または、<xref:System.MulticastDelegate>クラス。 デリゲートの型から新しい型を派生させることではありません。 <xref:System.Delegate>クラス、デリゲート型とは見なされません。 クラスはデリゲート型の派生に使用されるクラスです。  
  
 ほとんどの言語の実装を`delegate`キーワード、およびそれらの言語のコンパイラはから派生することが、<xref:System.MulticastDelegate>クラス。 そのため、ユーザーが使用する必要があります、`delegate`言語によって提供されるキーワード。  
  
> [!NOTE]
>  共通言語ランタイムが提供する`Invoke`デリゲートと同じシグネチャを持つ各デリゲート型のメソッド。 コンパイラは、それを自動的に呼び出すためから、c#、Visual Basic、または Visual C は、このメソッドを明示的に呼び出す必要はありません。 `Invoke`メソッドは[リフレクション](~/docs/framework/reflection-and-codedom/reflection.md)デリゲートのシグネチャを検索する場合。  
  
 各デリゲート型を提供する共通言語ランタイム`BeginInvoke`と`EndInvoke`メソッド、デリゲートの非同期呼び出しを有効にします。 これらのメソッドの詳細については、次を参照してください。 [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)します。  
  
 デリゲート型の宣言では、1 つまたは複数のメソッドのシグネチャを指定するコントラクトを確立します。 参照を持つデリゲート型のインスタンスをデリゲートには。  
  
-   型と、その型に割り当て可能なターゲット オブジェクトのインスタンス メソッド。  
  
-   非表示を持つ、型のインスタンス メソッドを`this`仮パラメーター リストで公開されているパラメーター。 デリゲートは、開いているインスタンスのデリゲートと呼ばれます。  
  
-   静的メソッド。  
  
-   静的メソッドは、メソッドの最初のパラメーターに割り当て可能なターゲット オブジェクト。 デリゲートは、最初の引数を終了すると呼ばれます。  
  
 デリゲート バインディングの詳細については、次を参照してください。、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>メソッドのオーバー ロードします。  
  
> [!NOTE]
>  .NET Framework バージョン 1.0 および 1.1 では、デリゲートは、メソッドのシグネチャはデリゲート型で指定されたシグネチャを完全に一致する場合にのみ、メソッドを表すことができます。 したがって、上記の最初と 3 番目の箇条書きのみがサポートされている、最初の箇条書き、正確な型に一致が必要です。  
  
 デリゲートはメソッドのエントリ ポイントへの参照と定義されている型に割り当てることができるは、ターゲットと呼ばれる、オブジェクトへの参照を格納デリゲートは、閉じられた最初の引数 (最も一般的なケース)、インスタンス メソッドを表している場合、メソッド。 デリゲートは、開いているインスタンス メソッドを表している場合は、メソッドのエントリ ポイントへの参照を格納します。 デリゲートのシグネチャを非表示に含める必要があります`this`その仮パラメーター リスト; のパラメーターでこの例では、デリゲートには、ターゲット オブジェクトへの参照がないと、デリゲートが呼び出されたときに、ターゲット オブジェクトを指定する必要があります。  
  
 デリゲートは、静的メソッドを表している場合、デリゲートはメソッドのエントリ ポイントへの参照を格納します。 デリゲートは、最初の引数を捕捉する静的メソッドを表している場合、デリゲートは、メソッドのエントリ ポイントへの参照とメソッドの最初の引数の型に代入のターゲット オブジェクトへの参照を格納します。 デリゲートが呼び出されたときに、静的メソッドの最初の引数は、対象のオブジェクトを受け取ります。  
  
 デリゲートの呼び出しリストとは、一覧の各要素が、デリゲートによって表されるメソッドの 1 つだけに呼び出すデリゲートの順序付けされたセットです。 呼び出しリストは、重複するメソッドを含めることができます。 、、の呼び出し中には、メソッドは呼び出しリストに表示される順序で呼び出されます。 デリゲートの呼び出しリスト内のすべてのメソッドを呼び出すしようとしました。重複部分は、呼び出しリストに表示されるたびに、後に呼び出されます。 デリゲートは不変です。作成されると、デリゲートの呼び出しリストは変更されません。  
  
 デリゲートは参照されます、マルチキャスト、または組み合わせ可能なデリゲートが 1 つまたは複数のメソッドを呼び出すことができ、操作を組み合わせることで使用できるためです。  
  
 など、操作を組み合わせて<xref:System.Delegate.Combine%2A>と<xref:System.Delegate.Remove%2A>、既存のデリゲートを変更しないでください。 代わりに、このような操作は、変更されていないデリゲートを操作の結果を格納している新しいデリゲートを返しますまたは`null`します。 結合操作が返されます`null`ときに、操作の結果は、デリゲートを少なくとも 1 つのメソッドを参照していません。 結合操作は、要求された操作が影響を与えません場合に、変更されていないデリゲートを返します。  
  
> [!NOTE]
>  マネージ言語を使用、<xref:System.Delegate.Combine%2A>と<xref:System.Delegate.Remove%2A>デリゲートの操作を実装するメソッド。 例としては、`AddHandler`と`RemoveHandler`Basic における宣言ステートメントと + = および-= 演算子を c# の型を委任します。  
  
 以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、汎用デリゲート型はバリアント型パラメーターを持つことができます。 反変の型パラメーターは、デリゲートのパラメーターの型として使用でき、共変の型パラメーターを戻り値の型として使用することができます。 この機能により、汎用デリゲート型の割り当てと互換性のある場合、型引数は、継承関係を持つ参照型で説明したように、同じジェネリック型定義から構築される[共変性と反変性](~/docs/standard/generics/covariance-and-contravariance.md)します。  
  
> [!NOTE]
>  汎用デリゲートの割り当て-互換性のある分散のためには必ずしも combinable できません。 Combinable には、型が正確に一致する必要があります。 たとえば、という名前のクラス`Derived`という名前のクラスから派生`Base`します。 型のデリゲート`Action<Base>`(`Action(Of Base)` Visual Basic で) 型の変数に割り当てることができます`Action<Derived>`が、型が正確に一致しないために、2 つのデリゲートを組み合わせることはできません。  
  
 呼び出されたメソッドでは、例外をスローする場合、メソッドの実行は停止、デリゲートの呼び出し元に渡された例外および呼び出しリスト内の残りのメソッドは呼び出されません。 呼び出し元で例外をキャッチしても、この動作は変更されません。  
  
 デリゲートが呼び出されたメソッドのシグネチャには、戻り値が含まれている場合、デリゲートは、呼び出しリスト内の最後の要素の戻り値を返します。 署名には、参照によって渡されるパラメーターが含まれている場合、パラメーターの最終的な値は順番に実行して、パラメーターの値の更新の呼び出しリスト内のすべてのメソッドの結果にします。  
  
 C では、デリゲートの最も近いは、関数ポインターです。 デリゲートには、静的メソッドまたはインスタンス メソッドを表すことができます。 デリゲートがインスタンス メソッドを表すときに、デリゲートは、メソッドのエントリ ポイントへの参照だけでなく、クラスのインスタンスへの参照を格納します。 関数のポインターとは異なり、デリゲートはオブジェクト指向し、タイプ セーフです。  
  
   
  
## Examples  
 次の例は、という名前のデリゲートを定義する方法を示します`myMethodDelegate`します。 このデリゲートのインスタンスをインスタンス メソッドと、入れ子になったの静的メソッドの作成は`mySampleClass`クラス。 インスタンス メソッドのデリゲートのインスタンスを必要と`mySampleClass`します。 `mySampleClass`という名前の変数にインスタンスが保存`mySC`します。  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="https://msdn.microsoft.com/library/41972034-92ed-450a-9664-ab93fcc6f1fb">同期メソッドの非同期呼び出し</related>
    <related type="Article" href="~/docs/csharp/programming-guide/delegates/index.md">デリゲート (C# プログラミング ガイド)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/delegates/index.md">デリゲート (Visual Basic)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1cdf3420-89c1-47c0-b796-aa984020e0f8">方法: デリゲートを定義および使用する (C++/CLI)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f">イベントの処理と発生</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新しいデリゲートを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">デリゲートが <paramref name="method" /> を呼び出す対象のクラス インスタンス。</param>
        <param name="method">デリゲートによって表されるインスタンス メソッドの名前。</param>
        <summary>指定したインスタンス メソッドを指定のクラス インスタンスに対して呼び出すデリゲートを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターは、アプリケーション コードでは使用できません。 インスタンス メソッドの名前を指定することでデリゲートを作成するには、オーバー ロードを使用して、<xref:System.Delegate.CreateDelegate%2A>メソッド名とターゲット オブジェクトを指定するメソッド。 たとえば、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29>メソッドのオーバー ロードは、指定の名前を持つインスタンス メソッドのデリゲートを作成します。  
  
 このコンス トラクターのデリゲートのインスタンス メソッドだけを作成します。 インスタンス メソッドをクラスのインスタンスに関連付けられているメソッド静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="method" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">呼び出し先のメソッドをバインドするときにエラーが発生しました。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target"><paramref name="method" /> を定義するクラスを表す <see cref="T:System.Type" />。</param>
        <param name="method">デリゲートによって表される静的メソッドの名前。</param>
        <summary>指定したクラスから指定の静的メソッドを呼び出すデリゲートを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターは、アプリケーション コードでは使用できません。 静的メソッドの名前を指定することでデリゲートを作成するには、オーバー ロードを使用して、<xref:System.Delegate.CreateDelegate%2A>メソッド名を指定しますが、ターゲット オブジェクトを指定しないメソッド。 たとえば、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29>メソッド オーバー ロードは、指定の名前を持つメソッドの静的なデリゲートを作成します。  
  
 このコンス トラクターは、静的メソッドのみのデリゲートを作成します。 インスタンス メソッドをクラスのインスタンスに関連付けられているメソッド静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="method" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
- または - 
 <paramref name="target" /> は、オープン ジェネリック型を表します。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>デリゲートの簡易コピーを作成します。</summary>
        <returns>デリゲートの簡易コピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 クローンが同じ<xref:System.Type>、元のデリゲートとしてターゲット、メソッド、および呼び出しの一覧。  
  
 簡易コピーは、元のオブジェクトと同じ型の新しいインスタンスを作成し、元のオブジェクトの非静的フィールドをコピーします。 フィールドが値型の場合は、フィールドのビットごとのコピーが使用されます。 フィールドが参照型の場合は、参照がコピーされますが、参照先オブジェクトがないです。そのため、元のオブジェクト参照と、複製の参照は、同じオブジェクトをポイントします。 これに対し、オブジェクトのディープ コピーは、直接または間接的には、オブジェクトのフィールドによって参照されるすべてのものを複製します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したマルチキャスト (組み合わせ可能) デリゲートの呼び出しリストを連結します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">組み合わせるデリゲートの配列。</param>
        <summary>デリゲートの配列の呼び出しリストを連結します。</summary>
        <returns><paramref name="delegates" /> 配列内のデリゲートの呼び出しリストが連結された単一の呼び出しリストを持つ新しいデリゲート。 <paramref name="delegates" /> が <see langword="null" /> の場合、<paramref name="delegates" /> の要素が 0 個の場合、または <paramref name="delegates" /> のすべてのエントリが <see langword="null" /> の場合は、<see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、`delegates`配列には、あるエントリが含まれています。 `null`、これらのエントリは無視されます。  
  
 呼び出しリストが重複するエントリを含めることができます。同じオブジェクト上の同じメソッドを参照するエントリは、します。  
  
> [!NOTE]
>  汎用デリゲートの割り当て-互換性のある分散のためには必ずしも combinable できません。 Combinable には、型が正確に一致する必要があります。 たとえば、という名前のクラス`Derived`という名前のクラスから派生`Base`します。 型のデリゲート`Action<Base>`(`Action(Of Base)` Visual Basic で) 型の変数に割り当てることができます`Action<Derived>`で説明したように[共変性と反変性](~/docs/standard/generics/covariance-and-contravariance.md)、ため、型、2 つのデリゲートを組み合わせることはできませんが、正確に一致しません。  
  
 <xref:System.Delegate.Combine%2A> 呼び出しを複数のメソッド、イベントの時刻に発生するイベント ハンドラーを作成するために役立ちます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="delegates" /> 内の null でないすべてのエントリが同じデリゲート型のインスタンスではありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">連結後のリスト内で前に配置する呼び出しリストを持つデリゲート。</param>
        <param name="b">連結後のリスト内で後に配置する呼び出しリストを持つデリゲート。</param>
        <summary>2 つのデリゲートの呼び出しリストを連結します。</summary>
        <returns><paramref name="a" /> と <paramref name="b" /> の呼び出しリストをこの順番で連結した単一の呼び出しリストを持つ新しいデリゲート。 <paramref name="b" /> が <see langword="null" /> の場合は <paramref name="a" /> を、<paramref name="a" /> が null 参照の場合は <paramref name="b" /> を返します。また、<paramref name="a" /> と <paramref name="b" /> の両方が null 参照の場合は null 参照を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出しリストが重複するエントリを含めることができます。同じオブジェクト上の同じメソッドを参照するエントリは、します。  
  
> [!NOTE]
>  汎用デリゲートの割り当て-互換性のある分散のためには必ずしも combinable できません。 Combinable には、型が正確に一致する必要があります。 たとえば、という名前のクラス`Derived`という名前のクラスから派生`Base`します。 型のデリゲート`Action<Base>`(`Action(Of Base)` Visual Basic で) 型の変数に割り当てることができます`Action<Derived>`で説明したように[共変性と反変性](~/docs/standard/generics/covariance-and-contravariance.md)、ため、型、2 つのデリゲートを組み合わせることはできませんが、正確に一致しません。  
  
 <xref:System.Delegate.Combine%2A> 呼び出しを複数のメソッド、イベントの時刻に発生するイベント ハンドラーを作成するために役立ちます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="a" /> と <paramref name="b" /> の両方が <see langword="null" /> ではなく、<paramref name="a" /> と <paramref name="b" /> が同じデリゲート型のインスタンスではありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">現在のマルチキャスト (組み合わせ可能) デリゲートの呼び出しリストの末尾に追加される呼び出しリストを持つマルチキャスト (組み合わせ可能) デリゲート。</param>
        <summary>指定したマルチキャスト (組み合わせ可能) デリゲートと現在のマルチキャスト (組み合わせ可能) デリゲートの呼び出しリストを連結します。</summary>
        <returns>現在のマルチキャスト (組み合わせ可能) デリゲートの呼び出しリストと <paramref name="d" /> の呼び出しリストを連結した単一の呼び出しリストを持つ新しいマルチキャスト (組み合わせ可能) デリゲート。<paramref name="d" /> が <see langword="null" /> の場合は、現在のマルチキャスト (組み合わせ可能) デリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のデリゲートがマルチキャストである場合にのみ適用されます (組み合わせ可能)。  
  
 単に、現在の実装をスローする<xref:System.MulticastNotSupportedException>します。  
  
 呼び出しリストが重複するエントリを含めることができます。同じオブジェクト上の同じメソッドを参照するエントリは、します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">常にスローされます。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した型のデリゲートを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="method">デリゲートが表す静的メソッドまたはインスタンス メソッドの情報を記述する <see cref="T:System.Reflection.MethodInfo" />。 .NET Framework Version 1.0 および 1.1 では、静的メソッドのみサポートされます。</param>
        <summary>指定した静的メソッドを表すために、指定した型のデリゲートを作成します。</summary>
        <returns>指定した静的メソッドを表すための、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET framework version 1.0 および 1.1 では、このメソッドのオーバー ロードは静的メソッドのみのデリゲートを作成します。 .NET framework version 2.0 では、このメソッドのオーバー ロードも作成できますインスタンスを開くメソッドのデリゲート。つまりの非表示の最初の引数を明示的に指定するデリゲートはインスタンス メソッドです。 詳細についてより一般的なを参照してください。<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29>メソッドのオーバー ロードですべてのインスタンスまたは静的メソッドは、オープンかクローズのデリゲートの組み合わせを作成すると、必要に応じて最初の引数を指定することができます。  
  
> [!NOTE]
>  このメソッドのオーバー ロードする必要があるために、使用、最初の引数をデリゲートが閉じられていないときにその場合は少し高速です。  
  
 このメソッドのオーバー ロードの呼び出しと同じですが、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>メソッドのオーバー ロードを指定して`true`の`throwOnBindFailure`します。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、呼び出し元が許可されている場合は、パブリックでないメソッドへのアクセスに使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグを設定し、許可セットまたはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
## <a name="compatible-parameter-types-and-return-type"></a>互換性のあるパラメーターの型と戻り値の型  
 .NET framework version 2.0 では、パラメーターの型と、このメソッドのオーバー ロードを使用して作成されたデリゲートの戻り値の型と互換性があるパラメーターの型とデリゲートが表すメソッドの戻り値の型型は、正確に一致する必要はありません。 これは、.NET framework version 1.0 および 1.1 では、型が正確に一致する必要があります、バインドの動作を緩和したトークンを表します。  
  
 デリゲートのパラメーターにメソッドのパラメーターよりも限定的な型が指定された場合、両者のパラメーター間に型の互換性があると見なされます。これによって、デリゲートに渡された引数が、メソッドに対して安全に渡されることが保証されます。  
  
 同様に、メソッドの戻り値の型の制限がデリゲートの戻り値の型より多いと、メソッドの戻り値がデリゲートの戻り値の型に安全にキャストされることが保証されるため、デリゲートの戻り値の型とメソッドの戻り値の型には互換性があります。  
  
 たとえば、型のパラメーターを持つデリゲート<xref:System.Collections.Hashtable>と戻り値の型の<xref:System.Object>型のパラメーターを持つメソッドを表すことができます<xref:System.Object>型の戻り値と<xref:System.Collections.Hashtable>します。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例では、このメソッドのオーバー ロードを作成できるデリゲートの 2 つの種類: インスタンス メソッドを開き、静的メソッドを開きます。  
  
 2 番目のコード例では、互換性のあるパラメーターの型について説明し、型を返します。  
  
 **例 1**  
  
 次のコード例は、のこのオーバー ロードを使用してデリゲートを作成できる 2 つの方法を示します、<xref:System.Delegate.CreateDelegate%2A>メソッド。  
  
> [!NOTE]
>  2 つのオーバー ロードがあります、<xref:System.Delegate.CreateDelegate%2A>メソッドを指定する、<xref:System.Reflection.MethodInfo>最初の引数されませんが、スロー、バインドに失敗するかどうかを指定することができますいずれかと、もう一方は常にスローする点を除いて、機能は同じです。 このコード例では、両方のオーバー ロードを使用します。  
  
 例では、クラスを宣言します`C`静的な方法で`M2`とインスタンス メソッド`M1`、2 つのデリゲート型と:`D1`のインスタンスを受け取り`C`および文字列、および`D2`は文字列を受け取ります。  
  
 という名前の 2 番目のクラス`Example`デリゲートを作成するコードが含まれています。  
  
-   型のデリゲート`D1`、開いているインスタンス メソッドを表す、インスタンス メソッドの作成は`M1`します。 デリゲートが呼び出されたときに、インスタンスを渡す必要があります。  
  
-   型のデリゲート`D2`、オープンな静的メソッドを表す、静的なメソッドの作成は`M2`します。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **例 2**  
  
 次のコード例では、パラメーターの型の互換性について説明し、型を返します。  
  
 コード例は、という名前の基本クラスを定義します。`Base`という名前のクラスと`Derived`から派生した`Base`します。 派生クラスには、 `static` (`Shared` Visual Basic で) という名前のメソッド`MyMethod`型の 1 つのパラメーターを持つ`Base`の戻り値の型`Derived`します。 コード例では、という名前のデリゲートも定義します`Example`型の 1 つのパラメーターを持つ`Derived`の戻り値の型と`Base`します。  
  
 このコード例で、デリゲートが名前付き`Example`メソッドを表すために使用できる`MyMethod`します。 メソッドは、ために、デリゲートにバインドできます。  
  
-   デリゲートのパラメーターの型 (`Derived`) のパラメーターの型より限定的な`MyMethod`(`Base`) は常に安全にするデリゲートの引数を渡すことにより、`MyMethod`します。  
  
-   戻り値の型`MyMethod`(`Derived`) が、デリゲートのパラメーターの型よりも厳しい (`Base`) デリゲートの戻り値の型をメソッドの戻り値の型をキャストしても安全では常にするようにします。  
  
 コード例は、出力を生成しません。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="method" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
- または - 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
- または - 
 <paramref name="method" /> は静的メソッドではなく、.NET Framework バージョンは 1.0 または 1.1 です。  
  
または 
 <paramref name="method" /> はバインドできません。  
  
または 
 <paramref name="method" /> が <see langword="RuntimeMethodInfo" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="firstArgument">デリゲートのバインド先のオブジェクト。<paramref name="method" /> を <see langword="static" /> (Visual Basic の場合は <see langword="Shared" />) として扱う場合は <see langword="null" />。</param>
        <param name="method">デリゲートが表す静的メソッドまたはインスタンス メソッドの情報を記述する <see cref="T:System.Reflection.MethodInfo" />。</param>
        <summary>指定された静的メソッドまたはインスタンス メソッドを表す、指定した型のデリゲートを、第 1 引数を指定して作成します。</summary>
        <returns>指定した静的メソッドまたはインスタンス メソッドを表すための、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出しと同じですがこのメソッドのオーバー ロードを呼び出し、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>メソッドのオーバー ロードを指定して`true`の`throwOnBindFailure`します。 これら 2 つのオーバー ロードは、デリゲートを作成する最も柔軟な方法を提供します。 インスタンス メソッド、またはいずれかの静的なデリゲートを作成して、最初の引数を指定する必要に応じて使用できます。  
  
> [!NOTE]
>  最初の引数を指定しない場合は、使用、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>パフォーマンス向上のためのメソッドのオーバー ロードします。  
  
 デリゲートの型とメソッドには、互換性のある戻り値の型がある場合があります。 戻り値の型は、`method`の戻り値の型に代入する必要があります`type`します。  
  
 場合`firstArgument`は省略するに渡される`method`たびに、デリゲートが呼び出されます。`firstArgument`デリゲートにバインドすると言いますと、最初の引数を終了するデリゲートを言います。 場合`method`は`static`(`Shared` Visual basic)、引数場合、デリゲートを呼び出すときに提供される一覧には、先頭を除くすべてのパラメーターが含まれて`method`し、インスタンス メソッドである`firstArgument`非表示のインスタンスに渡されますパラメーター (によって表される`this`で c# の場合、または`Me`Visual Basic で)。  
  
 場合`firstArgument`は、指定した最初のパラメーターの`method`、参照型である必要がありますと`firstArgument`型と一致する必要があります。  
  
> [!IMPORTANT]
>  場合`method`は`static`(`Shared` Visual basic)、最初のパラメーターの種類<xref:System.Object>または<xref:System.ValueType>、し`firstArgument`値型であることができます。 ここで`firstArgument`自動的にボックス化されます。 C# または Visual Basic の関数を呼び出す場合と、自動のボックス化は、その他の引数の発生しません。  
  
 場合`firstArgument`null 参照と`method`インスタンス メソッドでは、結果は、デリゲート型のシグネチャによって異なります`type`の`method`:。  
  
-   場合の署名`type`の非表示の最初のパラメーターを明示的に含まれて`method`デリゲートがインスタンスを開くメソッドを表すと呼ばれます。 インスタンスを非表示パラメーターに引数リストの最初の引数が渡されたデリゲートが呼び出されたときに`method`します。  
  
-   場合の署名`method`と`type`一致 (つまり、すべてのパラメーター型は互換性のある)、デリゲートが null 参照を終了すると言います。 特に使い道はありません、null のインスタンスのインスタンス メソッドを呼び出す場合とは、デリゲートの呼び出しです。  
  
 場合`firstArgument`null 参照と`method`は静的で、結果はデリゲート型のシグネチャに依存`type`の`method`:  
  
-   場合の署名`method`と`type`一致 (つまり、すべてのパラメーター型は互換性のある)、オープンな静的メソッドを表すデリゲートといいます。 これは、静的メソッドの最も一般的なケースです。 この場合は、若干優れたパフォーマンスを使用して取得できます、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>メソッドのオーバー ロードします。  
  
-   場合の署名`type`の 2 番目のパラメーターで始まる`method`パラメーターの型の残りの部分は、互換性のあるし、デリゲートが null 参照を終了すると言います。 最初のパラメーターに null 参照が渡されるデリゲートが呼び出されたときに`method`します。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、呼び出し元が許可されている場合は、パブリックでないメソッドへのアクセスに使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグを設定し、許可セットまたはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
## <a name="compatible-parameter-types-and-return-type"></a>互換性のあるパラメーターの型と戻り値の型  
 パラメーターの型とデリゲートの戻り値の型がパラメーターの型とデリゲートが表すメソッドの戻り値の型と互換性があります。型は、正確に一致する必要はありません。  
  
> [!NOTE]
>  .NET Framework version 1.0 および 1.1 では、種類が完全に一致する必要があります。  
  
 デリゲートのパラメーターにメソッドのパラメーターよりも限定的な型が指定された場合、両者のパラメーター間に型の互換性があると見なされます。これによって、デリゲートに渡された引数が、メソッドに対して安全に渡されることが保証されます。  
  
 同様に、メソッドの戻り値の型の制限がデリゲートの戻り値の型より多いと、メソッドの戻り値がデリゲートの戻り値の型に安全にキャストされることが保証されるため、デリゲートの戻り値の型とメソッドの戻り値の型には互換性があります。  
  
 たとえば、型のパラメーターを持つデリゲート<xref:System.Collections.Hashtable>と戻り値の型の<xref:System.Object>型のパラメーターを持つメソッドを表すことができます<xref:System.Object>型の戻り値と<xref:System.Collections.Hashtable>します。  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>メソッドを決定するデリゲートが表すことができます。  
 もう 1 つの便利な方法のこのオーバー ロードによって提供される柔軟性を考える<xref:System.Delegate.CreateDelegate%2A>は、特定のデリゲートがメソッドのシグネチャとメソッドの種類 (インスタンスと静的) の 4 つの異なる組み合わせを表すことができます。 デリゲート型を考えてみます`D`型の 1 つの引数を持つ`C`します。 メソッドを以下に示します`D`に常に一致する必要がありますので、戻り値の型を無視して、表すことができます。  
  
-   `D` 型の 1 つの引数を持つ任意のインスタンス メソッドを表すことができます`C`インスタンス メソッドが所属するどのような種類に関係なく、します。 ときに<xref:System.Delegate.CreateDelegate%2A>が呼び出され、 `firstArgument` 、型のインスタンスは、`method`が属していると、得られたデリゲート、そのインスタンスを終了します。 (普通に、`D`場合に null 参照を終了することも`firstArgument`は null 参照です)。  
  
-   `D` インスタンス メソッドを表すことができます`C`引数を持たない。 ときに<xref:System.Delegate.CreateDelegate%2A>が呼び出され、`firstArgument`は null 参照です。 得られたデリゲートのインスタンスと、開いているインスタンス メソッドを表します`C`が呼び出されるたびを指定する必要があります。  
  
-   `D` 型の 1 つの引数を受け取る静的メソッドを表すことができます`C`メソッドは、任意の型に属することができます。 ときに<xref:System.Delegate.CreateDelegate%2A>が呼び出され、`firstArgument`は null 参照です。 得られたデリゲートは、オープンな静的メソッドとのインスタンスを表します`C`が呼び出されるたびを指定する必要があります。  
  
-   `D` 型に属する静的メソッドを表すことができます`F`型の 2 つの引数を持つと`F`と種類`C`します。 ときに<xref:System.Delegate.CreateDelegate%2A>が呼び出され、`firstArgument`のインスタンスである`F`します。 結果として得られるデリゲートのインスタンス経由で閉じられている静的メソッドを表す`F`します。 場合は注意してください、`F`と`C`同じ型には、静的メソッドがその型の 2 つの引数。 (この場合、`D`場合は、null 参照で終了`firstArgument`は null 参照です)。  
  
   
  
## Examples  
 このセクションでは、次の 3 つのコード例を示します。 最初の例では、作成できるデリゲートの 4 つの種類: インスタンス メソッド、静的メソッドよりオープンで開いているインスタンス メソッド経由で閉じられ、静的メソッドを終了します。  
  
 2 番目のコード例では、互換性のあるパラメーターの型について説明し、型を返します。  
  
 3 番目のコード例では、1 つのデリゲート型を定義し、すべてのメソッドをデリゲート型を表すことができますを示します。  
  
 **例 1**  
  
 次のコード例は、のこのオーバー ロードを使用してデリゲートを作成することができます、4 つの方法を示します、<xref:System.Delegate.CreateDelegate%2A>メソッド。  
  
> [!NOTE]
>  2 つのオーバー ロードがあります、<xref:System.Delegate.CreateDelegate%2A>メソッドを指定する`firstArgument`と<xref:System.Reflection.MethodInfo>; をバインドするには、失敗した場合にスローするかどうかを指定することができますいずれかと、もう一方は常にスローする点を除いて、機能は同じです。 このコード例では、両方のオーバー ロードを使用します。  
  
 例では、クラスを宣言します`C`静的な方法で`M2`とインスタンス メソッド`M1`、3 つのデリゲート型と:`D1`のインスタンスを受け取り`C`および文字列、`D2`は文字列、および`D3`引数がありません。  
  
 という名前の 2 番目のクラス`Example`デリゲートを作成するコードが含まれています。  
  
-   型のデリゲート`D2`のインスタンスを終了済み`C`、インスタンス メソッドの作成は`M1`します。 バインドのインスタンスを表示する別の文字列でメソッドが呼び出された`C`は常に使用します。  
  
-   型のデリゲート`D1`、開いているインスタンス メソッドを表す、インスタンス メソッドの作成は`M1`します。 デリゲートが呼び出されたときに、インスタンスを渡す必要があります。  
  
-   型のデリゲート`D2`、オープンな静的メソッドを表す、静的なメソッドの作成は`M2`します。  
  
-   最後に、型のデリゲート`D3`、文字列を閉じ、静的メソッドが作成されます`M2`します。 メソッドは、連結文字列を使用しているかを表示します。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **例 2**  
  
 次のコード例では、パラメーターの型の互換性について説明し、型を返します。  
  
> [!NOTE]
>  このコード例では、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>メソッドのオーバー ロードします。 その他の使用にオーバー ロードを受け取る<xref:System.Reflection.MethodInfo>は似ています。  
  
 コード例は、という名前の基本クラスを定義します。`Base`という名前のクラスと`Derived`から派生した`Base`します。 派生クラスには、 `static` (`Shared` Visual Basic で) という名前のメソッド`MyMethod`型の 1 つのパラメーターを持つ`Base`の戻り値の型`Derived`します。 コード例では、という名前のデリゲートも定義します`Example`型の 1 つのパラメーターを持つ`Derived`の戻り値の型と`Base`します。  
  
 このコード例で、デリゲートが名前付き`Example`メソッドを表すために使用できる`MyMethod`します。 メソッドは、ために、デリゲートにバインドできます。  
  
-   デリゲートのパラメーターの型 (`Derived`) のパラメーターの型より限定的な`MyMethod`(`Base`) は常に安全にするデリゲートの引数を渡すことにより、`MyMethod`します。  
  
-   戻り値の型`MyMethod`(`Derived`) が、デリゲートのパラメーターの型よりも厳しい (`Base`) デリゲートの戻り値の型をメソッドの戻り値の型をキャストしても安全では常にするようにします。  
  
 コード例は、出力を生成しません。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **例 3**  
  
 次のコード例を示しています、すべてのメソッドを使用して、1 つのデリゲート型を表すことができます、<xref:System.Delegate.CreateDelegate%2A>メソッド、デリゲートを作成します。  
  
> [!NOTE]
>  2 つのオーバー ロードがあります、<xref:System.Delegate.CreateDelegate%2A>メソッドを指定する`firstArgument`と<xref:System.Reflection.MethodInfo>; をバインドするには、失敗した場合にスローするかどうかを指定することができますいずれかと、もう一方は常にスローする点を除いて、機能は同じです。 このコード例では、両方のオーバー ロードを使用します。  
  
 コード例は、2 つのクラスを定義します。`C`と`F`、とデリゲート型`D`型の 1 つの引数を持つ`C`します。 クラスが静的に一致して、インスタンス メソッド`M1`、 `M3`、および`M4`、およびクラス`C`インスタンス メソッドがあります`M2`引数を持たない。  
  
 という名前の 3 番目のクラス`Example`デリゲートを作成するコードが含まれています。  
  
-   メソッド インスタンスの作成デリゲート`M1`型の`C`と種類`F`; それぞれが、それぞれの型のインスタンスを閉じています。 メソッド`M1`型の`C`が表示されます、`ID`引数のバインドのインスタンスのプロパティ。  
  
-   メソッドのデリゲートを作成`M2`型の`C`します。 これはのインスタンスを開くデリゲート、デリゲートの引数が非表示の最初の引数でインスタンス メソッドを表します。 メソッドには、その他の引数がありません。 静的メソッドの場合と同様に呼び出されます。  
  
-   静的メソッドに対してデリゲートを作成`M3`型の`C`と種類`F`。 これらは、オープンな静的デリゲート。  
  
-   静的メソッドに対してデリゲートを作成する最後に、`M4`型の`C`と種類`F`; は、各メソッドが最初の引数として宣言する型と型のインスタンスが指定されるため、その最初の引数をデリゲートは閉じられます. メソッド`M4`型の`C`が表示されます、`ID`引数のバインドのインスタンスのプロパティ。  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="method" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
または 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
または 
 <paramref name="method" /> はバインドできません。  
  
または 
 <paramref name="method" /> が <see langword="RuntimeMethodInfo" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="target"><paramref name="method" /> を呼び出す対象のクラス インスタンス。</param>
        <param name="method">デリゲートによって表されるインスタンス メソッドの名前。</param>
        <summary>指定したクラス インスタンスに対して呼び出す指定したインスタンス メソッドを表す、指定した型のデリゲートを作成します。</summary>
        <returns>指定したクラス インスタンスに対して呼び出す指定したインスタンス メソッドを表す、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのデリゲートのインスタンス メソッドだけを作成します。 インスタンス メソッドをクラスのインスタンスに関連付けられているメソッド静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
 このメソッドのオーバー ロードの呼び出しと同じですが、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードを指定する`false`の`ignoreCase`と`true`の`throwOnBindFailure`します。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、呼び出し元が許可されている場合は、パブリックでないメソッドへのアクセスに使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグを設定し、許可セットまたはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="target" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="method" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
- または - 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
または 
 <paramref name="method" /> はインスタンス メソッドではありません。  
  
- または - 
 <paramref name="method" /> をバインドできません (たとえば、これが見つからないなど)。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="method">デリゲートが表す静的メソッドまたはインスタンス メソッドの情報を保持する <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="throwOnBindFailure"><paramref name="method" /> をバインドできないときに例外をスローする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定された静的メソッドを表す、指定された型のデリゲートを、バインドに失敗した場合の動作を指定して作成します。</summary>
        <returns>指定した静的メソッドを表すための、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのオーバー ロードは、オープンな静的メソッドのデリゲートを作成し、インスタンス メソッドのデリゲートには、インスタンス メソッドの非表示の最初の引数を公開するデリゲートを開きます。 詳細についてより一般的なを参照してください。<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>メソッド オーバー ロードを使用すると、インスタンスのすべてのオープンかクローズのデリゲートの組み合わせを作成または静的メソッド。  
  
> [!NOTE]
>  このメソッドのオーバー ロードする必要があるために、使用、最初の引数をデリゲートが閉じられていないときにその場合は少し高速です。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、呼び出し元が許可されている場合は、パブリックでないメソッドへのアクセスに使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグを設定し、許可セットまたはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
## <a name="compatible-parameter-types-and-return-type"></a>互換性のあるパラメーターの型と戻り値の型  
 パラメーターの型とデリゲートの戻り値の型がパラメーターの型とデリゲートが表すメソッドの戻り値の型と互換性があります。型は、正確に一致する必要はありません。  
  
> [!NOTE]
>  .NET Framework version 1.0 および 1.1 では、種類が完全に一致する必要があります。  
  
 デリゲートのパラメーターにメソッドのパラメーターよりも限定的な型が指定された場合、両者のパラメーター間に型の互換性があると見なされます。これによって、デリゲートに渡された引数が、メソッドに対して安全に渡されることが保証されます。  
  
 同様に、メソッドの戻り値の型の制限がデリゲートの戻り値の型より多いと、メソッドの戻り値がデリゲートの戻り値の型に安全にキャストされることが保証されるため、デリゲートの戻り値の型とメソッドの戻り値の型には互換性があります。  
  
 たとえば、型のパラメーターを持つデリゲート<xref:System.Collections.Hashtable>と戻り値の型の<xref:System.Object>型のパラメーターを持つメソッドを表すことができます<xref:System.Object>型の戻り値と<xref:System.Collections.Hashtable>します。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例では、このメソッドのオーバー ロードを作成できるデリゲートの 2 つの種類: インスタンス メソッドを開き、静的メソッドを開きます。  
  
 2 番目のコード例では、互換性のあるパラメーターの型について説明し、型を返します。  
  
 **例 1**  
  
 次のコード例は、のこのオーバー ロードを使用してデリゲートを作成できる 2 つの方法を示します、<xref:System.Delegate.CreateDelegate%2A>メソッド。  
  
> [!NOTE]
>  2 つのオーバー ロードがあります、<xref:System.Delegate.CreateDelegate%2A>メソッドを指定する、<xref:System.Reflection.MethodInfo>最初の引数されませんが、スロー、バインドに失敗するかどうかを指定することができますいずれかと、もう一方は常にスローする点を除いて、機能は同じです。 このコード例では、両方のオーバー ロードを使用します。  
  
 例では、クラスを宣言します`C`静的な方法で`M2`とインスタンス メソッド`M1`、2 つのデリゲート型と:`D1`のインスタンスを受け取り`C`および文字列、および`D2`は文字列を受け取ります。  
  
 という名前の 2 番目のクラス`Example`デリゲートを作成するコードが含まれています。  
  
-   型のデリゲート`D1`、開いているインスタンス メソッドを表す、インスタンス メソッドの作成は`M1`します。 デリゲートが呼び出されたときに、インスタンスを渡す必要があります。  
  
-   型のデリゲート`D2`、オープンな静的メソッドを表す、静的なメソッドの作成は`M2`します。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **例 2**  
  
 次のコード例では、パラメーターの型の互換性について説明し、型を返します。  
  
> [!NOTE]
>  このコード例では、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>メソッドのオーバー ロードします。 その他の使用にオーバー ロードを受け取る<xref:System.Reflection.MethodInfo>は似ています。  
  
 コード例は、という名前の基本クラスを定義します。`Base`という名前のクラスと`Derived`から派生した`Base`します。 派生クラスには、 `static` (`Shared` Visual Basic で) という名前のメソッド`MyMethod`型の 1 つのパラメーターを持つ`Base`の戻り値の型`Derived`します。 コード例では、という名前のデリゲートも定義します`Example`型の 1 つのパラメーターを持つ`Derived`の戻り値の型と`Base`します。  
  
 このコード例で、デリゲートが名前付き`Example`メソッドを表すために使用できる`MyMethod`します。 メソッドは、ために、デリゲートにバインドできます。  
  
-   デリゲートのパラメーターの型 (`Derived`) のパラメーターの型より限定的な`MyMethod`(`Base`) は常に安全にするデリゲートの引数を渡すことにより、`MyMethod`します。  
  
-   戻り値の型`MyMethod`(`Derived`) が、デリゲートのパラメーターの型よりも厳しい (`Base`) デリゲートの戻り値の型をメソッドの戻り値の型をキャストしても安全では常にするようにします。  
  
 コード例は、出力を生成しません。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="method" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
または 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
または 
 <paramref name="method" /> はバインドできず、<paramref name="throwOnBindFailure" /> は <see langword="true" /> です。  
  
または 
 <paramref name="method" /> が <see langword="RuntimeMethodInfo" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="target"><paramref name="method" /> を実装するクラスを表す <see cref="T:System.Type" />。</param>
        <param name="method">デリゲートによって表される静的メソッドの名前。</param>
        <summary>指定したクラスの指定した静的メソッドを表す、指定した型のデリゲートを作成します。</summary>
        <returns>指定したクラスの指定した静的メソッドを表す、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、静的メソッドのみのデリゲートを作成します。 インスタンス メソッドをクラスのインスタンスに関連付けられているメソッド静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
 このメソッドのオーバー ロードの呼び出しと同じですが、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードを指定する`false`の`ignoreCase`と`true`の`throwOnBindFailure`します。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、呼び出し元が許可されている場合は、パブリックでないメソッドへのアクセスに使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグを設定し、許可セットまたはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="target" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="method" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
または 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
または 
 <paramref name="target" /> が <see langword="RuntimeType" /> ではありません。  
  
または 
 <paramref name="target" /> はオープン ジェネリック型です。 つまり、その <see cref="P:System.Type.ContainsGenericParameters" /> プロパティは <see langword="true" /> です。  
  
- または - 
 <paramref name="method" /> は <see langword="static" /> メソッド (Visual Basic では <see langword="Shared" /> メソッド) ではありません。  
  
または 
 見つからないなどの原因により、<paramref name="method" /> をバインドできません。また、<paramref name="throwOnBindFailure" /> が <see langword="true" /> です。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの型を表す <see cref="T:System.Type" />。</param>
        <param name="firstArgument">デリゲートが表すメソッドの第 1 引数である <see cref="T:System.Object" />。 インスタンス メソッドの場合は、そのインスタンスの型との互換性が必要です。</param>
        <param name="method">デリゲートが表す静的メソッドまたはインスタンス メソッドの情報を保持する <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="throwOnBindFailure"><paramref name="method" /> をバインドできないときに例外をスローする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定された静的メソッドまたはインスタンス メソッドを表す、指定した型のデリゲートを、第 1 引数およびバインドに失敗したときの動作を指定して作成します。</summary>
        <returns>指定された静的メソッドまたはインスタンス メソッドを表す、指定された型のデリゲート。<paramref name="throwOnBindFailure" /> が <see langword="false" /> で、デリゲートを <paramref name="method" /> にバインドできない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのオーバー ロードと<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29>バインドに失敗したとき常にスローすると、メソッドのオーバー ロードは、デリゲートを作成する最も柔軟な方法を提供します。 最初の引数の有無、またはインスタンス メソッドのいずれかの静的なデリゲートを作成するのにには、それらを使用できます。  
  
> [!NOTE]
>  最初の引数を指定しない場合は、使用、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>パフォーマンス向上のためのメソッドのオーバー ロードします。  
  
 デリゲートの型とメソッドには、互換性のある戻り値の型がある場合があります。 戻り値の型は、`method`の戻り値の型に代入する必要があります`type`します。  
  
 場合`firstArgument`は省略するに渡される`method`たびに、デリゲートが呼び出されます。`firstArgument`デリゲートにバインドすると言いますと、最初の引数を終了するデリゲートを言います。 場合`method`は`static`(`Shared` Visual basic)、引数場合、デリゲートを呼び出すときに提供される一覧には、先頭を除くすべてのパラメーターが含まれて`method`し、インスタンス メソッドである`firstArgument`非表示のインスタンスに渡されますパラメーター (によって表される`this`で c# の場合、または`Me`Visual Basic で)。  
  
 場合`firstArgument`は、指定した最初のパラメーターの`method`、参照型である必要がありますと`firstArgument`型と一致する必要があります。  
  
> [!IMPORTANT]
>  場合`method`は`static`(`Shared` Visual basic)、最初のパラメーターの種類<xref:System.Object>または<xref:System.ValueType>、し`firstArgument`値型であることができます。 ここで`firstArgument`自動的にボックス化されます。 C# または Visual Basic の関数を呼び出す場合と、自動のボックス化は、その他の引数の発生しません。  
  
 場合`firstArgument`null 参照と`method`インスタンス メソッドでは、結果は、デリゲート型のシグネチャによって異なります`type`の`method`:。  
  
-   場合の署名`type`の非表示の最初のパラメーターを明示的に含まれて`method`デリゲートがインスタンスを開くメソッドを表すと呼ばれます。 インスタンスを非表示パラメーターに引数リストの最初の引数が渡されたデリゲートが呼び出されたときに`method`します。  
  
-   場合の署名`method`と`type`一致 (つまり、すべてのパラメーター型は互換性のある)、デリゲートが null 参照を終了すると言います。 特に使い道はありません、null のインスタンスのインスタンス メソッドを呼び出す場合とは、デリゲートの呼び出しです。  
  
 場合`firstArgument`null 参照と`method`は静的で、結果はデリゲート型のシグネチャに依存`type`の`method`:  
  
-   場合の署名`method`と`type`一致 (つまり、すべてのパラメーター型は互換性のある)、オープンな静的メソッドを表すデリゲートといいます。 これは、静的メソッドの最も一般的なケースです。 この場合は、若干優れたパフォーマンスを使用して取得できます、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>メソッドのオーバー ロードします。  
  
-   場合の署名`type`の 2 番目のパラメーターで始まる`method`パラメーターの型の残りの部分は、互換性のあるし、デリゲートが null 参照を終了すると言います。 最初のパラメーターに null 参照が渡されるデリゲートが呼び出されたときに`method`します。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、呼び出し元が許可されている場合は、パブリックでないメソッドへのアクセスに使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグを設定し、許可セットまたはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
## <a name="compatible-parameter-types-and-return-type"></a>互換性のあるパラメーターの型と戻り値の型  
 パラメーターの型とデリゲートの戻り値の型がパラメーターの型とデリゲートが表すメソッドの戻り値の型と互換性があります。型は、正確に一致する必要はありません。  
  
> [!NOTE]
>  .NET Framework version 1.0 および 1.1 では、型が正確に一致する必要があります。  
  
 デリゲートのパラメーターにメソッドのパラメーターよりも限定的な型が指定された場合、両者のパラメーター間に型の互換性があると見なされます。これによって、デリゲートに渡された引数が、メソッドに対して安全に渡されることが保証されます。  
  
 同様に、メソッドの戻り値の型の制限がデリゲートの戻り値の型より多いと、メソッドの戻り値がデリゲートの戻り値の型に安全にキャストされることが保証されるため、デリゲートの戻り値の型とメソッドの戻り値の型には互換性があります。  
  
 たとえば、型のパラメーターを持つデリゲート<xref:System.Collections.Hashtable>と戻り値の型の<xref:System.Object>型のパラメーターを持つメソッドを表すことができます<xref:System.Object>型の戻り値と<xref:System.Collections.Hashtable>します。  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>メソッドを決定するデリゲートが表すことができます。  
 もう 1 つの便利な方法のこのオーバー ロードによって提供される柔軟性を考える<xref:System.Delegate.CreateDelegate%2A>は、特定のデリゲートがメソッドのシグネチャとメソッドの種類 (インスタンスと静的) の 4 つの異なる組み合わせを表すことができます。 デリゲート型を考えてみます`D`型の 1 つの引数を持つ`C`します。 メソッドを以下に示します`D`に常に一致する必要がありますので、戻り値の型を無視して、表すことができます。  
  
-   `D` 型の 1 つの引数を持つ任意のインスタンス メソッドを表すことができます`C`インスタンス メソッドが所属するどのような種類に関係なく、します。 ときに<xref:System.Delegate.CreateDelegate%2A>が呼び出され、 `firstArgument` 、型のインスタンスは、`method`が属していると、得られたデリゲート、そのインスタンスを終了します。 (普通に、`D`場合に null 参照を終了することも`firstArgument`は`null`)。  
  
-   `D` インスタンス メソッドを表すことができます`C`引数を持たない。 ときに<xref:System.Delegate.CreateDelegate%2A>が呼び出され、`firstArgument`は null 参照です。 得られたデリゲートのインスタンスと、開いているインスタンス メソッドを表します`C`が呼び出されるたびを指定する必要があります。  
  
-   `D` 型の 1 つの引数を受け取る静的メソッドを表すことができます`C`メソッドは、任意の型に属することができます。 ときに<xref:System.Delegate.CreateDelegate%2A>が呼び出され、`firstArgument`は null 参照です。 得られたデリゲートは、オープンな静的メソッドとのインスタンスを表します`C`が呼び出されるたびを指定する必要があります。  
  
-   `D` 型に属する静的メソッドを表すことができます`F`型の 2 つの引数を持つと`F`と種類`C`します。 ときに<xref:System.Delegate.CreateDelegate%2A>が呼び出され、`firstArgument`のインスタンスである`F`します。 結果として得られるデリゲートのインスタンス経由で閉じられている静的メソッドを表す`F`します。 場合は注意してください、`F`と`C`同じ型には、静的メソッドがその型の 2 つの引数。 (この場合、`D`場合は、null 参照で終了`firstArgument`は`null`)。  
  
   
  
## Examples  
 このセクションでは、次の 3 つのコード例を示します。 最初の例では、作成できるデリゲートの 4 つの種類: インスタンス メソッド、静的メソッドよりオープンで開いているインスタンス メソッド経由で閉じられ、静的メソッドを終了します。  
  
 2 番目のコード例では、互換性のあるパラメーターの型について説明し、型を返します。  
  
 3 番目のコード例では、1 つのデリゲート型を定義し、すべてのメソッドをデリゲート型を表すことができますを示します。  
  
 **例 1**  
  
 次のコード例は、のこのオーバー ロードを使用してデリゲートを作成することができます、4 つの方法を示します、<xref:System.Delegate.CreateDelegate%2A>メソッド。  
  
> [!NOTE]
>  2 つのオーバー ロードがあります、<xref:System.Delegate.CreateDelegate%2A>メソッドを指定する`firstArgument`と<xref:System.Reflection.MethodInfo>; をバインドするには、失敗した場合にスローするかどうかを指定することができますいずれかと、もう一方は常にスローする点を除いて、機能は同じです。 このコード例では、両方のオーバー ロードを使用します。  
  
 例では、クラスを宣言します`C`静的な方法で`M2`とインスタンス メソッド`M1`、3 つのデリゲート型と:`D1`のインスタンスを受け取り`C`および文字列、`D2`は文字列、および`D3`引数がありません。  
  
 という名前の 2 番目のクラス`Example`デリゲートを作成するコードが含まれています。  
  
-   型のデリゲート`D2`のインスタンスを終了済み`C`、インスタンス メソッドの作成は`M1`します。 バインドのインスタンスを表示する別の文字列でメソッドが呼び出された`C`は常に使用します。  
  
-   型のデリゲート`D1`、開いているインスタンス メソッドを表す、インスタンス メソッドの作成は`M1`します。 デリゲートが呼び出されたときに、インスタンスを渡す必要があります。  
  
-   型のデリゲート`D2`、オープンな静的メソッドを表す、静的なメソッドの作成は`M2`します。  
  
-   最後に、型のデリゲート`D3`、文字列を閉じ、静的メソッドが作成されます`M2`します。 メソッドは、連結文字列を使用しているかを表示します。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **例 2**  
  
 次のコード例では、パラメーターの型の互換性について説明し、型を返します。  
  
> [!NOTE]
>  このコード例では、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>メソッドのオーバー ロードします。 その他の使用にオーバー ロードを受け取る<xref:System.Reflection.MethodInfo>は似ています。  
  
 コード例は、という名前の基本クラスを定義します。`Base`という名前のクラスと`Derived`から派生した`Base`します。 派生クラスには、 `static` (`Shared` Visual Basic で) という名前のメソッド`MyMethod`型の 1 つのパラメーターを持つ`Base`の戻り値の型`Derived`します。 コード例では、という名前のデリゲートも定義します`Example`型の 1 つのパラメーターを持つ`Derived`の戻り値の型と`Base`します。  
  
 このコード例で、デリゲートが名前付き`Example`メソッドを表すために使用できる`MyMethod`します。 メソッドは、ために、デリゲートにバインドできます。  
  
-   デリゲートのパラメーターの型 (`Derived`) のパラメーターの型より限定的な`MyMethod`(`Base`) は常に安全にするデリゲートの引数を渡すことにより、`MyMethod`します。  
  
-   戻り値の型`MyMethod`(`Derived`) が、デリゲートのパラメーターの型よりも厳しい (`Base`) デリゲートの戻り値の型をメソッドの戻り値の型をキャストしても安全では常にするようにします。  
  
 コード例は、出力を生成しません。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **例 3**  
  
 次のコード例では、単一のデリゲート型を表すすべてのメソッドを示します。  
  
> [!NOTE]
>  2 つのオーバー ロードがあります、<xref:System.Delegate.CreateDelegate%2A>メソッドを指定する`firstArgument`と<xref:System.Reflection.MethodInfo>; をバインドするには、失敗した場合にスローするかどうかを指定することができますいずれかと、もう一方は常にスローする点を除いて、機能は同じです。 このコード例では、両方のオーバー ロードを使用します。  
  
 コード例は、2 つのクラスを定義します。`C`と`F`、とデリゲート型`D`型の 1 つの引数を持つ`C`します。 クラスが静的に一致して、インスタンス メソッド`M1`、 `M3`、および`M4`、およびクラス`C`インスタンス メソッドがあります`M2`引数を持たない。  
  
 という名前の 3 番目のクラス`Example`デリゲートを作成するコードが含まれています。  
  
-   メソッド インスタンスの作成デリゲート`M1`型の`C`と種類`F`; それぞれが、それぞれの型のインスタンスを閉じています。 メソッド`M1`型の`C`が表示されます、`ID`引数のバインドのインスタンスのプロパティ。  
  
-   メソッドのデリゲートを作成`M2`型の`C`します。 これはのインスタンスを開くデリゲート、デリゲートの引数が非表示の最初の引数でインスタンス メソッドを表します。 メソッドには、その他の引数がありません。  
  
-   静的メソッドに対してデリゲートを作成`M3`型の`C`と種類`F`。 これらは、オープンな静的デリゲート。  
  
-   静的メソッドに対してデリゲートを作成する最後に、`M4`型の`C`と種類`F`; は、各メソッドが最初の引数として宣言する型と型のインスタンスが指定されるため、その最初の引数をデリゲートは閉じられます. メソッド`M4`型の`C`が表示されます、`ID`引数のバインドのインスタンスのプロパティ。  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="method" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
または 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
または 
 <paramref name="method" /> はバインドできず、<paramref name="throwOnBindFailure" /> は <see langword="true" /> です。  
  
または 
 <paramref name="method" /> が <see langword="RuntimeMethodInfo" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="target"><paramref name="method" /> を呼び出す対象のクラス インスタンス。</param>
        <param name="method">デリゲートによって表されるインスタンス メソッドの名前。</param>
        <param name="ignoreCase">メソッドの名前を比較するとき大文字と小文字を無視するかどうかを示すブール値。</param>
        <summary>大文字と小文字の区別方法を指定して、指定したクラス インスタンスに対して呼び出す指定した型のデリゲートを作成します。</summary>
        <returns>指定したクラス インスタンスに対して呼び出す指定したインスタンス メソッドを表す、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのデリゲートのインスタンス メソッドだけを作成します。 インスタンス メソッドをクラスのインスタンスに関連付けられているメソッド静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
 このメソッドのオーバー ロードの呼び出しと同じですが、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードを指定する`true`の`throwOnBindFailure`します。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、呼び出し元が許可されている場合は、パブリックでないメソッドへのアクセスに使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグを設定し、許可セットまたはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="target" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="method" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
- または - 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
または 
 <paramref name="method" /> はインスタンス メソッドではありません。  
  
または 
 <paramref name="method" /> をバインドできません (たとえば、これが見つからないなど)。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="target"><paramref name="method" /> を実装するクラスを表す <see cref="T:System.Type" />。</param>
        <param name="method">デリゲートによって表される静的メソッドの名前。</param>
        <param name="ignoreCase">メソッドの名前を比較するとき大文字と小文字を無視するかどうかを示すブール値。</param>
        <summary>指定したクラスの指定した静的メソッドを表す、指定した型のデリゲートを、大文字と小文字の区別方法を指定して作成します。</summary>
        <returns>指定したクラスの指定した静的メソッドを表す、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、静的メソッドのみのデリゲートを作成します。 インスタンス メソッドをクラスのインスタンスに関連付けられているメソッド静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
 このメソッドのオーバー ロードの呼び出しと同じですが、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードを指定する`true`の`throwOnBindFailure`します。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、呼び出し元が許可されている場合は、パブリックでないメソッドへのアクセスに使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグを設定し、許可セットまたはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="target" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="method" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
- または - 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
または 
 <paramref name="target" /> が <see langword="RuntimeType" /> ではありません。  
  
または 
 <paramref name="target" /> はオープン ジェネリック型です。 つまり、その <see cref="P:System.Type.ContainsGenericParameters" /> プロパティは <see langword="true" /> です。  
  
- または - 
 <paramref name="method" /> は <see langword="static" /> メソッド (Visual Basic では <see langword="Shared" /> メソッド) ではありません。  
  
- または - 
 <paramref name="method" /> をバインドできません (たとえば、これが見つからないなど)。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="target"><paramref name="method" /> を呼び出す対象のクラス インスタンス。</param>
        <param name="method">デリゲートによって表されるインスタンス メソッドの名前。</param>
        <param name="ignoreCase">メソッドの名前を比較するとき大文字と小文字を無視するかどうかを示すブール値。</param>
        <param name="throwOnBindFailure"><paramref name="method" /> をバインドできないときに例外をスローする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>大文字と小文字の区別方法およびバインドに失敗したときの動作を指定して、指定したクラス インスタンスに対して呼び出す指定した型のデリゲートを作成します。</summary>
        <returns>指定したクラス インスタンスに対して呼び出す指定したインスタンス メソッドを表す、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのデリゲートのインスタンス メソッドだけを作成します。 インスタンス メソッドをクラスのインスタンスに関連付けられているメソッド静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、呼び出し元が許可されている場合は、パブリックでないメソッドへのアクセスに使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグを設定し、許可セットまたはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="target" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="method" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
または 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
または 
 <paramref name="method" /> はインスタンス メソッドではありません。  
  
または 
 見つからないなどの原因により、<paramref name="method" /> をバインドできません。また、<paramref name="throwOnBindFailure" /> が <see langword="true" /> です。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">作成するデリゲートの <see cref="T:System.Type" />。</param>
        <param name="target"><paramref name="method" /> を実装するクラスを表す <see cref="T:System.Type" />。</param>
        <param name="method">デリゲートによって表される静的メソッドの名前。</param>
        <param name="ignoreCase">メソッドの名前を比較するとき大文字と小文字を無視するかどうかを示すブール値。</param>
        <param name="throwOnBindFailure"><paramref name="method" /> をバインドできないときに例外をスローする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>大文字と小文字の区別方法およびバインドに失敗したときの動作を指定して、指定したクラスの指定した静的メソッドを表す、指定した型のデリゲートを作成します。</summary>
        <returns>指定したクラスの指定した静的メソッドを表す、指定した型のデリゲート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、静的メソッドのみのデリゲートを作成します。 インスタンス メソッドをクラスのインスタンスに関連付けられているメソッド静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、呼び出し元が許可されている場合は、パブリックでないメソッドへのアクセスに使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグを設定し、許可セットまたはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="target" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="method" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> は <see cref="T:System.MulticastDelegate" /> を継承しません。  
  
- または - 
 <paramref name="type" /> が <see langword="RuntimeType" /> ではありません。 「[Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)」 (リフレクションのランタイム型) を参照してください。  
  
または 
 <paramref name="target" /> が <see langword="RuntimeType" /> ではありません。  
  
または 
 <paramref name="target" /> はオープン ジェネリック型です。 つまり、その <see cref="P:System.Type.ContainsGenericParameters" /> プロパティは <see langword="true" /> です。  
  
または 
 <paramref name="method" /> は <see langword="static" /> メソッド (Visual Basic では <see langword="Shared" /> メソッド) ではありません。  
  
- または - 
 見つからないなどの原因により、<paramref name="method" /> をバインドできません。また、<paramref name="throwOnBindFailure" /> が <see langword="true" /> です。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="type" /> の <see langword="Invoke" /> メソッドが見つかりません。</exception>
        <exception cref="T:System.MethodAccessException"><paramref name="method" /> へのアクセスに必要なアクセス許可が呼び出し元にありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">現在のデリゲートが表すメソッドに渡される引数であるオブジェクトの配列。  
  
または 
 現在のデリゲートが表すメソッドが引数を必要としない場合は <see langword="null" />。</param>
        <summary>現在のデリゲートが表すメソッドを動的に呼び出します (遅延バインディング)。</summary>
        <returns>デリゲートが表すメソッドによって返されるオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Delegate.DynamicInvokeImpl%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼び出し元には、デリゲートによって表されるメソッドへのアクセスはありません (たとえば、メソッドがプライベートである)。  
  
- または - 
<paramref name="args" /> にリストされているパラメーターの数、順序、または型が無効です。</exception>
        <exception cref="T:System.ArgumentException">デリゲートが表すメソッドが、そのメソッドをサポートしないオブジェクトまたはクラスに対して呼び出されています。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">デリゲートが表すメソッドがインスタンス メソッドであり、対象オブジェクトが <see langword="null" /> です。  
  
- または - 
カプセル化されたメソッドの 1 つが例外をスローします。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">現在のデリゲートが表すメソッドに渡される引数であるオブジェクトの配列。  
  
- または - 
 現在のデリゲートが表すメソッドが引数を必要としない場合は <see langword="null" />。</param>
        <summary>現在のデリゲートが表すメソッドを動的に呼び出します (遅延バインディング)。</summary>
        <returns>デリゲートが表すメソッドによって返されるオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、 <xref:System.Delegate.DynamicInvoke%2A> メソッドを実装します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼び出し元には、デリゲートによって表されるメソッドへのアクセスはありません (たとえば、メソッドがプライベートである)。  
  
または 
<paramref name="args" /> にリストされているパラメーターの数、順序、または型が無効です。</exception>
        <exception cref="T:System.ArgumentException">デリゲートが表すメソッドが、そのメソッドをサポートしないオブジェクトまたはクラスに対して呼び出されています。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">デリゲートが表すメソッドがインスタンス メソッドであり、対象オブジェクトが <see langword="null" /> です。  
  
または 
カプセル化されたメソッドの 1 つが例外をスローします。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">現在のデリゲートと比較するオブジェクト。</param>
        <summary>指定したオブジェクトと現在のデリゲートが同じ型を持ち、同じターゲット、メソッド、および呼び出しリストを共有しているかどうかを確認します。</summary>
        <returns><paramref name="obj" /> と現在のデリゲートが、同じターゲット、メソッド、および呼び出しリストを共有している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 同じ型の 2 つのデリゲートがない場合、いない等しいと見なされます。  
  
> [!IMPORTANT]
>  .NET framework version 1.0 および 1.1 では、2 つのデリゲートが場合に、ターゲット、メソッド、および呼び出しリストが等しくない場合は、さまざまな種類の代理人がいた場合でも、等しい検討されました。  
  
 メソッドとターゲット」は、次のように等しいかどうか比較されます。  
  
-   比較対象となる 2 つの方法では、両方とも静的メソッドで、同じクラスの同じメソッド場合、メソッドが等しいと見なされ、ターゲットを等しいと見なされますも。  
  
-   比較対象となる 2 つの方法では、インスタンス メソッドし、同じオブジェクト上の同じメソッドには場合、メソッドは等しいと見なされます、ターゲットも等しいと見なされます。  
  
-   それ以外の場合、メソッドと同じと見なされないと、ターゲットもと見なされないと同じです。  
  
 2 つの呼び出しリストは順序が存在し、2 つのリストから対応する要素が同じメソッドとターゲットを表す場合にのみ、同一と見なされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼び出し元には、デリゲートによって表されるメソッドへのアクセスはありません (たとえば、メソッドがプライベートである)。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>デリゲートのハッシュ コードを返します。</summary>
        <returns>デリゲートのハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの戻り値は 2 つの理由の永続化されませんする必要があります。 最初に、クラスのハッシュ関数を変更して、レンダリング古いハッシュ関数からの値が役に立たないより優れた分布を生成する可能性があります。 次に、このクラスの既定の実装では、同じ値が異なるインスタンスによって返されることは限りません。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>デリゲートの呼び出しリストを返します。</summary>
        <returns>現在のデリゲートの呼び出しリストを表すデリゲートの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 配列内の各デリゲートは、1 つのメソッドを表します。  
  
 配列内のデリゲートの順序を現在のデリゲートがそれらのデリゲートが表すメソッドを呼び出すのと同じ順序です。  
  
   
  
## Examples  
 次の例は、3 つのメソッドをデリゲートに割り当てます。 呼び出して、 <xref:System.Delegate.GetInvocationList%2A> "File"、デリゲートを逆の順序で実行して、名前の部分文字列を含めないでくださいメソッドの実行に、デリゲートに割り当てられているメソッドの合計数を取得します。  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のデリゲートによって表される静的メソッドを取得します。</summary>
        <returns>現在のデリゲートによって表される静的メソッドについて説明する <see cref="T:System.Reflection.MethodInfo" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のデリゲートが静的メソッドを表す場合にのみ適用されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼び出し元には、デリゲートによって表されるメソッドへのアクセスはありません (たとえば、メソッドがプライベートである)。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">サポートされていません。</param>
        <param name="context">サポートされていません。</param>
        <summary>サポートされていません。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">このメソッドはサポートされていません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デリゲートによって表されるメソッドを取得します。</summary>
        <value>デリゲートによって表されるメソッドについて説明する <see cref="T:System.Reflection.MethodInfo" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">呼び出し元には、デリゲートによって表されるメソッドへのアクセスはありません (たとえば、メソッドがプライベートである)。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">比較する最初のデリゲート。</param>
        <param name="d2">比較する 2 番目のデリゲート。</param>
        <summary>指定したデリゲートが等しいかどうかを判断します。</summary>
        <returns><see langword="true" /> が <paramref name="d1" /> に等しい場合は <paramref name="d2" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 同じターゲット、メソッド、および呼び出しリストと同じ型の 2 つのデリゲートが等しいと見なされます。  
  
 同じ型の 2 つのデリゲートがない場合、いない等しいと見なされます。  
  
> [!IMPORTANT]
>  .NET framework version 1.0 および 1.1 では、2 つのデリゲートが場合に、ターゲット、メソッド、および呼び出しリストが等しくない場合は、さまざまな種類の代理人がいた場合でも、等しい検討されました。  
  
 メソッドとターゲット」は、次のように等しいかどうか比較されます。  
  
-   比較対象となる 2 つの方法では、両方とも静的メソッドで、同じクラスの同じメソッド場合、メソッドが等しいと見なされ、ターゲットを等しいと見なされますも。  
  
-   比較対象となる 2 つの方法では、インスタンス メソッドし、同じオブジェクト上の同じメソッドには場合、メソッドは等しいと見なされます、ターゲットも等しいと見なされます。  
  
-   それ以外の場合、メソッドと同じと見なされないと、ターゲットもと見なされないと同じです。  
  
 2 つの呼び出しリストは順序が存在し、2 つのリストから対応する要素が同じメソッドとターゲットを表す場合、同一と見なされます。  
  
 この演算子を同等のメソッドは、します。 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">比較する最初のデリゲート。</param>
        <param name="d2">比較する 2 番目のデリゲート。</param>
        <summary>指定したデリゲートが等しくないかどうかを判断します。</summary>
        <returns><see langword="true" /> が <paramref name="d1" /> と等しくない場合は <paramref name="d2" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 2 つのデリゲートと見なされますと等しい場合は、さまざまな種類は、またはさまざまな方法、ターゲット、または別の呼び出しリストがあります。  
  
 同じ型の 2 つのデリゲートがない場合、いない等しいと見なされます。  
  
> [!IMPORTANT]
>  .NET framework version 1.0 および 1.1 では、2 つのデリゲートが場合に、ターゲット、メソッド、および呼び出しリストが等しくない場合は、さまざまな種類の代理人がいた場合でも、等しいと見なされます。  
  
 メソッドとターゲット」は、次のように等しいかどうか比較されます。  
  
-   比較対象となる 2 つの方法では、両方とも静的メソッドで、同じクラスの同じメソッド場合、メソッドが等しいと見なされ、ターゲットを等しいと見なされますも。  
  
-   比較対象となる 2 つの方法では、インスタンス メソッドし、同じオブジェクト上の同じメソッドには場合、メソッドは等しいと見なされます、ターゲットも等しいと見なされます。  
  
-   それ以外の場合、メソッドと同じと見なされないと、ターゲットもと見なされないと同じです。  
  
 2 つの呼び出しリストは、さまざまなサイズは、順序が、異なる場合がある場合、または 1 つのリストから少なくとも 1 つの要素は、メソッドまたはその他の一覧で、対応する要素によって表されるとは異なるターゲットを表す場合は等しくありません。  
  
 この演算子を同等のメソッドは、します。 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source"><paramref name="value" /> の呼び出しリストの削除元のデリゲート。</param>
        <param name="value"><paramref name="source" /> の呼び出しリストから削除される呼び出しリストを持つデリゲート。</param>
        <summary>一方のデリゲートの呼び出しリストから、最後に出現した他方のデリゲートの呼び出しリストを削除します。</summary>
        <returns><paramref name="source" /> の呼び出しリストが <paramref name="value" /> の呼び出しリスト内に存在する場合は、<paramref name="value" /> の呼び出しリストから、最後に出現した <paramref name="source" /> の呼び出しリストを削除して得られる呼び出しリストを持つ新しいデリゲート。 <paramref name="source" /> が <see langword="null" /> の場合、または <paramref name="value" /> の呼び出しリストが <paramref name="value" /> の呼び出しリスト内に見つからない場合は <paramref name="source" /> を返します。 <paramref name="value" /> の呼び出しリストが <paramref name="source" /> の呼び出しリストと等しい場合、または <paramref name="source" /> が null 参照の場合は、null 参照を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合の呼び出しリスト`value`連続した一連の呼び出しリスト内の要素と一致する`source`の呼び出しリストから`value`の呼び出しリスト内で発生すると言います`source`します。 場合の呼び出しリスト`value`の呼び出しリスト内に複数回に発生します。 `source`、最後に出現を削除します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼び出し元には、デリゲートによって表されるメソッドへのアクセスはありません (たとえば、メソッドがプライベートである)。</exception>
        <exception cref="T:System.ArgumentException">デリゲートの型が一致しません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source"><paramref name="value" /> の呼び出しリストの削除元のデリゲート。</param>
        <param name="value"><paramref name="source" /> の呼び出しリストから削除される呼び出しリストを持つデリゲート。</param>
        <summary>一方のデリゲートの呼び出しリストから、そこに出現する他方のデリゲートの呼び出しリストをすべて削除します。</summary>
        <returns><paramref name="source" /> の呼び出しリストが <paramref name="value" /> の呼び出しリスト内に存在する場合は、<paramref name="value" /> の呼び出しリストから、そこに出現する <paramref name="source" /> の呼び出しリストをすべて削除して得られる呼び出しリストを持つ新しいデリゲート。 <paramref name="source" /> が <see langword="null" /> の場合、または <paramref name="value" /> の呼び出しリストが <paramref name="value" /> の呼び出しリスト内に見つからない場合は <paramref name="source" /> を返します。 <paramref name="value" /> の呼び出しリストが <paramref name="source" /> の呼び出しリストに等しい場合、<paramref name="source" /> の呼び出しリストに等しい一連の呼び出しリストだけが <paramref name="value" /> に含まれる場合、または <paramref name="source" /> が null 参照の場合は null 参照を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合の呼び出しリスト`value`連続した一連の呼び出しリスト内の要素と一致する`source`の呼び出しリストから`value`の呼び出しリスト内で発生すると言います`source`します。 場合の呼び出しリスト`value`の呼び出しリスト内に複数回に発生します。`source`をすべて削除します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼び出し元には、デリゲートによって表されるメソッドへのアクセスはありません (たとえば、メソッドがプライベートである)。</exception>
        <exception cref="T:System.ArgumentException">デリゲートの型が一致しません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">現在のデリゲートの呼び出しリストから削除される呼び出しリストを持つデリゲート。</param>
        <summary>一方のデリゲートの呼び出しリストから、他方のデリゲートの呼び出しリストを削除します。</summary>
        <returns>現在のデリゲートの呼び出しリストを取得し、そのリスト内に <paramref name="value" /> の呼び出しリストがある場合は、現在のデリゲートのリストから <paramref name="value" /> の呼び出しリストを削除した結果のリストを持つ新しいデリゲート。 <paramref name="value" /> が <see langword="null" /> の場合、または <paramref name="value" /> の呼び出しリストが現在のデリゲートの呼び出しリスト内で見つからなかった場合は現在のデリゲートを返します。 <paramref name="value" /> の呼び出しリストが現在のデリゲートの呼び出しリストと等しい場合は <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合の呼び出しリスト`value`連続した現在のデリゲートの呼び出しリストでは、次の呼び出しリスト内の要素のセットと一致する`value`現在のデリゲートの呼び出しリスト内で発生すると言います。 場合の呼び出しリスト`value`2 回以上発生現在のデリゲートの呼び出しリストで、最後に出現を削除します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼び出し元には、デリゲートによって表されるメソッドへのアクセスはありません (たとえば、メソッドがプライベートである)。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のデリゲートがインスタンス メソッドを呼び出す対象のクラス インスタンスを取得します。</summary>
        <value>現在のデリゲートがインスタンス メソッドを表す場合は、デリゲートがインスタンス メソッドを呼び出す対象のオブジェクト。デリゲートが静的メソッドを表す場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンス メソッドをクラスのインスタンスに関連付けられているメソッド静的メソッドは、クラス自体に関連付けられているメソッドです。  
  
 デリゲートに 1 つまたは複数のインスタンス メソッドが呼び出される場合、このプロパティは、呼び出しリストの最後のインスタンス メソッドのターゲットを返します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>