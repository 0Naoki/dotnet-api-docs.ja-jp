<Type Name="Delegate" FullName="System.Delegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c32a7cd3f267f6ad99691a54a7da944b20a5a479" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36432042" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Delegate>クラスはデリゲート型の基本クラスです。 ただし、システムとコンパイラから派生できる明示的に、<xref:System.Delegate>クラスから、または、<xref:System.MulticastDelegate>クラスです。 デリゲート型から新しい型を派生させることではないです。 <xref:System.Delegate>クラス、デリゲート型とは見なされません。 を使用してデリゲート型を派生クラスであります。  
  
 ほとんどの言語の実装、`delegate`キーワード、およびそれらの言語のコンパイラから派生することは、<xref:System.MulticastDelegate>クラスです。 したがって、ユーザーが使用する必要があります、 `delegate` 、言語によって提供されるキーワード。  
  
> [!NOTE]
>  共通言語ランタイムが提供する`Invoke`デリゲートと同じシグネチャを持つ各デリゲート型のメソッドです。 ありません c#、Visual Basic または Visual C からこのメソッドを明示的に呼び出すと、コンパイラが自動的に、呼び出すためです。 `Invoke`メソッドは[リフレクション](~/docs/framework/reflection-and-codedom/reflection.md)デリゲートのシグネチャを検索するときにします。  
  
 共通言語ランタイムの各デリゲート型を提供する`BeginInvoke`と`EndInvoke`メソッドは、デリゲートの非同期呼び出しを有効にします。 これらのメソッドの詳細については、次を参照してください。[同期のメソッドを非同期に呼び出す](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)です。  
  
 デリゲート型の宣言では、1 つまたは複数のメソッドのシグネチャを指定するコントラクトを確立します。 参照を持つデリゲート型のインスタンスをデリゲートには。  
  
-   型と、その型に割り当てることができるターゲット オブジェクトのインスタンス メソッドです。  
  
-   インスタンス メソッド、型を非表示の`this`仮パラメーター リストで公開されているパラメーターです。 デリゲートは、開いているインスタンス デリゲートと呼ばれます。  
  
-   静的メソッド。  
  
-   静的メソッドは、メソッドの最初のパラメーターに割り当て可能なターゲット オブジェクト。 デリゲートは、最初の引数を終了すると言います。  
  
 デリゲート バインディングの詳細については、次を参照してください。、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>メソッドのオーバー ロードします。  
  
> [!NOTE]
>  .NET Framework バージョン 1.0 および 1.1 では、デリゲートは、メソッドのシグネチャはデリゲート型で指定されたシグネチャを完全に一致する場合にのみ、メソッドを表すことができます。 したがって、上記の最初と 3 番目の箇条書きのみがサポートされ、最初の箇条書きには、正確な型の一致が必要です。  
  
 メソッドのエントリ ポイントへの参照とは定義されている型に割り当てることができる型では、ターゲットと呼ばれる、オブジェクトへの参照に、デリゲートを格納、デリゲートは、最初の引数 (最も一般的なケース) 経由で閉じられたインスタンス メソッドを表している場合、メソッド。 デリゲートは、開いているインスタンス メソッドを表している場合は、メソッドのエントリ ポイントへの参照を格納します。 デリゲートのシグネチャを非表示に含める必要があります`this`; 仮パラメーター リスト内のパラメーターここでは、デリゲートは、ターゲット オブジェクトへの参照がないと、デリゲートが呼び出されたときに、ターゲット オブジェクトを指定する必要があります。  
  
 デリゲートは、静的メソッドを表している場合、デリゲートは、メソッドのエントリ ポイントへの参照を格納します。 デリゲートは、最初の引数を閉じている静的メソッドを表している場合、デリゲートは、メソッドのエントリ ポイントへの参照と、メソッドの最初の引数の型に代入のターゲット オブジェクトへの参照を格納します。 デリゲートが呼び出されたときに、静的メソッドの最初の引数はターゲット オブジェクトを受け取ります。  
  
 デリゲートの呼び出しリストとは、一覧の各要素が、デリゲートによって表されるメソッドの 1 つだけに呼び出すデリゲートの順序付けされたセットです。 呼び出しリストには、重複したメソッドを含めることができます。 呼び出し中には、メソッドは呼び出しリストに表示される順序で呼び出されます。 デリゲートが、呼び出しリスト内のすべてのメソッドを呼び出すしようとしています。重複部分は、呼び出しリストに表示されるたびに、後に呼び出されます。 デリゲートは不変です。作成されると、デリゲートの呼び出しリストは変わりません。  
  
 デリゲートをいいます、マルチキャスト、または組み合わせ可能なデリゲートは 1 つまたは複数のメソッドを呼び出すことができ、操作を組み合わせることで使用できるためです。  
  
 など、操作を組み合わせて<xref:System.Delegate.Combine%2A>と<xref:System.Delegate.Remove%2A>、既存のデリゲートを変更しないでください。 代わりに、このような操作は、変更されていないデリゲートを操作の結果を含む新しいデリゲートを返しますまたは`null`です。 結合操作が返されます`null`操作の結果が少なくとも 1 つのメソッドを参照していないするデリゲートの場合。 結合操作は、要求された操作に影響があるない場合に、変更されていないデリゲートを返します。  
  
> [!NOTE]
>  マネージ言語を使用、<xref:System.Delegate.Combine%2A>と<xref:System.Delegate.Remove%2A>デリゲート操作を実装するメソッド。 例としては、`AddHandler`と`RemoveHandler`Visual Basic におけるステートメントと + = および -= の演算子にデリゲート (C#) の型。  
  
 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、汎用デリゲート型は、バリアント型パラメーターを持つことができます。 反変の型パラメーターは、デリゲートのパラメーターの型として使用できるし、共変の型パラメーターは戻り値の型として使用することができます。 この機能により、汎用デリゲート型の割り当てと互換性のある場合は、型引数が、継承関係を持つ参照型で説明したように、同じジェネリック型定義から構築される[共変性と反変性](~/docs/standard/generics/covariance-and-contravariance.md)です。  
  
> [!NOTE]
>  代入互換性のある汎用デリゲートの分散のためには必ずしも combinable できません。 組み合わせ可能にするのには、種類が正確に一致する必要があります。 たとえば、クラスがという名前の`Derived`という名前のクラスから派生した`Base`です。 型のデリゲート`Action<Base>`(`Action(Of Base)` Visual Basic で) 型の変数に代入できます`Action<Derived>`種類が正確に一致しないために、2 つのデリゲートを組み合わせることはできませんが、します。  
  
 呼び出されたメソッドは、例外をスローする場合は、メソッドの実行は停止し、デリゲートの呼び出し元に渡された例外呼び出しリスト内の残りのメソッドは呼び出されません。 呼び出し元で例外をキャッチしても、この動作は変更されません。  
  
 デリゲートから呼び出されるメソッドのシグネチャには、戻り値が含まれている場合、デリゲートは、呼び出しリスト内の最後の要素の戻り値を返します。 シグネチャには、参照によって渡されるパラメーターが含まれている場合、パラメーターの最終値は順番に実行して、パラメーターの値の更新の呼び出しリスト内のすべてのメソッドの結果  
  
 C または C++ でのデリゲートの最も近いは、関数ポインターです。 デリゲートには、静的メソッドまたはインスタンス メソッドを表すことができます。 デリゲートは、インスタンス メソッドを表している場合、デリゲートは、メソッドのエントリ ポイントへの参照だけでなく、クラスのインスタンスへの参照を格納します。 関数ポインターとは異なり、デリゲートはオブジェクト指向し、タイプ セーフです。  
  
   
  
## Examples  
 次の例は、という名前のデリゲートを定義する方法を示しています。`myMethodDelegate`です。 このデリゲートのインスタンスがインスタンス メソッドと、入れ子になったの静的メソッドの作成`mySampleClass`クラスです。 インスタンス メソッドのデリゲートのインスタンスを必要と`mySampleClass`です。 `mySampleClass`インスタンスがという名前の変数に保存`mySC`です。  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new delegate.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">The class instance on which the delegate invokes <c>method</c>.</param>
        <param name="method">The name of the instance method that the delegate represents.</param>
        <summary>Initializes a delegate that invokes the specified instance method on the specified class instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターは、アプリケーション コードでは使用できません。 インスタンス メソッドの名前を指定することによって、デリゲートを作成するには、オーバー ロードを使用して、<xref:System.Delegate.CreateDelegate%2A>がメソッド名とターゲット オブジェクトを指定するメソッド。 たとえば、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29>メソッド オーバー ロードは、指定した名前を持つインスタンス メソッドのデリゲートを作成します。  
  
 このコンス トラクターのデリゲートのインスタンス メソッドだけを作成します。 インスタンス メソッドがクラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられている方法です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">There was an error binding to the target method.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">The <see cref="T:System.Type" /> representing the class that defines <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate represents.</param>
        <summary>Initializes a delegate that invokes the specified static method from the specified class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターは、アプリケーション コードでは使用できません。 静的メソッドの名前を指定することによって、デリゲートを作成するには、オーバー ロードを使用して、<xref:System.Delegate.CreateDelegate%2A>メソッドをメソッドの名前を指定しますが、ターゲット オブジェクトが指定されていません。 たとえば、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29>メソッド オーバー ロードは、指定した名前の静的メソッドのデリゲートを作成します。  
  
 このコンス トラクターでは、静的メソッドのみのデリゲートを作成します。 インスタンス メソッドがクラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられている方法です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> represents an open generic type.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a shallow copy of the delegate.</summary>
        <returns>A shallow copy of the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 クローンが同じ<xref:System.Type>ターゲット、メソッド、および呼び出し元のデリゲートとして ボックスの一覧です。  
  
 シャロー コピーでは、元のオブジェクトと同じ型の新しいインスタンスを作成し、元のオブジェクトの非静的フィールドをコピーします。 フィールドが値型の場合は、フィールドのビットごとのコピーは実行されます。 フィールドが参照型の場合は、参照がコピーが、参照されるオブジェクトはありません。そのため、元のオブジェクト参照と、複製の参照は、同じオブジェクトをポイントします。 これに対し、オブジェクトのディープ コピーでは、直接または間接的には、オブジェクト内のフィールドが参照されるすべて重複しています。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatenates the invocation lists of the specified multicast (combinable) delegates.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">The array of delegates to combine.</param>
        <summary>Concatenates the invocation lists of an array of delegates.</summary>
        <returns>A new delegate with an invocation list that concatenates the invocation lists of the delegates in the <paramref name="delegates" /> array. Returns <see langword="null" /> if <paramref name="delegates" /> is <see langword="null" />, if <paramref name="delegates" /> contains zero elements, or if every entry in <paramref name="delegates" /> is <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、`delegates`配列にいるエントリが含まれています`null`、これらのエントリは無視されます。  
  
 呼び出しリストに重複するエントリを含めることができます。同じオブジェクトの同じメソッドを参照するエントリは、します。  
  
> [!NOTE]
>  代入互換性のある汎用デリゲートの分散のためには必ずしも combinable できません。 組み合わせ可能にするのには、種類が正確に一致する必要があります。 たとえば、クラスがという名前の`Derived`という名前のクラスから派生した`Base`です。 型のデリゲート`Action<Base>`(`Action(Of Base)` Visual Basic で) 型の変数に代入できます`Action<Derived>`」の説明に従って、[共変性と反変性](~/docs/standard/generics/covariance-and-contravariance.md)種類が、2 つのデリゲートを組み合わせることができませんが、完全に一致しません。  
  
 <xref:System.Delegate.Combine%2A> 呼び出しを複数のメソッド、イベントの時刻に発生するイベント ハンドラーを作成するために役立ちます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Not all the non-null entries in <paramref name="delegates" /> are instances of the same delegate type.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">The delegate whose invocation list comes first.</param>
        <param name="b">The delegate whose invocation list comes last.</param>
        <summary>Concatenates the invocation lists of two delegates.</summary>
        <returns>A new delegate with an invocation list that concatenates the invocation lists of <paramref name="a" /> and <paramref name="b" /> in that order. Returns <paramref name="a" /> if <paramref name="b" /> is <see langword="null" />, returns <paramref name="b" /> if <paramref name="a" /> is a null reference, and returns a null reference if both <paramref name="a" /> and <paramref name="b" /> are null references.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出しリストに重複するエントリを含めることができます。同じオブジェクトの同じメソッドを参照するエントリは、します。  
  
> [!NOTE]
>  代入互換性のある汎用デリゲートの分散のためには必ずしも combinable できません。 組み合わせ可能にするのには、種類が正確に一致する必要があります。 たとえば、クラスがという名前の`Derived`という名前のクラスから派生した`Base`です。 型のデリゲート`Action<Base>`(`Action(Of Base)` Visual Basic で) 型の変数に代入できます`Action<Derived>`」の説明に従って、[共変性と反変性](~/docs/standard/generics/covariance-and-contravariance.md)種類が、2 つのデリゲートを組み合わせることができませんが、完全に一致しません。  
  
 <xref:System.Delegate.Combine%2A> 呼び出しを複数のメソッド、イベントの時刻に発生するイベント ハンドラーを作成するために役立ちます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Both <paramref name="a" /> and <paramref name="b" /> are not <see langword="null" />, and <paramref name="a" /> and <paramref name="b" /> are not instances of the same delegate type.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">The multicast (combinable) delegate whose invocation list to append to the end of the invocation list of the current multicast (combinable) delegate.</param>
        <summary>Concatenates the invocation lists of the specified multicast (combinable) delegate and the current multicast (combinable) delegate.</summary>
        <returns>A new multicast (combinable) delegate with an invocation list that concatenates the invocation list of the current multicast (combinable) delegate and the invocation list of <paramref name="d" />, or the current multicast (combinable) delegate if <paramref name="d" /> is <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のデリゲートはマルチキャスト場合にのみ適用されます (組み合わせ可能)。  
  
 現在の実装は単にスロー、<xref:System.MulticastNotSupportedException>です。  
  
 呼び出しリストに重複するエントリを含めることができます。同じオブジェクトの同じメソッドを参照するエントリは、します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">Always thrown.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a delegate of the specified type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent. Only static methods are supported in the .NET Framework version 1.0 and 1.1.</param>
        <summary>Creates a delegate of the specified type to represent the specified static method.</summary>
        <returns>A delegate of the specified type to represent the specified static method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET framework version 1.0 および 1.1 では、このメソッドのオーバー ロードは、静的メソッドのみのデリゲートを作成します。 .NET framework version 2.0 では、このメソッドのオーバー ロード作成することも開いているインスタンス メソッドのデリゲート。つまり、非表示の最初の引数を明示的に指定するデリゲートはインスタンス メソッドです。 詳細についてより一般的なを参照してください。 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> 、すべてのインスタンスまたは静的メソッドは、オープンかクローズのデリゲートの組み合わせを作成したり、必要に応じて、最初の引数を指定するメソッドのオーバー ロードします。  
  
> [!NOTE]
>  このメソッドのオーバー ロードする必要があるために、使用、デリゲートは、最初の引数を終了していないときにその場合は多少高速です。  
  
 このメソッドはオーバー ロードを呼び出すことと同等、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>メソッドのオーバー ロードを指定して`true`の`throwOnBindFailure`します。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、非パブリック メソッドを呼び出し元が許可されている場合にアクセスするために使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグし、許可セット、またはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
## <a name="compatible-parameter-types-and-return-type"></a>互換性のあるパラメーターの型と戻り値の型  
 .NET framework version 2.0 では、このメソッドのオーバー ロードを使用して作成されたデリゲートの戻り値の型とパラメーターの型がありますパラメーターの型とデリゲートが表すメソッドの戻り値の型と互換性のあります。型を完全に一致する必要はありません。 これには、.NET Framework version 1.0 および 1.1 では、種類が正確に一致する必要があります、内のバインド動作の緩和を表します。  
  
 デリゲートのパラメーターにメソッドのパラメーターよりも限定的な型が指定された場合、両者のパラメーター間に型の互換性があると見なされます。これによって、デリゲートに渡された引数が、メソッドに対して安全に渡されることが保証されます。  
  
 同様に、メソッドの戻り値の型の制限がデリゲートの戻り値の型より多いと、メソッドの戻り値がデリゲートの戻り値の型に安全にキャストされることが保証されるため、デリゲートの戻り値の型とメソッドの戻り値の型には互換性があります。  
  
 型のパラメーターを持つデリゲートなど、<xref:System.Collections.Hashtable>と戻り値の型<xref:System.Object>型のパラメーターを持つメソッドを表すことができる<xref:System.Object>型の値を返す<xref:System.Collections.Hashtable>です。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例では、このメソッドのオーバー ロードを作成するデリゲートの 2 つの種類: インスタンス メソッドで開き、静的メソッドを開きます。  
  
 2 番目のコード例では、互換性のあるパラメーターの型について説明し、型を返します。  
  
 **例 1**  
  
 次のコード例は、のこのオーバー ロードを使用してデリゲートを作成する 2 つの方法を示します、<xref:System.Delegate.CreateDelegate%2A>メソッドです。  
  
> [!NOTE]
>  2 つのオーバー ロードがあります、<xref:System.Delegate.CreateDelegate%2A>メソッドを指定する、<xref:System.Reflection.MethodInfo>最初の引数されませんが、いずれか、バインドするには、失敗した場合にスローするかどうかを指定することができ、もう一方は常にスローする点を除いて、機能は同じです。 このコード例では、両方のオーバー ロードを使用します。  
  
 例では、クラスを宣言して`C`静的メソッドを使用して`M2`とインスタンス メソッド`M1`、2 つのデリゲート型と:`D1`のインスタンスを受け取り`C`および文字列、および`D2`文字列を使用します。  
  
 2 番目のクラスを名前付き`Example`デリゲートを作成するコードが含まれています。  
  
-   型のデリゲート`D1`、開いているインスタンス メソッドを表す、インスタンス メソッドの作成は`M1`します。 デリゲートが呼び出されたときに、インスタンスを渡す必要があります。  
  
-   型のデリゲート`D2`、オープンな静的メソッドを表す、静的なメソッドの作成は`M2`します。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **例 2**  
  
 次のコード例では、パラメーターの型との互換性について説明し、型を返します。  
  
 このコード例は、という名前の基本クラスを定義`Base`という名前のクラスと`Derived`から派生した`Base`です。 派生クラスには、 `static` (`Shared` Visual Basic で) という名前のメソッド`MyMethod`型の 1 つのパラメーターを持つ`Base`と戻り値の型`Derived`です。 このコード例もという名前のデリゲートを定義`Example`型の 1 つのパラメーターを持つ`Derived`と戻り値の型`Base`です。  
  
 このコード例で、デリゲートがという名前の`Example`、メソッドを表すために使用できる`MyMethod`です。 メソッドは、ために、デリゲートにバインドできます。  
  
-   デリゲートのパラメーターの型 (`Derived`) のパラメーターの型より限定的な`MyMethod`(`Base`) できるように、安全にデリゲートの引数を渡すには常に、`MyMethod`です。  
  
-   戻り値の型`MyMethod`(`Derived`) デリゲートのパラメーターの型より限定的な (`Base`) デリゲートの戻り値の型をメソッドの戻り値の型をキャストしても安全では常にするようにします。  
  
 コード例は、出力を生成されません。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not a static method, and the .NET Framework version is 1.0 or 1.1.  -or-  <paramref name="method" /> cannot be bound.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="firstArgument">The object to which the delegate is bound, or <see langword="null" /> to treat <c>method</c> as <see langword="static" /> (<see langword="Shared" /> in Visual Basic).</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
        <summary>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument.</summary>
        <returns>A delegate of the specified type that represents the specified static or instance method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことと同じではこのメソッドのオーバー ロードを呼び出して、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>メソッドのオーバー ロードを指定して`true`の`throwOnBindFailure`します。 これら 2 つのオーバー ロードは、デリゲートを作成する最も柔軟な方法を提供します。 インスタンス メソッド、または静的のデリゲートを作成して、最初の引数を指定するオプションで使用できます。  
  
> [!NOTE]
>  最初の引数を指定しない場合は使用して、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>パフォーマンス向上のためのメソッドのオーバー ロードします。  
  
 デリゲート型と、メソッドには、互換性のある戻り値の型がある場合があります。 戻り値の型は、`method`の戻り値の型に割り当てることがあります`type`です。  
  
 場合`firstArgument`が指定するに渡される`method`たびに、デリゲートが呼び出されます。`firstArgument`デリゲートにバインドすることと、最初の引数を終了するデリゲートを言います。 場合`method`は`static`(`Shared` Visual Basic で) では、引数のデリゲートを呼び出すときに提供される一覧に場合は、先頭を除くすべてのパラメーターが含まれます`method`し、インスタンス メソッドでは、`firstArgument`非表示のインスタンスに渡されるパラメーター (によって表される`this`C# の場合、または`Me`Visual Basic で)。  
  
 場合`firstArgument`が指定されている最初のパラメーターの`method`、参照型である必要がありますと`firstArgument`型と一致する必要があります。  
  
> [!IMPORTANT]
>  場合`method`は`static`(`Shared` Visual Basic で) し、その最初のパラメーターの型は<xref:System.Object>または<xref:System.ValueType>、し`firstArgument`値型であることができます。 ここでは`firstArgument`が自動的にボックス化されます。 C# または Visual Basic の関数を呼び出す場合は、自動的なボックス化は他の引数がある場合は発生しません。  
  
 場合`firstArgument`null 参照と`method`インスタンス メソッドでは、結果は、デリゲート型のシグニチャによって異なります`type`および`method`:。  
  
-   場合の署名`type`の非表示の最初のパラメーターを明示的に含まれて`method`、開いているインスタンス メソッドを表すため、デリゲートといいます。 デリゲートが呼び出されると、最初の引数、引数リストでは、非表示のインスタンスのパラメーターに渡す`method`です。  
  
-   場合の署名`method`と`type`と一致 (つまり、すべてのパラメーター型は互換性のある)、デリゲートが null 参照に対して閉じられていると考えられます。 デリゲートを呼び出すことは、インスタンスでは null、特に便利にすることではないインスタンス メソッドを呼び出すことと似ています。  
  
 場合`firstArgument`null 参照と`method`は静的、結果は、デリゲート型のシグネチャに依存`type`および`method`:  
  
-   場合の署名`method`と`type`一致 (つまり、すべてのパラメーター型は互換性のある)、オープンな静的メソッドを表すため、デリゲートといいます。 これは、静的メソッドの最も一般的なケースです。 この例では、わずかですが優れたパフォーマンスを使用して取得できます、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>メソッドのオーバー ロードします。  
  
-   場合の署名`type`の 2 番目のパラメーターで始まる`method`し、その他のパラメーター型に互換性が、デリゲートが null 参照に対して閉じられていると考えられます。 最初のパラメーターに null 参照が渡されたデリゲートが呼び出されると、`method`です。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、非パブリック メソッドを呼び出し元が許可されている場合にアクセスするために使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグし、許可セット、またはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
## <a name="compatible-parameter-types-and-return-type"></a>互換性のあるパラメーターの型と戻り値の型  
 パラメーターの型とデリゲートの戻り値の型はパラメーターの型とデリゲートが表すメソッドの戻り値の型と互換性のあるする必要があります。型を完全に一致する必要はありません。  
  
> [!NOTE]
>  .NET Framework version 1.0 および 1.1 では、種類が完全に一致する必要があります。  
  
 デリゲートのパラメーターにメソッドのパラメーターよりも限定的な型が指定された場合、両者のパラメーター間に型の互換性があると見なされます。これによって、デリゲートに渡された引数が、メソッドに対して安全に渡されることが保証されます。  
  
 同様に、メソッドの戻り値の型の制限がデリゲートの戻り値の型より多いと、メソッドの戻り値がデリゲートの戻り値の型に安全にキャストされることが保証されるため、デリゲートの戻り値の型とメソッドの戻り値の型には互換性があります。  
  
 型のパラメーターを持つデリゲートなど、<xref:System.Collections.Hashtable>と戻り値の型<xref:System.Object>型のパラメーターを持つメソッドを表すことができる<xref:System.Object>型の値を返す<xref:System.Collections.Hashtable>です。  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>デリゲートを表すことができる方法を決定します。  
 このオーバー ロードが提供する柔軟性の検討するもう 1 つの便利な方法<xref:System.Delegate.CreateDelegate%2A>は任意の指定されたデリゲートがメソッドのシグネチャとメソッドの種類 (静的インスタンスではなく) の 4 つの異なる組み合わせを表すことができます。 デリゲートの型について考えます`D`型の 1 つの引数を持つ`C`します。 メソッドを以下に示します`D`表すことのできるすべての場合に一致する必要がありますので、戻り値の型を無視しています。  
  
-   `D` 型の 1 つの引数を持つ任意のインスタンス メソッドを表すことができる`C`インスタンス メソッドが属するどのような種類に関係なく、します。 ときに<xref:System.Delegate.CreateDelegate%2A>が呼び出されると、`firstArgument`型のインスタンスは、`method`が属している、得られたデリゲートをそのインスタンスを終了するとします。 (普通、`D`場合に null 参照を終了することも`firstArgument`null 参照です)。  
  
-   `D` インスタンス メソッドを表すことができる`C`引数を持たない。 ときに<xref:System.Delegate.CreateDelegate%2A>が呼び出されると、 `firstArgument` null 参照です。 そのため、デリゲートを表し、開いているインスタンス メソッドでのインスタンス`C`が呼び出されるたびに指定する必要があります。  
  
-   `D` 型の 1 つの引数を受け取る静的メソッドを表すことができる`C`、し、メソッドは、任意の型に属することができます。 ときに<xref:System.Delegate.CreateDelegate%2A>が呼び出されると、 `firstArgument` null 参照です。 そのため、デリゲートを表し、オープンな静的メソッドのインスタンス`C`が呼び出されるたびに指定する必要があります。  
  
-   `D` 型に属している静的メソッドを表すことができる`F`は型の 2 つの引数が`F`および種類`C`です。 ときに<xref:System.Delegate.CreateDelegate%2A>が呼び出されると、`firstArgument`のインスタンスは、`F`です。 得られたデリゲートは、上のインスタンスが閉じられている静的メソッドを表す`F`です。 場合に注意してください。 場所`F`と`C`同じの型は、静的メソッドがその型の 2 つの引数。 (この場合、`D`場合は、null 参照で終了`firstArgument`null 参照です)。  
  
   
  
## Examples  
 このセクションには、3 つのコード例が含まれています。 最初の例では、作成できるデリゲートの 4 つの種類: インスタンス メソッドで静的メソッドよりオープンで開いているインスタンス メソッドを終了して、静的メソッドを終了します。  
  
 2 番目のコード例では、互換性のあるパラメーターの型について説明し、型を返します。  
  
 3 番目のコード例では、単一のデリゲート型を定義し、デリゲート型をすべてのメソッドを表すことを示しています。  
  
 **例 1**  
  
 次のコード例は、のこのオーバー ロードを使用してデリゲートを作成することができます、4 つの方法を示します、<xref:System.Delegate.CreateDelegate%2A>メソッドです。  
  
> [!NOTE]
>  2 つのオーバー ロードがあります、<xref:System.Delegate.CreateDelegate%2A>メソッドを指定する`firstArgument`と<xref:System.Reflection.MethodInfo>; をバインドするには、失敗した場合にスローするかどうかを指定できますいずれかと、もう一方は常にスローする点を除いて、機能は同じです。 このコード例では、両方のオーバー ロードを使用します。  
  
 例では、クラスを宣言して`C`静的メソッドを持つ`M2`とインスタンス メソッド`M1`、3 つのデリゲート型と:`D1`のインスタンスを受け取り`C`および文字列、`D2`文字列、およびを受け取る`D3`引数がありません。  
  
 2 番目のクラスを名前付き`Example`デリゲートを作成するコードが含まれています。  
  
-   型のデリゲート`D2`のインスタンスを終了済み`C`、インスタンス メソッドの作成は`M1`します。 呼び出されることのバインドのインスタンスを示すための異なる文字列と`C`は常に使用します。  
  
-   型のデリゲート`D1`、開いているインスタンス メソッドを表す、インスタンス メソッドの作成は`M1`します。 デリゲートが呼び出されたときに、インスタンスを渡す必要があります。  
  
-   型のデリゲート`D2`、オープンな静的メソッドを表す、静的なメソッドの作成は`M2`します。  
  
-   型のデリゲートを最後に、 `D3`、文字列を閉じ、静的メソッドの作成は`M2`します。 メソッドは、連結文字列を使用することを表示します。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **例 2**  
  
 次のコード例では、パラメーターの型との互換性について説明し、型を返します。  
  
> [!NOTE]
>  このコード例では、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>メソッドのオーバー ロードします。 その他の使用にオーバー ロードを受け取る<xref:System.Reflection.MethodInfo>と似ています。  
  
 このコード例は、という名前の基本クラスを定義`Base`という名前のクラスと`Derived`から派生した`Base`です。 派生クラスには、 `static` (`Shared` Visual Basic で) という名前のメソッド`MyMethod`型の 1 つのパラメーターを持つ`Base`と戻り値の型`Derived`です。 このコード例もという名前のデリゲートを定義`Example`型の 1 つのパラメーターを持つ`Derived`と戻り値の型`Base`です。  
  
 このコード例で、デリゲートがという名前の`Example`、メソッドを表すために使用できる`MyMethod`です。 メソッドは、ために、デリゲートにバインドできます。  
  
-   デリゲートのパラメーターの型 (`Derived`) のパラメーターの型より限定的な`MyMethod`(`Base`) できるように、安全にデリゲートの引数を渡すには常に、`MyMethod`です。  
  
-   戻り値の型`MyMethod`(`Derived`) デリゲートのパラメーターの型より限定的な (`Base`) デリゲートの戻り値の型をメソッドの戻り値の型をキャストしても安全では常にするようにします。  
  
 コード例は、出力を生成されません。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **例 3**  
  
 次のコード例を示しています、すべてのメソッドを使用して、単一のデリゲート型を表すことができます、<xref:System.Delegate.CreateDelegate%2A>デリゲートを作成するメソッド。  
  
> [!NOTE]
>  2 つのオーバー ロードがあります、<xref:System.Delegate.CreateDelegate%2A>メソッドを指定する`firstArgument`と<xref:System.Reflection.MethodInfo>; をバインドするには、失敗した場合にスローするかどうかを指定できますいずれかと、もう一方は常にスローする点を除いて、機能は同じです。 このコード例では、両方のオーバー ロードを使用します。  
  
 このコード例は、2 つのクラスを定義`C`と`F`とデリゲート型`D`型の 1 つの引数を持つ`C`します。 クラスには対応する静的メソッドとインスタンス`M1`、 `M3`、および`M4`、およびクラス`C`はインスタンス メソッドもあります`M2`引数を持たない。  
  
 3 番目のクラスを名前付き`Example`デリゲートを作成するコードが含まれています。  
  
-   デリゲートがインスタンス メソッドで作成された`M1`型の`C`および種類`F`; それぞれの型のインスタンス上の各が閉じられます。 メソッド`M1`型の`C`が表示されます、`ID`引数およびバインドされたインスタンスのプロパティです。  
  
-   メソッドのデリゲートを作成`M2`型の`C`します。 これは、デリゲートの引数が非表示の最初の引数でインスタンス メソッドを表しますが、開いているインスタンス デリゲートです。 メソッドには、その他の引数がありません。 静的メソッドの場合と同様に呼び出されます。  
  
-   静的メソッドに対してデリゲートを作成`M3`型の`C`および種類`F`です。 これらは、オープンな静的デリゲート。  
  
-   静的メソッドのデリゲートを作成する最後に、`M4`型の`C`および種類`F`; 各メソッドには、最初の引数として宣言する型と型のインスタンスが指定されるため、デリゲートは、第 1 引数経由で閉じられます. メソッド`M4`型の`C`が表示されます、`ID`引数およびバインドされたインスタンスのプロパティです。  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> cannot be bound.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The class instance on which <c>method</c> is invoked.</param>
        <param name="method">The name of the instance method that the delegate is to represent.</param>
        <summary>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</summary>
        <returns>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのデリゲートのインスタンス メソッドだけを作成します。 インスタンス メソッドがクラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられている方法です。  
  
 このメソッドはオーバー ロードを呼び出すことと同等、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>メソッド オーバー ロードを指定する`false`の`ignoreCase`と`true`の`throwOnBindFailure`します。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、非パブリック メソッドを呼び出し元が許可されている場合にアクセスするために使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグし、許可セット、またはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not an instance method.  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type to represent the specified static method, with the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type to represent the specified static method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのオーバー ロードがオープンの静的メソッドのデリゲートを作成し、インスタンス メソッドのデリゲートを開くことができます、つまり、メソッドのインスタンスの非表示の最初の引数を公開するデリゲート。 詳細についてより一般的なを参照してください。<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>メソッド オーバー ロードを使用すると、インスタンスのすべてのオープンかクローズ デリゲートの組み合わせを作成または静的メソッドです。  
  
> [!NOTE]
>  このメソッドのオーバー ロードする必要があるために、使用、デリゲートは、最初の引数を終了していないときにその場合は多少高速です。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、非パブリック メソッドを呼び出し元が許可されている場合にアクセスするために使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグし、許可セット、またはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
## <a name="compatible-parameter-types-and-return-type"></a>互換性のあるパラメーターの型と戻り値の型  
 パラメーターの型とデリゲートの戻り値の型はパラメーターの型とデリゲートが表すメソッドの戻り値の型と互換性のあるする必要があります。型を完全に一致する必要はありません。  
  
> [!NOTE]
>  .NET Framework version 1.0 および 1.1 では、種類が完全に一致する必要があります。  
  
 デリゲートのパラメーターにメソッドのパラメーターよりも限定的な型が指定された場合、両者のパラメーター間に型の互換性があると見なされます。これによって、デリゲートに渡された引数が、メソッドに対して安全に渡されることが保証されます。  
  
 同様に、メソッドの戻り値の型の制限がデリゲートの戻り値の型より多いと、メソッドの戻り値がデリゲートの戻り値の型に安全にキャストされることが保証されるため、デリゲートの戻り値の型とメソッドの戻り値の型には互換性があります。  
  
 型のパラメーターを持つデリゲートなど、<xref:System.Collections.Hashtable>と戻り値の型<xref:System.Object>型のパラメーターを持つメソッドを表すことができる<xref:System.Object>型の値を返す<xref:System.Collections.Hashtable>です。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例では、このメソッドのオーバー ロードを作成するデリゲートの 2 つの種類: インスタンス メソッドで開き、静的メソッドを開きます。  
  
 2 番目のコード例では、互換性のあるパラメーターの型について説明し、型を返します。  
  
 **例 1**  
  
 次のコード例は、のこのオーバー ロードを使用してデリゲートを作成する 2 つの方法を示します、<xref:System.Delegate.CreateDelegate%2A>メソッドです。  
  
> [!NOTE]
>  2 つのオーバー ロードがあります、<xref:System.Delegate.CreateDelegate%2A>メソッドを指定する、<xref:System.Reflection.MethodInfo>最初の引数されませんが、いずれか、バインドするには、失敗した場合にスローするかどうかを指定することができ、もう一方は常にスローする点を除いて、機能は同じです。 このコード例では、両方のオーバー ロードを使用します。  
  
 例では、クラスを宣言して`C`静的メソッドを使用して`M2`とインスタンス メソッド`M1`、2 つのデリゲート型と:`D1`のインスタンスを受け取り`C`および文字列、および`D2`文字列を使用します。  
  
 2 番目のクラスを名前付き`Example`デリゲートを作成するコードが含まれています。  
  
-   型のデリゲート`D1`、開いているインスタンス メソッドを表す、インスタンス メソッドの作成は`M1`します。 デリゲートが呼び出されたときに、インスタンスを渡す必要があります。  
  
-   型のデリゲート`D2`、オープンな静的メソッドを表す、静的なメソッドの作成は`M2`します。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **例 2**  
  
 次のコード例では、パラメーターの型との互換性について説明し、型を返します。  
  
> [!NOTE]
>  このコード例では、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>メソッドのオーバー ロードします。 その他の使用にオーバー ロードを受け取る<xref:System.Reflection.MethodInfo>と似ています。  
  
 このコード例は、という名前の基本クラスを定義`Base`という名前のクラスと`Derived`から派生した`Base`です。 派生クラスには、 `static` (`Shared` Visual Basic で) という名前のメソッド`MyMethod`型の 1 つのパラメーターを持つ`Base`と戻り値の型`Derived`です。 このコード例もという名前のデリゲートを定義`Example`型の 1 つのパラメーターを持つ`Derived`と戻り値の型`Base`です。  
  
 このコード例で、デリゲートがという名前の`Example`、メソッドを表すために使用できる`MyMethod`です。 メソッドは、ために、デリゲートにバインドできます。  
  
-   デリゲートのパラメーターの型 (`Derived`) のパラメーターの型より限定的な`MyMethod`(`Base`) できるように、安全にデリゲートの引数を渡すには常に、`MyMethod`です。  
  
-   戻り値の型`MyMethod`(`Derived`) デリゲートのパラメーターの型より限定的な (`Base`) デリゲートの戻り値の型をメソッドの戻り値の型をキャストしても安全では常にするようにします。  
  
 コード例は、出力を生成されません。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate is to represent.</param>
        <summary>Creates a delegate of the specified type that represents the specified static method of the specified class.</summary>
        <returns>A delegate of the specified type that represents the specified static method of the specified class.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、静的メソッドのみのデリゲートを作成します。 インスタンス メソッドがクラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられている方法です。  
  
 このメソッドはオーバー ロードを呼び出すことと同等、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>メソッド オーバー ロードを指定する`false`の`ignoreCase`と`true`の`throwOnBindFailure`します。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、非パブリック メソッドを呼び出し元が許可されている場合にアクセスするために使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグし、許可セット、またはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> is not a <see langword="RuntimeType" />.  -or-  <paramref name="target" /> is an open generic type. That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> representing the type of delegate to create.</param>
        <param name="firstArgument">An <see cref="T:System.Object" /> that is the first argument of the method the delegate represents. For instance methods, it must be compatible with the instance type.</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument and the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type that represents the specified static or instance method, or <see langword="null" /> if <paramref name="throwOnBindFailure" /> is <see langword="false" /> and the delegate cannot be bound to <paramref name="method" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのオーバー ロードおよび<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29>メソッド オーバー ロードを常にバインドするには、失敗した場合にスローすると、デリゲートを作成する最も柔軟な方法を提供します。 最初の引数の有無、またはインスタンス メソッドのいずれかの静的デリゲートを作成するのにには、それらを使用できます。  
  
> [!NOTE]
>  最初の引数を指定しない場合は使用して、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>パフォーマンス向上のためのメソッドのオーバー ロードします。  
  
 デリゲート型と、メソッドには、互換性のある戻り値の型がある場合があります。 戻り値の型は、`method`の戻り値の型に割り当てることがあります`type`です。  
  
 場合`firstArgument`が指定するに渡される`method`たびに、デリゲートが呼び出されます。`firstArgument`デリゲートにバインドすることと、最初の引数を終了するデリゲートを言います。 場合`method`は`static`(`Shared` Visual Basic で) では、引数のデリゲートを呼び出すときに提供される一覧に場合は、先頭を除くすべてのパラメーターが含まれます`method`し、インスタンス メソッドでは、`firstArgument`非表示のインスタンスに渡されるパラメーター (によって表される`this`C# の場合、または`Me`Visual Basic で)。  
  
 場合`firstArgument`が指定されている最初のパラメーターの`method`、参照型である必要がありますと`firstArgument`型と一致する必要があります。  
  
> [!IMPORTANT]
>  場合`method`は`static`(`Shared` Visual Basic で) し、その最初のパラメーターの型は<xref:System.Object>または<xref:System.ValueType>、し`firstArgument`値型であることができます。 ここでは`firstArgument`が自動的にボックス化されます。 C# または Visual Basic の関数を呼び出す場合は、自動的なボックス化は他の引数がある場合は発生しません。  
  
 場合`firstArgument`null 参照と`method`インスタンス メソッドでは、結果は、デリゲート型のシグニチャによって異なります`type`および`method`:。  
  
-   場合の署名`type`の非表示の最初のパラメーターを明示的に含まれて`method`、開いているインスタンス メソッドを表すため、デリゲートといいます。 デリゲートが呼び出されると、最初の引数、引数リストでは、非表示のインスタンスのパラメーターに渡す`method`です。  
  
-   場合の署名`method`と`type`と一致 (つまり、すべてのパラメーター型は互換性のある)、デリゲートが null 参照に対して閉じられていると考えられます。 デリゲートを呼び出すことは、インスタンスでは null、特に便利にすることではないインスタンス メソッドを呼び出すことと似ています。  
  
 場合`firstArgument`null 参照と`method`は静的、結果は、デリゲート型のシグネチャに依存`type`および`method`:  
  
-   場合の署名`method`と`type`一致 (つまり、すべてのパラメーター型は互換性のある)、オープンな静的メソッドを表すため、デリゲートといいます。 これは、静的メソッドの最も一般的なケースです。 この例では、わずかですが優れたパフォーマンスを使用して取得できます、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>メソッドのオーバー ロードします。  
  
-   場合の署名`type`の 2 番目のパラメーターで始まる`method`し、その他のパラメーター型に互換性が、デリゲートが null 参照に対して閉じられていると考えられます。 最初のパラメーターに null 参照が渡されたデリゲートが呼び出されると、`method`です。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、非パブリック メソッドを呼び出し元が許可されている場合にアクセスするために使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグし、許可セット、またはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
## <a name="compatible-parameter-types-and-return-type"></a>互換性のあるパラメーターの型と戻り値の型  
 パラメーターの型とデリゲートの戻り値の型はパラメーターの型とデリゲートが表すメソッドの戻り値の型と互換性のあるする必要があります。型を完全に一致する必要はありません。  
  
> [!NOTE]
>  .NET Framework version 1.0 および 1.1 での型が正確に一致する必要があります。  
  
 デリゲートのパラメーターにメソッドのパラメーターよりも限定的な型が指定された場合、両者のパラメーター間に型の互換性があると見なされます。これによって、デリゲートに渡された引数が、メソッドに対して安全に渡されることが保証されます。  
  
 同様に、メソッドの戻り値の型の制限がデリゲートの戻り値の型より多いと、メソッドの戻り値がデリゲートの戻り値の型に安全にキャストされることが保証されるため、デリゲートの戻り値の型とメソッドの戻り値の型には互換性があります。  
  
 型のパラメーターを持つデリゲートなど、<xref:System.Collections.Hashtable>と戻り値の型<xref:System.Object>型のパラメーターを持つメソッドを表すことができる<xref:System.Object>型の値を返す<xref:System.Collections.Hashtable>です。  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>デリゲートを表すことができる方法を決定します。  
 このオーバー ロードが提供する柔軟性の検討するもう 1 つの便利な方法<xref:System.Delegate.CreateDelegate%2A>は任意の指定されたデリゲートがメソッドのシグネチャとメソッドの種類 (静的インスタンスではなく) の 4 つの異なる組み合わせを表すことができます。 デリゲートの型について考えます`D`型の 1 つの引数を持つ`C`します。 メソッドを以下に示します`D`表すことのできるすべての場合に一致する必要がありますので、戻り値の型を無視しています。  
  
-   `D` 型の 1 つの引数を持つ任意のインスタンス メソッドを表すことができる`C`インスタンス メソッドが属するどのような種類に関係なく、します。 ときに<xref:System.Delegate.CreateDelegate%2A>が呼び出されると、`firstArgument`型のインスタンスは、`method`が属している、得られたデリゲートをそのインスタンスを終了するとします。 (普通、`D`場合に null 参照を終了することも`firstArgument`は`null`)。  
  
-   `D` インスタンス メソッドを表すことができる`C`引数を持たない。 ときに<xref:System.Delegate.CreateDelegate%2A>が呼び出されると、 `firstArgument` null 参照です。 そのため、デリゲートを表し、開いているインスタンス メソッドでのインスタンス`C`が呼び出されるたびに指定する必要があります。  
  
-   `D` 型の 1 つの引数を受け取る静的メソッドを表すことができる`C`、し、メソッドは、任意の型に属することができます。 ときに<xref:System.Delegate.CreateDelegate%2A>が呼び出されると、 `firstArgument` null 参照です。 そのため、デリゲートを表し、オープンな静的メソッドのインスタンス`C`が呼び出されるたびに指定する必要があります。  
  
-   `D` 型に属している静的メソッドを表すことができる`F`は型の 2 つの引数が`F`および種類`C`です。 ときに<xref:System.Delegate.CreateDelegate%2A>が呼び出されると、`firstArgument`のインスタンスは、`F`です。 得られたデリゲートは、上のインスタンスが閉じられている静的メソッドを表す`F`です。 場合に注意してください。 場所`F`と`C`同じの型は、静的メソッドがその型の 2 つの引数。 (この場合、`D`場合は、null 参照で終了`firstArgument`は`null`)。  
  
   
  
## Examples  
 このセクションには、3 つのコード例が含まれています。 最初の例では、作成できるデリゲートの 4 つの種類: インスタンス メソッドで静的メソッドよりオープンで開いているインスタンス メソッドを終了して、静的メソッドを終了します。  
  
 2 番目のコード例では、互換性のあるパラメーターの型について説明し、型を返します。  
  
 3 番目のコード例では、単一のデリゲート型を定義し、デリゲート型をすべてのメソッドを表すことを示しています。  
  
 **例 1**  
  
 次のコード例は、のこのオーバー ロードを使用してデリゲートを作成することができます、4 つの方法を示します、<xref:System.Delegate.CreateDelegate%2A>メソッドです。  
  
> [!NOTE]
>  2 つのオーバー ロードがあります、<xref:System.Delegate.CreateDelegate%2A>メソッドを指定する`firstArgument`と<xref:System.Reflection.MethodInfo>; をバインドするには、失敗した場合にスローするかどうかを指定できますいずれかと、もう一方は常にスローする点を除いて、機能は同じです。 このコード例では、両方のオーバー ロードを使用します。  
  
 例では、クラスを宣言して`C`静的メソッドを持つ`M2`とインスタンス メソッド`M1`、3 つのデリゲート型と:`D1`のインスタンスを受け取り`C`および文字列、`D2`文字列、およびを受け取る`D3`引数がありません。  
  
 2 番目のクラスを名前付き`Example`デリゲートを作成するコードが含まれています。  
  
-   型のデリゲート`D2`のインスタンスを終了済み`C`、インスタンス メソッドの作成は`M1`します。 呼び出されることのバインドのインスタンスを示すための異なる文字列と`C`は常に使用します。  
  
-   型のデリゲート`D1`、開いているインスタンス メソッドを表す、インスタンス メソッドの作成は`M1`します。 デリゲートが呼び出されたときに、インスタンスを渡す必要があります。  
  
-   型のデリゲート`D2`、オープンな静的メソッドを表す、静的なメソッドの作成は`M2`します。  
  
-   型のデリゲートを最後に、 `D3`、文字列を閉じ、静的メソッドの作成は`M2`します。 メソッドは、連結文字列を使用することを表示します。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **例 2**  
  
 次のコード例では、パラメーターの型との互換性について説明し、型を返します。  
  
> [!NOTE]
>  このコード例では、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>メソッドのオーバー ロードします。 その他の使用にオーバー ロードを受け取る<xref:System.Reflection.MethodInfo>と似ています。  
  
 このコード例は、という名前の基本クラスを定義`Base`という名前のクラスと`Derived`から派生した`Base`です。 派生クラスには、 `static` (`Shared` Visual Basic で) という名前のメソッド`MyMethod`型の 1 つのパラメーターを持つ`Base`と戻り値の型`Derived`です。 このコード例もという名前のデリゲートを定義`Example`型の 1 つのパラメーターを持つ`Derived`と戻り値の型`Base`です。  
  
 このコード例で、デリゲートがという名前の`Example`、メソッドを表すために使用できる`MyMethod`です。 メソッドは、ために、デリゲートにバインドできます。  
  
-   デリゲートのパラメーターの型 (`Derived`) のパラメーターの型より限定的な`MyMethod`(`Base`) できるように、安全にデリゲートの引数を渡すには常に、`MyMethod`です。  
  
-   戻り値の型`MyMethod`(`Derived`) デリゲートのパラメーターの型より限定的な (`Base`) デリゲートの戻り値の型をメソッドの戻り値の型をキャストしても安全では常にするようにします。  
  
 コード例は、出力を生成されません。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **例 3**  
  
 次のコード例では、単一のデリゲート型を表すことができるすべてのメソッドを示します。  
  
> [!NOTE]
>  2 つのオーバー ロードがあります、<xref:System.Delegate.CreateDelegate%2A>メソッドを指定する`firstArgument`と<xref:System.Reflection.MethodInfo>; をバインドするには、失敗した場合にスローするかどうかを指定できますいずれかと、もう一方は常にスローする点を除いて、機能は同じです。 このコード例では、両方のオーバー ロードを使用します。  
  
 このコード例は、2 つのクラスを定義`C`と`F`とデリゲート型`D`型の 1 つの引数を持つ`C`します。 クラスには対応する静的メソッドとインスタンス`M1`、 `M3`、および`M4`、およびクラス`C`はインスタンス メソッドもあります`M2`引数を持たない。  
  
 3 番目のクラスを名前付き`Example`デリゲートを作成するコードが含まれています。  
  
-   デリゲートがインスタンス メソッドで作成された`M1`型の`C`および種類`F`; それぞれの型のインスタンス上の各が閉じられます。 メソッド`M1`型の`C`が表示されます、`ID`引数およびバインドされたインスタンスのプロパティです。  
  
-   メソッドのデリゲートを作成`M2`型の`C`します。 これは、デリゲートの引数が非表示の最初の引数でインスタンス メソッドを表しますが、開いているインスタンス デリゲートです。 メソッドには、その他の引数がありません。  
  
-   静的メソッドに対してデリゲートを作成`M3`型の`C`および種類`F`です。 これらは、オープンな静的デリゲート。  
  
-   静的メソッドのデリゲートを作成する最後に、`M4`型の`C`および種類`F`; 各メソッドには、最初の引数として宣言する型と型のインスタンスが指定されるため、デリゲートは、第 1 引数経由で閉じられます. メソッド`M4`型の`C`が表示されます、`ID`引数およびバインドされたインスタンスのプロパティです。  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The class instance on which <c>method</c> is invoked.</param>
        <param name="method">The name of the instance method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <summary>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance with the specified case-sensitivity.</summary>
        <returns>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのデリゲートのインスタンス メソッドだけを作成します。 インスタンス メソッドがクラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられている方法です。  
  
 このメソッドはオーバー ロードを呼び出すことと同等、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>メソッド オーバー ロードを指定する`true`の`throwOnBindFailure`します。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、非パブリック メソッドを呼び出し元が許可されている場合にアクセスするために使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグし、許可セット、またはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not an instance method.  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <summary>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity.</summary>
        <returns>A delegate of the specified type that represents the specified static method of the specified class.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、静的メソッドのみのデリゲートを作成します。 インスタンス メソッドがクラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられている方法です。  
  
 このメソッドはオーバー ロードを呼び出すことと同等、<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>メソッド オーバー ロードを指定する`true`の`throwOnBindFailure`します。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、非パブリック メソッドを呼び出し元が許可されている場合にアクセスするために使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグし、許可セット、またはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> is not a <see langword="RuntimeType" />.  -or-  <paramref name="target" /> is an open generic type. That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The class instance on which <c>method</c> is invoked.</param>
        <param name="method">The name of the instance method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance, with the specified case-sensitivity and the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのデリゲートのインスタンス メソッドだけを作成します。 インスタンス メソッドがクラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられている方法です。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、非パブリック メソッドを呼び出し元が許可されている場合にアクセスするために使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグし、許可セット、またはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not an instance method.  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity and the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type that represents the specified static method of the specified class.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、静的メソッドのみのデリゲートを作成します。 インスタンス メソッドがクラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられている方法です。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、非パブリック メソッドを呼び出し元が許可されている場合にアクセスするために使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグし、許可セット、またはサブセットに非パブリック メソッドの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> is not a <see langword="RuntimeType" />.  -or-  <paramref name="target" /> is an open generic type. That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙値:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />です。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">An array of objects that are the arguments to pass to the method represented by the current delegate.  -or-  <see langword="null" />, if the method represented by the current delegate does not require arguments.</param>
        <summary>Dynamically invokes (late-bound) the method represented by the current delegate.</summary>
        <returns>The object returned by the method represented by the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Delegate.DynamicInvokeImpl%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).  -or-  The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</exception>
        <exception cref="T:System.ArgumentException">The method represented by the delegate is invoked on an object or a class that does not support it.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The method represented by the delegate is an instance method and the target object is <see langword="null" />.  -or-  One of the encapsulated methods throws an exception.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">An array of objects that are the arguments to pass to the method represented by the current delegate.  -or-  <see langword="null" />, if the method represented by the current delegate does not require arguments.</param>
        <summary>Dynamically invokes (late-bound) the method represented by the current delegate.</summary>
        <returns>The object returned by the method represented by the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Delegate.DynamicInvoke%2A> メソッドを実装します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).  -or-  The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</exception>
        <exception cref="T:System.ArgumentException">The method represented by the delegate is invoked on an object or a class that does not support it.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The method represented by the delegate is an instance method and the target object is <see langword="null" />.  -or-  One of the encapsulated methods throws an exception.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The object to compare with the current delegate.</param>
        <summary>Determines whether the specified object and the current delegate are of the same type and share the same targets, methods, and invocation list.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> and the current delegate have the same targets, methods, and invocation list; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 同じ型の 2 つのデリゲート場合とは見なされません等しい。  
  
> [!IMPORTANT]
>  .NET framework version 1.0 および 1.1 では、2 つのデリゲートが等しいと見なされる場合は、ターゲット、メソッド、および呼び出しリストが等しいか、異なる型のデリゲート場合でもです。  
  
 メソッドとターゲット」は、次のように等しいかどうか比較されます。  
  
-   比較対象となる 2 つの方法では、どちらも静的で、同じクラス上の同じメソッド場合、メソッドは、等しいと見なされます、ターゲットも等しいと見なさです。  
  
-   比較対象となる 2 つの方法では、インスタンス メソッドし、同じオブジェクトに対して同じメソッドである場合、メソッドは、等しいと見なされますターゲットも等しいと見なさです。  
  
-   それ以外の場合、メソッドと同じと見なされないやターゲットもいないと見なされますと同じです。  
  
 2 つの呼び出しリストは同じ順序が存在し、2 つの一覧から対応する要素が同じメソッドとターゲットを表す場合にのみ、同一と見なされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a hash code for the delegate.</summary>
        <returns>A hash code for the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの戻り値は、2 つの理由の永続化されません必要があります。 最初に、古いハッシュ関数からの値が役に立ちませんレンダリングより優れた分布を生成するクラスのハッシュ関数を変更する可能性があります。 次に、このクラスの既定の実装では、同じ値を別のインスタンスによって返されることは限りません。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the invocation list of the delegate.</summary>
        <returns>An array of delegates representing the invocation list of the current delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 配列内の各デリゲートは、1 つのメソッドを表します。  
  
 配列内のデリゲートの順序は、現在のデリゲートがそれらのデリゲートが表すメソッドを呼び出すが、同じ順序です。  
  
   
  
## Examples  
 次の例は、3 つのメソッドをデリゲートに割り当てます。 呼び出して、 <xref:System.Delegate.GetInvocationList%2A> "File"に、デリゲートを逆の順序で実行して、名前の部分文字列を含めないでくださいメソッドを実行する、デリゲートに割り当てられているメソッドの合計数を取得します。  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the static method represented by the current delegate.</summary>
        <returns>A <see cref="T:System.Reflection.MethodInfo" /> describing the static method represented by the current delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のデリゲートは、静的メソッドを表す場合にのみ適用されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Not supported.</param>
        <param name="context">Not supported.</param>
        <summary>Not supported.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">This method is not supported.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the method represented by the delegate.</summary>
        <value>A<see cref="T:System.Reflection.MethodInfo" />デリゲートによって表されるメソッドを記述します。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">The first delegate to compare.</param>
        <param name="d2">The second delegate to compare.</param>
        <summary>Determines whether the specified delegates are equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="d1" /> is equal to <paramref name="d2" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 同じターゲット、メソッド、および呼び出しリストを持つ同じ型の 2 つのデリゲートは、等しいと見なされます。  
  
 同じ型の 2 つのデリゲート場合とは見なされません等しい。  
  
> [!IMPORTANT]
>  .NET framework version 1.0 および 1.1 では、2 つのデリゲートが等しいと見なされる場合は、ターゲット、メソッド、および呼び出しリストが等しいか、異なる型のデリゲート場合でもです。  
  
 メソッドとターゲット」は、次のように等しいかどうか比較されます。  
  
-   比較対象となる 2 つの方法では、どちらも静的で、同じクラス上の同じメソッド場合、メソッドは、等しいと見なされます、ターゲットも等しいと見なさです。  
  
-   比較対象となる 2 つの方法では、インスタンス メソッドし、同じオブジェクトに対して同じメソッドである場合、メソッドは、等しいと見なされますターゲットも等しいと見なさです。  
  
-   それ以外の場合、メソッドと同じと見なされないやターゲットもいないと見なされますと同じです。  
  
 2 つの呼び出しリストは同じ順序が存在し、2 つの一覧から対応する要素が同じメソッドとターゲットを表す場合、同一と見なされます。  
  
 この演算子を同等の方法は、します。 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">The first delegate to compare.</param>
        <param name="d2">The second delegate to compare.</param>
        <summary>Determines whether the specified delegates are not equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="d1" /> is not equal to <paramref name="d2" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 2 つのデリゲートが等しくないと見なさ型が異なる、または別の方法、ターゲット、または別の呼び出しリストがある場合。  
  
 同じ型の 2 つのデリゲート場合とは見なされません等しい。  
  
> [!IMPORTANT]
>  .NET framework version 1.0 および 1.1 では、2 つのデリゲートが場合に、ターゲット、メソッド、および呼び出しリストが等しいか、異なる型のデリゲート場合でも、等しいと見なされます。  
  
 メソッドとターゲット」は、次のように等しいかどうか比較されます。  
  
-   比較対象となる 2 つの方法では、どちらも静的で、同じクラス上の同じメソッド場合、メソッドは、等しいと見なされます、ターゲットも等しいと見なさです。  
  
-   比較対象となる 2 つの方法では、インスタンス メソッドし、同じオブジェクトに対して同じメソッドである場合、メソッドは、等しいと見なされますターゲットも等しいと見なさです。  
  
-   それ以外の場合、メソッドと同じと見なされないやターゲットもいないと見なされますと同じです。  
  
 2 つの呼び出しリストがあれば、サイズが異なる場合は順序が異なる、または 1 つのリストから、少なくとも 1 つの要素は、メソッドまたはその他のリスト内の対応する要素によって表されるとは異なるターゲットを表す場合は等しくありません。  
  
 この演算子を同等の方法は、します。 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">The delegate from which to remove the invocation list of <c>value</c>.</param>
        <param name="value">The delegate that supplies the invocation list to remove from the invocation list of <c>source</c>.</param>
        <summary>Removes the last occurrence of the invocation list of a delegate from the invocation list of another delegate.</summary>
        <returns>A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing the last occurrence of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />. Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />. Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" /> or if <paramref name="source" /> is a null reference.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合の呼び出しリスト`value`連続した一連の呼び出しリスト内の要素と一致する`source`の呼び出しリストし、`value`の呼び出しリスト内に発生すると言います`source`です。 場合の呼び出しリスト`value`の呼び出しリスト内に 1 回以上発生`source`、最後に見つかった位置を削除します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <exception cref="T:System.ArgumentException">The delegate types do not match.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">The delegate from which to remove the invocation list of <c>value</c>.</param>
        <param name="value">The delegate that supplies the invocation list to remove from the invocation list of <c>source</c>.</param>
        <summary>Removes all occurrences of the invocation list of a delegate from the invocation list of another delegate.</summary>
        <returns>A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing all occurrences of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />. Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />. Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" />, if <paramref name="source" /> contains only a series of invocation lists that are equal to the invocation list of <paramref name="value" />, or if <paramref name="source" /> is a null reference.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合の呼び出しリスト`value`連続した一連の呼び出しリスト内の要素と一致する`source`の呼び出しリストし、`value`の呼び出しリスト内に発生すると言います`source`です。 場合の呼び出しリスト`value`の呼び出しリスト内に 1 回以上発生`source`をすべて削除します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <exception cref="T:System.ArgumentException">The delegate types do not match.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">The delegate that supplies the invocation list to remove from the invocation list of the current delegate.</param>
        <summary>Removes the invocation list of a delegate from the invocation list of another delegate.</summary>
        <returns>A new delegate with an invocation list formed by taking the invocation list of the current delegate and removing the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the current delegate's invocation list. Returns the current delegate if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the current delegate's invocation list. Returns <see langword="null" /> if the invocation list of <paramref name="value" /> is equal to the current delegate's invocation list.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合の呼び出しリスト`value`連続した現在のデリゲートの呼び出しリストでは、次の呼び出しリスト内の要素のセットと一致する`value`現在のデリゲートの呼び出しリスト内で発生すると言います。 場合の呼び出しリスト`value`が複数回出現現在のデリゲートの呼び出しリストに、最後に見つかった位置を削除します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the class instance on which the current delegate invokes the instance method.</summary>
        <value>現在のデリゲートが、デリゲートがインスタンス メソッドを表す場合、インスタンス メソッドを呼び出す対象のオブジェクト<see langword="null" />場合は、デリゲートは、静的メソッドを表します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンス メソッドがクラスのインスタンスに関連付けられているメソッドです。静的メソッドは、クラス自体に関連付けられている方法です。  
  
 デリゲートは 1 つまたは複数のインスタンス メソッドが呼び出される場合、このプロパティは、呼び出しリストにある最後のインスタンス メソッドのターゲットを返します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />です。 関連する列挙。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>