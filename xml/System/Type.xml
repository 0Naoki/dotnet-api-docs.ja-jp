<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Type.xml" source-language="en-US" target-language="ja-JP">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5a40925048dd06746d1e1cda2a76aa4ecaae1b916.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a40925048dd06746d1e1cda2a76aa4ecaae1b916</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</source>
          <target state="translated">型宣言を表します。型には、クラス型、インターフェイス型、配列型、値型、列挙型、型パラメーター、ジェネリック型定義、およびオープン構築ジェネリック型またはクローズ構築ジェネリック型があります。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><ph id="ph1">`Type`</ph> is the root of the <ph id="ph2">&lt;xref:System.Reflection&gt;</ph> functionality and is the primary way to access metadata.</source>
          <target state="translated"><ph id="ph1">`Type`</ph> ルート、<ph id="ph2">&lt;xref:System.Reflection&gt;</ph>機能であり、メタデータにアクセスする主な方法です。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Use the members of <ph id="ph1">&lt;xref:System.Type&gt;</ph> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</source>
          <target state="translated">メンバーを使って<ph id="ph1">&lt;xref:System.Type&gt;</ph>だけでなく、モジュールおよびアセンブリのクラスが展開されている、(など、コンス トラクター、メソッド、フィールド、プロパティ、およびイベント クラスの)、型のメンバーは、型の宣言に関する情報を取得します。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</source>
          <target state="translated">アクセス許可のリフレクションを使用して、これらのアクセス レベルに関係なく型とそのメンバーに関する情報を取得するコードの必要はありません。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</source>
          <target state="translated">アクセス許可のパブリック メンバー、またはアクセス レベルが表示されるように通常のコンパイル中に他のメンバーにアクセスするリフレクションを使用するコードの必要はありません。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">ただし、通常アクセスできなくなる、プライベートまたは内部のメソッドなど、保護の種類のフィールドまたはメンバーにアクセスするためにリフレクションを使用するコードのクラスは継承されません、コードいる必要があります<ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">参照してください<bpt id="p1">[</bpt>リフレクションに関するセキュリティの考慮事項<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><ph id="ph1">`Type`</ph> is an abstract base class that allows multiple implementations.</source>
          <target state="translated"><ph id="ph1">`Type`</ph> 抽象基本クラスにより、複数の実装です。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The system will always provide the derived class <ph id="ph1">`RuntimeType`</ph>.</source>
          <target state="translated">システムは常に、派生クラスを提供する<ph id="ph1">`RuntimeType`</ph>です。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</source>
          <target state="translated">リフレクションの場合、システムとサポートの比較操作でオブジェクトごと 1 回だけ実行時の単語で始まるすべてのクラスが作成されます。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>In multithreading scenarios, do not lock <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects in order to synchronize access to <ph id="ph2">`static`</ph> data.</source>
          <target state="translated">マルチ スレッドでは、ロックしない<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクトへのアクセスを同期するために<ph id="ph2">`static`</ph>データ。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Other code, over which you have no control, might also lock your class type.</source>
          <target state="translated">コントロールでその他のコードでは、クラスの型はロックも可能性がありません。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This might result in a deadlock.</source>
          <target state="translated">これにより、デッドロック可能性があります。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Instead, synchronize access to static data by locking a private <ph id="ph1">`static`</ph> object.</source>
          <target state="translated">代わりに、プライベートをロックすることで静的なデータへのアクセスを同期<ph id="ph1">`static`</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>A derived class can access protected members of the calling code's base classes.</source>
          <target state="translated">派生クラスは、呼び出し元のコードの基本クラスのプロテクト メンバーにアクセスできます。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Also, access is allowed to assembly members of the calling code's assembly.</source>
          <target state="translated">また、呼び出し元のコードのアセンブリのアセンブリのメンバーにアクセスが許可されます。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</source>
          <target state="translated">原則として、事前バインディングされたコードでアクセスを許可されている場合は、遅延バインディングされたコードでもアクセスできます。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</source>
          <target state="translated">その他のインターフェイスを拡張するインターフェイスでは、拡張インターフェイスで定義されているメソッドは継承されません。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>In this section:</source>
          <target state="translated">このセクションの内容:</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><bpt id="p1">[</bpt>What types does a Type object represent?<ept id="p1">](#WhatTypes)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>型オブジェクトはどのような種類を表しているか。<ept id="p1">](#WhatTypes)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><bpt id="p1">[</bpt>Retrieving a Type object<ept id="p1">](#Retrieve)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>型のオブジェクトを取得します。<ept id="p1">](#Retrieve)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><bpt id="p1">[</bpt>Comparing type objects for equality<ept id="p1">](#Equality)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>型のオブジェクトの等価性を比較します。<ept id="p1">](#Equality)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>What types does a Type object represent?</source>
          <target state="translated">型オブジェクトはどのような種類を表しているか。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This class is thread safe; multiple threads can concurrently read from an instance of this type.</source>
          <target state="translated">このクラスはスレッド セーフです。複数のスレッドは、この型のインスタンスから同時に読み取ることができます。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Type&gt;</ph> class can represent any of the following types:</source>
          <target state="translated">インスタンス、<ph id="ph1">&lt;xref:System.Type&gt;</ph>クラスには、次の種類を表すことができます。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Classes</source>
          <target state="translated">クラス</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Value types</source>
          <target state="translated">値型</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Arrays</source>
          <target state="translated">配列</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Interfaces</source>
          <target state="translated">インターフェイス</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Enumerations</source>
          <target state="translated">列挙</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Delegates</source>
          <target state="translated">デリゲート</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Constructed generic types and generic type definitions</source>
          <target state="translated">構築ジェネリック型とジェネリック型定義</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</source>
          <target state="translated">型引数と構築ジェネリック型、ジェネリック型定義、およびジェネリック メソッド定義のパラメーターの型</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Retrieving a Type object</source>
          <target state="translated">型のオブジェクトを取得します。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object associated with a particular type can be obtained in the following ways:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph>特定の種類に関連付けられているオブジェクトを取得するには、次の方法で。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The instance <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents the type of an instance.</source>
          <target state="translated">インスタンス<ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph>メソッドを返します、<ph id="ph2">&lt;xref:System.Type&gt;</ph>インスタンスの型を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Because all managed types derive from <ph id="ph1">&lt;xref:System.Object&gt;</ph>, the <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> method can be called on an instance of any type.</source>
          <target state="translated">すべてのマネージ型から派生しているため<ph id="ph1">&lt;xref:System.Object&gt;</ph>、<ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph>メソッドは、任意の型のインスタンスで呼び出すことができます。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph> method to determine the runtime type of each object in an object array.</source>
          <target state="translated">次の例では、<ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph>オブジェクト配列内の各オブジェクトのランタイム型を調べます。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The static <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> methods return a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a type specified by its fully qualified name.</source>
          <target state="translated">静的な<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>を返し、<ph id="ph2">&lt;xref:System.Type&gt;</ph>完全修飾名で指定された型を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType&gt;</ph> methods return <ph id="ph4">`Type`</ph> objects that represent the types defined in a module.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType&gt;</ph>、 <ph id="ph2">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>、および<ph id="ph3">&lt;xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType&gt;</ph>メソッドが返す<ph id="ph4">`Type`</ph>モジュールで定義された型を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The first method can be used to obtain an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects for all the public and private types defined in a module.</source>
          <target state="translated">配列を取得する最初のメソッドを使用できます<ph id="ph1">&lt;xref:System.Type&gt;</ph>モジュールで定義されたすべてのパブリックおよびプライベート型のオブジェクト。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>(You can obtain an instance of <ph id="ph1">`Module`</ph> through the <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType&gt;</ph> method, or through the <ph id="ph4">&lt;xref:System.Type.Module%2A?displayProperty=nameWithType&gt;</ph> property.)</source>
          <target state="translated">(のインスタンスを取得する<ph id="ph1">`Module`</ph>を通じて、<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph3">&lt;xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType&gt;</ph>メソッド、または、<ph id="ph4">&lt;xref:System.Type.Module%2A?displayProperty=nameWithType&gt;</ph>プロパティです)。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly?displayProperty=nameWithType&gt;</ph> object contains a number of methods to retrieve the classes defined in an assembly, including <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly?displayProperty=nameWithType&gt;</ph>オブジェクトには含む、アセンブリで定義されたクラスを取得するメソッドの数が含まれています<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>、 <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph>、および<ph id="ph4">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> method returns a filtered list of interface types supported by a type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>メソッドの種類でサポートされているインターフェイスの種類のフィルター選択された一覧を返します。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> method returns a <ph id="ph2">`Type`</ph> object that represents the element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph>メソッドを返します、<ph id="ph2">`Type`</ph>要素を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetInterface%2A&gt;</ph> methods return <ph id="ph3">&lt;xref:System.Type&gt;</ph> objects representing the interface types supported by a type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Type.GetInterface%2A&gt;</ph>メソッドが返す<ph id="ph3">&lt;xref:System.Type&gt;</ph>型でサポートされているインターフェイス型を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> method returns an array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects representing the types specified by an arbitrary set of objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph>メソッドの配列を返します<ph id="ph2">&lt;xref:System.Type&gt;</ph>オブジェクトの任意のセットで指定された型を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The objects are specified with an array of type <ph id="ph1">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">型の配列では、オブジェクトを指定<ph id="ph1">&lt;xref:System.Object&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> methods are provided for COM interoperability.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>COM 相互運用性のメソッドが用意されています。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>They return a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the type specified by a <ph id="ph2">`ProgID`</ph> or <ph id="ph3">`CLSID`</ph>.</source>
          <target state="translated">返される、<ph id="ph1">&lt;xref:System.Type&gt;</ph>で指定された型を表すオブジェクト、<ph id="ph2">`ProgID`</ph>または<ph id="ph3">`CLSID`</ph>です。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> method is provided for interoperability.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph>メソッドは、相互運用性を提供します。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>It returns a <ph id="ph1">`Type`</ph> object that represents the type specified by a class handle.</source>
          <target state="translated">返します、<ph id="ph1">`Type`</ph>クラス ハンドルで指定された型を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The C# <ph id="ph1">`typeof`</ph> operator, the C++ <ph id="ph2">`typeid`</ph> operator, and the Visual Basic <ph id="ph3">`GetType`</ph> operator obtain the <ph id="ph4">`Type`</ph> object for a type.</source>
          <target state="translated">C#<ph id="ph1">`typeof`</ph>演算子、C++<ph id="ph2">`typeid`</ph>演算子、および Visual Basic<ph id="ph3">`GetType`</ph>演算子を取得、<ph id="ph4">`Type`</ph>型のオブジェクト。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing a constructed generic type, which is an open constructed type if its <ph id="ph3">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>, and a closed constructed type otherwise.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>メソッドを返します、<ph id="ph2">&lt;xref:System.Type&gt;</ph>場合オープン構築型である構築ジェネリック型を表すオブジェクトをその<ph id="ph3">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>プロパティから返される<ph id="ph4">`true`</ph>、クローズ構築された型がそれ以外の場合とします。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>A generic type can be instantiated only if it is closed.</source>
          <target state="translated">閉じている場合にのみ、ジェネリック型をインスタンス化できます。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> methods return <ph id="ph4">&lt;xref:System.Type&gt;</ph> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (<ph id="ph5">`ref`</ph> in C#, <ph id="ph6">`ByRef`</ph> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>、および<ph id="ph3">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph>メソッドが返す<ph id="ph4">&lt;xref:System.Type&gt;</ph>をそれぞれに、指定された型、指定した型と参照パラメーターの型へのポインターの配列を表すオブジェクト (<ph id="ph5">`ref`</ph> 、C# の場合は、 <ph id="ph6">`ByRef`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Comparing type objects for equality</source>
          <target state="translated">型のオブジェクトの等価性を比較します。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents a type is unique; that is, two <ph id="ph2">&lt;xref:System.Type&gt;</ph> object references refer to the same object if and only if they represent the same type.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表す型が一意であるオブジェクトです。 つまり、2 つ<ph id="ph2">&lt;xref:System.Type&gt;</ph>オブジェクト参照は、同じ型を表している場合にのみ、同じオブジェクトを参照しています。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This allows for comparison of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects using reference equality.</source>
          <target state="translated">これにより、比較の<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクト参照の等価性を使用します。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The following example compares the <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects that represent a number of integer values to determine whether they are of the same type.</source>
          <target state="translated">次の例を比較して、<ph id="ph1">&lt;xref:System.Type&gt;</ph>を同じ型のいるかどうかを決定する整数値の数を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The following  example shows a few representative features of <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">次の例では、いくつかの代表的な機能の<ph id="ph1">&lt;xref:System.Type&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The C# <ph id="ph1">`typeof`</ph> operator (<ph id="ph2">`GetType`</ph> operator in Visual Basic, <ph id="ph3">`typeid`</ph> operator in Visual C++) is used to get a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing <ph id="ph5">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">C#<ph id="ph1">`typeof`</ph>演算子 (<ph id="ph2">`GetType`</ph> Visual Basic の演算子<ph id="ph3">`typeid`</ph>Visual C では演算子) を取得するために使用、<ph id="ph4">&lt;xref:System.Type&gt;</ph>オブジェクトを表す<ph id="ph5">&lt;xref:System.String&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>From this <ph id="ph1">&lt;xref:System.Type&gt;</ph> object, the <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method is used to get a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> representing the <ph id="ph4">&lt;xref:System.String.Substring%2A&gt;</ph> overload that takes a starting location and a length.</source>
          <target state="translated">これから<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクト、<ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph>メソッドを使用して、取得、<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>を表す、<ph id="ph4">&lt;xref:System.String.Substring%2A&gt;</ph>を開始位置と長さを受け取るオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>To identify the overload signature, the code example creates a temporary array containing two <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects representing <ph id="ph2">`int`</ph> (<ph id="ph3">`Integer`</ph> in Visual Basic).</source>
          <target state="translated">2 つを含む一時配列を作成するコード例をオーバー ロードのシグネチャを識別するため<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクトを表す<ph id="ph2">`int`</ph>(<ph id="ph3">`Integer`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>To be precise, the array contains two references to the instance of <ph id="ph1">&lt;xref:System.Type&gt;</ph> that represents <ph id="ph2">`int`</ph> in the current application domain.</source>
          <target state="translated">正確に言うと、配列にはインスタンスに 2 つの参照が含まれています<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表す<ph id="ph2">`int`</ph>現在のアプリケーション ドメインでします。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>For any type, there is only one instance of <ph id="ph1">&lt;xref:System.Type&gt;</ph> per application domain.</source>
          <target state="translated">任意の種類の 1 つだけのインスタンスが<ph id="ph1">&lt;xref:System.Type&gt;</ph>あたりのアプリケーション ドメイン。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The code example uses the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> to invoke the <ph id="ph2">&lt;xref:System.String.Substring%2A&gt;</ph> method on the string "Hello, World!", and displays the result.</source>
          <target state="translated">コードの例では、<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>を呼び出す、<ph id="ph2">&lt;xref:System.String.Substring%2A&gt;</ph>文字列「こんにちは, World!」、メソッド、結果を表示します。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This type is thread safe.</source>
          <target state="translated">この型はスレッド セーフです。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>When you inherit from <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, you must override the following members:</source>
          <target state="translated">継承する場合<ph id="ph1">&lt;see langword="Type" /&gt;</ph>、次のメンバーをオーバーライドする必要があります。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><ph id="ph1">&lt;see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /&gt;</ph> ,</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /&gt;</ph> ,</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Type.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> クラスの新しいインスタンスを初期化します。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.#ctor">
          <source>This constructor is invoked by derived classes during the construction of type objects.</source>
          <target state="translated">このコンス トラクターは、型のオブジェクトの作成中に、派生クラスによって呼び出されます。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="P:System.Type.Assembly">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> in which the type is declared.</source>
          <target state="translated">型が宣言される <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> を取得します。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="P:System.Type.Assembly">
          <source>For generic types, gets the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> in which the generic type is defined.</source>
          <target state="translated">ジェネリック型の場合は、ジェネリック型が定義される <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> を取得します。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> instance that describes the assembly containing the current type.</source>
          <target state="translated">現在の型を含むアセンブリを説明する <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> インスタンス。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</source>
          <target state="translated">ジェネリック型の場合、インスタンスは特定の構築型を作成および使用するアセンブリではなく、ジェネリック型定義を含むアセンブリを説明します。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクトが構築されたジェネリック型を表し、このプロパティは、ジェネリック型定義を含むアセンブリを返します。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition <ph id="ph1">`MyGenericStack&lt;T&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of T)`</ph> in Visual Basic, <ph id="ph3">`generic&lt;T&gt; ref class MyGenericStack`</ph> in C++).</source>
          <target state="translated">たとえば、ジェネリック型定義を含む MyGenerics.dll をという名前のアセンブリを作成する<ph id="ph1">`MyGenericStack&lt;T&gt;`</ph>(<ph id="ph2">`MyGenericStack(Of T)`</ph> Visual basic で<ph id="ph3">`generic&lt;T&gt; ref class MyGenericStack`</ph>C++ で)。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>If you create an instance of <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of Integer)`</ph> in Visual Basic) in another assembly, the <ph id="ph3">&lt;xref:System.Type.Assembly%2A&gt;</ph> property for the constructed type returns an <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> object that represents MyGenerics.dll.</source>
          <target state="translated">インスタンスを作成する場合<ph id="ph1">`MyGenericStack&lt;int&gt;`</ph>(<ph id="ph2">`MyGenericStack(Of Integer)`</ph> Visual Basic で) 別のアセンブリ内、<ph id="ph3">&lt;xref:System.Type.Assembly%2A&gt;</ph>構築された型のプロパティを返します、 <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> MyGenerics.dll を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents an unassigned generic parameter <ph id="ph2">`T`</ph>, this property returns the assembly that contains the generic type that defines <ph id="ph3">`T`</ph>.</source>
          <target state="translated">同様に場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクト未割り当てのジェネリック パラメーターを表す<ph id="ph2">`T`</ph>、このプロパティを定義するジェネリック型を含むアセンブリを返します<ph id="ph3">`T`</ph>です。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>If the <ph id="ph1">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> property is not available on a particular .NET implementation, such as .NET Core or the Universal Windows Platform, use the <ph id="ph2">&lt;xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType&gt;</ph> property instead.</source>
          <target state="translated">場合、 <ph id="ph1">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> .NET Core またはユニバーサル Windows プラットフォームなど、特定の .NET 実装で使用できるプロパティは、使用して、<ph id="ph2">&lt;xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType&gt;</ph>プロパティ代わりにします。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>This property is read-only.</source>
          <target state="translated">このプロパティは読み取り専用です。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>The following example displays the assembly name associated with the class and the fully qualified name of the type.</source>
          <target state="translated">次の例では、クラスに関連付けられているアセンブリ名と型の完全修飾名が表示されます。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="P:System.Type.AssemblyQualifiedName">
          <source>Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object was loaded.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの読み込み元であるアセンブリの名前を含む型のアセンブリ修飾名を取得します。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The assembly-qualified name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, which includes the name of the assembly from which the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> was loaded, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the current instance represents a generic type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の読み込み元であるアセンブリの名前を含む、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> のアセンブリ修飾名。現在のインスタンスがジェネリック型パラメーターを表す場合は <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</source>
          <target state="translated">型のアセンブリ修飾名は、アセンブリの表示名を続けて、コンマの後にその名前空間を含む型の名前で構成されます。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The display name of an assembly is obtained using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">使用してアセンブリの表示名を取得、<ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">.NET Framework version 2.0 では、プロセッサのアーキテクチャは、アセンブリ id に追加され、アセンブリ名の文字列の一部として指定できます。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">たとえば、"ProcessorArchitecture = msil"です。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">ただし、これが含まれていませんによって返される文字列で、<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>互換性のためのプロパティです。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">「<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">共通言語ランタイムをサポートするすべてのコンパイラは、入れ子になったクラスの簡易名を生成し、リフレクションは、次の規則に従って、照会されたときに、完全修飾名を構築します。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Delimiter</source>
          <target state="translated">区切り記号</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Meaning</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">円記号 (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Escape character.</source>
          <target state="translated">文字をエスケープします。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Comma (,)</source>
          <target state="translated">コンマ (,)</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Precedes the Assembly name.</source>
          <target state="translated">アセンブリ名の前にします。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Plus sign (+)</source>
          <target state="translated">プラス記号 (+)</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Precedes a nested class.</source>
          <target state="translated">入れ子になったクラスが前に付きます。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Period (.)</source>
          <target state="translated">ピリオド (.)</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">名前空間の識別子を表します。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Brackets ([])</source>
          <target state="translated">角かっこ ()</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>After a type name, denotes an array of that type.</source>
          <target state="translated">型名の後に、その型の配列を表します。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For a generic type, encloses the generic type argument list.</source>
          <target state="translated">ジェネリック型のジェネリック型引数リストを囲みます。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Within a type argument list, encloses an assembly-qualified type.</source>
          <target state="translated">型引数リスト内で、アセンブリ修飾型を囲みます。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For example, the assembly-qualified name for a class might look like this:</source>
          <target state="translated">たとえば、クラスのアセンブリ修飾名は、次のようになります。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">名前空間には、たとえば TopNamespace.Sub+Namespace、プラス記号が含まれているかどうかは、プラス記号 (+) は、エスケープ文字が前は (<ph id="ph1">\\</ph>)、入れ子の区切り記号として解釈されないようにします。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Reflection would emit this string as follows:</source>
          <target state="translated">リフレクションでは、次のようにこの文字列を出力は。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">この修飾名を永続化し、読み込みに使用された後で、<ph id="ph1">&lt;xref:System.Type&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">検索して読み込む、<ph id="ph1">&lt;xref:System.Type&gt;</ph>を使用して<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>のみまたはアセンブリ修飾型名を持つという名前を型のいずれか。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 型と名前のみが検索、<ph id="ph2">&lt;xref:System.Type&gt;</ph>呼び出し元のアセンブリにし、システム アセンブリです。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> アセンブリ修飾型名は探します、<ph id="ph2">&lt;xref:System.Type&gt;</ph>任意のアセンブリにします。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">型名には、型は、参照型、ポインター型または配列型かどうかの種類に関する追加情報を示す末尾の文字が含まれます。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">このような末尾の文字型の名前を取得する<ph id="ph1">`t.GetElementType().ToString()`</ph>ここで、<ph id="ph2">`t`</ph>型です。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">アセンブリ名に ',' 区切り記号の前にスペースは、関連するが、',' 区切り記号の後のスペースは無視されます。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Generic arguments of generic types are themselves qualified by assembly name.</source>
          <target state="translated">ジェネリック型のジェネリック引数は、アセンブリ名で修飾された自体です。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For example, in the assembly-qualified type name for <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> in Visual Basic), <ph id="ph3">`int`</ph> is expanded to the assembly-qualified type name for <ph id="ph4">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">などのアセンブリ修飾型名で<ph id="ph1">`MyGenericClass&lt;int&gt;`</ph>(<ph id="ph2">`MyGenericClass(Of Integer)`</ph> Visual Basic で)、<ph id="ph3">`int`</ph>のアセンブリ修飾型名に拡張された<ph id="ph4">&lt;xref:System.Int32&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a generic parameter, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクトは、ジェネリック パラメーターを表す、このプロパティを返します<ph id="ph2">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The following example displays the assembly name associated with the class and the fully qualified name of the type.</source>
          <target state="translated">次の例では、クラスに関連付けられているアセンブリ名と型の完全修飾名が表示されます。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The following example compares the strings returned by the <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> method and the <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> properties.</source>
          <target state="translated">次の例で返される文字列の比較、<ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph>メソッドおよび<ph id="ph2">`Name`</ph>、 <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>、および<ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="P:System.Type.Attributes">
          <source>Gets the attributes associated with the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> に関連付けられている属性を取得します。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph> object representing the attribute set of the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, unless the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> represents a generic type parameter, in which case the value is unspecified.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph> の属性セットを表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクト。ただし、<ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> がジェネリック型パラメーターを表す場合、値は未指定。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>Some members of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration are masks that represent a group of values.</source>
          <target state="translated">一部のメンバー、<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph>列挙体は値のグループを表すマスク。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>Each group includes one member whose underlying value is zero.</source>
          <target state="translated">各グループには、基になる値が 0、1 つのメンバーが含まれています。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>For example, the underlying value of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType&gt;</ph> member in the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> group is zero, as is the <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> member in the <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> group.</source>
          <target state="translated">たとえば、基になる値の<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType&gt;</ph>内のメンバー、<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph>グループは、0 の場合は、<ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>内のメンバー、<ph id="ph4">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph>グループ。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>Because of this, you must use the mask before testing for those values.</source>
          <target state="translated">このため、それらの値をテストする前に、マスクを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>The example provides an illustration.</source>
          <target state="translated">具体的な例を次に示します。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>For most purposes, properties like <ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph>,<ph id="ph2">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSpecialName%2A&gt;</ph> are easier to use than type attributes.</source>
          <target state="translated">ほとんどの目的のプロパティと同様に<ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph>、<ph id="ph2">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph>、および<ph id="ph3">&lt;xref:System.Type.IsSpecialName%2A&gt;</ph>型の属性より簡単に使用されます。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the attributes of the generic type definition.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>表します構築されたジェネリック型、このプロパティは、ジェネリック型定義の属性を返します。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>For example, the attributes returned for <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> in Visual Basic) are the attributes of <ph id="ph3">`MyGenericClass&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericClass(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">に対して返される属性など、 <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> Visual Basic で) の属性<ph id="ph3">`MyGenericClass&lt;T&gt;`</ph>(<ph id="ph4">`MyGenericClass(Of T)`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter — that is, if the <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph3">`true`</ph> — the <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> value returned by this property is unspecified.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>がジェネリック型パラメーターを表す-は場合、<ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>プロパティから返される<ph id="ph3">`true`</ph>—、<ph id="ph4">&lt;xref:System.Reflection.TypeAttributes&gt;</ph>このプロパティによって返される値は指定されていません。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>The following example usesthe <ph id="ph1">&lt;xref:System.Type.Attributes%2A&gt;</ph> property.</source>
          <target state="translated">次の例ポイント<ph id="ph1">&lt;xref:System.Type.Attributes%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="P:System.Type.BaseType">
          <source>Gets the type from which the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> directly inherits.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の直接の継承元である型を取得します。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> from which the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> directly inherits, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the current <ph id="ph4">&lt;see langword="Type" /&gt;</ph> represents the <ph id="ph5">&lt;see cref="T:System.Object" /&gt;</ph> class or an interface.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の直接の継承元の <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。現在の <ph id="ph3">&lt;see langword="null" /&gt;</ph> が <ph id="ph4">&lt;see langword="Type" /&gt;</ph> クラスまたはインターフェイスを表す場合は <ph id="ph5">&lt;see cref="T:System.Object" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The base type is the type from which the current type directly inherits.</source>
          <target state="translated">基本型は、現在の型の直接の継承元となる型です。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source><ph id="ph1">&lt;xref:System.Object&gt;</ph> is the only type that does not have a base type, therefore <ph id="ph2">`null`</ph> is returned as the base type of <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object&gt;</ph> したがって、基本データ型を持たない唯一の種類は、<ph id="ph2">`null`</ph>の基本型として返される<ph id="ph3">&lt;xref:System.Object&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>Interfaces inherit from zero or more base interfaces; therefore, this property returns <ph id="ph1">`null`</ph> if the <ph id="ph2">`Type`</ph> object represents an interface.</source>
          <target state="translated">インターフェイスは、0 個以上の基底インターフェイスから継承します。したがって、このプロパティが返されます<ph id="ph1">`null`</ph>場合、<ph id="ph2">`Type`</ph>オブジェクトは、インターフェイスを表します。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The base interfaces can be determined with <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>.</source>
          <target state="translated">基本インターフェイスを確定できる<ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, the base type reflects the generic arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>構築されたジェネリック型を表し、基本データ型はジェネリック引数を反映します。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>For example, consider the following declarations:</source>
          <target state="translated">たとえば、次のような宣言があるとします。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>For the constructed type <ph id="ph1">`C&lt;int&gt;`</ph> (<ph id="ph2">`C(Of Integer)`</ph> in Visual Basic), the <ph id="ph3">&lt;xref:System.Type.BaseType%2A&gt;</ph> property returns <ph id="ph4">`B&lt;int&gt;`</ph>.</source>
          <target state="translated">構築型<ph id="ph1">`C&lt;int&gt;`</ph>(<ph id="ph2">`C(Of Integer)`</ph> Visual Basic で)、<ph id="ph3">&lt;xref:System.Type.BaseType%2A&gt;</ph>プロパティから返される<ph id="ph4">`B&lt;int&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type definition, <ph id="ph2">&lt;xref:System.Type.BaseType%2A&gt;</ph> returns the class constraint, that is, the class the type parameter must inherit.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>、ジェネリック型定義の型パラメーターを表す<ph id="ph2">&lt;xref:System.Type.BaseType%2A&gt;</ph>クラスの制約、型パラメーターを継承する必要があります、クラスを返します。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>If there is no class constraint, <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> returns <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">クラスの制約がない場合は<ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph>返します<ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>This property is read-only.</source>
          <target state="translated">このプロパティは読み取り専用です。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The following example demonstrates using the <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> property.</source>
          <target state="translated">次の例では、使用方法を示します、<ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly.</source>
          <target state="translated">次の例では、再帰を使用して、アセンブリで見つかった各クラスの完全な継承階層を一覧表示します。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The example defines a class named <ph id="ph1">`C`</ph> that derives from a class named <ph id="ph2">`B`</ph>, which, in turn, derives from a class named <ph id="ph3">`A`</ph>.</source>
          <target state="translated">例では、という名前のクラスを定義する<ph id="ph1">`C`</ph>という名前のクラスから派生した<ph id="ph2">`B`</ph>であり、という名前のクラスから派生、<ph id="ph3">`A`</ph>です。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="P:System.Type.ContainsGenericParameters">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object has type parameters that have not been replaced by specific types.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトが特定の型で置き換えられていない型パラメーターを持っているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> オブジェクト自体がジェネリック型パラメーターであるか、特定の型が指定されていない型パラメーターを持っている場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。そうでない場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</source>
          <target state="translated">型のインスタンスを作成するために必要がありますいないジェネリック型定義または型自体の外側のジェネリック型、または要素の中で、型の型引数でオープン構築型。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</source>
          <target state="translated">言い換えると、別の方法は、再帰的を調べたときに、型はジェネリック型パラメーターを含める必要がありますではありません。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>Since types can be arbitrarily complex, making this determination is difficult.</source>
          <target state="translated">型指定できますが、任意の複雑なので、この決定を行うは困難です。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>For convenience and to reduce the chance of error, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</source>
          <target state="translated">便宜上、およびエラーの可能性を低減する、<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>プロパティは、インスタンス化できる、クローズ構築型を区別するために標準的な方法を提供およびオープン構築型で、このことはできません。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>If the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, the type cannot be instantiated.</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>プロパティから返される<ph id="ph2">`true`</ph>型がインスタンス化することはできません。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property searches recursively for type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>プロパティが型パラメーターに対して再帰的を検索します。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>For example, it returns <ph id="ph1">`true`</ph> for an array whose elements are type <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> in Visual Basic), even though the array is not itself generic.</source>
          <target state="translated">たとえばを返します<ph id="ph1">`true`</ph>、要素が配列型の<ph id="ph2">`A&lt;T&gt;`</ph>(<ph id="ph3">`A(Of T)`</ph> Visual Basic で)、配列は汎用の自体がないにもかかわらず、します。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>Contrast this with the behavior of the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property, which returns <ph id="ph2">`false`</ph> for arrays.</source>
          <target state="translated">動作と違って、<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>を返すプロパティ<ph id="ph2">`false`</ph>の配列。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>For a set of example classes and a table showing the values of the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property, see <ph id="ph2">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</source>
          <target state="translated">一連の例のクラスとの値を示す表に、<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>プロパティを参照してください<ph id="ph2">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class.</source>
          <target state="translated">次の例では、次の 2 つの型パラメーターを持つジェネリック クラスを定義し、最初のクラスから派生する 2 番目のジェネリック クラスを定義します。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The derived class's base class has two type arguments: the first is <ph id="ph1">&lt;xref:System.Int32&gt;</ph> and the second is a type parameter of the derived type.</source>
          <target state="translated">派生クラスの基本クラスは、次の 2 つの型引数を持つ: 1 つは<ph id="ph1">&lt;xref:System.Int32&gt;</ph>2 番目の派生型の型パラメーターです。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The example displays information about these generic classes, including the positions reported by the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property.</source>
          <target state="translated">によって報告この例では、これらのジェネリック クラスに関する情報を表示、位置を含む、<ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="P:System.Type.DeclaringMethod">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that represents the declaring method, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter of a generic method.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> がジェネリック メソッドの型パラメーターを表している場合に、宣言するメソッドを表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> を取得します。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>If the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter of a generic method, a <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that represents declaring method; otherwise, <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> がジェネリック メソッドの型パラメーターを表している場合は、宣言メソッドを表す <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The declaring method is a generic method definition.</source>
          <target state="translated">宣言するメソッドは、ジェネリック メソッド定義です。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>That is, if <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> does not return <ph id="ph2">`null`</ph>, then <ph id="ph3">`DeclaringMethod.IsGenericMethodDefinition`</ph> returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">つまり場合、<ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>返さない<ph id="ph2">`null`</ph>、し<ph id="ph3">`DeclaringMethod.IsGenericMethodDefinition`</ph>を返します<ph id="ph4">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>プロパティは、ジェネリック型定義またはジェネリック型パラメーターが最初に定義されたジェネリック メソッド定義を識別します。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>プロパティから返される、 <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>、その<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>を表し、ジェネリック メソッド定義では、現在<ph id="ph4">&lt;xref:System.Type&gt;</ph>オブジェクトはそのジェネリック メソッド定義の型パラメーターを表します。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>プロパティから返される<ph id="ph2">`null`</ph>、<ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>プロパティは常に返します、<ph id="ph4">&lt;xref:System.Type&gt;</ph>ジェネリック型定義、および現在を表すオブジェクト<ph id="ph5">&lt;xref:System.Type&gt;</ph>オブジェクトはそのジェネリック型定義の型パラメーターを表します。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>Getting the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property on a type whose <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph3">`false`</ph> throws an <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">取得、<ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>型のプロパティが<ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>プロパティは<ph id="ph3">`false`</ph>をスロー、<ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> that is returned by the <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property is either a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> in the case of a generic method, or a <ph id="ph4">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> in the case of a generic constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>によって返される、<ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>プロパティが、<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>ジェネリック メソッドの場合、または<ph id="ph4">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>ジェネリック コンス トラクターの場合。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>In the .NET Framework version 2.0, generic constructors are not supported.</source>
          <target state="translated">.NET framework version 2.0 では、ジェネリック コンス トラクターはサポートされていません。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> プロパティの解説を参照してください。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method.</source>
          <target state="translated">次のコード例をジェネリック メソッドがあります、メソッドに型引数が割り当てられ、結果の構築されたジェネリック メソッドを呼び出してクラスを定義します。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>It also displays information about the generic method definition and the constructed method.</source>
          <target state="translated">ジェネリック メソッド定義と構築されるメソッドに関する情報も表示されます。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>When displaying information about the type parameters of the generic method definition, in the <ph id="ph1">`DisplayGenericMethodInfo`</ph> method, the example code shows the value of the <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property for the method's generic type parameter.</source>
          <target state="translated">ジェネリック メソッド定義の型のパラメーターに関する情報を表示するときに、<ph id="ph1">`DisplayGenericMethodInfo`</ph>メソッド、コード例は、の値を示しています、<ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>メソッドのジェネリック型パラメーターのプロパティです。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="P:System.Type.DeclaringType">
          <source>Gets the type that declares the current nested type or generic type parameter.</source>
          <target state="translated">現在の入れ子にされた型またはジェネリック型パラメーターを宣言する型を取得します。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">現在の型が入れ子にされた型である場合、包含する型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクト。現在の型がジェネリック型の型パラメーターである場合、ジェネリック型定義。現在の型がジェネリック メソッドの型パラメーターである場合、ジェネリック メソッドを宣言する型。それ以外の場合、<ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic type, this property returns the generic type definition.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクトがジェネリック型の型パラメーターを表す、このプロパティは、ジェネリック型定義を返します。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクトがジェネリック メソッドの型パラメーターを表す、このプロパティは、ジェネリック メソッド定義を含む型を返します。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the type is generic, the generic type definition is returned.</source>
          <target state="translated">型がジェネリックの場合、ジェネリック型定義が返されます。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>That is, the following code returns the generic type definition of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> generic class, which contains the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.ConvertAll%2A&gt;</ph> generic method:</source>
          <target state="translated">つまり、次のコードがジェネリック型の定義を返します、<ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>ジェネリック クラスは、含まれています、<ph id="ph2">&lt;xref:System.Collections.Generic.List%601.ConvertAll%2A&gt;</ph>ジェネリック メソッド。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, the <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>のジェネリック型またはジェネリック メソッド定義の型パラメーターを表す、<ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>と<ph id="ph3">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>プロパティを識別、ジェネリック型定義またはジェネリック メソッド定義のジェネリック型パラメーターが最初に定義されています。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>プロパティから返される、 <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>、その<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>を表し、ジェネリック メソッド定義では、現在<ph id="ph4">&lt;xref:System.Type&gt;</ph>オブジェクトはそのジェネリック メソッド定義の型パラメーターを表します。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>プロパティから返される<ph id="ph2">`null`</ph>、<ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>プロパティは常に返します、<ph id="ph4">&lt;xref:System.Type&gt;</ph>ジェネリック型定義、および現在を表すオブジェクト<ph id="ph5">&lt;xref:System.Type&gt;</ph>オブジェクトはそのジェネリック型定義の型パラメーターを表します。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>Getting the <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property on a type whose <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph3">`false`</ph> throws an <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">取得、<ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>型のプロパティが<ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>プロパティは<ph id="ph3">`false`</ph>をスロー、<ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>This example displays the declaring type of a method in a derived class.</source>
          <target state="translated">この例では、派生クラスでメソッドの宣言する型を表示します。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="P:System.Type.DefaultBinder">
          <source>Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">既定のバインダーへの参照を取得します。このバインダーは、<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph> によって呼び出される適切なメンバーを選択するための内部規則を実装します。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>A reference to the default binder used by the system.</source>
          <target state="translated">システムで使用される既定のバインダーへの参照。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</source>
          <target state="translated">共通言語ランタイムに用意されている既定のバインダーは、非常に特殊な状況がすべてに該当します。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <ph id="ph1">&lt;xref:System.Reflection.Binder&gt;</ph> class and pass an instance of that type using the <ph id="ph2">`binder`</ph> parameter of one of the <ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> overloads.</source>
          <target state="translated">バインダー、指定された既定のバインダーの内容と異なる次のようにルールを定義する必要がある場合、派生型から、<ph id="ph1">&lt;xref:System.Reflection.Binder&gt;</ph>クラスし、を使用してその型のインスタンスを渡す、<ph id="ph2">`binder`</ph>のいずれかのパラメーター、<ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>オーバー ロードします。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Reflection models the accessibility rules of the common type system.</source>
          <target state="translated">リフレクションには、共通型システムのアクセシビリティ規則がモデル化します。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</source>
          <target state="translated">たとえば、呼び出し元が、同じアセンブリ内にある場合は、呼び出し元は、必要はありません特殊なアクセス許可内部メンバーの。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Otherwise, the caller needs <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">それ以外の場合、呼び出し元が必要な<ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>This is consistent with lookup of members that are protected, private, and so on.</source>
          <target state="translated">これは、保護されているメンバーの参照と一貫性のある、プライベート、およびなどです。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The general principle is that <ph id="ph1">&lt;xref:System.Reflection.Binder.ChangeType%2A&gt;</ph> should perform only widening conversions, which never lose data.</source>
          <target state="translated">一般的な方針は<ph id="ph1">&lt;xref:System.Reflection.Binder.ChangeType%2A&gt;</ph>拡大変換で、データが失われることのみを実行する必要があります。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</source>
          <target state="translated">拡大変換の例は、64 ビット符号付き整数である値を 32 ビット符号付き整数である値を変換しています。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>This is distinguished from a narrowing conversion, which may lose data.</source>
          <target state="translated">これは、データが失われる可能性があります、縮小変換と区別されます。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</source>
          <target state="translated">縮小変換の例は、64 ビット符号付き整数を変換する 32 ビット符号付き整数には。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The following table lists the conversions supported by the default binder.</source>
          <target state="translated">次の表では、既定のバインダーがサポートする変換が一覧表示します。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Source Type</source>
          <target state="translated">ソースの種類</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Target Type</source>
          <target state="translated">ターゲットの種類</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Any type</source>
          <target state="translated">任意の型</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Its base type.</source>
          <target state="translated">その基本型です。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Any type</source>
          <target state="translated">任意の型</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The interface it implements.</source>
          <target state="translated">実装するインターフェイスです。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Char</source>
          <target state="translated">Char</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Unt16, UInt32, Int32, UInt64, Int64, Single, Double</source>
          <target state="translated">Unt16、UInt32、Int32、UInt64、Int64 を Single、Double</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Byte</source>
          <target state="translated">Byte</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</source>
          <target state="translated">Char、Unt16、Int16、UInt32、Int32、UInt64、Int64、Single、Double</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>SByte</source>
          <target state="translated">SByte</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int16, Int32, Int64, Single, Double</source>
          <target state="translated">Int16、Int32、Int64、Single、Double</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt16</source>
          <target state="translated">UInt16</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt32, Int32, UInt64, Int64, Single, Double</source>
          <target state="translated">UInt32、Int32、UInt64、Int64、Single、Double</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int16</source>
          <target state="translated">Int16</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int32, Int64, Single, Double</source>
          <target state="translated">Int32、Int64、Single、Double</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt32</source>
          <target state="translated">UInt32</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt64, Int64, Single, Double</source>
          <target state="translated">UInt64、Int64、Single、Double</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int32</source>
          <target state="translated">Int32</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int64, Single, Double</source>
          <target state="translated">Int64、Single、Double</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt64</source>
          <target state="translated">UInt64</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Single, Double</source>
          <target state="translated">Single、Double</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int64</source>
          <target state="translated">Int64</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Single, Double</source>
          <target state="translated">Single、Double</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Single</source>
          <target state="translated">Single</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Double</source>
          <target state="translated">倍精度浮動小数点型</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Non-reference</source>
          <target state="translated">非参照</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>By-reference.</source>
          <target state="translated">参照渡しされます。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The following example gets the default binder from the <ph id="ph1">`DefaultBinder`</ph> property, and invokes a member of MyClass by passing the <ph id="ph2">`DefaultBinder`</ph> value as a parameter to <ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>.</source>
          <target state="translated">次の例から既定のバインダーを取得する、<ph id="ph1">`DefaultBinder`</ph>プロパティ、MyClass のメンバーを渡すことによって呼び出されます、<ph id="ph2">`DefaultBinder`</ph>へのパラメーターとして値<ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="F:System.Type.Delimiter">
          <source>Separates names in the namespace of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の名前空間で、複数の名前を区切ります。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="F:System.Type.Delimiter">
          <source>This field is read-only.</source>
          <target state="translated">このフィールドは読み取り専用です。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="F:System.Type.EmptyTypes">
          <source>Represents an empty array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列を表します。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="F:System.Type.EmptyTypes">
          <source>This field is read-only.</source>
          <target state="translated">このフィールドは読み取り専用です。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.EmptyTypes">
          <source>The following code example shows the <ph id="ph1">`EmptyTypes`</ph> field used in one of the <ph id="ph2">`GetConstructor`</ph> methods to get a constructor that takes no parameters.</source>
          <target state="translated">次のコード例は、<ph id="ph1">`EmptyTypes`</ph>のいずれかで使用されるフィールド、<ph id="ph2">`GetConstructor`</ph>メソッド パラメーターをとらないコンス トラクターを取得します。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Determines if the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is the same as the underlying system type of the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の基になるシステム型が、指定した <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> または <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> の基になるシステム型と同じかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>The object whose underlying system type is to be compared with the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">基になるシステム型が、現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の基になるシステム型との比較対象になるオブジェクト。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>For the comparison to succeed, <bpt id="p1">&lt;c&gt;</bpt>o<ept id="p1">&lt;/c&gt;</ept> must be able to be cast or converted to an object of type   <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">比較を成功させるには、<bpt id="p1">&lt;c&gt;</bpt>o<ept id="p1">&lt;/c&gt;</ept> をキャストまたは型 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のオブジェクトに変換できる必要があります。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>Determines if the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is the same as the underlying system type of the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの基になるシステム型が、指定した <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> の基になるシステム型と同じかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the underlying system type of <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is the same as the underlying system type of the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="o" /&gt;</ph> の基になるシステム型が現在の <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> の基になるシステム型と同じである場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>This method also returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if: .</source>
          <target state="translated">次の場合にも、このメソッドは <ph id="ph1">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> cannot be cast or converted to a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> をキャストまたは <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトに変換できない。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">このメソッドは、<ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> をオーバーライドします。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>It casts <ph id="ph1">`o`</ph> to an object of type <ph id="ph2">&lt;xref:System.Type&gt;</ph> and calls the <ph id="ph3">&lt;xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">キャストして<ph id="ph1">`o`</ph>型のオブジェクトに<ph id="ph2">&lt;xref:System.Type&gt;</ph>を呼び出すと、<ph id="ph3">&lt;xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Type.Equals%28System.Object%29&gt;</ph> to compare various <ph id="ph2">&lt;xref:System.Type&gt;</ph> object instances with various <ph id="ph3">&lt;xref:System.Object&gt;</ph> instances.</source>
          <target state="translated">次の例で<ph id="ph1">&lt;xref:System.Type.Equals%28System.Object%29&gt;</ph>さまざまなを比較する<ph id="ph2">&lt;xref:System.Type&gt;</ph>オブジェクトと各種インスタンス<ph id="ph3">&lt;xref:System.Object&gt;</ph>インスタンス。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>Two things are particularly worth noting about the example:</source>
          <target state="translated">次の 2 つは、例に関する特に特にです。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>The comparison of a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents an integer with a <ph id="ph2">&lt;xref:System.Reflection.TypeInfo&gt;</ph> object that represents an integer return <ph id="ph3">`true`</ph> because <ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph> is derived from <ph id="ph5">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">比較した結果、<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表す整数を表すオブジェクト、<ph id="ph2">&lt;xref:System.Reflection.TypeInfo&gt;</ph>戻り値の整数を表すオブジェクト<ph id="ph3">`true`</ph>ため<ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph>から派生した<ph id="ph5">&lt;xref:System.Type&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>The comparison of a  <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents a <ph id="ph2">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> object (an open generic type) with a <ph id="ph3">`List(Of String)`</ph> object (a closed generic type) returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">比較した結果、<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表すオブジェクト、<ph id="ph2">&lt;xref:System.Collections.Generic.IList%601&gt;</ph>オブジェクト (オープン ジェネリック型)、<ph id="ph3">`List(Of String)`</ph>オブジェクト (クローズ ジェネリック型) を返します<ph id="ph4">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Type)">
          <source>The object whose underlying system type is to be compared with the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">基になるシステム型が、現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の基になるシステム型との比較対象になるオブジェクト。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Type)">
          <source>Determines if the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is the same as the underlying system type of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の基になるシステム型が、指定した <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> の基になるシステム型と同じかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the underlying system type of <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is the same as the underlying system type of the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="o" /&gt;</ph> の基になるシステム型が現在の <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> の基になるシステム型と同じである場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Type)">
          <source>The following example uses <ph id="ph1">`Equals`</ph> to compare two types.</source>
          <target state="translated">次の例で<ph id="ph1">`Equals`</ph>2 つの種類を比較します。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="F:System.Type.FilterAttribute">
          <source>Represents the member filter used on attributes.</source>
          <target state="translated">属性に適用するメンバー フィルターを表します。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="F:System.Type.FilterAttribute">
          <source>This field is read-only.</source>
          <target state="translated">このフィールドは読み取り専用です。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
          <target state="translated">このフィールドによって使用されるデリゲートへの参照を保持する、<ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">このデリゲートによってカプセル化されるメソッドが 2 つのパラメーターを受け取る: 1 つは、<ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph>オブジェクトと、2 つ目は、<ph id="ph2">`Object`</ph>です。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">メソッドを決定するかどうか、<ph id="ph1">`MemberInfo`</ph>オブジェクトで指定された条件に一致する、<ph id="ph2">`Object`</ph>です。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The <ph id="ph1">`Object`</ph> may be assigned the value of any one of the fields on the classes <ph id="ph2">&lt;xref:System.Reflection.FieldAttributes&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, or <ph id="ph4">&lt;xref:System.Reflection.MethodImplAttributes&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`Object`</ph>クラスのフィールドのいずれかの値を割り当てることができます<ph id="ph2">&lt;xref:System.Reflection.FieldAttributes&gt;</ph>、 <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>、または<ph id="ph4">&lt;xref:System.Reflection.MethodImplAttributes&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>For example, the <ph id="ph1">`Object`</ph> can be assigned the value of a field from <ph id="ph2">`FieldAttributes`</ph> such as Public.</source>
          <target state="translated">たとえば、<ph id="ph1">`Object`</ph>からフィールドの値を割り当てることができます<ph id="ph2">`FieldAttributes`</ph>Public などです。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>In that case, when the <ph id="ph1">`FilterAttribute`</ph> delegate is invoked, it will return <ph id="ph2">`true`</ph> only if the method represented by the <ph id="ph3">`MemberInfo`</ph> object is decorated with the public field attribute in metadata.</source>
          <target state="translated">その場合は、ときに、<ph id="ph1">`FilterAttribute`</ph>デリゲートが呼び出されるが返されます<ph id="ph2">`true`</ph>によって表されるメソッドの場合にのみ、<ph id="ph3">`MemberInfo`</ph>オブジェクトは、メタデータ内のパブリック フィールドの属性で装飾されてです。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The following example gets the <ph id="ph1">`FilterAttribute`</ph> delegate, passes it as a parameter to the <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method, and displays the specified members and their attributes.</source>
          <target state="translated">次の例を取得、<ph id="ph1">`FilterAttribute`</ph>デリゲートへのパラメーターとして渡す、<ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph>メソッドを指定したメンバーとその属性が表示されます。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="F:System.Type.FilterName">
          <source>Represents the case-sensitive member filter used on names.</source>
          <target state="translated">名前に適用され、大文字と小文字を区別するメンバー フィルターを表します。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="F:System.Type.FilterName">
          <source>This field is read-only.</source>
          <target state="translated">このフィールドは読み取り専用です。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
          <target state="translated">このフィールドによって使用されるデリゲートへの参照を保持する、<ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">このデリゲートによってカプセル化されるメソッドが 2 つのパラメーターを受け取る: 1 つは、<ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph>オブジェクトと、2 つ目は、<ph id="ph2">`Object`</ph>です。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">メソッドを決定するかどうか、<ph id="ph1">`MemberInfo`</ph>オブジェクトで指定された条件に一致する、<ph id="ph2">`Object`</ph>です。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The <ph id="ph1">`Object`</ph> is assigned a string value, which may include a trailing "*" wildcard character.</source>
          <target state="translated"><ph id="ph1">`Object`</ph>末尾には、文字列値が割り当てられている"*"のワイルドカード文字です。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>Only wildcard end string matching is supported.</source>
          <target state="translated">のみ終了文字列ワイルドカードはサポートされます。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>For example, the <ph id="ph1">`Object`</ph> may be assigned the value "Byte*".</source>
          <target state="translated">たとえば、 <ph id="ph1">`Object`</ph> 「バイト *」値を割り当てることができます。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>In that case, when the <ph id="ph1">`FilterName`</ph> delegate is invoked, it will return <ph id="ph2">`true`</ph> only if the method represented by the <ph id="ph3">`MemberInfo`</ph> object has a name that begins with "Byte".</source>
          <target state="translated">その場合は、<ph id="ph1">`FilterName`</ph>デリゲートが呼び出されるが返されます<ph id="ph2">`true`</ph>によって表されるメソッドの場合にのみ、 <ph id="ph3">`MemberInfo`</ph> 「バイト」で始まる名前が付きます。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The following code example gets the methods associated with the user-defined <ph id="ph1">`Application`</ph> type.</source>
          <target state="translated">次のコード例は、ユーザー定義に関連付けられたメソッドを取得<ph id="ph1">`Application`</ph>型です。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="F:System.Type.FilterNameIgnoreCase">
          <source>Represents the case-insensitive member filter used on names.</source>
          <target state="translated">名前に適用され、大文字と小文字を区別しないメンバー フィルターを表します。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="F:System.Type.FilterNameIgnoreCase">
          <source>This field is read-only.</source>
          <target state="translated">このフィールドは読み取り専用です。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
          <target state="translated">このフィールドによって使用されるデリゲートへの参照を保持する、<ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">このデリゲートによってカプセル化されるメソッドが 2 つのパラメーターを受け取る: 1 つは、<ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph>オブジェクトと、2 つ目は、<ph id="ph2">`Object`</ph>です。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">メソッドを決定するかどうか、<ph id="ph1">`MemberInfo`</ph>オブジェクトで指定された条件に一致する、<ph id="ph2">`Object`</ph>です。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The <ph id="ph1">`Object`</ph> is assigned a string value, which may include a trailing "*" wildcard character.</source>
          <target state="translated"><ph id="ph1">`Object`</ph>末尾には、文字列値が割り当てられている"*"のワイルドカード文字です。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>Only wildcard end string matching is supported.</source>
          <target state="translated">のみ終了文字列ワイルドカードはサポートされます。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>For example, the <ph id="ph1">`Object`</ph> may be assigned the value "ByTe*".</source>
          <target state="translated">たとえば、 <ph id="ph1">`Object`</ph> 「バイト *」値を割り当てることができます。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>In that case, when the <ph id="ph1">`FilterName`</ph> delegate is invoked, it will return true only if the method represented by the <ph id="ph2">`MemberInfo`</ph> object has a name that begins with "byte", ignoring case.</source>
          <target state="translated">その場合は、<ph id="ph1">`FilterName`</ph>デリゲートが呼び出される、true を返しますのみ、メソッドがによって表されるかどうか、<ph id="ph2">`MemberInfo`</ph>オブジェクトが「バイト」、大文字と小文字で始まる名前。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The following example gets the <ph id="ph1">`MemberFilter`</ph> delegate, passes it as a parameter to the <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method, and displays the methods and their attributes of the <ph id="ph3">`String`</ph> class that begin with the letter "c", disregarding the case.</source>
          <target state="translated">次の例を取得、<ph id="ph1">`MemberFilter`</ph>デリゲートへのパラメーターとして渡す、<ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph>メソッド、メソッドとその属性の表示、<ph id="ph3">`String`</ph>大文字と小文字を無視すると、文字"c"で始まるクラスです。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The delegate that compares the interfaces against <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">インターフェイスを <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept> と比較するデリゲート。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The search criteria that determines whether an interface should be included in the returned array.</source>
          <target state="translated">返される配列に、検出したインターフェイスを含めるかどうかを判断する検索条件。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing a filtered list of interfaces implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> によって実装または継承されているインターフェイスのフィルター適用済みリストを表す、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列を返します。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing a filtered list of the interfaces implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or an empty array of type <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> if no interfaces matching the filter are implemented or inherited by the current <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> によって実装または継承されたインターフェイスのフィルター処理されたリストを表している <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。フィルターに一致するインターフェイスが現在の <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> によって実装または継承されていない場合は、型 <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph> の空の配列。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">このメソッドは、派生クラスでオーバーライドできます。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType&gt;</ph> delegates supplied by the <ph id="ph3">&lt;xref:System.Reflection.Module?displayProperty=nameWithType&gt;</ph> class may also be used, in lieu of the <ph id="ph4">&lt;xref:System.Reflection.TypeFilter?displayProperty=nameWithType&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType&gt;</ph>によって提供されるデリゲート、<ph id="ph3">&lt;xref:System.Reflection.Module?displayProperty=nameWithType&gt;</ph>の lieu で、クラスも使用できます、<ph id="ph4">&lt;xref:System.Reflection.TypeFilter?displayProperty=nameWithType&gt;</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</source>
          <target state="translated">基底クラスまたはこのクラス自体で宣言されているかどうか、検索中にこのクラスで実装されたインターフェイスのすべてと見なされます。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</source>
          <target state="translated">このメソッドは、これらのインターフェイスを実装の各クラスは、すべての一致するだけでなく、一致するインターフェイスの各インターフェイスを返す、基本クラスの階層構造を検索 (つまり、一致するインターフェイスの推移的閉包が返されます)。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>No duplicate interfaces are returned.</source>
          <target state="translated">重複するインターフェイスが返されません。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>のジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>型パラメーターに対する制約で宣言されているすべてのインターフェイスを検索し、インターフェイスによって継承されたすべてのインターフェイスの制約内で宣言します。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type argument of a generic type, <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> searches all the interfaces implemented by the type, whether or not they match constraints.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>がジェネリック型の引数の型を表す<ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>制約に一致するかどうか、型によって実装されたすべてのインターフェイスを検索します。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> can return generic interfaces, even on types that are not generic.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> ジェネリックな型の場合でも、ジェネリック インターフェイスを返すことができます。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>For example, a nongeneric type might implement <ph id="ph1">`IEnumerable&lt;int&gt;`</ph> (<ph id="ph2">`IEnumerable(Of Integer)`</ph> in Visual Basic).</source>
          <target state="translated">たとえば、非ジェネリック型を実装<ph id="ph1">`IEnumerable&lt;int&gt;`</ph>(<ph id="ph2">`IEnumerable(Of Integer)`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</source>
          <target state="translated">次の例では、指定されたインターフェイスが実装されているまたは、指定した型によって継承され、インターフェイス名を表示しを検索します。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>A static initializer is invoked and throws an exception.</source>
          <target state="translated">静的初期化子が呼び出され、例外をスローします。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>An object that indicates the type of member to search for.</source>
          <target state="translated">検索するメンバーの型を示すオブジェクト。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The delegate that does the comparisons, returning <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the member currently being inspected matches the <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept> and <ph id="ph2">&lt;see langword="false" /&gt;</ph> otherwise.</source>
          <target state="translated">比較を実行して、現在調べているメンバーが <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept> に一致する場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph> を返し、それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph> を返すデリゲート。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>You can use the <ph id="ph1">&lt;see langword="FilterAttribute" /&gt;</ph>, <ph id="ph2">&lt;see langword="FilterName" /&gt;</ph>, and <ph id="ph3">&lt;see langword="FilterNameIgnoreCase" /&gt;</ph> delegates supplied by this class.</source>
          <target state="translated">このクラスで提供される <ph id="ph1">&lt;see langword="FilterAttribute" /&gt;</ph> デリゲート、<ph id="ph2">&lt;see langword="FilterName" /&gt;</ph> デリゲート、および <ph id="ph3">&lt;see langword="FilterNameIgnoreCase" /&gt;</ph> デリゲートを使用できます。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The first uses the fields of <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>, <ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph>, and <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> as search criteria, and the other two delegates use <ph id="ph4">&lt;see langword="String" /&gt;</ph> objects as the search criteria.</source>
          <target state="translated">1 つ目のデリゲートは、検索条件として <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>、<ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph>、<ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> の各フィールドを使用し、他の 2 つのデリゲートは、検索条件として <ph id="ph4">&lt;see langword="String" /&gt;</ph> オブジェクトを使用します。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The search criteria that determines whether a member is returned in the array of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> オブジェクトの配列でメンバーが返されたかどうかを判断する検索条件。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The fields of <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>, <ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph>, and <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> can be used in conjunction with the <ph id="ph4">&lt;see langword="FilterAttribute" /&gt;</ph> delegate supplied by this class.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>、<ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph>、<ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> の各フィールドは、このクラスで提供される <ph id="ph4">&lt;see langword="FilterAttribute" /&gt;</ph> デリゲートと組み合わせて使用できます。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Returns a filtered array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects of the specified member type.</source>
          <target state="translated">指定したメンバー型の <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> オブジェクトの配列にフィルターを適用して返します。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>A filtered array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects of the specified member type.</source>
          <target state="translated">指定したメンバー型の <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> オブジェクトのフィルター適用済みの配列。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have members of type <ph id="ph3">&lt;paramref name="memberType" /&gt;</ph> that match the filter criteria.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> に、フィルター条件に一致する <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 型のメンバーが存在しない場合は、<ph id="ph3">&lt;paramref name="memberType" /&gt;</ph> 型の空の配列。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">このメソッドは、派生クラスでオーバーライドできます。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.Instance`</ph> to include instance members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Instance`</ph>検索でインスタンス メンバーを含めるようにします。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.Static`</ph> to include static members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Static`</ph>検索に静的メンバーを含める。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック メンバーを含める。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索に含める非パブリック メンバー (つまり、プライベート、内部、およびプロテクト メンバー)、します。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されたメンバーのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたメンバーされません。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Valid values for <ph id="ph1">&lt;xref:System.Type.MemberType%2A&gt;</ph> are defined in <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>.</source>
          <target state="translated">有効な値<ph id="ph1">&lt;xref:System.Type.MemberType%2A&gt;</ph>で定義された<ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>If no such members are found, an empty array is returned.</source>
          <target state="translated">このようなメンバーが見つからない場合は、空の配列が返されます。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>To get the class initializer (.cctor) using this method, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">このメソッドを使用してクラス初期化子 (.cctor) を取得する必要がありますを指定する<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">使用して、クラス初期化子を取得することも、<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type or generic method, <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> processes any members declared by the class constraint and the interface constraints of the type parameter.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>ジェネリック型またはジェネリック メソッドの型パラメーターを表す<ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph>クラス制約と型パラメーターのインターフェイスの制約で宣言された任意のメンバーを処理します。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</source>
          <target state="translated">次の例では、指定した検索条件に一致するクラス内のすべてのメンバーを検索し、一致するメンバーを表示します。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="P:System.Type.FullName">
          <source>Gets the fully qualified name of the type, including its namespace but not its assembly.</source>
          <target state="translated">型の完全修飾名を取得します。その名前空間を含みますが、アセンブリは含みません。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The fully qualified name of the type, including its namespace but not its assembly; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the current instance represents a generic type parameter, an array type, pointer type, or <ph id="ph2">&lt;see langword="byref" /&gt;</ph> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</source>
          <target state="translated">型の完全修飾名で、名前空間を含むが、アセンブリは含まないもの。現在のインスタンスが、ジェネリック型パラメーター、配列型、ポインター型、または型パラメーターに基づく<ph id="ph1">&lt;see langword="null" /&gt;</ph> 型、またはジェネリック型定義ではないが未解決の型パラメーターを含むジェネリック型を表す場合は、<ph id="ph2">&lt;see langword="byref" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>For example, the fully qualified name of the <ph id="ph1">&lt;xref:System.String&gt;</ph> type is <ph id="ph2">`System.String`</ph>.</source>
          <target state="translated">たとえば、完全修飾名の<ph id="ph1">&lt;xref:System.String&gt;</ph>型は<ph id="ph2">`System.String`</ph>します。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>Contrast this with the assembly-qualified name returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, which consists of the full name plus the full assembly name.</source>
          <target state="translated">これによって返されるアセンブリ修飾名に対し、<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>プロパティで、完全な名前と完全なアセンブリ名で構成されます。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>If the current type represents a closed generic type, the type arguments in the string returned by the <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</source>
          <target state="translated">文字列内の型引数がによって返される現在の型は、クローズ ジェネリック型を表している場合、<ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph>プロパティは、ジェネリック型パラメーター自体の文字列表現が、完全で修飾されていない場合でも、アセンブリの完全名で修飾されてアセンブリ名。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</source>
          <target state="translated">次の例は、ジェネリック型定義を表す型とクローズ ジェネリック型を表す 1 つに対する FullName プロパティの違いを示しています。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>This property returns <ph id="ph1">`null`</ph> if:</source>
          <target state="translated">このプロパティを返します<ph id="ph1">`null`</ph>場合。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic type.</source>
          <target state="translated">現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクトがジェネリック型の型パラメーターを表します。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example retrieves the type parameter of the <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type and attempts to display its <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> property.</source>
          <target state="translated">次の例は、の型パラメーターを取得、<ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph>表示しようと種類、<ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents an array type, a pointer  type, or a <ph id="ph2">`byref`</ph> type that is based on a generic type parameter.</source>
          <target state="translated">現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクトを表す配列型、ポインター型、または<ph id="ph2">`byref`</ph>型がジェネリック型パラメーターに基づいています。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example defines a generic type, <ph id="ph1">`Generictype1&lt;T&gt;`</ph>, with three methods: <ph id="ph2">`Display(T[])`</ph>, which is passed an array of type T; <ph id="ph3">`HandleT(T)`</ph>, which is passed a T object; and <ph id="ph4">`ChangeValue(ref T)`</ph>, which is passed a T object by reference.</source>
          <target state="translated">次の例は、ジェネリック型を定義<ph id="ph1">`Generictype1&lt;T&gt;`</ph>、3 つの方法で: <ph id="ph2">`Display(T[])`</ph>、渡される型 T の配列<ph id="ph3">`HandleT(T)`</ph>、T は渡されたと<ph id="ph4">`ChangeValue(ref T)`</ph>、T オブジェクト参照によって渡されます。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>Because C# and Visual Basic do not allow us to define T as a pointer in the <ph id="ph1">`HandleT`</ph> method, we have to call the <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Type&gt;</ph> object that represents the method's parameter type to create a pointer to a generic type.</source>
          <target state="translated">C# および Visual Basic が内のポインターとして T を定義することに許可されないため、<ph id="ph1">`HandleT`</ph>を呼び出すメソッドがある、<ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>メソッドを<ph id="ph3">&lt;xref:System.Type&gt;</ph>をジェネリック型へのポインターを作成するメソッドのパラメーターの型を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The output from the example shows that in all three cases, the <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> property is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">出力例をことを示しています、3 つすべてのケースで、<ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph>プロパティは<ph id="ph2">`null`</ph>します。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The current type contains generic type parameters that have not been replaced by specific types (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>), but the type is not a generic type definition (that is, the <ph id="ph3">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property returns <ph id="ph4">`false`</ph></source>
          <target state="translated">現在の型には、特定の型で置き換えられていないジェネリック型パラメーターが含まれています (つまり、<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>プロパティから返される<ph id="ph2">`true`</ph>)、型がジェネリック型定義ではないが、(つまり、<ph id="ph3">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>プロパティから返される <ph id="ph4">`false`</ph></target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>In the following example, <ph id="ph1">`Derived&lt;T&gt;`</ph> inherits from <ph id="ph2">`Base&lt;T&gt;`</ph>.</source>
          <target state="translated">次の例では、<ph id="ph1">`Derived&lt;T&gt;`</ph>から継承<ph id="ph2">`Base&lt;T&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> property obtains the  <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents the base type of <ph id="ph3">`Derived&lt;T&gt;`</ph>, and its <ph id="ph4">&lt;xref:System.Type.FullName%2A&gt;</ph> property returns <ph id="ph5">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph>プロパティは、<ph id="ph2">&lt;xref:System.Type&gt;</ph>の基本型を表すオブジェクト<ph id="ph3">`Derived&lt;T&gt;`</ph>、およびその<ph id="ph4">&lt;xref:System.Type.FullName%2A&gt;</ph>プロパティから返される<ph id="ph5">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>To get a <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> that is not <ph id="ph2">`null`</ph>, you can use the <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method to get the generic type definition, as the example illustrates.</source>
          <target state="translated">取得する、<ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph>外にある<ph id="ph2">`null`</ph>、使用することができます、<ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>例に示すように、ジェネリック型定義を取得するメソッド。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>This property is read-only.</source>
          <target state="translated">このプロパティは読み取り専用です。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example displays the full name of the specified type.</source>
          <target state="translated">次の例では、指定した型の完全名を表示します。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example compares the strings returned by the <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> method and the <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> properties.</source>
          <target state="translated">次の例で返される文字列の比較、<ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph>メソッドおよび<ph id="ph2">`Name`</ph>、 <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>、および<ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>Gets a combination of <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> flags that describe the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">現在のジェネリック型パラメーターの共変性および特殊な制約を説明する <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> フラグの組み合わせを取得します。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> values that describes the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">現在のジェネリック型パラメーターの共変性と特殊な制約を表す <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</source>
          <target state="translated">このプロパティの値には、現在のジェネリック型パラメーターは共変であるかどうかを示すフラグと特殊な制約を記述するフラグが含まれています。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType&gt;</ph> value to select the covariance flags, and use the <ph id="ph2">&lt;xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType&gt;</ph> value to select the constraint flags.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType&gt;</ph>値の共変性フラグを選択してを使用して、<ph id="ph2">&lt;xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType&gt;</ph>制約フラグを選択する値。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> プロパティの解説を参照してください。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>The following code example defines a generic type <ph id="ph1">`Test`</ph> with two type parameters that have different constraints.</source>
          <target state="translated">次のコード例は、ジェネリック型を定義<ph id="ph1">`Test`</ph>異なる制約を持つ 2 つの型パラメーターを使用します。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>When the program executes, the constraints are examined using the <ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph> method.</source>
          <target state="translated">使用して、制約を検査、プログラムを実行するとき、<ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph>プロパティおよび<ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is not a generic type parameter.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトは、ジェネリック型パラメーターではありません。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">つまり、<ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> プロパティが <ph id="ph2">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">呼び出されたメソッドは基底クラスでサポートされていません。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterPosition">
          <source>Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type parameter of a generic type or a generic method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトがジェネリック型またはジェネリック メソッドの型パラメーターを表す場合に、パラメーターを宣言したジェネリック型またはジェネリック メソッドの型パラメーター リスト内の型パラメーターの位置を取得します。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</source>
          <target state="translated">パラメーターを定義するジェネリック型またはジェネリック メソッドの型パラメーター リスト内の型パラメーターの位置。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>Position numbers begin at 0.</source>
          <target state="translated">位置の番号は 0 で始まります。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>プロパティは、型パラメーターが最初に定義されているのジェネリック型定義またはジェネリック メソッド定義のパラメーター リストで、型パラメーターの位置を返します。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type or method definition:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>プロパティは、ジェネリック型またはジェネリック メソッド定義を識別します。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>プロパティから返される、 <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>、その<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>を表し、ジェネリック メソッド定義では、現在<ph id="ph4">&lt;xref:System.Type&gt;</ph>オブジェクトはそのジェネリック メソッド定義の型パラメーターを表します。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>プロパティから返される<ph id="ph2">`null`</ph>、<ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>プロパティは常に返します、<ph id="ph4">&lt;xref:System.Type&gt;</ph>ジェネリック型定義、および現在を表すオブジェクト<ph id="ph5">&lt;xref:System.Type&gt;</ph>オブジェクトはそのジェネリック型定義の型パラメーターを表します。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>To provide the correct context for the value of the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property, it is necessary to identify the generic type or method a type parameter belongs to.</source>
          <target state="translated">値を正しいコンテキストを提供する、<ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>プロパティは、ジェネリック型またはジェネリック型パラメーターが属するメソッドを識別するために必要です。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>For example, consider the return value of the generic method <ph id="ph1">`GetSomething`</ph> in the following code:</source>
          <target state="translated">たとえば、ジェネリック メソッドの戻り値<ph id="ph1">`GetSomething`</ph>次のコードに。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The type returned by <ph id="ph1">`GetSomething`</ph> depends on the type arguments supplied to class <ph id="ph2">`A`</ph> and to <ph id="ph3">`GetSomething`</ph> itself.</source>
          <target state="translated">によって返される型<ph id="ph1">`GetSomething`</ph>クラスに指定された型引数に依存<ph id="ph2">`A`</ph>にされ、<ph id="ph3">`GetSomething`</ph>自体です。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>You can obtain a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for <ph id="ph2">`GetSomething`</ph>, and from that you can obtain the return type.</source>
          <target state="translated">取得することができます、<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>の<ph id="ph2">`GetSomething`</ph>から戻り値の型を取得したりできます。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>When you examine the type parameters of the return type, <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> returns 0 for both.</source>
          <target state="translated">戻り値の型の型パラメーターを確認する際<ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>両方に対しては 0 を返します。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The position of <ph id="ph1">`V`</ph> is 0 because <ph id="ph2">`V`</ph> is the first type parameter in the type parameter list for class <ph id="ph3">`A`</ph>.</source>
          <target state="translated">位置<ph id="ph1">`V`</ph>ためには 0<ph id="ph2">`V`</ph>クラスの型パラメーター リスト内の最初の型パラメーターは、<ph id="ph3">`A`</ph>です。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The position of <ph id="ph1">`X`</ph> is 0 because <ph id="ph2">`X`</ph> is the first type parameter in the type parameter list for <ph id="ph3">`GetSomething`</ph>.</source>
          <target state="translated">位置<ph id="ph1">`X`</ph>ためには 0 <ph id="ph2">`X`</ph> 、型パラメーター リスト内の最初の型パラメーターは、<ph id="ph3">`GetSomething`</ph>です。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>Calling the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property causes an exception if the current <ph id="ph2">&lt;xref:System.Type&gt;</ph> does not represent a type parameter.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>プロパティ例外が発生した場合、現在<ph id="ph2">&lt;xref:System.Type&gt;</ph>型パラメーターを表していません。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>When you examine the type arguments of an open constructed type, use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell which are type parameters and which are types.</source>
          <target state="translated">オープン構築型の型引数を確認する際に使用して、<ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>は型パラメーターと型を指定するプロパティです。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for a type parameter; you can then use the <ph id="ph3">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> method to obtain its position and use the <ph id="ph4">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> properties to determine the generic method or type definition that defines it.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>プロパティから返される<ph id="ph2">`true`</ph>は型パラメーターを使用してできます、<ph id="ph3">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>の位置を取得し、使用する方法、<ph id="ph4">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>と<ph id="ph5">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>の種類を定義している定義またはジェネリック メソッドを判断するプロパティです。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class.</source>
          <target state="translated">次の例では、次の 2 つの型パラメーターを持つジェネリック クラスを定義し、最初のクラスから派生する 2 番目のジェネリック クラスを定義します。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The derived class's base class has two type arguments: the first is <ph id="ph1">&lt;xref:System.Int32&gt;</ph>, and the second is a type parameter of the derived type.</source>
          <target state="translated">派生クラスの基本クラスは、次の 2 つの型引数を持つ: 1 つは<ph id="ph1">&lt;xref:System.Int32&gt;</ph>、2 つ目は、派生型の型パラメーターとします。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The example displays information about these generic classes, including the positions reported by the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property.</source>
          <target state="translated">によって報告この例では、これらのジェネリック クラスに関する情報を表示、位置を含む、<ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterPosition">
          <source>The current type does not represent a type parameter.</source>
          <target state="translated">現在の型は型パラメーターを表していません。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterPosition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">つまり、<ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> は <ph id="ph2">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="P:System.Type.GenericTypeArguments">
          <source>Gets an array of the generic type arguments for this type.</source>
          <target state="translated">この型のジェネリック型引数の配列を取得します。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>An array of the generic type arguments for this type.</source>
          <target state="translated">この型のジェネリック型引数の配列。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</source>
          <target state="translated">このプロパティは、ジェネリック型引数のみを取得します。つまり、現在の型のジェネリック型パラメーターで指定されている型。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>If the current type is a generic type definition, this property returns an empty array.</source>
          <target state="translated">現在の型がジェネリック型定義の場合は、このプロパティは空の配列を返します。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</source>
          <target state="translated">別のジェネリック型またはジェネリック メソッドでジェネリック型を使用する場合は、外側のメソッドまたは型のジェネリック型パラメーター、ジェネリック型引数のいくつかの可能性があります。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>To get the generic type parameters of a type that represents a generic type definition, use the <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">ジェネリック型定義を表す型のジェネリック型パラメーターを取得する、<ph id="ph1">&lt;xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>To get a <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> object for the current <ph id="ph2">&lt;xref:System.Type&gt;</ph> object, use the <ph id="ph3">&lt;xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType&gt;</ph> extension method.</source>
          <target state="translated">取得する、<ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph>現在のオブジェクト<ph id="ph2">&lt;xref:System.Type&gt;</ph>オブジェクトを使用して、<ph id="ph3">&lt;xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType&gt;</ph>拡張メソッド。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>Gets the number of dimensions in an array.</source>
          <target state="translated">配列の次元数を取得します。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>An integer that contains the number of dimensions in the current type.</source>
          <target state="translated">現在の型の次元数である整数。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetArrayRank">
          <source>The following example displays the number of dimensions in an array.</source>
          <target state="translated">次の例では、配列の次元数を表示します。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</source>
          <target state="translated">このメソッドの機能は、基底クラスではサポートされていないため、代わりに派生クラスで実装する必要があります。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>The current type is not an array.</source>
          <target state="translated">現在の型は配列ではありません。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Type.GetAttributeFlagsImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property and gets a bitmask indicating the attributes associated with the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">派生クラスによってオーバーライドされた場合、<ph id="ph1">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> プロパティを実装し、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> に関連付けられている属性を示すビットマスクを取得します。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Type.GetAttributeFlagsImpl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph> object representing the attribute set of the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph> の属性のセットを表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific constructor of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の特定のコンストラクターを取得します。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the desired constructor.</source>
          <target state="translated">目的のコンストラクターのパラメーターの数、順序、および型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects, to get a constructor that takes no parameters.</source>
          <target state="translated">パラメーターをとらないコンストラクターを取得するための、<ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>Such an empty array is provided by the <ph id="ph1">&lt;see langword="static" /&gt;</ph> field <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>.</source>
          <target state="translated">このような空の配列は、<ph id="ph1">&lt;see langword="static" /&gt;</ph> フィールド <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> によって提供されます。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>Searches for a public instance constructor whose parameters match the types in the specified array.</source>
          <target state="translated">指定した配列の型に一致するパラメーターが設定されているパブリック インスタンス コンストラクターを検索します。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">パラメーター型配列の型と一致するパラメーターが設定されているパブリック インスタンス コンストラクターが存在する場合は、そのコンストラクターを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor).</source>
          <target state="translated">このメソッドのオーバー ロードは、パブリック インスタンス コンス トラクターを検索し、クラス初期化子 (.cctor) を取得するのには使用できません。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>To get a class initializer, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">クラス初期化子を取得するを受け取るオーバー ロードを使用<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>、し、指定<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">使用して、クラス初期化子を取得することも、<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>If the requested constructor is non-public, this method returns <ph id="ph1">`null`</ph>.</source>
          <target state="translated">要求されたコンス トラクターが非パブリックのかどうか、このメソッドが戻る<ph id="ph1">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">呼び出すときにのみ、パラメーターを省略できます。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドは常にジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す<ph id="ph2">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>The following example obtains the type of <ph id="ph1">`MyClass`</ph>, gets the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object, and displays the constructor signature.</source>
          <target state="translated">次の例の種類を取得する<ph id="ph1">`MyClass`</ph>、取得、<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>オブジェクト、およびコンス トラクターのシグネチャが表示されます。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> の要素の 1 つが <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> を使用する場合は、null 参照 (Visual Basic の場合は <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
          <target state="translated">取得するコンストラクターのパラメーターの数、順序、および型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
          <target state="translated">パラメーターをとらないコンストラクターを取得するための、<ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列 (Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the parameter type array.</source>
          <target state="translated">パラメーター型配列内の対応する要素に関連付けられている属性を表す <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">既定のバインダーでは、このパラメーターは処理されません。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">指定したバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表す <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> オブジェクト。それ以外の場合は <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">厳密な一致が存在しない場合、<ph id="ph1">`binder`</ph>で指定されたパラメーター型を強制的に試みます、<ph id="ph2">`types`</ph>配列、一致項目を選択するためにします。</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">場合、<ph id="ph1">`binder`</ph>が、一致するものを選択し、できない<ph id="ph2">`null`</ph>が返されます。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>検索に含めるにどのコンス トラクターを定義するフィルター フラグを使用できます。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>パブリック コンス トラクターを検索します。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索にパブリックでないコンス トラクター (つまり、プライベート、内部、および保護されたコンス トラクター) を含める。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">このメソッドのオーバー ロードを使用したクラス初期化子 (.cctor) を取得する必要がありますを指定する<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">使用して、クラス初期化子を取得することも、<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">呼び出すときにのみ、パラメーターを省略できます。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドは常にジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す<ph id="ph2">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following program obtains the type of <ph id="ph1">`MyClass1`</ph> class, gets the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object matching the specified binding flags, and displays the signature of the constructor.</source>
          <target state="translated">次のプログラムの種類を取得する<ph id="ph1">`MyClass1`</ph>クラス、取得、<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>オブジェクトの指定したバインディング フラグに一致して、コンス トラクターのシグネチャが表示されます。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> の要素の 1 つが <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> と <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> の長さが異なります。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> を使用する場合は、null 参照 (Visual Basic の場合は <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</source>
          <target state="translated">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップに関する一連の規則を指定するオブジェクト。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
          <target state="translated">取得するコンストラクターのパラメーターの数、順序、および型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
          <target state="translated">パラメーターをとらないコンストラクターを取得するための、<ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列 (Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt> 型 <ept id="p1">&lt;/c&gt;</ept> 配列内の対応する要素に関連付けられている属性を表す <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">既定のバインダーでは、このパラメーターは処理されません。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">指定したバインディング制約および指定した呼び出し規則を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">既定のバインダーが処理されませんが<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(、<ph id="ph2">`modifiers`</ph>パラメーター)、abstract を使用することができます<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>を処理することはカスタムのバインダーを記述するクラス<ph id="ph4">`modifiers`</ph>です。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">厳密な一致が存在しない場合、<ph id="ph1">`binder`</ph>で指定されたパラメーター型を強制的に試みます、<ph id="ph2">`types`</ph>配列、一致項目を選択するためにします。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">場合、<ph id="ph1">`binder`</ph>が、一致するものを選択し、できない<ph id="ph2">`null`</ph>が返されます。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>検索に含めるにどのコンス トラクターを定義するフィルター フラグを使用できます。</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>パブリック コンス トラクターを検索します。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索にパブリックでないコンス トラクター (つまり、プライベート、内部、および保護されたコンス トラクター) を含める。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To get the class initializer (.cctor) using this method, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">このメソッドを使用してクラス初期化子 (.cctor) を取得する必要がありますを指定する<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">使用して、クラス初期化子を取得することも、<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`Get`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">呼び出すときにのみ、パラメーターを省略できます。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドは常にジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す<ph id="ph2">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example obtains the type of <ph id="ph1">`MyClass1`</ph>, gets the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object that matches the specified binding flags, and displays the constructor signature.</source>
          <target state="translated">次の例の種類を取得する<ph id="ph1">`MyClass1`</ph>、取得、<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>を指定したバインディング フラグに一致し、コンス トラクターのシグネチャを表示するオブジェクト。</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> の要素の 1 つが <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> と <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> の長さが異なります。</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> を使用する場合は、null 参照 (Visual Basic の場合は <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</source>
          <target state="translated">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップに関する一連の規則を指定するオブジェクト。</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
          <target state="translated">取得するコンストラクターのパラメーターの数、順序、および型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
          <target state="translated">パラメーターをとらないコンストラクターを取得するための、<ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列 (Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt> 型 <ept id="p1">&lt;/c&gt;</ept> 配列内の対応する要素に関連付けられている属性を表す <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">既定のバインダーでは、このパラメーターは処理されません。</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">派生クラス内でオーバーライドされた場合、指定したバインディング制約および指定した呼び出し規則を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表す <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> オブジェクト。それ以外の場合は <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">既定のバインダーが処理されませんが<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(、<ph id="ph2">`modifiers`</ph>パラメーター)、abstract を使用することができます<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>を処理することはカスタムのバインダーを記述するクラス<ph id="ph4">`modifiers`</ph>です。</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">厳密な一致が存在しない場合、<ph id="ph1">`binder`</ph>で指定されたパラメーター型を強制的に試みます、<ph id="ph2">`types`</ph>配列、一致項目を選択するためにします。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">場合、<ph id="ph1">`binder`</ph>が、一致するものを選択し、できない<ph id="ph2">`null`</ph>が返されます。</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>検索に含めるにどのコンス トラクターを定義するフィルター フラグを使用できます。</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>パブリック コンス トラクターを検索します。</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索にパブリックでないコンス トラクター (つまり、プライベート、内部、および保護されたコンス トラクター) を含める。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This method implements <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>.</source>
          <target state="translated">このメソッドは、<ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> を実装します。</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> の要素の 1 つが <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> と <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> の長さが異なります。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The current type is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</source>
          <target state="translated">現在の型は、<ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> または <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the constructors of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のコンストラクターを取得します。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors">
          <source>Returns all the public constructors defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> に対して定義されているパブリック コンストラクターをすべて返します。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing all the public instance constructors defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, but not including the type initializer (static constructor).</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> に対して定義されたすべてのパブリック インスタンス コンストラクター (ただし、型初期化子 (静的コンストラクター) を除く) を表している <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors">
          <source>If no public instance constructors are defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, or if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter in the definition of a generic type or generic method, an empty array of type <ph id="ph3">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> is returned.</source>
          <target state="translated">パブリック インスタンス コンストラクターが現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> に対して定義されている場合、または現在の <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、型 <ph id="ph3">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> の空の配列が返されます。</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method does not return constructors in a particular order, such as declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>メソッドでは、宣言の順序など、特定の順序では、コンス トラクターは返しません。</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Your code must not depend on the order in which constructors are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存、コンス トラクターが返される順序のためする順序が異なります。</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`Get`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>This method overload calls the <ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> method overload, with <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">このメソッドのオーバー ロードを呼び出す、<ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph>メソッド オーバー ロードで<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>It will not find class initializers (.cctor).</source>
          <target state="translated">クラス初期化子 (.cctor) は検索されません。</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">クラス初期化子を検索するを受け取るオーバー ロードを使用して<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>、し、指定<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">使用して、クラス初期化子を取得することも、<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>適切な型引数に置き換え、型パラメーターを持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a constructor <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> in Visual Basic), calling <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns a <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents <ph id="ph7">`C(int t1)`</ph> in C# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> in Visual Basic).</source>
          <target state="translated">たとえば場合、クラス<ph id="ph1">`C&lt;T&gt;`</ph>コンス トラクターを持つ<ph id="ph2">`C(T t1)`</ph>(<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> Visual Basic で) を呼び出す<ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>で<ph id="ph5">`C&lt;int&gt;`</ph>を返します、<ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>を表す<ph id="ph7">`C(int t1)`</ph>(C#) (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter, the <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method returns an empty array.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>がジェネリック型パラメーターを表す、<ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>メソッドが空の配列を返します。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>This example shows the output of the <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> overload from a class that has two instance constructors and one static constructor.</source>
          <target state="translated">この例の出力を示しています、<ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>オーバー ロードの 2 つのインスタンス コンス トラクターおよび静的コンス トラクターを持つクラスであるからです。</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The output of this code is:</source>
          <target state="translated">このコードの出力です。</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Because the <ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph> overload uses only <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, the static constructor is neither counted by the <ph id="ph4">`for`</ph> expression nor evaluated by <ph id="ph5">`IsStatic`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph>のみ使用するオーバー ロード<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>と<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>、によって、静的コンス トラクターがカウントされるも、<ph id="ph4">`for`</ph>式によって評価も<ph id="ph5">`IsStatic`</ph>します。</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>To find static constructors, use the <ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> overload, and pass the combination (logical <ph id="ph2">`OR`</ph>) of <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, as shown in the following code example:</source>
          <target state="translated">静的コンス トラクターを検索する、<ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph>過負荷、および組み合わせを渡す (論理<ph id="ph2">`OR`</ph>) の<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>、 <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>、 <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>、<ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>次のコード例のように。</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Now the output is:</source>
          <target state="translated">これで、出力です。</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>True</source>
          <target state="translated">True</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the constructors defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified <ph id="ph2">&lt;see langword="BindingFlags" /&gt;</ph>.</source>
          <target state="translated">派生クラスによってオーバーライドされた場合、指定した <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> を使用して、現在の <ph id="ph2">&lt;see langword="BindingFlags" /&gt;</ph> に対して定義されているコンストラクターを検索します。</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing all constructors defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints, including the type initializer if it is defined.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> にコンストラクターが定義されている場合は、型初期化子を含め、定義されているコンストラクターのうち指定したバインディング制約に一致するすべてのコンストラクターを表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> if no constructors are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, if none of the defined constructors match the binding constraints, or if the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter in the definition of a generic type or generic method.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> に対してコンストラクターが定義されていない場合、または現在の <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、型 <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> の空の配列を返します。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method does not return constructors in a particular order, such as declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>メソッドでは、宣言の順序など、特定の順序では、コンス トラクターは返しません。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which constructors are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存、コンス トラクターが返される順序のためする順序が異なります。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`bindingAttr`</ph> can be used to specify whether to return only public constructors or both public and non-public constructors.</source>
          <target state="translated"><ph id="ph1">`bindingAttr`</ph> パブリック コンス トラクターまたはパブリックと非パブリックの両方のコンス トラクターのみを返すかどうかを指定するために使用します。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">厳密な一致が存在しない場合、<ph id="ph1">`binder`</ph>で指定されたパラメーター型を強制的に試みます、<ph id="ph2">`types`</ph>配列、一致項目を選択するためにします。</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">場合、<ph id="ph1">`binder`</ph>が、一致するものを選択し、できない<ph id="ph2">`null`</ph>が返されます。</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>検索に含めるにどのコンス トラクターを定義するフィルター フラグを使用できます。</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>パブリック コンス トラクターを検索します。</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索にパブリックでないコンス トラクター (つまり、プライベート、内部、および保護されたコンス トラクター) を含める。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Constructors of base classes are not returned.</source>
          <target state="translated">基本クラスのコンス トラクターは返されません。</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">このメソッドのオーバー ロードを使用したクラス初期化子 (.cctor) を取得する必要がありますを指定する<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">使用して、クラス初期化子を取得することも、<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>適切な型引数に置き換え、型パラメーターを持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a constructor <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> in Visual Basic), calling <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns a <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents <ph id="ph7">`C(int t1)`</ph> in C# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> in Visual Basic).</source>
          <target state="translated">たとえば場合、クラス<ph id="ph1">`C&lt;T&gt;`</ph>コンス トラクターを持つ<ph id="ph2">`C(T t1)`</ph>(<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> Visual Basic で) を呼び出す<ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>で<ph id="ph5">`C&lt;int&gt;`</ph>を返します、<ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>を表す<ph id="ph7">`C(int t1)`</ph>(C#) (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter, the <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method returns an empty array.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>がジェネリック型パラメーターを表す、<ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>メソッドが空の配列を返します。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>This example shows the output of the <ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph> overload from a class that has two instance constructors and one static constructor.</source>
          <target state="translated">この例の出力を示しています、<ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph>オーバー ロードの 2 つのインスタンス コンス トラクターおよび静的コンス トラクターを持つクラスであるからです。</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>The output of this code is:</source>
          <target state="translated">このコードの出力です。</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Because the <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> overload uses only <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance&gt;</ph>, the static constructor is neither counted by the <ph id="ph4">`for`</ph> expression nor evaluated by <ph id="ph5">`IsStatic`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>のみ使用するオーバー ロード<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public&gt;</ph>と<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance&gt;</ph>、によって、静的コンス トラクターがカウントされるも、<ph id="ph4">`for`</ph>式によって評価も<ph id="ph5">`IsStatic`</ph>します。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>To find static constructors, use the <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> overload, and pass it the combination (logical OR) of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, as shown in the following code example:</source>
          <target state="translated">静的コンス トラクターを検索する、<ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>過負荷との組み合わせ (論理 OR) を渡す<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>、 <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>、 <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>、<ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>次のコード例のように。</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Now the output is:</source>
          <target state="translated">これで、出力です。</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>True</source>
          <target state="translated">True</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>Searches for the members defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> whose <ph id="ph2">&lt;see cref="T:System.Reflection.DefaultMemberAttribute" /&gt;</ph> is set.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が設定されている現在の <ph id="ph2">&lt;see cref="T:System.Reflection.DefaultMemberAttribute" /&gt;</ph> に定義されているメンバーを検索します。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing all default members of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> のすべての既定メンバーを表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have default members.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> に既定のメンバーがない場合は、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列。</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph>メソッドで返されないメンバーを特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存、メンバーが返される順序のためする順序が異なります。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">このメソッドは、派生クラスでオーバーライドできます。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`Get`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>適切な型引数に置き換え、型パラメーターを持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a property <ph id="ph2">`P`</ph> that returns <ph id="ph3">`T`</ph>, calling <ph id="ph4">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns <ph id="ph6">`int P`</ph> in C# (<ph id="ph7">`Property P As Integer`</ph> in Visual Basic).</source>
          <target state="translated">たとえば場合、クラス<ph id="ph1">`C&lt;T&gt;`</ph>プロパティが含まれる<ph id="ph2">`P`</ph>を返す<ph id="ph3">`T`</ph>、呼び出し元<ph id="ph4">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph>で<ph id="ph5">`C&lt;int&gt;`</ph>を返します<ph id="ph6">`int P`</ph>(C#) (<ph id="ph7">`Property P As Integer`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表しますがジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメンバーまたはのメンバーを検索<ph id="ph2">&lt;xref:System.Object&gt;</ph>クラスの制約が存在しない場合。</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The following example obtains the default member information of <ph id="ph1">`MyClass`</ph> and displays the default members.</source>
          <target state="translated">次の例の既定のメンバー情報を取得する<ph id="ph1">`MyClass`</ph>し、既定のメンバーを表示します。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Type.GetElementType">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the object encompassed or referred to by the current array, pointer or reference type.</source>
          <target state="translated">派生クラスによってオーバーライドされた場合、現在の配列、ポインター、または参照型によって包含または参照されるオブジェクトの <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Type.GetElementType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the object encompassed or referred to by the current array, pointer, or reference type, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</source>
          <target state="translated">現在の配列、ポインター、または参照型によって包含または参照されるオブジェクトの <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。現在の <ph id="ph2">&lt;see langword="null" /&gt;</ph> が配列またはポインターではない場合、参照によって渡されない場合、ジェネリック型やジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、<ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetElementType">
          <source>This method returns <ph id="ph1">`null`</ph> for the <ph id="ph2">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">このメソッドが戻る<ph id="ph1">`null`</ph>の<ph id="ph2">&lt;xref:System.Array&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetElementType">
          <source>The following example demonstrates using the <ph id="ph1">`GetElementType`</ph> method.</source>
          <target state="translated">次の例では、使用方法を示します、<ph id="ph1">`GetElementType`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>The value whose name is to be retrieved.</source>
          <target state="translated">名前を取得する対象の値。</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>Returns the name of the constant that has the specified value, for the current enumeration type.</source>
          <target state="translated">現在の列挙型の指定された値を持つ定数の名前を返します。</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>The name of the member of the current enumeration type that has the specified value, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no such constant is found.</source>
          <target state="translated">指定された値を持つ現在の列挙型のメンバーの名前。そのような定数が見つからない場合は、<ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>The current type is not an enumeration.</source>
          <target state="translated">現在の型は列挙型ではありません。</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is neither of the current type nor does it have the same underlying type as the current type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> は、現在の型ではなく、またその基になる型は現在の型と同じではありません。</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumNames">
          <source>Returns the names of the members of the current enumeration type.</source>
          <target state="translated">現在の列挙型のメンバーの名前を返します。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumNames">
          <source>An array that contains the names of the members of the enumeration.</source>
          <target state="translated">列挙型のメンバーの名前が含まれている配列。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumNames">
          <source>The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</source>
          <target state="translated">戻り値の配列の要素は、列挙型定数のバイナリ値 (つまり、符号なしの値) に基づいて並べ替えられます。</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumNames">
          <source>If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</source>
          <target state="translated">配列に同じ値を持つ列挙定数が含まれている場合の対応する名前の順序は指定されません。</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumNames">
          <source>The current type is not an enumeration.</source>
          <target state="translated">現在の型は列挙型ではありません。</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>Returns the underlying type of the current enumeration type.</source>
          <target state="translated">現在の列挙型の基になる型を返します。</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>The underlying type of the current enumeration.</source>
          <target state="translated">現在の列挙型の基になる型。</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumUnderlyingType">
          <source>By default, the underlying type of an enumeration in C# and Visual Basic is <ph id="ph1">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">C# および Visual Basic での列挙の基になる型は、既定では、<ph id="ph1">&lt;xref:System.Int32&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumUnderlyingType">
          <source>Other integer types can be specified.</source>
          <target state="translated">その他の整数型を指定することができます。</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>The current type is not an enumeration.</source>
          <target state="translated">現在の型は列挙型ではありません。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>The enumeration type is not valid, because it contains more than one instance field.</source>
          <target state="translated">列挙型に複数のインスタンス フィールドが含まれているため、無効です。</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>Returns an array of the values of the constants in the current enumeration type.</source>
          <target state="translated">現在の列挙型の定数の値の配列を返します。</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>An array that contains the values.</source>
          <target state="translated">値を格納する配列。</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</source>
          <target state="translated">配列の要素は列挙定数のバイナリ値 (符号なしの値) に基づいて並べ替えられます。</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>The current type is not an enumeration.</source>
          <target state="translated">現在の型は列挙型ではありません。</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific event declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> で宣言または継承されている特定のイベントを取得します。</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source>The string containing the name of an event that is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> で宣言または継承されているイベントの名前を格納する文字列。</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the specified public event.</source>
          <target state="translated">指定したパブリック イベントを表す <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source>The object representing the specified public event that is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> で宣言または継承されている指定パブリック イベントが存在する場合は、そのイベントを表すオブジェクト。それ以外の場合は <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">イベントは、少なくとも 1 つのメソッドまたはパブリックであるアクセサーがある場合、リフレクションには、パブリックと見なされます。</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">それ以外の場合、イベントは、プライベートと見なされ、使用する必要があります<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (Visual basic での結合を使用して値<ph id="ph4">`Or`</ph>) それを取得します。</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">検索<ph id="ph1">`name`</ph>小文字が区別されます。</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The search includes public static and public instance events.</source>
          <target state="translated">検索には、static および public インスタンスのパブリック イベントが含まれています。</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`Get`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のイベントを検索します。</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The following example creates an <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> object and gets the event for a button class for the specified event.</source>
          <target state="translated">次の例を作成、<ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph>オブジェクトし、指定されたイベントに対してボタン クラスのイベントを取得します。</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of an event which is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> で宣言または継承されているイベントの名前を格納する文字列。</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the specified event, using the specified binding constraints.</source>
          <target state="translated">派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、指定したイベントを表す <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The object representing the specified event that is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> で宣言または継承されている指定イベントが存在する場合は、そのイベントを表すオブジェクト。それ以外の場合は <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which events to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>検索に含めるイベントを定義するフィルター フラグを使用できます。</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public events in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック イベントを含めます。</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public events (that is, private, internal, and protected events) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索にパブリックでないイベント (つまり、プライベート、内部、および保護されたイベント) を含めます。</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>に含める<ph id="ph2">`public`</ph>と<ph id="ph3">`protected`</ph>階層; の静的メンバー<ph id="ph4">`private`</ph>継承クラスの静的メンバーは含まれません。</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 小文字を区別しない<ph id="ph2">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the events declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not events that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されているイベントのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたイベントされません。</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">イベントは、少なくとも 1 つのメソッドまたはパブリックであるアクセサーがある場合、リフレクションには、パブリックと見なされます。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">それ以外の場合、イベントは、プライベートと見なされ、使用する必要があります<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (Visual basic での結合を使用して値<ph id="ph4">`Or`</ph>) それを取得します。</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のイベントを検索します。</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method to search a type for a public or non-public event named "Click" that is not <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">次のコード例では、<ph id="ph1">&lt;xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph>パブリックまたはパブリックでないイベントの「クリックして」という名前ではない型を検索するメソッド<ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the events that are declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> で宣言または継承されているイベントを取得します。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>Returns all the public events that are declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> で宣言または継承されているすべてのパブリック イベントを返します。</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing all the public events which are declared or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> で宣言または継承されているすべてのパブリック イベントを表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have public events.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> にパブリック イベントがない場合は、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列。</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">イベントは、少なくとも 1 つのメソッドまたはパブリックであるアクセサーがある場合、リフレクションには、パブリックと見なされます。</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">それ以外の場合、イベントは、プライベートと見なされ、使用する必要があります<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (Visual basic での結合を使用して値<ph id="ph4">`Or`</ph>) それを取得します。</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> method does not return events in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph>メソッドで返されないイベントを特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Your code must not depend on the order in which events are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存、イベントが返される順序のためする順序が異なります。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">このメソッドは、派生クラスでオーバーライドできます。</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`Get`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph>適切な型引数に置き換え、型パラメーターを持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のイベントを検索します。</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The following example obtains an array of <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects, gets all the events for a <ph id="ph2">`Button`</ph> class, and displays the event names.</source>
          <target state="translated">次の例の配列を取得する<ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph>オブジェクト、すべてのイベントを取得、<ph id="ph2">`Button`</ph>クラス、およびイベント名が表示されます。</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>To compile the Visual Basic example, use the following command line:</source>
          <target state="translated">Visual Basic の例をコンパイルするには、次のコマンドラインを使用します。</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for events that are declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> で宣言または継承されているイベントを検索します。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing all events that are declared or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> で宣言または継承されているイベントのうち、指定したバインディング制約に一致するすべてのイベントを表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have events, or if none of the events match the binding constraints.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> にイベントが存在しないか、またはイベントの中にバインディング制約に一致するものがない場合は、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列。</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> method does not return events in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph>メソッドで返されないイベントを特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which events are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存、イベントが返される順序のためする順序が異なります。</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which events to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>検索に含めるイベントを定義するフィルター フラグを使用できます。</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public events in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック イベントを含めます。</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public events (that is, private, internal, and protected events) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索にパブリックでないイベント (つまり、プライベート、内部、および保護されたイベント) を含めます。</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Only protected and internal events on base classes are returned; private events on base classes are not returned.</source>
          <target state="translated">のみ保護され、基本クラスの内部のイベントが返されます。基本クラスにプライベート イベントは返されません。</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>に含める<ph id="ph2">`public`</ph>と<ph id="ph3">`protected`</ph>階層; の静的メンバー<ph id="ph4">`private`</ph>継承クラスの静的メンバーは含まれません。</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the events declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not events that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されているイベントのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたイベントされません。</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">イベントは、少なくとも 1 つのメソッドまたはパブリックであるアクセサーがある場合、リフレクションには、パブリックと見なされます。</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">それ以外の場合、イベントは、プライベートと見なされ、使用する必要があります<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (Visual basic での結合を使用して値<ph id="ph4">`Or`</ph>) それを取得します。</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph>適切な型引数に置き換え、型パラメーターを持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のイベントを検索します。</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The following example obtains an array of <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects that match the specified binding flags, gets all the events for a <ph id="ph2">`Button`</ph> class, and displays the event names.</source>
          <target state="translated">次の例の配列を取得する<ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph>指定したバインディング フラグに一致するオブジェクトのすべてのイベントの取得、<ph id="ph2">`Button`</ph>クラス、およびイベント名が表示されます。</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>To compile the Visual Basic example, use the following command line:</source>
          <target state="translated">Visual Basic の例をコンパイルするには、次のコマンドラインを使用します。</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific field of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の特定のフィールドを取得します。</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>The string containing the name of the data field to get.</source>
          <target state="translated">取得するデータ フィールドの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>Searches for the public field with the specified name.</source>
          <target state="translated">指定した名前のパブリック フィールドを検索します。</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>An object representing the public field with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した名前のパブリック フィールドが存在する場合は、そのフィールドを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">検索<ph id="ph1">`name`</ph>小文字が区別されます。</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>The search includes public static and public instance fields.</source>
          <target state="translated">検索には、static および public のパブリック インスタンス フィールドが含まれています。</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のフィールドを検索します。</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>The following example gets the <ph id="ph1">`Type`</ph> object for the specified class, obtains the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object for the field, and displays the value of the field.</source>
          <target state="translated">次の例を取得、 <ph id="ph1">`Type`</ph> 、指定したクラス オブジェクトを取得、<ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph>フィールドに、オブジェクトとフィールドの値を表示します。</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>This <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> whose <ph id="ph3">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method has not yet been called.</source>
          <target state="translated">この <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトは、<ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> メソッドがまだ呼び出されていない <ph id="ph3">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the data field to get.</source>
          <target state="translated">取得するデータ フィールドの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified field, using the specified binding constraints.</source>
          <target state="translated">指定したバインディング制約を使用して、指定したフィールドを検索します。</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the field that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した要件と一致するフィールドが存在する場合は、そのフィールドを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`Get`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which fields to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>検索に含めるフィールドを定義するフィルター フラグを使用できます。</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public fields in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック フィールドを含める。</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public fields (that is, private, internal, and protected fields) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索にパブリックでないフィールド (つまり、プライベート、内部、および保護されている) を含める。</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>に含める<ph id="ph2">`public`</ph>と<ph id="ph3">`protected`</ph>階層; の静的メンバー<ph id="ph4">`private`</ph>継承クラスの静的メンバーは含まれません。</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 小文字を区別しない<ph id="ph2">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the fields declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not fields that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されているフィールドのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、単に継承されたフィールドではなくです。</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のフィールドを検索します。</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following example gets the <ph id="ph1">`Type`</ph> object for the specified class, obtains the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object for the field that matches the specified binding flags, and displays the value of the field.</source>
          <target state="translated">次の例を取得、 <ph id="ph1">`Type`</ph> 、指定したクラスのオブジェクトとは、取得、<ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph>を指定したバインディング フラグに一致し、フィールドの値を表示するフィールドのオブジェクト。</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the fields of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のフィールドを取得します。</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>Returns all the public fields of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のすべてのパブリック フィールドを返します。</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing all the public fields defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> に対して定義されているすべてのパブリック フィールドを表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, if no public fields are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> に対してパブリック フィールドが定義されていない場合は、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph>メソッドで返されないフィールドを特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Your code must not depend on the order in which fields are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存、フィールドが返される順序のためする順序が異なります。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`Get`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph>適切な型引数に置き換え、型パラメーターを持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のパブリック フィールドを検索します。</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The following example shows a use of the <ph id="ph1">`GetFields()`</ph> method.</source>
          <target state="translated">次の例を使用して、<ph id="ph1">`GetFields()`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the fields defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> に対して定義されているフィールドを検索します。</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing all fields defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> に対して定義されているフィールドのうち、指定したバインディング制約に一致するすべてのフィールドを表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, if no fields are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the defined fields match the binding constraints.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> に対してフィールドが定義されていないか、または定義されているフィールドの中にバインディング制約に一致するものが存在しない場合は、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列。</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph>メソッドで返されないフィールドを特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which fields are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存、フィールドが返される順序のためする順序が異なります。</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which fields to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>検索に含めるフィールドを定義するフィルター フラグを使用できます。</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public fields in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック フィールドを含める。</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public fields (that is, private, internal, and protected fields) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索にパブリックでないフィールド (つまり、プライベート、内部、および保護されている) を含める。</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</source>
          <target state="translated">のみ保護され、基本クラスの内部のフィールドが返されます。基本クラスにプライベート フィールドには返されません。</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>に含める<ph id="ph2">`public`</ph>と<ph id="ph3">`protected`</ph>階層; の静的メンバー<ph id="ph4">`private`</ph>継承クラスの静的メンバーは含まれません。</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the fields declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not fields that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されているフィールドのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、単に継承されたフィールドではなくです。</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph>適切な型引数に置き換え、型パラメーターを持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のパブリック フィールドを検索します。</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The following example shows a use of the <ph id="ph1">`GetFields(BindingFlags)`</ph> method.</source>
          <target state="translated">次の例を使用して、<ph id="ph1">`GetFields(BindingFlags)`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</source>
          <target state="translated">クローズ ジェネリック型の型引数またはジェネリック型定義の型パラメーターを表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列を返します。</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic type.</source>
          <target state="translated">ジェネリック型の型引数を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>Returns an empty array if the current type is not a generic type.</source>
          <target state="translated">現在の型がジェネリック型でない場合は空の配列を返します。</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</source>
          <target state="translated">配列の要素は、ジェネリック型の型引数の一覧に表示される順序で返されます。</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>If the current type is a closed constructed type (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>), the array returned by the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic type definition.</source>
          <target state="translated">現在の型がクローズ構築型である場合 (つまり、<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>プロパティから返される<ph id="ph2">`false`</ph>)、によって返される配列、<ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph>メソッドにジェネリック型定義のジェネリック型パラメーターに割り当てられている型が含まれています。</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>If the current type is a generic type definition, the array contains the type parameters.</source>
          <target state="translated">現在の型がジェネリック型定義の場合は、配列には、型パラメーターが含まれています。</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>If the current type is an open constructed type (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</source>
          <target state="translated">現在の型がオープン構築型の場合 (つまり、<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>プロパティから返される<ph id="ph2">`true`</ph>) すべての型パラメーターと外側のジェネリック型またはメソッドの型パラメーターにどのような種類が割り当てられていないで、配列には、型と型の両方が含まれていますパラメーター。</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>プロパティを見分けます。</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>For a demonstration of this scenario, see the code example for the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">このシナリオの例については、のコード例を参照してください、<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> プロパティの解説を参照してください。</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</source>
          <target state="translated">次のコード例では、<ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph>構築された型の型引数とそのジェネリック型定義の型パラメーターを表示するメソッド。</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property.</source>
          <target state="translated">このコード例に示されている例の一部である、<ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>See the larger example for sample output.</source>
          <target state="translated">サンプル出力の例を参照してください。</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">呼び出されたメソッドは基底クラスでサポートされていません。</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">派生クラスには実装を指定しなければなりません。</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the constraints on the current generic type parameter.</source>
          <target state="translated">現在のジェネリック型パラメーターの制約を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列を返します。</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the constraints on the current generic type parameter.</source>
          <target state="translated">現在のジェネリック型パラメーターの制約を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の配列。</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>Each constraint on a generic type parameter is expressed as a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated">各制約のジェネリック型パラメーターを表した、<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph> property to determine whether a constraint is the base class constraint; if the property returns <ph id="ph2">`false`</ph>, the constraint is an interface constraint.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph>プロパティの制約が基底クラスの制約がかどうか以外のかどうか、プロパティを返します<ph id="ph2">`false`</ph>制約がインターフェイスの制約。</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>If a type parameter has no class constraint and no interface constraints, an empty array is returned.</source>
          <target state="translated">型パラメーターにクラス制約のないおよびインターフェイス制約がない場合は、空の配列が返されます。</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> プロパティの解説を参照してください。</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>The following code example defines a generic type <ph id="ph1">`Test`</ph> with two type parameters that have different constraints.</source>
          <target state="translated">次のコード例は、ジェネリック型を定義<ph id="ph1">`Test`</ph>異なる制約を持つ 2 つの型パラメーターを使用します。</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>When the program executes, the constraints are examined using the <ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph> method.</source>
          <target state="translated">使用して、制約を検査、プログラムを実行するとき、<ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph>プロパティおよび<ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is not a generic type parameter.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトは、ジェネリック型パラメーターではありません。</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">つまり、<ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> プロパティが <ph id="ph2">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a generic type definition from which the current generic type can be constructed.</source>
          <target state="translated">現在のジェネリック型を構築する元になるジェネリック型定義を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a generic type from which the current type can be constructed.</source>
          <target state="translated">現在の型を構築する元になるジェネリック型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>A generic type definition is a template from which other types can be constructed.</source>
          <target state="translated">ジェネリック型定義は、他の型を構築するためのテンプレートです。</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>For example, from the generic type definition <ph id="ph1">`G&lt;T&gt;`</ph> (expressed in C# syntax; <ph id="ph2">`G(Of T)`</ph> in Visual Basic or <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> in C++) you can construct and instantiate the type <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> in Visual Basic).</source>
          <target state="translated">たとえば、ジェネリック型定義から<ph id="ph1">`G&lt;T&gt;`</ph>(c# の構文で表現します。<ph id="ph2">`G(Of T)`</ph> Visual basic または<ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph>C++ で) を構築し、型のインスタンスを作成できます<ph id="ph4">`G&lt;int&gt;`</ph>(<ph id="ph5">`G(Of Integer)`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Given a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing this constructed type, the <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method returns the generic type definition.</source>
          <target state="translated">指定された、<ph id="ph1">&lt;xref:System.Type&gt;</ph>これを表すオブジェクトの構築型を<ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>メソッドがジェネリック型定義を返します。</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>If two constructed types are created from the same generic type definition, using the same type arguments, the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method returns the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for both types.</source>
          <target state="translated">2 つの構築された型が同じジェネリック型定義から作成する場合は、同じ型の引数を使用して、<ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>メソッドは、同じを返します<ph id="ph2">&lt;xref:System.Type&gt;</ph>両方の種類のオブジェクト。</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>If you call the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that already represents a generic type definition, it returns the current <ph id="ph3">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">呼び出す場合は、<ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>メソッドを<ph id="ph2">&lt;xref:System.Type&gt;</ph>を既に、ジェネリック型定義を表すオブジェクトを返す現在<ph id="ph3">&lt;xref:System.Type&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>An array of generic types is not itself generic.</source>
          <target state="translated">ジェネリック型の配列は、ジェネリックではないです。</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>In the C# code <ph id="ph1">`A&lt;int&gt;[] v;`</ph> or the Visual Basic code <ph id="ph2">`Dim v() As A(Of Integer)`</ph>, the type of variable <ph id="ph3">`v`</ph> is not generic.</source>
          <target state="translated">C# コードで<ph id="ph1">`A&lt;int&gt;[] v;`</ph>または Visual Basic コード<ph id="ph2">`Dim v() As A(Of Integer)`</ph>、変数の型<ph id="ph3">`v`</ph>ジェネリックではありません。</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Use <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> to determine whether a type is generic before calling <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>.</source>
          <target state="translated">使用して<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>型が呼び出しの前にジェネリックかどうかを判断する<ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> プロパティの解説を参照してください。</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> methods to retrieve the constructed type and the generic type definition.</source>
          <target state="translated">次のコード例が通常のインスタンスの作成を使用して構築された型のインスタンスを作成し、使用、<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>構築型とジェネリック型定義を取得するメソッド。</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>This example uses the generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> type; the constructed type represents a <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph3">`Test`</ph> objects with string keys.</source>
          <target state="translated">この例は、ジェネリックを使用して<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>型以外の構築型を表す、<ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>の<ph id="ph3">`Test`</ph>文字列キーを持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>The current type is not a generic type.</source>
          <target state="translated">現在の型はジェネリック型ではありません。</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericType" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">つまり、<ph id="ph1">&lt;see cref="P:System.Type.IsGenericType" /&gt;</ph> は <ph id="ph2">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">呼び出されたメソッドは基底クラスでサポートされていません。</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">派生クラスには実装を指定しなければなりません。</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="M:System.Type.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">このインスタンスのハッシュ コードを返します。</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.Type.GetHashCode">
          <source>The hash code for this instance.</source>
          <target state="translated">対象のインスタンスのハッシュ コード。</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetHashCode">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">このメソッドは、<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> をオーバーライドします。</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetHashCode">
          <source>The following example displays the hash code of the <ph id="ph1">`System.Windows.Forms.Button`</ph> class.</source>
          <target state="translated">次の例のハッシュ コードを表示する、<ph id="ph1">`System.Windows.Forms.Button`</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific interface implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> で実装または継承されている特定のインターフェイスを取得します。</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>The string containing the name of the interface to get.</source>
          <target state="translated">取得するインターフェイスの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>For generic interfaces, this is the mangled name.</source>
          <target state="translated">ジェネリック インターフェイスの場合、これは完全修飾名です。</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>Searches for the interface with the specified name.</source>
          <target state="translated">指定した名前のインターフェイスを検索します。</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>An object representing the interface with the specified name, implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> で実装または継承されているインターフェイスのうち、指定した名前のインターフェイスが存在する場合は、そのインターフェイスを表すオブジェクト。それ以外の場合は <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">検索<ph id="ph1">`name`</ph>小文字が区別されます。</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Type&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、インターフェイスの制約とクラスまたはインターフェイスの制約から継承するインターフェイスを検索します。</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>For generic interfaces, the <ph id="ph1">`name`</ph> parameter is the mangled name, ending with a grave accent (<ph id="ph2">\`</ph>) and the number of type parameters.</source>
          <target state="translated">ジェネリック インターフェイスの場合、<ph id="ph1">`name`</ph>パラメーターは、アクサン グラーブで終わる、完全修飾名 (<ph id="ph2">\`</ph>) と型パラメーターの数。</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>This is true for both generic interface definitions and constructed generic interfaces.</source>
          <target state="translated">これは、ジェネリック インターフェイスの定義と構築されたジェネリック インターフェイスの両方に当てはまります。</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>For example, to find <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> in Visual Basic) or <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> in Visual Basic), search for <ph id="ph5">``"IExample`1"``</ph>.</source>
          <target state="translated">たとえば、検索する<ph id="ph1">`IExample&lt;T&gt;`</ph>(<ph id="ph2">`IExample(Of T)`</ph> Visual Basic で) または<ph id="ph3">`IExample&lt;string&gt;`</ph>(<ph id="ph4">`IExample(Of String)`</ph> Visual Basic で)、検索<ph id="ph5">``"IExample`1"``</ph>です。</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph> method to search the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> class for the <ph id="ph3">&lt;xref:System.Runtime.Serialization.IDeserializationCallback&gt;</ph> interface, and lists the methods of the interface.</source>
          <target state="translated">次のコード例では、<ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph>を検索するメソッド、<ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>のクラス、<ph id="ph3">&lt;xref:System.Runtime.Serialization.IDeserializationCallback&gt;</ph>インターフェイス、およびインターフェイスのメソッドの一覧です。</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph> method overload and the <ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> method.</source>
          <target state="translated">このコード例も示します、<ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph>メソッドのオーバー ロードおよび<ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type that implements the same generic interface with different type arguments.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> は、別の型引数で同じジェネリック インターフェイスを実装する型を表します。</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The string containing the name of the interface to get.</source>
          <target state="translated">取得するインターフェイスの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For generic interfaces, this is the mangled name.</source>
          <target state="translated">ジェネリック インターフェイスの場合、これは完全修飾名です。</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore the case of that part of <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</source>
          <target state="translated">単純なインターフェイス名を指定する <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> の部分 (名前空間が大文字と小文字を厳密に区別することを指定されている部分) で大文字と小文字の区別を無視する場合は、<ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for all parts of <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> のすべての部分の検索時に大文字と小文字を区別する場合は、<ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</source>
          <target state="translated">派生クラスでオーバーライドされた場合、インターフェイス名の大文字と小文字を区別するかどうかを指定して、指定したインターフェイスを検索します。</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>An object representing the interface with the specified name, implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> で実装または継承されているインターフェイスのうち、指定した名前のインターフェイスが存在する場合は、そのインターフェイスを表すオブジェクト。それ以外の場合は <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The <ph id="ph1">`ignoreCase`</ph> parameter applies only to the simple interface name, not to the namespace.</source>
          <target state="translated"><ph id="ph1">`ignoreCase`</ph>パラメーターは名前空間ではないシンプルなインターフェイス名にのみ適用されます。</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The portion of <ph id="ph1">`name`</ph> that specifies the namespace must have the correct case, or the interface will not be found.</source>
          <target state="translated">部分<ph id="ph1">`name`</ph>名前空間が正しい場合は、必要またはインターフェイスは検出されませんを指定します。</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For example, the string "System.icomparable" finds the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface, but the string "system.icomparable" does not.</source>
          <target state="translated">たとえば、"System.icomparable"を検索文字列、<ph id="ph1">&lt;xref:System.IComparable&gt;</ph>が、文字列"system.icomparable"しません。</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Type&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、インターフェイスの制約とクラスまたはインターフェイスの制約から継承するインターフェイスを検索します。</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For generic interfaces, the <ph id="ph1">`name`</ph> parameter is the mangled name, ending with a grave accent (<ph id="ph2">\`</ph>) and the number of type parameters.</source>
          <target state="translated">ジェネリック インターフェイスの場合、<ph id="ph1">`name`</ph>パラメーターは、アクサン グラーブで終わる、完全修飾名 (<ph id="ph2">\`</ph>) と型パラメーターの数。</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>This is true for both generic interface definitions and constructed generic interfaces.</source>
          <target state="translated">これは、ジェネリック インターフェイスの定義と構築されたジェネリック インターフェイスの両方に当てはまります。</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For example, to find <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> in Visual Basic) or <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> in Visual Basic), search for <ph id="ph5">`"IExample`</ph>1"`.</source>
          <target state="translated">たとえば、検索する<ph id="ph1">`IExample&lt;T&gt;`</ph>(<ph id="ph2">`IExample(Of T)`</ph> Visual Basic で) または<ph id="ph3">`IExample&lt;string&gt;`</ph>(<ph id="ph4">`IExample(Of String)`</ph> Visual Basic で)、検索<ph id="ph5">`"IExample`</ph>1"' です。</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph> method to perform a case-insensitive search of the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> class for the <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface.</source>
          <target state="translated">次のコード例では、<ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph>の大文字と小文字の検索を実行するメソッド、<ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>のクラス、<ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph>インターフェイスです。</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph> method overload and the <ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> method.</source>
          <target state="translated">このコード例も示します、<ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph>メソッドのオーバー ロードおよび<ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type that implements the same generic interface with different type arguments.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> は、別の型引数で同じジェネリック インターフェイスを実装する型を表します。</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The interface type to retrieve a mapping for.</source>
          <target state="translated">割り当ての取得対象であるインターフェイス型。</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>Returns an interface mapping for the specified interface type.</source>
          <target state="translated">指定したインターフェイス型に対するインターフェイスの割り当てを返します。</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>An object that represents the interface mapping for <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> に対するインターフェイスの割り当てを表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</source>
          <target state="translated">インターフェイス マップは、そのインターフェイスを実装するクラスの実際のメンバーにインターフェイスをマップする方法を示します。</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> returned by this method.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>構築ジェネリック型パラメーターに置換された要素に適切な型引数の型を表す、<ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph>このメソッドによって返されます。</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> method to determine how the <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> interface maps to <ph id="ph3">&lt;xref:System.Globalization.CultureInfo&gt;</ph> methods, and how the <ph id="ph4">&lt;xref:System.IAppDomainSetup&gt;</ph> interface maps to <ph id="ph5">&lt;xref:System.AppDomainSetup&gt;</ph> properties.</source>
          <target state="translated">次の例では、<ph id="ph1">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph>メソッドを呼び出せば確認方法、<ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph>インターフェイスにマップ<ph id="ph3">&lt;xref:System.Globalization.CultureInfo&gt;</ph>メソッド、方法、および<ph id="ph4">&lt;xref:System.IAppDomainSetup&gt;</ph>インターフェイスにマップ<ph id="ph5">&lt;xref:System.AppDomainSetup&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>Note that, because the <ph id="ph1">&lt;xref:System.IAppDomainSetup&gt;</ph> interface defines a set of properties, the returned <ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> object includes separate <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects for a property's get and set accessors.</source>
          <target state="translated">注意してください。、<ph id="ph1">&lt;xref:System.IAppDomainSetup&gt;</ph>インターフェイスは、返されたプロパティのセットを定義<ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph>オブジェクトを含む独立した<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>プロパティの get および set アクセサーのオブジェクト。</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is not implemented by the current type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> は、現在の型では実装されていません。</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> parameter does not refer to an interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> パラメーターは、インターフェイスを参照しません。</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is a generic interface, and the current type is an array type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> はジェネリック インターフェイスで、現在の型は配列型です。</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a generic type parameter; that is, <ph id="ph2">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> は、ジェネリック型のパラメーターを表します。つまり、<ph id="ph2">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> は <ph id="ph3">&lt;see langword="true" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">呼び出されたメソッドは基底クラスでサポートされていません。</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">派生クラスには実装を指定しなければなりません。</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>When overridden in a derived class, gets all the interfaces implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">派生クラスによってオーバーライドされた場合、現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> で実装または継承されているすべてのインターフェイスを取得します。</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing all the interfaces implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> で実装または継承されているすべてのインターフェイスを表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if no interfaces are implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> で実装または継承されているインターフェイスが存在しない場合は、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列。</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> method does not return interfaces in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph>メソッドで返されないインターフェイスを特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>Your code must not depend on the order in which interfaces are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存、インターフェイスが返される順序のためする順序が異なります。</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Type&gt;</ph>適切な型引数に置き換え、型パラメーターを持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、インターフェイスの制約とクラスまたはインターフェイスの制約から継承するインターフェイスを検索します。</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits.</source>
          <target state="translated">次の例では、指定したクラスの型を取得し、型を実装または継承するすべてのインターフェイスを表示します。</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>To compile the Visual Basic example, use the following compiler commands:</source>
          <target state="translated">Visual Basic の例をコンパイルするには、次のコンパイラ コマンドを使用します。</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>A static initializer is invoked and throws an exception.</source>
          <target state="translated">静的初期化子が呼び出され、例外をスローします。</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the specified members of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のメンバーのうち、指定したメンバーを取得します。</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source>The string containing the name of the public members to get.</source>
          <target state="translated">取得するパブリック メンバーの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source>Searches for the public members with the specified name.</source>
          <target state="translated">指定した名前のパブリック メンバーを検索します。</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
          <target state="translated">指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> オブジェクトの配列。それ以外の場合は空の配列。</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">検索<ph id="ph1">`name`</ph>小文字が区別されます。</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The search includes public static and public instance members.</source>
          <target state="translated">検索には、static および public のパブリック インスタンス メンバーが含まれています。</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph>メソッドで返されないメンバーを特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存、メンバーが返される順序のためする順序が異なります。</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>This method overload will not find class initializers (.cctor).</source>
          <target state="translated">このメソッドのオーバー ロードでは、クラス初期化子 (.cctor) は検索されません。</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">クラス初期化子を検索するを受け取るオーバー ロードを使用して<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>、し、指定<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">使用して、クラス初期化子を取得することも、<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`Get`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表しますがジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメンバーまたはのメンバーを検索<ph id="ph2">&lt;xref:System.Object&gt;</ph>クラスの制約が存在しない場合。</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">ジェネリック メソッドの場合は含めないでください、型引数は<ph id="ph1">`name`</ph>します。</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">たとえば、c# コード<ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph>テキストの名前を持つメンバーを検索"<ph id="ph2">`MyMethod&lt;int&gt;`</ph>"、という名前のメソッドではなく<ph id="ph3">`MyMethod`</ph>型の 1 つのジェネリック引数を持つ<ph id="ph4">`int`</ph>します。</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The following example displays all the members of the <ph id="ph1">`String`</ph> class that start with the letter C.</source>
          <target state="translated">次の例のすべてのメンバーの表示、<ph id="ph1">`String`</ph>文字 C で始まるクラス</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the members to get.</source>
          <target state="translated">取得するメンバーの名前を含む文字列。</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return an empty array.</source>
          <target state="translated">空の配列を返す場合は 0。</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified members, using the specified binding constraints.</source>
          <target state="translated">指定したバインディング制約を使用して、指定したメンバーを検索します。</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
          <target state="translated">指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> オブジェクトの配列。それ以外の場合は空の配列。</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">このメソッドは、派生クラスでオーバーライドできます。</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph>メソッドで返されないメンバーを特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存、メンバーが返される順序のためする順序が異なります。</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック メンバーを含める。</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索に含める非パブリック メンバー (つまり、プライベート、内部、およびプロテクト メンバー)、します。</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>に含める<ph id="ph2">`public`</ph>と<ph id="ph3">`protected`</ph>階層; の静的メンバー<ph id="ph4">`private`</ph>継承クラスの静的メンバーは含まれません。</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 小文字を区別しない<ph id="ph2">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されたメンバーのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたメンバーされません。</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for <ph id="ph1">`name`</ph>, and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic) for <ph id="ph7">`bindingAttr`</ph>.</source>
          <target state="translated">このメソッドのオーバー ロードを使用したクラス初期化子 (.cctor) を取得する必要がありますを指定する「.cctor」の<ph id="ph1">`name`</ph>、および<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> Visual Basic で) の<ph id="ph7">`bindingAttr`</ph>です。</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">使用して、クラス初期化子を取得することも、<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表しますがジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメンバーまたはのメンバーを検索<ph id="ph2">&lt;xref:System.Object&gt;</ph>クラスの制約が存在しない場合。</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">ジェネリック メソッドの場合は含めないでください、型引数は<ph id="ph1">`name`</ph>します。</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">たとえば、c# コード<ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph>テキストの名前を持つメンバーを検索"<ph id="ph2">`MyMethod&lt;int&gt;`</ph>"、という名前のメソッドではなく<ph id="ph3">`MyMethod`</ph>型の 1 つのジェネリック引数を持つ<ph id="ph4">`int`</ph>します。</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The following example displays all the public static members of the <ph id="ph1">`myString`</ph> class that start with the letter C.</source>
          <target state="translated">次の例のすべてのパブリック静的メンバーの表示、<ph id="ph1">`myString`</ph>文字 C で始まるクラス</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The string containing the name of the members to get.</source>
          <target state="translated">取得するメンバーの名前を含む文字列。</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The value to search for.</source>
          <target state="translated">検索する値。</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Zero, to return an empty array.</source>
          <target state="translated">空の配列を返す場合は 0。</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Searches for the specified members of the specified member type, using the specified binding constraints.</source>
          <target state="translated">指定されたバインディング制約を使用して、指定されたメンバー型の指定されたメンバーを検索します。</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
          <target state="translated">指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> オブジェクトの配列。それ以外の場合は空の配列。</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph>メソッドで返されないメンバーを特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存、メンバーが返される順序のためする順序が異なります。</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック メンバーを含める。</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索に含める非パブリック メンバー (つまり、プライベート、内部、およびプロテクト メンバー)、します。</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>に含める<ph id="ph2">`public`</ph>と<ph id="ph3">`protected`</ph>階層; の静的メンバー<ph id="ph4">`private`</ph>継承クラスの静的メンバーは含まれません。</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 小文字を区別しない<ph id="ph2">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されたメンバーのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたメンバーされません。</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for <ph id="ph1">`name`</ph>, <ph id="ph2">&lt;xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType&gt;</ph> for <ph id="ph3">`type`</ph>, and  <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph7">`Or`</ph><ph id="ph8">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic) for <ph id="ph9">`bindingAttr`</ph>.</source>
          <target state="translated">このメソッドのオーバー ロードを使用したクラス初期化子 (.cctor) を取得する必要がありますを指定する「.cctor」の<ph id="ph1">`name`</ph>、<ph id="ph2">&lt;xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType&gt;</ph>の<ph id="ph3">`type`</ph>、および<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph7">`Or`</ph> <ph id="ph8">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>でVisual Basic の場合) の<ph id="ph9">`bindingAttr`</ph>します。</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">使用して、クラス初期化子を取得することも、<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表しますがジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメンバーまたはのメンバーを検索<ph id="ph2">&lt;xref:System.Object&gt;</ph>クラスの制約が存在しない場合。</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">ジェネリック メソッドの場合は含めないでください、型引数は<ph id="ph1">`name`</ph>します。</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">たとえば、c# コード<ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph>テキストの名前を持つメンバーを検索"<ph id="ph2">`MyMethod&lt;int&gt;`</ph>"、という名前のメソッドではなく<ph id="ph3">`MyMethod`</ph>型の 1 つのジェネリック引数を持つ<ph id="ph4">`int`</ph>します。</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The following example displays all the methods of the <ph id="ph1">`myString`</ph> class that start with the letter C.</source>
          <target state="translated">次の例のすべてのメソッドを表示する、<ph id="ph1">`myString`</ph>文字 C で始まるクラス</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>A derived class must provide an implementation.</source>
          <target state="translated">派生クラスにより実装が提供される必要があります。</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the members (properties, methods, fields, events, and so on) of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のメンバー (プロパティ、メソッド、フィールド、イベントなど) を取得します。</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>Returns all the public members of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のすべてのパブリック メンバーを返します。</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing all the public members of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> のすべてのパブリック メンバーを表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have public members.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> にパブリック メンバーが存在しない場合は、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列。</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>メソッドで返されないメンバーを特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存、メンバーが返される順序のためする順序が異なります。</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>This method overload calls the <ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> method overload, with <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (<ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph><ph id="ph6">`Or`</ph><ph id="ph7">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph><ph id="ph8">`Or`</ph><ph id="ph9">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">このメソッドのオーバー ロードを呼び出す、<ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph>メソッド オーバー ロードで<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (<ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> <ph id="ph6">`Or`</ph> <ph id="ph7">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> <ph id="ph8">`Or`</ph> <ph id="ph9">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>It will not find class initializers (.cctor).</source>
          <target state="translated">クラス初期化子 (.cctor) は検索されません。</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">クラス初期化子を検索するを受け取るオーバー ロードを使用して<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>、し、指定<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">使用して、クラス初期化子を取得することも、<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`Get`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>適切な型引数に置き換え、型パラメーターを持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表しますがジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメンバーまたはのメンバーを検索<ph id="ph2">&lt;xref:System.Object&gt;</ph>クラスの制約が存在しない場合。</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Type.GetMembers&gt;</ph> method overload to collect information about all public members of a specified class.</source>
          <target state="translated">次のコード例を使用する方法を示しています、<ph id="ph1">&lt;xref:System.Type.GetMembers&gt;</ph>メソッドのオーバー ロードを指定したクラスのすべてのパブリック メンバーに関する情報を収集します。</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Zero (<ph id="ph1">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>), to return an empty array.</source>
          <target state="translated">空の配列を返す場合は 0 (<ph id="ph1">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the members defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> に対して定義されているメンバーを検索します。</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing all members defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> に対して定義されているメンバーのうち、指定したバインディング制約に一致するすべてのメンバーを表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if no members are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the defined members match the binding constraints.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> に対してメンバーが定義されていないか、または定義されているメンバーの中にバインディング制約に一致するものが存在しない場合は、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列。</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>メソッドで返されないメンバーを特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存、メンバーが返される順序のためする順序が異なります。</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック メンバーを含める。</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索に含める非パブリック メンバー (つまり、プライベート、内部、およびプロテクト メンバー)、します。</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Only protected and internal members on base classes are returned; private members on base classes are not returned.</source>
          <target state="translated">のみ保護され、基本クラスの内部メンバーが返されます。基本クラスにプライベート メンバーは返されません。</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>に含める<ph id="ph2">`public`</ph>と<ph id="ph3">`protected`</ph>階層; の静的メンバー<ph id="ph4">`private`</ph>継承クラスの静的メンバーは含まれません。</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されたメンバーのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたメンバーされません。</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Calling this method with only the <ph id="ph1">`Public`</ph> flag or only the <ph id="ph2">`NonPublic`</ph> flag will return the specified members and does not require any other flags.</source>
          <target state="translated">だけでは、このメソッドを呼び出し、<ph id="ph1">`Public`</ph>フラグまたはのみ、<ph id="ph2">`NonPublic`</ph>フラグが、指定したメンバーを返すし、他の任意のフラグは不要です。</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">このメソッドのオーバー ロードを使用したクラス初期化子 (.cctor) を取得する必要がありますを指定する<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">使用して、クラス初期化子を取得することも、<ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph>適切な型引数に置き換え、型パラメーターを持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表しますがジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメンバーまたはのメンバーを検索<ph id="ph2">&lt;xref:System.Object&gt;</ph>クラスの制約が存在しない場合。</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> method overload to collect information about all public instance members of a specified class.</source>
          <target state="translated">次のコード例を使用する方法を示しています、<ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph>メソッドのオーバー ロードを指定したクラスのすべてのパブリック インスタンス メンバーに関する情報を収集します。</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific method of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の特定のメソッドを取得します。</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>The string containing the name of the public method to get.</source>
          <target state="translated">取得するパブリック メソッドの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>Searches for the public method with the specified name.</source>
          <target state="translated">指定した名前のパブリック メソッドを検索します。</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>An object that represents the public method with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した名前のパブリック メソッドが存在する場合は、そのパブリック メソッドを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">検索<ph id="ph1">`name`</ph>小文字が区別されます。</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>The search includes public static and public instance methods.</source>
          <target state="translated">検索には、static および public のパブリック インスタンス メソッドが含まれています。</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>If a method is overloaded and has more than one public method, the <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
          <target state="translated">メソッドはオーバー ロードし、に 1 つ以上のパブリック メソッドがある場合、<ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph>メソッドがスローされます、<ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph>例外。</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>In the following example, an exception is thrown because there is more than one public overload of the <ph id="ph1">&lt;xref:System.Int32.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">次の例では、例外がスローの 1 つ以上のパブリック オーバー ロードがあるので、<ph id="ph1">&lt;xref:System.Int32.ToString%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>On the other hand, because the <ph id="ph1">`Person.ToString`</ph> method overrides  <ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> and therefore is not overloaded, the <ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> method is able to retrieve the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">その一方で、ため、<ph id="ph1">`Person.ToString`</ph>メソッドのオーバーライド<ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>したがってオーバー ロードされていないと、<ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph>メソッドを取得することが、<ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>You can do one of the following to retrieve a specific method:</source>
          <target state="translated">特定のメソッドを取得するには、次のいずれかの操作を行うことができます。</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method and specify a <ph id="ph2">`bindingAttr`</ph> argument that uniquely identifies the method.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph>メソッドを指定し、<ph id="ph2">`bindingAttr`</ph>メソッドを一意に識別する引数。</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  <ph id="ph1">`bindingAttr`</ph> argument  of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph><ph id="ph3">`Or`</ph><ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">たとえば、型は、静的およびインスタンスのオーバー ロードを持つため、例外がスローされた場合を指定できます、<ph id="ph1">`bindingAttr`</ph>の引数<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> <ph id="ph3">`Or`</ph><ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>Call an overload of the <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method that includes a <ph id="ph2">`types`</ph> parameter which defines the types of the method's parameters.</source>
          <target state="translated">オーバー ロードを呼び出して、<ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph>メソッドを含む、<ph id="ph2">`types`</ph>メソッドのパラメーターの型を定義するパラメーターです。</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethods&gt;</ph> method to retrieve an array containing all of the public methods belonging to a type.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Type.GetMethods&gt;</ph>すべての型に属しているパブリック メソッドを格納する配列を取得します。</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>You can then iterate it to identify the duplicate methods named <ph id="ph1">`name`</ph>.</source>
          <target state="translated">反復処理するという名前の重複するメソッドを識別するために<ph id="ph1">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<ph id="ph2">&lt;xref:System.Object&gt;</ph>クラスの制約が存在しない場合。</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">ジェネリック メソッドの場合は含めないでください、型引数は<ph id="ph1">`name`</ph>します。</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">たとえば、c# コード<ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph>テキストの名前を持つメンバーを検索"<ph id="ph2">`MyMethod&lt;int&gt;`</ph>"、という名前のメソッドではなく<ph id="ph3">`MyMethod`</ph>型の 1 つのジェネリック引数を持つ<ph id="ph4">`int`</ph>します。</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>The following example gets a method named <ph id="ph1">`MethodA`</ph>.</source>
          <target state="translated">次の例は、という名前のメソッドを取得<ph id="ph1">`MethodA`</ph>です。</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>More than one method is found with the specified name.</source>
          <target state="translated">指定した名前のメソッドが複数個見つかりました。</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">取得するメソッドの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified method, using the specified binding constraints.</source>
          <target state="translated">指定したバインディング制約を使用して、指定したメソッドを検索します。</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> to include public methods in the search.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>検索にパブリック メソッドを含める。</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>検索に含める非パブリック メソッド (つまり、プライベート、内部、および保護されたメソッド)、します。</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType&gt;</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType&gt;</ph>に含める<ph id="ph2">`public`</ph>と<ph id="ph3">`protected`</ph>階層; の静的メンバー<ph id="ph4">`private`</ph>継承クラスの静的メンバーは含まれません。</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType&gt;</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType&gt;</ph> 小文字を区別しない<ph id="ph2">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> 宣言されたメソッドのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたメソッドされません。</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>If a method is overloaded and more than one overload meets the constraints specified by the <ph id="ph1">`bindingAttr`</ph> argument, the method throws an <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
          <target state="translated">メソッドはオーバー ロードされ、複数のオーバー ロードによって指定された制約を満たしている場合、<ph id="ph1">`bindingAttr`</ph>引数、メソッドをスロー、<ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph>例外。</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>In the following example, an exception is thrown because:</source>
          <target state="translated">次の例では、ため、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">`TestClass`</ph> type has two public instance overloads of the <ph id="ph2">`DisplayValue`</ph> method, <ph id="ph3">`DisplayValue(String)`</ph> and <ph id="ph4">`DisplayValue(String, Object[])`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestClass`</ph>型の 2 つのパブリック インスタンス オーバー ロードを持つ、<ph id="ph2">`DisplayValue`</ph>メソッド、<ph id="ph3">`DisplayValue(String)`</ph>と<ph id="ph4">`DisplayValue(String, Object[])`</ph>です。</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">`TestClass`</ph> type has two public instance overloads of the <ph id="ph2">`Equals`</ph> method,  one of which is inherited from <ph id="ph3">&lt;xref:System.Object&gt;</ph>: <ph id="ph4">`Equals(TestClass)`</ph> and <ph id="ph5">`Equals(Object)`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestClass`</ph>型の 2 つのパブリック インスタンス オーバー ロードを持つ、<ph id="ph2">`Equals`</ph>から継承されたうちの 1 つは、メソッド<ph id="ph3">&lt;xref:System.Object&gt;</ph>:<ph id="ph4">`Equals(TestClass)`</ph>と<ph id="ph5">`Equals(Object)`</ph>です。</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>You can do one of the following to retrieve a specific method:</source>
          <target state="translated">特定のメソッドを取得するには、次のいずれかの操作を行うことができます。</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Change the binding constraints.</source>
          <target state="translated">バインディング制約を変更します。</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>In the previous example, attempting to retrieve a public instance <ph id="ph1">`Equals`</ph> method that is declared by the type and not inherited successfully retrieves <ph id="ph2">`Equals(TestClass)`</ph>.</source>
          <target state="translated">前の例では、パブリック インスタンスを取得しようとして<ph id="ph1">`Equals`</ph>は型で宣言され、正常に継承されないメソッドは、取得<ph id="ph2">`Equals(TestClass)`</ph>です。</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Call an overload of the <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method that includes a <ph id="ph2">`types`</ph> parameter which defines the types of the method's parameters.</source>
          <target state="translated">オーバー ロードを呼び出して、<ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph>メソッドを含む、<ph id="ph2">`types`</ph>メソッドのパラメーターの型を定義するパラメーターです。</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29&gt;</ph> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29&gt;</ph>を指定したバインディング属性を持つ型に属するメソッドのすべてを含む配列を取得します。</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>You can then iterate it to identify the duplicate methods named <ph id="ph1">`name`</ph>.</source>
          <target state="translated">反復処理するという名前の重複するメソッドを識別するために<ph id="ph1">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>This approach is illustrated in the previous example's handler for the <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
          <target state="translated">このアプローチは、前の例のハンドラーで説明されて、<ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph>例外。</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<ph id="ph2">&lt;xref:System.Object&gt;</ph>クラスの制約が存在しない場合。</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">ジェネリック メソッドの場合は含めないでください、型引数は<ph id="ph1">`name`</ph>します。</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">たとえば、c# コード<ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph>テキストの名前を持つメンバーを検索"<ph id="ph2">`MyMethod&lt;int&gt;`</ph>"、という名前のメソッドではなく<ph id="ph3">`MyMethod`</ph>型の 1 つのジェネリック引数を持つ<ph id="ph4">`int`</ph>します。</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The following example gets the method that matches the specified binding flags.</source>
          <target state="translated">次の例では、指定したバインディング フラグに一致するメソッドを取得します。</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The string containing the name of the public method to get.</source>
          <target state="translated">取得するパブリック メソッドの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">取得するメソッドのパラメーターの数、順序、および型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated">パラメーターをとらないメソッドを取得するための <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの空の配列 (<ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> フィールドで指定)。</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>Searches for the specified public method whose parameters match the specified argument types.</source>
          <target state="translated">指定したパブリック メソッドのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>An object representing the public method whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した引数型と一致するパラメーターが設定されたパブリック メソッドが存在する場合は、そのパブリック メソッドを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">検索<ph id="ph1">`name`</ph>小文字が区別されます。</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The search includes public static and public instance methods.</source>
          <target state="translated">検索には、static および public のパブリック インスタンス メソッドが含まれています。</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">呼び出すときにのみ、パラメーターを省略できます。</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<ph id="ph2">&lt;xref:System.Object&gt;</ph>クラスの制約が存在しない場合。</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The <ph id="ph1">`name`</ph> parameter cannot include type arguments.</source>
          <target state="translated"><ph id="ph1">`name`</ph>パラメーターは、型引数を含めることはできません。</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>For example, the C# code <ph id="ph1">`GetMethod("MyGenericMethod&lt;int&gt;")`</ph> searches for a method with the text name "<ph id="ph2">`MyGenericMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyGenericMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">たとえば、c# コード<ph id="ph1">`GetMethod("MyGenericMethod&lt;int&gt;")`</ph>テキストの名前を持つメソッドを検索"<ph id="ph2">`MyGenericMethod&lt;int&gt;`</ph>"、という名前のメソッドではなく<ph id="ph3">`MyGenericMethod`</ph>型の 1 つのジェネリック引数を持つ<ph id="ph4">`int`</ph>します。</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>Instead, use <ph id="ph1">`GetMethod("MyGenericMethod")`</ph> with the appropriate parameter in the <ph id="ph2">`types`</ph> array.</source>
          <target state="translated">代わりに、<ph id="ph1">`GetMethod("MyGenericMethod")`</ph>で適切なパラメーターを持つ、<ph id="ph2">`types`</ph>配列。</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The following example finds specific overloads of <ph id="ph1">`MethodA`</ph>, specifying a variety of argument types.</source>
          <target state="translated">次の例の特定のオーバー ロードを検索する<ph id="ph1">`MethodA`</ph>さまざまな引数の型を指定します。</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> example requires the <ph id="ph2">`/unsafe`</ph> compiler option.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>例が必要です、<ph id="ph2">`/unsafe`</ph>コンパイラ オプション。</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The following example retrieves <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects that represent the <ph id="ph2">`Add`</ph> methods  of a non-generic type (the <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> class), an open generic type (the <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class), and a closed generic type (the <ph id="ph5">`List(Of String)`</ph> type.</source>
          <target state="translated">次の例では取得<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>オブジェクトを表す、<ph id="ph2">`Add`</ph>非ジェネリック型のメソッド (、<ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph>クラス)、オープン ジェネリック型 (、<ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph>クラス)、およびクローズ ジェネリック型 (、<ph id="ph5">`List(Of String)`</ph>型です。</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The example defines a <ph id="ph1">`GetAddMethod`</ph> method that retrieves the appropriate <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">例では、定義、 <ph id="ph1">`GetAddMethod`</ph> 、適切なを取得するメソッド<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>To provide the <ph id="ph1">`types`</ph> argument for an open generic type, it calls the <ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">提供する、<ph id="ph1">`types`</ph>オープン ジェネリック型の引数を呼び出し、<ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>To provide the <ph id="ph1">`types`</ph> argument for a closed generic type, it retrieves the value of the <ph id="ph2">&lt;xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">提供する、<ph id="ph1">`types`</ph>クローズ ジェネリック型の引数は、の値を取得、<ph id="ph2">&lt;xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>More than one method is found with the specified name and specified parameters.</source>
          <target state="translated">指定された名前および指定されたパラメーターを持つメソッドが複数見つかりました。</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> の要素の 1 つが <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the public method to get.</source>
          <target state="translated">取得するパブリック メソッドの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">取得するメソッドのパラメーターの数、順序、および型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated">パラメーターをとらないメソッドを取得するための <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの空の配列 (<ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> フィールドで指定)。</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt> 型 <ept id="p1">&lt;/c&gt;</ept> 配列内の対応する要素に関連付けられている属性を表す <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated">COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">既定のバインダーでは、このパラメーターは処理されません。</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified public method whose parameters match the specified argument types and modifiers.</source>
          <target state="translated">指定したパブリック メソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the public method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">既定のバインダーが処理されませんが<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(、<ph id="ph2">`modifiers`</ph>パラメーター)、abstract を使用することができます<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>を処理することはカスタムのバインダーを記述するクラス<ph id="ph4">`modifiers`</ph>です。</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">検索<ph id="ph1">`name`</ph>小文字が区別されます。</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search includes public static and public instance methods.</source>
          <target state="translated">検索には、static および public のパブリック インスタンス メソッドが含まれています。</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">呼び出すときにのみ、パラメーターを省略できます。</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<ph id="ph2">&lt;xref:System.Object&gt;</ph>クラスの制約が存在しない場合。</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">ジェネリック メソッドの場合は含めないでください、型引数は<ph id="ph1">`name`</ph>します。</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the C# code <ph id="ph1">`GetMethod("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">たとえば、c# コード<ph id="ph1">`GetMethod("MyMethod&lt;int&gt;")`</ph>テキストの名前を持つメンバーを検索"<ph id="ph2">`MyMethod&lt;int&gt;`</ph>"、という名前のメソッドではなく<ph id="ph3">`MyMethod`</ph>型の 1 つのジェネリック引数を持つ<ph id="ph4">`int`</ph>します。</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Instead, use <ph id="ph1">`GetMethod("MyMethod")`</ph> with the appropriate parameter in the <ph id="ph2">`types`</ph> array.</source>
          <target state="translated">代わりに、<ph id="ph1">`GetMethod("MyMethod")`</ph>で適切なパラメーターを持つ、<ph id="ph2">`types`</ph>配列。</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and specified parameters.</source>
          <target state="translated">指定された名前および指定されたパラメーターを持つメソッドが複数見つかりました。</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> の要素の 1 つが <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">取得するメソッドの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> を使用する場合は、null 参照 (Visual Basic の場合は <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">取得するメソッドのパラメーターの数、順序、および型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated">パラメーターをとらないメソッドを取得するための <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの空の配列 (<ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> フィールドで指定)。</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt> 型 <ept id="p1">&lt;/c&gt;</ept> 配列内の対応する要素に関連付けられている属性を表す <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated">COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">既定のバインダーでは、このパラメーターは処理されません。</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">指定したバインディング制約を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">既定のバインダーが処理されませんが<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(、<ph id="ph2">`modifiers`</ph>パラメーター)、abstract を使用することができます<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>を処理することはカスタムのバインダーを記述するクラス<ph id="ph4">`modifiers`</ph>です。</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック メソッドを含める。</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include nonpublic methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索に含める非パブリック メソッド (つまり、プライベート、内部、および保護されたメソッド)、します。</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>に含める<ph id="ph2">`public`</ph>と<ph id="ph3">`protected`</ph>階層; の静的メンバー<ph id="ph4">`private`</ph>継承クラスの静的メンバーは含まれません。</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 小文字を区別しない<ph id="ph2">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されたメソッドのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたメソッドされません。</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">呼び出すときにのみ、パラメーターを省略できます。</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<ph id="ph2">&lt;xref:System.Object&gt;</ph>クラスの制約が存在しない場合。</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">ジェネリック メソッドの場合は含めないでください、型引数は<ph id="ph1">`name`</ph>します。</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">たとえば、c# コード<ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph>テキストの名前を持つメンバーを検索"<ph id="ph2">`MyMethod&lt;int&gt;`</ph>"、という名前のメソッドではなく<ph id="ph3">`MyMethod`</ph>型の 1 つのジェネリック引数を持つ<ph id="ph4">`int`</ph>します。</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example finds specific overloads of <ph id="ph1">`MethodA`</ph>, specifying binding constraints and a variety of argument types.</source>
          <target state="translated">次の例の特定のオーバー ロードを検索する<ph id="ph1">`MethodA`</ph>、バインディング制約と、さまざまな引数の型を指定します。</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> example requires the <ph id="ph2">`/unsafe`</ph> compiler option.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>例が必要です、<ph id="ph2">`/unsafe`</ph>コンパイラ オプション。</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> の要素の 1 つが <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">取得するメソッドの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> を使用する場合は、null 参照 (Visual Basic の場合は <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</source>
          <target state="translated">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップの方法に関する一連の規則を指定するオブジェクト。</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">取得するメソッドのパラメーターの数、順序、および型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated">パラメーターをとらないメソッドを取得するための <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの空の配列 (<ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> フィールドで指定)。</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt> 型 <ept id="p1">&lt;/c&gt;</ept> 配列内の対応する要素に関連付けられている属性を表す <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated">COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">既定のバインダーでは、このパラメーターは処理されません。</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">指定したバインディング制約および指定した呼び出し規則を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">既定のバインダーが処理されませんが<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(、<ph id="ph2">`modifiers`</ph>パラメーター)、abstract を使用することができます<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>を処理することはカスタムのバインダーを記述するクラス<ph id="ph4">`modifiers`</ph>です。</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`GetXXX`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`GetXXX`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック メソッドを含める。</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include nonpublic methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索に含める非パブリック メソッド (つまり、プライベート、内部、および保護されたメソッド)、します。</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>に含める<ph id="ph2">`public`</ph>と<ph id="ph3">`protected`</ph>階層; の静的メンバー<ph id="ph4">`private`</ph>継承クラスの静的メンバーは含まれません。</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 小文字を区別しない<ph id="ph2">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されたメソッドのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたメソッドされません。</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">呼び出すときにのみ、パラメーターを省略できます。</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<ph id="ph2">&lt;xref:System.Object&gt;</ph>クラスの制約が存在しない場合。</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">ジェネリック メソッドの場合は含めないでください、型引数は<ph id="ph1">`name`</ph>します。</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">たとえば、c# コード<ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph>テキストの名前を持つメンバーを検索"<ph id="ph2">`MyMethod&lt;int&gt;`</ph>"、という名前のメソッドではなく<ph id="ph3">`MyMethod`</ph>型の 1 つのジェネリック引数を持つ<ph id="ph4">`int`</ph>します。</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example finds specific overloads of <ph id="ph1">`MethodA`</ph>, specifying binding constraints, calling conventions, and a variety of argument types.</source>
          <target state="translated">次の例の特定のオーバー ロードを検索する<ph id="ph1">`MethodA`</ph>、バインディング制約を指定する、呼び出し規約、引数の型のさまざまなです。</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> example requires the <ph id="ph2">`/unsafe`</ph> compiler option.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>例が必要です、<ph id="ph2">`/unsafe`</ph>コンパイラ オプション。</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> の要素の 1 つが <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">取得するメソッドの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> を使用する場合は、null 参照 (Visual Basic の場合は <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</source>
          <target state="translated">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックをクリーンアップするプロセスに関する一連の規則を指定するオブジェクト。</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">取得するメソッドのパラメーターの数、順序、および型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</source>
          <target state="translated">パラメーターをとらないメソッドを取得するための、<ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列 (Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, arguments are not matched.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> が <ph id="ph1">&lt;see langword="null" /&gt;</ph> の場合、引数は一致していません。</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt> 型 <ept id="p1">&lt;/c&gt;</ept> 配列内の対応する要素に関連付けられている属性を表す <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">既定のバインダーでは、このパラメーターは処理されません。</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">派生クラスによってオーバーライドされた場合、指定したバインディング制約および指定した呼び出し規則を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">既定のバインダーが処理されませんが<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(、<ph id="ph2">`modifiers`</ph>パラメーター)、abstract を使用することができます<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>を処理することはカスタムのバインダーを記述するクラス<ph id="ph4">`modifiers`</ph>です。</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <ph id="ph1">`types`</ph> is <ph id="ph2">`null`</ph>, arguments are not matched.</source>
          <target state="translated"><ph id="ph1">`types`</ph> が<ph id="ph2">`null`</ph> の場合、引数は一致していません。</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック メソッドを含める。</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索に含める非パブリック メソッド (つまり、プライベート、内部、および保護されたメソッド)、します。</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>に含める<ph id="ph2">`public`</ph>と<ph id="ph3">`protected`</ph>階層; の静的メンバー<ph id="ph4">`private`</ph>継承クラスの静的メンバーは含まれません。</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 小文字を区別しない<ph id="ph2">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されたメソッドのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたメソッドされません。</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> と <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> の長さが異なります。</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The current type is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</source>
          <target state="translated">現在の型は、<ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> または <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the methods of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のメソッドを取得します。</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>Returns all the public methods of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のすべてのパブリック メソッドを返します。</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing all the public methods defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> に対して定義されているすべてのパブリック メソッドを表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, if no public methods are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> に対してパブリック メソッドが定義されていない場合は、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列。</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> method does not return methods in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph>メソッドで返されないメソッドを特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Your code must not depend on the order in which methods are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存、メソッドが返される順序のためする順序が異なります。</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Constructors are not included in the array of methods returned by this call.</source>
          <target state="translated">コンス トラクターは、この呼び出しによって返されるメソッドの配列には含まれません。</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Make a separate call to <ph id="ph1">`GetConstructors()`</ph> to get the constructor methods.</source>
          <target state="translated">別の呼び出しを行う<ph id="ph1">`GetConstructors()`</ph>コンス トラクター メソッドを取得します。</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`Get`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">呼び出すときにのみ、パラメーターを省略できます。</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>適切な型引数に置き換え、型パラメーターを持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<ph id="ph2">&lt;xref:System.Object&gt;</ph>クラスの制約が存在しない場合。</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the methods defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> に対して定義されているメソッドを検索します。</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing all methods defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> に対して定義されているメソッドのうち、指定したバインディング制約に一致するすべてのメソッドを表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, if no methods are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the defined methods match the binding constraints.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> に対してメソッドが定義されていないか、または定義されているメソッドの中にバインディング制約に一致するものが存在しない場合は、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列。</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> method does not return methods in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph>メソッドで返されないメソッドを特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which methods are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存、メソッドが返される順序のためする順序が異なります。</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック メソッドを含める。</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索に含める非パブリック メソッド (つまり、プライベート、内部、および保護されたメソッド)、します。</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</source>
          <target state="translated">のみ保護され、基本クラスの内部メソッドが返されます。基本クラスのプライベート メソッドは返されません。</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>に含める<ph id="ph2">`public`</ph>と<ph id="ph3">`protected`</ph>階層; の静的メンバー<ph id="ph4">`private`</ph>継承クラスの静的メンバーは含まれません。</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されたメソッドのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたメソッドされません。</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">呼び出すときにのみ、パラメーターを省略できます。</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>適切な型引数に置き換え、型パラメーターを持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターは、クラス制約のメソッドまたはのメソッドを検索<ph id="ph2">&lt;xref:System.Object&gt;</ph>クラスの制約が存在しない場合。</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The following example creates a class with two public methods and one protected method, creates a <ph id="ph1">`Type`</ph> object corresponding to <ph id="ph2">`MyTypeClass`</ph>, gets all public and non-public methods, and displays their names.</source>
          <target state="translated">次の例は、次の 2 つのパブリック メソッドと 1 つの保護されたメソッドを使用するクラスを作成、作成、<ph id="ph1">`Type`</ph>オブジェクトに対応する<ph id="ph2">`MyTypeClass`</ph>、すべてのパブリックと非パブリック メソッドを取得し、その名前を表示します。</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific type nested within the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 内で入れ子になっている特定の型を取得します。</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source>The string containing the name of the nested type to get.</source>
          <target state="translated">取得対象の入れ子にされた型の名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source>Searches for the public nested type with the specified name.</source>
          <target state="translated">指定した名前を持つ入れ子にされたパブリックな型を検索します。</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source>An object representing the public nested type with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した名前を持ち、入れ子にされたパブリックな型が存在する場合は、その型を表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">検索<ph id="ph1">`name`</ph>小文字が区別されます。</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Use the simple name of the nested class for <ph id="ph1">`name`</ph>.</source>
          <target state="translated">入れ子になったクラスの簡易名を使用して<ph id="ph1">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Do not qualify it with the name of the outer class.</source>
          <target state="translated">外側のクラスの名前では、修飾しません。</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic arguments.</source>
          <target state="translated">入れ子になったのジェネリック クラスの完全修飾名を使用して-は、アクサン グラーブと汎用引数の数を追加します。</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For example, use the string "Inner<ph id="ph1">\`</ph>1" to get the generic nested class <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">たとえば、文字列を使用して"内部<ph id="ph1">\`</ph>1"入れ子になったクラスをジェネリック<ph id="ph2">`Inner&lt;T&gt;`</ph>(<ph id="ph3">`Inner(Of T)`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Do not include language-specific syntax for type parameters.</source>
          <target state="translated">型パラメーターの言語固有の構文を含めないでください。</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`Get`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約の入れ子にされた型を検索します。</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">入れ子にされた型がジェネリックの場合、このメソッドは、そのジェネリック型定義を返します。</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">これは、外側のジェネリック型がクローズ構築型である場合でも当てはまります。</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>c#、Visual Basic、または C++ で定義されているジェネリック型を表す、独自のジェネリック パラメーターがあるない場合でも、その入れ子にされた型はすべてジェネリックです。</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">これは必ずしも動的アセンブリで定義されているかでコンパイルされた入れ子にされた型の場合は true ではありません、 <bpt id="p1">[</bpt>Ilasm.exe (IL アセンブラー)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">については、ジェネリック型定義から入れ子になったジェネリック型を構築して、入れ子になったジェネリック型で、次を参照してください。<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the nested type to get.</source>
          <target state="translated">取得対象の入れ子にされた型の名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</source>
          <target state="translated">派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、指定されている入れ子にされた型を検索します。</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the nested type that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した要件と一致し、入れ子にされた型が存在する場合は、その型を表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Use the simple name of the nested class for <ph id="ph1">`name`</ph>.</source>
          <target state="translated">入れ子になったクラスの簡易名を使用して<ph id="ph1">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Do not qualify it with the name of the outer class.</source>
          <target state="translated">外側のクラスの名前では、修飾しません。</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic parameters.</source>
          <target state="translated">入れ子になったのジェネリック クラスの完全修飾名を使用して-は、アクサン グラーブとジェネリック パラメーターの数を追加します。</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>For example, use the string "Inner<ph id="ph1">\`</ph>1" to get the generic nested class <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">たとえば、文字列を使用して"内部<ph id="ph1">\`</ph>1"入れ子になったクラスをジェネリック<ph id="ph2">`Inner&lt;T&gt;`</ph>(<ph id="ph3">`Inner(Of T)`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Do not include language-specific syntax for type parameters.</source>
          <target state="translated">型パラメーターの言語固有の構文を含めないでください。</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>フィルターを定義する入れ子になったフラグを使用することができますが、検索に含める型します。</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>を戻り値を取得します。</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> to include public nested types in the search.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>検索にパブリックな入れ子になった型を含める。</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>検索に含める非パブリックの入れ子にされた型 (つまり、プライベート、内部、および保護されている入れ子になった型)、します。</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This method returns only the nested types of the current type.</source>
          <target state="translated">このメソッドは、現在の型の入れ子にされた型のみを返します。</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>It does not search the base classes of the current type.</source>
          <target state="translated">現在の型の基本クラスを検索しません。</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <ph id="ph1">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> at each level.</source>
          <target state="translated">基本クラスに入れ子にされた型を呼び出し、継承階層を見つける必要があります<ph id="ph1">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>レベルごとにします。</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> are ignored.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> および<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>は無視されます。</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Calling this method with only the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> flag or only the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> flag will return the specified nested types and does not require any other flags.</source>
          <target state="translated">だけでは、このメソッドを呼び出し、<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>フラグまたはのみ、<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>フラグは、指定した入れ子になった型を必要し、しないその他の任意のフラグを返します。</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約の入れ子にされた型を検索します。</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">入れ子にされた型がジェネリックの場合、このメソッドは、そのジェネリック型定義を返します。</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">これは、外側のジェネリック型がクローズ構築型である場合でも当てはまります。</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>c#、Visual Basic、または C++ で定義されているジェネリック型を表す、独自のジェネリック パラメーターがあるない場合でも、その入れ子にされた型はすべてジェネリックです。</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">これは必ずしも動的アセンブリで定義されているかでコンパイルされた入れ子にされた型の場合は true ではありません、 <bpt id="p1">[</bpt>Ilasm.exe (IL アセンブラー)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">については、ジェネリック型定義から入れ子になったジェネリック型を構築して、入れ子になったジェネリック型で、次を参照してください。<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the types nested within the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 内で入れ子になっている型を取得します。</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes">
          <source>Returns the public types nested in the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 内で入れ子になっているすべてのパブリック型を返します。</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the public types nested in the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> (the search is not recursive), or an empty array of type <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> if no public types are nested in the current <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 内で入れ子になっているパブリック型を表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列 (検索は非再帰的)。または、現在の <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> で入れ子になっているパブリック型がない場合は、<ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列。</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> method does not return types in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>メソッドで返されないの種類を特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Your code must not depend on the order in which types are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存しません、型が返される順序のためオーダーが変化します。</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Only the public types immediately nested in the current type are returned; the search is not recursive.</source>
          <target state="translated">現在の型ですぐに入れ子にされたパブリック型のみが返されます。検索は、再帰的ではありません。</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`Get`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約の入れ子にされた型を検索します。</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">入れ子にされた型がジェネリックの場合、このメソッドは、そのジェネリック型定義を返します。</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">これは、外側のジェネリック型がクローズ構築型である場合でも当てはまります。</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>c#、Visual Basic、または C++ で定義されているジェネリック型を表す、独自のジェネリック パラメーターがあるない場合でも、その入れ子にされた型はすべてジェネリックです。</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">これは必ずしも動的アセンブリで定義されているかでコンパイルされた入れ子にされた型の場合は true ではありません、 <bpt id="p1">[</bpt>Ilasm.exe (IL アセンブラー)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">については、ジェネリック型定義から入れ子になったジェネリック型を構築して、入れ子になったジェネリック型で、次を参照してください。<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The following example defines a nested class and a <ph id="ph1">`struct`</ph> in <ph id="ph2">`MyClass`</ph>, and then obtains objects of the nested types using the type of <ph id="ph3">`MyClass`</ph>.</source>
          <target state="translated">次の例は、入れ子になったクラスを定義し、<ph id="ph1">`struct`</ph>で<ph id="ph2">`MyClass`</ph>の型を使用して入れ子にされた型のオブジェクトを取得し、<ph id="ph3">`MyClass`</ph>です。</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the types nested in the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 内で入れ子になっている型を検索します。</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing all the types nested in the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints (the search is not recursive), or an empty array of type <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>, if no nested types are found that match the binding constraints.</source>
          <target state="translated">指定したバインディング制約と一致する現在の <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> で入れ子にされたすべての型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列 (検索は非再帰的)。または、バインディング制約と一致する入れ子にされた型が見つからない場合は、<ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列。</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The search for nested types is not recursive.</source>
          <target state="translated">入れ子にされた型の検索は、再帰的ではありません。</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> method does not return types in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>メソッドで返されないの種類を特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which types are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存しません、型が返される順序のためオーダーが変化します。</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>フィルターを定義する入れ子になったフラグを使用することができますが、検索に含める型します。</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>を戻り値を取得します。</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> to include public nested types in the search.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>検索にパブリックな入れ子になった型を含める。</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>検索に含める非パブリックの入れ子にされた型 (つまり、プライベート、内部、および保護されている入れ子になった型)、します。</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This method returns only the nested types of the current type.</source>
          <target state="translated">このメソッドは、現在の型の入れ子にされた型のみを返します。</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>It does not search the base classes of the current type.</source>
          <target state="translated">現在の型の基本クラスを検索しません。</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> at each level.</source>
          <target state="translated">基本クラスに入れ子にされた型を呼び出し、継承階層を見つける必要があります<ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>レベルごとにします。</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> are ignored.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> および<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>は無視されます。</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Calling this method with only the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> flag or only the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> flag will return the specified nested types and does not require any other flags.</source>
          <target state="translated">だけでは、このメソッドを呼び出し、<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>フラグまたはのみ、<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>フラグは、指定した入れ子になった型を必要し、しないその他の任意のフラグを返します。</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約の入れ子にされた型を検索します。</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">入れ子にされた型がジェネリックの場合、このメソッドは、そのジェネリック型定義を返します。</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">これは、外側のジェネリック型がクローズ構築型である場合でも当てはまります。</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>c#、Visual Basic、または C++ で定義されているジェネリック型を表す、独自のジェネリック パラメーターがあるない場合でも、その入れ子にされた型はすべてジェネリックです。</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">これは必ずしも動的アセンブリで定義されているかでコンパイルされた入れ子にされた型の場合は true ではありません、 <bpt id="p1">[</bpt>Ilasm.exe (IL アセンブラー)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">については、ジェネリック型定義から入れ子になったジェネリック型を構築して、入れ子になったジェネリック型で、次を参照してください。<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</source>
          <target state="translated">次の例では、2 つの入れ子になったパブリック クラスと 2 つの入れ子になったプロテクト クラスを作成し、指定したバインディング制約に一致するクラスの情報を表示します。</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the properties of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のプロパティを取得します。</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>Returns all the public properties of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のすべてのパブリック プロパティを返します。</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> objects representing all public properties of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> のすべてのパブリック プロパティを表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have public properties.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> にパブリック プロパティが存在しない場合は、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列。</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Calling this overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29&gt;</ph> overload with a <ph id="ph2">`bindingAttr`</ph> argument equal to <ph id="ph3">`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`</ph> in C# and  <ph id="ph4">`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`</ph> in Visual Basic.</source>
          <target state="translated">呼び出すことと同じではこのオーバー ロードを呼び出して、<ph id="ph1">&lt;xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29&gt;</ph>を持つオーバー ロード、<ph id="ph2">`bindingAttr`</ph>引数と等しい<ph id="ph3">`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`</ph>C# の場合と<ph id="ph4">`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`</ph>Visual Basic でします。</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>It returns all public instance and static properties, both those defined by the type represented by the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object as well as those inherited from its base types.</source>
          <target state="translated">すべてのパブリック インスタンスと、現在によって表される型で定義されている両方の静的なプロパティを返します<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクトだけでなく、その基本型から継承します。</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (Visual basic での結合を使用して値<ph id="ph4">`Or`</ph>) それを取得します。</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> method does not return properties in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph>メソッドで返されないプロパティを特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Your code must not depend on the order in which properties are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存しません、プロパティが返される順序のためオーダーが変化します。</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`Get`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>適切な型引数に置き換え、型パラメーターを持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The following example demonstrates the use of the <ph id="ph1">`GetProperties`</ph> method.</source>
          <target state="translated"><ph id="ph1">`GetProperties`</ph> メソッドの使用例を次に示します。</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the properties of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のプロパティを検索します。</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> objects representing all properties of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> のプロパティのうち、指定したバインディング制約に一致するすべてのプロパティを表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have properties, or if none of the properties match the binding constraints.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> にプロパティが設定されていないか、またはプロパティの中でバインディング制約に一致するものが存在しない場合は、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列。</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (Visual basic での結合を使用して値<ph id="ph4">`Or`</ph>) それを取得します。</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> method does not return properties in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph>メソッドで返されないプロパティを特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which properties are returned, because that order varies.</source>
          <target state="translated">コードする必要がありますに依存しません、プロパティが返される順序のためオーダーが変化します。</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>フィルターを定義する入れ子になったフラグを使用することができますが、検索に含める型します。</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック プロパティを含めます。</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>非パブリック プロパティ (つまり、プライベート、内部、および保護されたプロパティ) を検索に含めます。</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</source>
          <target state="translated">のみ保護され、基本クラスの内部プロパティが返されます。基本クラスのプライベート プロパティは返されません。</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>に含める<ph id="ph2">`public`</ph>と<ph id="ph3">`protected`</ph>階層; の静的メンバー<ph id="ph4">`private`</ph>継承クラスの静的メンバーは含まれません。</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されたプロパティのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたプロパティされません。</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (Visual basic での結合を使用して値<ph id="ph4">`Or`</ph>) それを取得します。</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">かどうか、現在は、構築されたジェネリック型を表す、このメソッドが戻る、<ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>適切な型引数に置き換え、型パラメーターを持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The following example defines a class named <ph id="ph1">`PropertyClass`</ph> that includes six properties: two are public, one is private, one is protected, one is internal (<ph id="ph2">`Friend`</ph> in Visual Basic), and one is protected internal (<ph id="ph3">`Protected Friend`</ph> in Visual Basic).</source>
          <target state="translated">次の例は、という名前のクラスを定義<ph id="ph1">`PropertyClass`</ph>6 つのプロパティを含む: 2 つはパブリック、1 つは、プライベート、いずれかが保護されている、1 つは内部 (<ph id="ph2">`Friend`</ph> Visual Basic で)、いずれかが保護されている内部および (<ph id="ph3">`Protected Friend`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its <ph id="ph1">`get`</ph> and <ph id="ph2">`set`</ph> accessors) for the properties that match the specified binding constraints.</source>
          <target state="translated">いくつかの基本的なプロパティの情報を表示します (プロパティの名前と種類、かどうかは読み取り/書き込み、およびの可視性、<ph id="ph1">`get`</ph>と<ph id="ph2">`set`</ph>アクセサー) の指定したバインディング制約に一致するプロパティです。</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific property of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の特定のプロパティを取得します。</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">取得するパブリック プロパティの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>Searches for the public property with the specified name.</source>
          <target state="translated">指定した名前のパブリック プロパティを検索します。</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>An object representing the public property with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した名前のパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">検索<ph id="ph1">`name`</ph>小文字が区別されます。</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">検索には、static および public のパブリック インスタンス プロパティが含まれています。</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (Visual basic での結合を使用して値<ph id="ph4">`Or`</ph>) それを取得します。</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Situations in which <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> occurs include the following:</source>
          <target state="translated">場合に、<ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph>が発生した、次のとおりです。</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>A type contains two indexed properties that have the same name but different numbers of parameters.</source>
          <target state="translated">型には 2 つが同じであるインデックス付きプロパティの名前が異なる数のパラメーターです。</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>To resolve the ambiguity, use an overload of the <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> method that specifies parameter types.</source>
          <target state="translated">あいまいさを解決するには、オーバー ロードを使用して、<ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph>パラメーターの型を指定するメソッド。</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>A derived type declares a property that hides an inherited property with the same name, by using the <ph id="ph1">`new`</ph> modifier (<ph id="ph2">`Shadows`</ph> in Visual Basic).</source>
          <target state="translated">派生型を使用して、同じ名前を持つ継承されたプロパティを非表示にするプロパティを宣言する、<ph id="ph1">`new`</ph>修飾子 (<ph id="ph2">`Shadows`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>To resolve the ambiguity, use the <ph id="ph1">&lt;xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method overload and add the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> flag to restrict the search to members that are not inherited.</source>
          <target state="translated">あいまいさを解決するを使用して、<ph id="ph1">&lt;xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph>メソッド オーバー ロードを追加、<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph>継承されていないメンバーに、検索を制限するフラグ。</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Indexers and Default Properties</source>
          <target state="translated">インデクサーと既定のプロパティ</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>、 <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>、および<ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph>インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">たとえば場合、変数<ph id="ph1">`myList`</ph>を指す、 <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>、構文<ph id="ph3">`myList[3]`</ph>(<ph id="ph4">`myList(3)`</ph> Visual Basic で) 3 のインデックスを持つ要素を取得します。</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>You can overload the property.</source>
          <target state="translated">プロパティはオーバー ロードすることができます。</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">C# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">既定では、c# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">ただし、開発者はクラス ライブラリを使用して、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph>メタデータのインデクサーの名前を変更する属性。</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">たとえば、<ph id="ph1">&lt;xref:System.String&gt;</ph>クラスという名前のインデクサーには、<ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">型が既定のプロパティを持つかどうかを確認するには<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph>をテストするメソッド、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">型が<ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph>プロパティが既定のプロパティの名前を返します。</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>The following example retrieves the <ph id="ph1">`Type`</ph> object of a user-defined class, retrieves a property of that class, and displays the property name.</source>
          <target state="translated">次の例では取得、<ph id="ph1">`Type`</ph>ユーザー定義のクラスのオブジェクトが、そのクラスのプロパティを取得し、プロパティ名を表示します。</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Internally, this property is referred to in the metadata by the name "Item."</source>
          <target state="translated">内部的には、このプロパティは、メタデータ内で参照名「項目」</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Any attempt to get <ph id="ph1">`PropertyInfo`</ph> using reflection must specify this internal name in order to correctly return the <ph id="ph2">`PropertyInfo`</ph> property.</source>
          <target state="translated">取得しようとすると<ph id="ph1">`PropertyInfo`</ph>リフレクションを使用して正しくを返すためにこの内部名を指定する必要があります、<ph id="ph2">`PropertyInfo`</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>More than one property is found with the specified name.</source>
          <target state="translated">指定した名前のプロパティが複数個見つかりました。</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the property to get.</source>
          <target state="translated">取得するプロパティの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified property, using the specified binding constraints.</source>
          <target state="translated">指定されたバインディング制約を使用して、指定されたプロパティを検索します。</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した要件と一致するプロパティが存在する場合は、そのプロパティを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (Visual basic での結合を使用して値<ph id="ph4">`Or`</ph>) それを取得します。</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>検索に含めるプロパティを定義するフィルター フラグを使用できます。</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック プロパティを含めます。</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>非パブリック プロパティ (つまり、プライベート、内部、および保護されたプロパティ) を検索に含めます。</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>に含める<ph id="ph2">`public`</ph>と<ph id="ph3">`protected`</ph>階層; の静的メンバー<ph id="ph4">`private`</ph>継承クラスの静的メンバーは含まれません。</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 小文字を区別しない<ph id="ph2">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されたプロパティのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたプロパティされません。</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Situations in which <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> occurs include the following:</source>
          <target state="translated">場合に、<ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph>が発生した、次のとおりです。</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A type contains two indexed properties that have the same name but different numbers of parameters.</source>
          <target state="translated">型には 2 つが同じであるインデックス付きプロパティの名前が異なる数のパラメーターです。</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>To resolve the ambiguity, use an overload of the <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> method that specifies parameter types.</source>
          <target state="translated">あいまいさを解決するには、オーバー ロードを使用して、<ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph>パラメーターの型を指定するメソッド。</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A derived type declares a property that hides an inherited property with the same name, using the <ph id="ph1">`new`</ph> modifier (<ph id="ph2">`Shadows`</ph> in Visual Basic).</source>
          <target state="translated">派生型が、同じ名前を持つ継承されたプロパティを非表示にするプロパティを宣言を使用して、<ph id="ph1">`new`</ph>修飾子 (<ph id="ph2">`Shadows`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>To resolve the ambiguity, include <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> to restrict the search to members that are not inherited.</source>
          <target state="translated">あいまいさを解決するには、含める<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph>継承されていないメンバーへの検索を制限します。</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Indexers and Default Properties</source>
          <target state="translated">インデクサーと既定のプロパティ</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>、 <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>、および<ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph>インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">たとえば場合、変数<ph id="ph1">`myList`</ph>を指す、 <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>、構文<ph id="ph3">`myList[3]`</ph>(<ph id="ph4">`myList(3)`</ph> Visual Basic で) 3 のインデックスを持つ要素を取得します。</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>You can overload the property.</source>
          <target state="translated">プロパティはオーバー ロードすることができます。</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">C# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">既定では、c# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">ただし、開発者はクラス ライブラリを使用して、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph>メタデータのインデクサーの名前を変更する属性。</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">たとえば、<ph id="ph1">&lt;xref:System.String&gt;</ph>クラスという名前のインデクサーには、<ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">型が既定のプロパティを持つかどうかを確認するには<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph>をテストするメソッド、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">型が<ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph>プロパティが既定のプロパティの名前を返します。</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</source>
          <target state="translated">次の例は、ユーザー定義のクラスの型を取得、そのクラスのプロパティを取得し、指定したバインディング制約に一致するプロパティ名を表示します。</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">指定された名前を持ち、指定されたバインディング制約に一致する 2 つ以上のプロパティが存在します。</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">取得するパブリック プロパティの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The return type of the property.</source>
          <target state="translated">プロパティの戻り値の型。</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Searches for the public property with the specified name and return type.</source>
          <target state="translated">指定した名前および戻り値の型を持つパブリック プロパティを検索します。</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>An object representing the public property with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した名前のパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (Visual basic での結合を使用して値<ph id="ph4">`Or`</ph>) それを取得します。</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">検索<ph id="ph1">`name`</ph>小文字が区別されます。</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">検索には、static および public のパブリック インスタンス プロパティが含まれています。</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Indexers and Default Properties</source>
          <target state="translated">インデクサーと既定のプロパティ</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>、 <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>、および<ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph>インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">たとえば場合、変数<ph id="ph1">`myList`</ph>を指す、 <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>、構文<ph id="ph3">`myList[3]`</ph>(<ph id="ph4">`myList(3)`</ph> Visual Basic で) 3 のインデックスを持つ要素を取得します。</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>You can overload the property.</source>
          <target state="translated">プロパティはオーバー ロードすることができます。</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">C# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">既定では、c# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">ただし、開発者はクラス ライブラリを使用して、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph>メタデータのインデクサーの名前を変更する属性。</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">たとえば、<ph id="ph1">&lt;xref:System.String&gt;</ph>クラスという名前のインデクサーには、<ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">型が既定のプロパティを持つかどうかを確認するには<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph>をテストするメソッド、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">型が<ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph>プロパティが既定のプロパティの名前を返します。</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The following example defines a class with one property and retrieves the name and type of the property.</source>
          <target state="translated">次の例では、1 つのプロパティを持つクラスを定義し、名前およびプロパティの型を取得します。</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>More than one property is found with the specified name.</source>
          <target state="translated">指定した名前のプロパティが複数個見つかりました。</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="returnType" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>、<ph id="ph2">&lt;see langword="null" /&gt;</ph>、または <ph id="ph3">&lt;paramref name="returnType" /&gt;</ph> が <ph id="ph4">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">取得するパブリック プロパティの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">インデックス付けされていないプロパティを取得するための、<ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列 (Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Searches for the specified public property whose parameters match the specified argument types.</source>
          <target state="translated">指定したパブリック プロパティのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An object representing the public property whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した引数型と一致するパラメーターが設定されているパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (Visual basic での結合を使用して値<ph id="ph4">`Or`</ph>) それを取得します。</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">検索<ph id="ph1">`name`</ph>小文字が区別されます。</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">検索には、static および public のパブリック インスタンス プロパティが含まれています。</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">インデクサーと既定のプロパティ</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>、 <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>、および<ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph>インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">たとえば場合、変数<ph id="ph1">`myList`</ph>を指す、 <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>、構文<ph id="ph3">`myList[3]`</ph>(<ph id="ph4">`myList(3)`</ph> Visual Basic で) 3 のインデックスを持つ要素を取得します。</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>You can overload the property.</source>
          <target state="translated">プロパティはオーバー ロードすることができます。</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">C# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">既定では、c# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">ただし、開発者はクラス ライブラリを使用して、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph>メタデータのインデクサーの名前を変更する属性。</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">たとえば、<ph id="ph1">&lt;xref:System.String&gt;</ph>クラスという名前のインデクサーには、<ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">型が既定のプロパティを持つかどうかを確認するには<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph>をテストするメソッド、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">型が<ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph>プロパティが既定のプロパティの名前を返します。</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The following example retrieves the <ph id="ph1">`Type`</ph> object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to <ph id="ph2">`GetProperty`</ph>.</source>
          <target state="translated">次の例では取得、<ph id="ph1">`Type`</ph>ユーザー定義のクラスのオブジェクトが、そのクラスのプロパティを取得しに渡される引数で指定されたプロパティの名前とプロパティの型を表示<ph id="ph2">`GetProperty`</ph>です。</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>More than one property is found with the specified name and matching the specified argument types.</source>
          <target state="translated">指定した名前を持ち引数の型が一致する複数のプロパティが存在します。</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> の要素は <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">取得するパブリック プロパティの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The return type of the property.</source>
          <target state="translated">プロパティの戻り値の型。</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">インデックス付けされていないプロパティを取得するための、<ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列 (Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Searches for the specified public property whose parameters match the specified argument types.</source>
          <target state="translated">指定したパブリック プロパティのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An object representing the public property whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した引数型と一致するパラメーターが設定されているパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (Visual basic での結合を使用して値<ph id="ph4">`Or`</ph>) それを取得します。</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">検索<ph id="ph1">`name`</ph>小文字が区別されます。</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">検索には、static および public のパブリック インスタンス プロパティが含まれています。</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">インデクサーと既定のプロパティ</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>、 <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>、および<ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph>インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">たとえば場合、変数<ph id="ph1">`myList`</ph>を指す、 <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>、構文<ph id="ph3">`myList[3]`</ph>(<ph id="ph4">`myList(3)`</ph> Visual Basic で) 3 のインデックスを持つ要素を取得します。</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>You can overload the property.</source>
          <target state="translated">プロパティはオーバー ロードすることができます。</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">C# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">既定では、c# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">ただし、開発者はクラス ライブラリを使用して、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph>メタデータのインデクサーの名前を変更する属性。</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">たとえば、<ph id="ph1">&lt;xref:System.String&gt;</ph>クラスという名前のインデクサーには、<ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">型が既定のプロパティを持つかどうかを確認するには<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph>をテストするメソッド、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">型が<ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph>プロパティが既定のプロパティの名前を返します。</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>More than one property is found with the specified name and matching the specified argument types.</source>
          <target state="translated">指定した名前を持ち引数の型が一致する複数のプロパティが存在します。</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> の要素は <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">取得するパブリック プロパティの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">プロパティの戻り値の型。</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">インデックス付けされていないプロパティを取得するための、<ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列 (Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt> 型 <ept id="p1">&lt;/c&gt;</ept> 配列内の対応する要素に関連付けられている属性を表す <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">既定のバインダーでは、このパラメーターは処理されません。</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified public property whose parameters match the specified argument types and modifiers.</source>
          <target state="translated">指定したパブリック プロパティのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the public property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した要件と一致するパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (Visual basic での結合を使用して値<ph id="ph4">`Or`</ph>) それを取得します。</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">既定のバインダーが処理されませんが<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(、<ph id="ph2">`modifiers`</ph>パラメーター)、abstract を使用することができます<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>を処理することはカスタムのバインダーを記述するクラス<ph id="ph4">`modifiers`</ph>です。</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">検索<ph id="ph1">`name`</ph>小文字が区別されます。</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">検索には、static および public のパブリック インスタンス プロパティが含まれています。</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">インデクサーと既定のプロパティ</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>、 <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>、および<ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph>インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">たとえば場合、変数<ph id="ph1">`myList`</ph>を指す、 <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>、構文<ph id="ph3">`myList[3]`</ph>(<ph id="ph4">`myList(3)`</ph> Visual Basic で) 3 のインデックスを持つ要素を取得します。</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can overload the property.</source>
          <target state="translated">プロパティはオーバー ロードすることができます。</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">C# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">既定では、c# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">ただし、開発者はクラス ライブラリを使用して、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph>メタデータのインデクサーの名前を変更する属性。</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">たとえば、<ph id="ph1">&lt;xref:System.String&gt;</ph>クラスという名前のインデクサーには、<ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">型が既定のプロパティを持つかどうかを確認するには<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph>をテストするメソッド、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">型が<ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph>プロパティが既定のプロパティの名前を返します。</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example obtains a <ph id="ph1">`Type`</ph> object corresponding to <ph id="ph2">`MyPropertyClass`</ph>, and the indexed property of this class is retrieved using the arguments passed to the <ph id="ph3">`GetProperty`</ph> method.</source>
          <target state="translated">次の例では取得、<ph id="ph1">`Type`</ph>オブジェクトに対応する<ph id="ph2">`MyPropertyClass`</ph>に渡される引数を使用して、このクラスのインデックス付きプロパティを取得し、<ph id="ph3">`GetProperty`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one property is found with the specified name and matching the specified argument types and modifiers.</source>
          <target state="translated">指定された名前を持ち、指定された引数の型および修飾子に一致する 2 つ以上のプロパティが存在します。</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> と <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> の長さが異なります。</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> の要素は <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the property to get.</source>
          <target state="translated">取得するプロパティの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> を使用する場合は、null 参照 (Visual Basic の場合は <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">プロパティの戻り値の型。</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">インデックス付けされていないプロパティを取得するための、<ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列 (Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt> 型 <ept id="p1">&lt;/c&gt;</ept> 配列内の対応する要素に関連付けられている属性を表す <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">既定のバインダーでは、このパラメーターは処理されません。</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">指定したバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定された指定のプロパティを検索します。</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した要件と一致するプロパティが存在する場合は、そのプロパティを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">プロパティは公開されている、少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (Visual basic での結合を使用して値<ph id="ph4">`Or`</ph>) それを取得します。</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">既定のバインダーが処理されませんが<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(、<ph id="ph2">`modifiers`</ph>パラメーター)、abstract を使用することができます<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>を処理することはカスタムのバインダーを記述するクラス<ph id="ph4">`modifiers`</ph>です。</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`Get`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>検索に含めるプロパティを定義するフィルター フラグを使用できます。</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック プロパティを含めます。</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>非パブリック プロパティ (つまり、プライベート、内部、および保護されたプロパティ) を検索に含めます。</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>に含める<ph id="ph2">`public`</ph>と<ph id="ph3">`protected`</ph>階層; の静的メンバー<ph id="ph4">`private`</ph>継承クラスの静的メンバーは含まれません。</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 小文字を区別しない<ph id="ph2">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されたプロパティのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたプロパティされません。</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このメソッドが戻るが構築ジェネリック型を表す、<ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>型パラメーターを適切な型引数によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">インデクサーと既定のプロパティ</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>、 <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>、および<ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph>インデックス付きプロパティにアクセスするための構文を単純化し、その型の既定値である 1 つのインデックス付きプロパティを許可します。</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">たとえば場合、変数<ph id="ph1">`myList`</ph>を指す、 <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>、構文<ph id="ph3">`myList[3]`</ph>(<ph id="ph4">`myList(3)`</ph> Visual Basic で) 3 のインデックスを持つ要素を取得します。</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can overload the property.</source>
          <target state="translated">プロパティはオーバー ロードすることができます。</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">C# の場合は、この機能は、インデクサーが呼び出された、名前によって参照にすることはできません。</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">既定では、c# のインデクサーに表示されますメタデータ"Item"という名前のインデックス付きプロパティとして。</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">ただし、開発者はクラス ライブラリを使用して、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph>メタデータのインデクサーの名前を変更する属性。</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">たとえば、<ph id="ph1">&lt;xref:System.String&gt;</ph>クラスという名前のインデクサーには、<ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もを持つことができます。</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">型が既定のプロパティを持つかどうかを確認するには<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph>をテストするメソッド、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">型が<ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>、<ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph>プロパティが既定のプロパティの名前を返します。</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">指定された名前を持ち、指定されたバインディング制約に一致する 2 つ以上のプロパティが存在します。</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> と <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> の長さが異なります。</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> の要素は <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the property to get.</source>
          <target state="translated">取得するプロパティの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> を返す 0。</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメンバーの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> を使用する場合は、null 参照 (Visual Basic の場合は <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">プロパティの戻り値の型。</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">インデックス付けされていないプロパティを取得するための、<ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列 (Type[] types = new Type[0])。</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt> 型 <ept id="p1">&lt;/c&gt;</ept> 配列内の対応する要素に関連付けられている属性を表す <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">既定のバインダーでは、このパラメーターは処理されません。</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">派生クラス内でオーバーライドされるときに、指定のバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されたプロパティを検索します。</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した要件と一致するプロパティが存在する場合は、そのプロパティを表すオブジェクト。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">既定のバインダーが処理されませんが<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>(、<ph id="ph2">`modifiers`</ph>パラメーター)、abstract を使用することができます<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>を処理することはカスタムのバインダーを記述するクラス<ph id="ph4">`modifiers`</ph>です。</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>検索に含めるプロパティを定義するフィルター フラグを使用できます。</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">どちらかを指定する必要があります<ph id="ph1">`BindingFlags.Instance`</ph>または<ph id="ph2">`BindingFlags.Static`</ph>戻り値を取得するためにします。</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック プロパティを含めます。</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>非パブリック プロパティ (つまり、プライベート、内部、および保護されたプロパティ) を検索に含めます。</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>に含める<ph id="ph2">`public`</ph>と<ph id="ph3">`protected`</ph>階層; の静的メンバー<ph id="ph4">`private`</ph>継承クラスの静的メンバーは含まれません。</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 小文字を区別しない<ph id="ph2">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されたプロパティのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたプロパティされません。</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">指定された名前を持ち、指定されたバインディング制約に一致する 2 つ以上のプロパティが存在します。</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> の要素の 1 つが <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> が多次元です。</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> と <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> の長さが異なります。</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The current type is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.EnumBuilder" /&gt;</ph>, or <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</source>
          <target state="translated">現在の型は、<ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>、<ph id="ph2">&lt;see cref="T:System.Reflection.Emit.EnumBuilder" /&gt;</ph>、または <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the specified type.</source>
          <target state="translated">指定された型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトを取得します。</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" uid="M:System.Type.GetType">
          <source>Gets the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> を取得します。</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" uid="M:System.Type.GetType">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" uid="M:System.Type.GetType">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">クラス初期化子が呼び出され、例外をスローします。</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The assembly-qualified name of the type to get.</source>
          <target state="translated">取得する型のアセンブリ修飾名。</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</source>
          <target state="translated">「<ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">型が現在実行中のアセンブリまたは Mscorlib.dll 内にある場合は、名前空間で修飾された型名を指定するだけで十分です。</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, performing a case-sensitive search.</source>
          <target state="translated">大文字と小文字を区別する検索を実行して、指定した名前の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> を取得します。</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The type with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">存在する場合は、指定した名前を持つ型。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if you know its namespace-qualified name.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>を取得するメソッド、<ph id="ph2">&lt;xref:System.Type&gt;</ph>名前空間で修飾された名前がわかっている場合は、別のアセンブリ内の型のオブジェクトします。</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 指定されたアセンブリの読み込みを発生させます<ph id="ph2">`typeName`</ph>です。</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated">使用してアセンブリを読み込むことも、<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>メソッド、およびしを使用して、<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph>のメソッド、<ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph>クラスを取得する<ph id="ph5">&lt;xref:System.Type&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or  in C++.</source>
          <target state="translated">C# の場合は、使用する方が効率的では、型がコンパイル時に、プログラムを既知のアセンブリ内にある場合は、 <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> Visual Basic、または C++ です。</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If <ph id="ph1">`typeName`</ph> cannot be found, the call to the <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%29&gt;</ph> method returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">場合<ph id="ph1">`typeName`</ph>が見つからないことを呼び出し、<ph id="ph2">&lt;xref:System.Type.GetType%28System.String%29&gt;</ph>メソッドを返します。<ph id="ph3">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>It does not throw an exception.</source>
          <target state="translated">例外はスローされません。</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To control whether an exception is thrown, call an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that has a <ph id="ph2">`throwOnError`</ph> parameter.</source>
          <target state="translated">制御するかどうか、例外がスローされますのオーバー ロードを呼び出して、<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>メソッドが、<ph id="ph2">`throwOnError`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> only works on assemblies loaded from disk.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> ディスクから読み込まれるアセンブリでのみ機能します。</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If you call <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
          <target state="translated">呼び出す場合<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>を使用して定義された動的アセンブリで定義された型を検索する、 <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, 一貫性のない動作を取得する可能性があります。</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">動作するかどうか、動的はアセンブリが、永続的なによって異なりますを使用して作成、<ph id="ph1">`RunAndSave`</ph>または<ph id="ph2">`Save`</ph>アクセスのモード、<ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph>列挙します。</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
          <target state="translated">かどうか、動的アセンブリが永続的なとが前にディスクに書き込まれた<ph id="ph1">`GetType`</ph>が呼び出されると、ローダー ディスク上の保存されたアセンブリを検索、そのアセンブリが読み込まれ、そのアセンブリから型を取得します。</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">アセンブリがディスクに保存されていない場合<ph id="ph1">`GetType`</ph>が呼び出されると、このメソッドを返します<ph id="ph2">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> 一時動的アセンブリ; は理解していませんそのため、<ph id="ph2">`GetType`</ph>動的アセンブリを返しますを一時的に型を取得する<ph id="ph3">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
          <target state="translated">使用する<ph id="ph1">`GetType`</ph>動的モジュールのサブスクライブ、<ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph>イベントと呼び出し<ph id="ph3">`GetType`</ph>保存する前にします。</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
          <target state="translated">それ以外の場合、メモリ内アセンブリの 2 つのコピーが表示されます。</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`Get`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
          <target state="translated">配列または COM 型は検索されませんの使用可能なクラスのテーブルに読み込まれていない限り、します。</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
          <target state="translated"><ph id="ph1">`typeName`</ph> 型名で修飾できます、名前空間またはアセンブリ修飾名はアセンブリ名の指定が含まれています。</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">「<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
          <target state="translated">場合<ph id="ph1">`typeName`</ph>には、名前空間が、アセンブリ名ではなく、このメソッドは、呼び出し元のオブジェクトのアセンブリと、Mscorlib.dll のみがこの順序で検索します。</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
          <target state="translated">TypeName は、部分的または完全なアセンブリ名を持つ完全に修飾されている場合、このメソッドは、指定したアセンブリで検索します。</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
          <target state="translated">アセンブリの厳密な名前が、アセンブリの完全名が必要です。</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>プロパティは入れ子にされた型、アセンブリ名、およびジェネリック型引数を含む完全修飾型名を返します。</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">共通言語ランタイムをサポートするすべてのコンパイラでは、入れ子になったクラスの簡易名を出力し、リフレクションは、次の規則に従って、照会されたときに、完全修飾名を構築します。</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">.NET Framework version 2.0 では、プロセッサのアーキテクチャは、アセンブリ id に追加され、アセンブリ名の文字列の一部として指定できます。</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">たとえば、"ProcessorArchitecture = msil"です。</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">ただし、これが含まれていませんによって返される文字列で、<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>互換性のためのプロパティです。</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">作成することで、型を読み込むことも、<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>オブジェクトとの適切なオーバー ロードに渡す、<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method to load types from the assembly.</source>
          <target state="translated">使用してできます、<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>アセンブリから型のメソッドを読み込めません。</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">「<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>」も参照してください。</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Delimiter</source>
          <target state="translated">区切り記号</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Meaning</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">円記号 (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Escape character.</source>
          <target state="translated">文字をエスケープします。</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Backtick (`)</source>
          <target state="translated">バッククォート (')</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
          <target state="translated">ジェネリック型の名前の末尾にある、型パラメーターの数を表す 1 つ以上の数字を先頭に付きます。</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Brackets ([])</source>
          <target state="translated">角かっこ ()</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
          <target state="translated">構築されたジェネリック型のジェネリック型引数リストを囲む型引数リスト内で、アセンブリ修飾型を囲みます。</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Comma (,)</source>
          <target state="translated">コンマ (,)</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Precedes the Assembly name.</source>
          <target state="translated">アセンブリ名の前にします。</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Period (.)</source>
          <target state="translated">ピリオド (.)</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">名前空間の識別子を表します。</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Plus sign (+)</source>
          <target state="translated">プラス記号 (+)</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Precedes a nested class.</source>
          <target state="translated">入れ子になったクラスが前に付きます。</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, the fully qualified name for a class might look like this:</source>
          <target state="translated">たとえば、クラスの完全修飾名は、次のようになります。</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">名前空間が TopNamespace.Sub+Namespace としている場合、文字列がエスケープ文字をプラス記号 (+) を前に指定する必要があります (<ph id="ph1">\\</ph>)、入れ子の区切り記号として解釈されないようにします。</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Reflection emits this string as follows:</source>
          <target state="translated">リフレクションでは、次のようにこの文字列を生成します。</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">この修飾名を永続化し、読み込みに使用された後で、<ph id="ph1">&lt;xref:System.Type&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">検索して読み込む、<ph id="ph1">&lt;xref:System.Type&gt;</ph>を使用して<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>のみまたはアセンブリ修飾型名を持つという名前を型のいずれか。</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 型と名前のみが検索、<ph id="ph2">&lt;xref:System.Type&gt;</ph>呼び出し元のアセンブリにし、システム アセンブリです。</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> アセンブリ修飾型名は探します、<ph id="ph2">&lt;xref:System.Type&gt;</ph>任意のアセンブリにします。</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">型名には、型は、参照型、ポインター型または配列型かどうかの種類に関する追加情報を示す末尾の文字が含まれます。</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">このような末尾の文字型の名前を取得する<ph id="ph1">`t.GetElementType().ToString()`</ph>ここで、<ph id="ph2">`t`</ph>型です。</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">アセンブリ名に ',' 区切り記号の前にスペースは、関連するが、',' 区切り記号の後のスペースは無視されます。</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
          <target state="translated">ジェネリック型の名前は、バッククォートで終わる (<ph id="ph1">\`</ph>) 後にジェネリック型引数の数を表す数字です。</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
          <target state="translated">この名前のマングルの目的は、ジェネリック型と同じ名前が、型パラメーターの数値が異なる同じスコープ内で発生しているをサポートするためにコンパイラを許可します。</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
          <target state="translated">たとえば、リフレクションは完全修飾名を返します<ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>組<ph id="ph3">`2`</ph>ジェネリック メソッドから<ph id="ph4">`Tuple(Of T)`</ph>と<ph id="ph5">`Tuple(Of T0, T1)`</ph>Visual basic でまたは<ph id="ph6">`Tuple&lt;T&gt;`</ph>と組<ph id="ph7">`\&lt;T0, T1&gt;`</ph>Visual C# の場合。</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
          <target state="translated">ジェネリック型の型引数リストが角かっこで囲まれているし、型引数がコンマで区切られます。</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
          <target state="translated">たとえば、ジェネリック<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>2 つの型パラメーターです。</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>の<ph id="ph2">`MyType`</ph>型のキーを持つ<ph id="ph3">&lt;xref:System.String&gt;</ph>次のように表される可能性があります。</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
          <target state="translated">型引数リスト内のアセンブリ修飾の型を指定するには、角かっこ内のアセンブリ修飾型を囲みます。</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
          <target state="translated">それ以外の場合、アセンブリ修飾名の部分を区切るコンマは、追加の型引数を区切るとして解釈されます。</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> fromMyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
          <target state="translated">たとえば、<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>の<ph id="ph2">`MyType`</ph>型のキーを持つ、fromMyAssembly.dll <ph id="ph3">&lt;xref:System.String&gt;</ph>、次のように指定する場合があります。</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
          <target state="translated">アセンブリ修飾の型は、型パラメーター リスト内に表示されるときにのみ、角かっこで囲むことができます。</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
          <target state="translated">型パラメーター リストで修飾し、非修飾の型のアセンブリを検索するための規則は、修飾および非修飾の非ジェネリック型の規則と同じです。</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Nullable types are a special case of generic types.</source>
          <target state="translated">Null 許容型は、ジェネリック型の特殊なケースです。</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
          <target state="translated">たとえば、null 許容<ph id="ph1">&lt;xref:System.Int32&gt;</ph>"System.Nullable'1[System.Int32]"の文字列として表されます。</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
          <target state="translated">C#、C++、および Visual Basic で、型の演算子を使用して、null 許容型を取得することもできます。</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
          <target state="translated">たとえば、null 値を許容<ph id="ph1">&lt;xref:System.Boolean&gt;</ph>によって型が返される<ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph>、C# の場合は、によって<ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph>C++ では、および<ph id="ph4">`GetType(Nullable(Of Boolean))`</ph>Visual Basic でします。</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
          <target state="translated">次の表で使用する構文を示しています。<ph id="ph1">`GetType`</ph>さまざまな種類です。</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To Get</source>
          <target state="translated">取得するには</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Use</source>
          <target state="translated">使用</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
          <target state="translated">Null 許容型 <ph id="ph1">&lt;xref:System.Int32&gt;</ph></target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">アンマネージ ポインター <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">ポインターへのアンマネージ ポインター <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">マネージ ポインターまたは参照先 <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>。</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Note that unlike pointers, references are limited to one level.</source>
          <target state="translated">ポインターとは異なり、参照は 1 つのレベルに制限されます。</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A parent class and a nested class</source>
          <target state="translated">親クラスと入れ子になったクラス</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A one-dimensional array with a lower bound of 0</source>
          <target state="translated">下限を 0 と 1 次元配列</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A one-dimensional array with an unknown lower bound</source>
          <target state="translated">不明な下限を持つ 1 次元配列</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An n-dimensional array</source>
          <target state="translated">N 次元の配列</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
          <target state="translated">合計 n-1 回角かっこ内のコンマ (,) です。</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
          <target state="translated">たとえば、 <ph id="ph1">`System.Object[,,]`</ph> 、3 次元を表す<ph id="ph2">`Object`</ph>配列。</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An array of one-dimensional arrays</source>
          <target state="translated">1 次元配列の配列</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
          <target state="translated">不明な下限四角形の 2 次元配列</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type with one type argument</source>
          <target state="translated">1 つの型引数を持つジェネリック型</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type with two type arguments</source>
          <target state="translated">2 つの型引数を持つジェネリック型</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type with two assembly-qualified type arguments</source>
          <target state="translated">2 つのアセンブリ修飾型引数を持つジェネリック型</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
          <target state="translated">アセンブリ修飾型引数を持つアセンブリ修飾の汎用型</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
          <target state="translated">型引数が 2 つの型引数を持つジェネリック型のジェネリック型</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The following example retrieves the type of <ph id="ph1">`System.Int32`</ph> and uses that type object to display the <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> property of <ph id="ph3">`System.Int32`</ph>.</source>
          <target state="translated">次の例の種類を取得する<ph id="ph1">`System.Int32`</ph>し、その型のオブジェクトを使用して、表示、<ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph>プロパティ<ph id="ph3">`System.Int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">クラス初期化子が呼び出され、例外をスローします。</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は、型引数の 1 つとしてポインター型、<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>、または <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> を持つジェネリック型を表しています。</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> が、正しい数の型引数が格納されていないジェネリック型を表しています。</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> がジェネリック型を表しており、その型引数の 1 つが対応する型パラメーターの制約を満たしていません。</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は、<ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> の配列を表します。</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated"><bpt id="p1">[</bpt>Windows ストア アプリ用 .NET<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> または<bpt id="p2">[</bpt>ポータブル クラス ライブラリ<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>では、基本クラスの例外である <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph> を代わりにキャッチします。</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">アセンブリまたはその依存関係のうちの 1 つが正しくありません。</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
          <target state="translated">共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The assembly-qualified name of the type to get.</source>
          <target state="translated">取得する型のアセンブリ修飾名。</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</source>
          <target state="translated">「<ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">型が現在実行中のアセンブリまたは Mscorlib.dll 内にある場合は、名前空間で修飾された型名を指定するだけで十分です。</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">型が見つからなかったときに例外をスローする場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。<ph id="ph2">&lt;see langword="false" /&gt;</ph> を返す場合は <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">また、<ph id="ph1">&lt;see langword="false" /&gt;</ph> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">「例外」を参照してください。</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</source>
          <target state="translated">大文字と小文字を区別する検索を実行し、型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> を取得します。</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">指定した名前を持つ型。</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">型が見つからない場合、<ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> パラメーターで <ph id="ph2">&lt;see langword="null" /&gt;</ph> を返すか例外をスローするかを指定します。</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">一部の場合は、<ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> の値に関係なく、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">「例外」を参照してください。</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if the you know its namespace-qualified name.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>を取得するメソッド、<ph id="ph2">&lt;xref:System.Type&gt;</ph>わかっている場合、その名前空間で修飾された名前に、別のアセンブリ内の型のオブジェクトします。</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 指定されたアセンブリの読み込みを発生させます<ph id="ph2">`typeName`</ph>です。</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated">使用してアセンブリを読み込むことも、<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>メソッド、およびしを使用して、<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph>のメソッド、<ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph>クラスを取得する<ph id="ph5">&lt;xref:System.Type&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use <ph id="ph1">`typeof`</ph> in C#, <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or <ph id="ph3">`typeid`</ph> in C++.</source>
          <target state="translated">使用する方が効率的では、型がコンパイル時に、プログラムを既知のアセンブリ内にある場合は、 <ph id="ph1">`typeof`</ph> 、C# の場合は、 <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> Visual basic、または<ph id="ph3">`typeid`</ph>C++ でします。</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> only works on assemblies loaded from disk.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> ディスクから読み込まれるアセンブリでのみ機能します。</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If you call <ph id="ph1">`GetType`</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
          <target state="translated">呼び出す場合<ph id="ph1">`GetType`</ph>を使用して定義された動的アセンブリで定義された型を検索する、 <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, 一貫性のない動作を取得する可能性があります。</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">動作するかどうか、動的はアセンブリが、永続的なによって異なりますを使用して作成、<ph id="ph1">`RunAndSave`</ph>または<ph id="ph2">`Save`</ph>アクセスのモード、<ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph>列挙します。</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
          <target state="translated">かどうか、動的アセンブリが永続的なとが前にディスクに書き込まれた<ph id="ph1">`GetType`</ph>が呼び出されると、ローダー ディスク上の保存されたアセンブリを検索、そのアセンブリが読み込まれ、そのアセンブリから型を取得します。</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">アセンブリがディスクに保存されていない場合<ph id="ph1">`GetType`</ph>が呼び出されると、このメソッドを返します<ph id="ph2">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> 一時動的アセンブリ; は理解していませんそのため、<ph id="ph2">`GetType`</ph>動的アセンブリを返しますを一時的に型を取得する<ph id="ph3">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
          <target state="translated">使用する<ph id="ph1">`GetType`</ph>動的モジュールのサブスクライブ、<ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph>イベントと呼び出し<ph id="ph3">`GetType`</ph>保存する前にします。</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
          <target state="translated">それ以外の場合、メモリ内アセンブリの 2 つのコピーが表示されます。</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
          <target state="translated"><ph id="ph1">`throwOnError`</ph>パラメーターは、例外セクションで説明した型が見つからないし、もその他の特定の例外条件を抑制ときの動作を指定します。</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwOnError`</ph>.</source>
          <target state="translated">値に関係なく一部の例外がスローされた<ph id="ph1">`throwOnError`</ph>です。</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, if the type is found but cannot be loaded, a <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">たとえば、種類が見つかりましたが、アンロードすることはできません、<ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph>スローされる場合でも<ph id="ph2">`throwOnError`</ph>は<ph id="ph3">`false`</ph>します。</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`Get`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
          <target state="translated">配列または COM 型は検索されませんの使用可能なクラスのテーブルに読み込まれていない限り、します。</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
          <target state="translated"><ph id="ph1">`typeName`</ph> 型名で修飾できます、名前空間またはアセンブリ修飾名はアセンブリ名の指定が含まれています。</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">「<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
          <target state="translated">場合<ph id="ph1">`typeName`</ph>には、名前空間が、アセンブリ名ではなく、このメソッドは、呼び出し元のオブジェクトのアセンブリと、Mscorlib.dll のみがこの順序で検索します。</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
          <target state="translated">TypeName は、部分的または完全なアセンブリ名を持つ完全に修飾されている場合、このメソッドは、指定したアセンブリで検索します。</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
          <target state="translated">アセンブリの厳密な名前が、アセンブリの完全名が必要です。</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>プロパティは入れ子にされた型、アセンブリ名、およびジェネリック型引数を含む完全修飾型名を返します。</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">共通言語ランタイムをサポートするすべてのコンパイラでは、入れ子になったクラスの簡易名を出力し、リフレクションは、次の規則に従って、照会されたときに、完全修飾名を構築します。</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">.NET Framework version 2.0 では、プロセッサのアーキテクチャは、アセンブリ id に追加され、アセンブリ名の文字列の一部として指定できます。</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">たとえば、"ProcessorArchitecture = msil"です。</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">ただし、これが含まれていませんによって返される文字列で、<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>互換性のためのプロパティです。</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">作成することで、型を読み込むことも、<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>オブジェクトとの適切なオーバー ロードに渡す、<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method to load types from the assembly.</source>
          <target state="translated">使用してできます、<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>アセンブリから型のメソッドを読み込めません。</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">「<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>」も参照してください。</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Delimiter</source>
          <target state="translated">区切り記号</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Meaning</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">円記号 (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Escape character.</source>
          <target state="translated">文字をエスケープします。</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Backtick (`)</source>
          <target state="translated">バッククォート (')</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
          <target state="translated">ジェネリック型の名前の末尾にある、型パラメーターの数を表す 1 つ以上の数字を先頭に付きます。</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Brackets ([])</source>
          <target state="translated">角かっこ ()</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
          <target state="translated">構築されたジェネリック型のジェネリック型引数リストを囲む型引数リスト内で、アセンブリ修飾型を囲みます。</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Comma (,)</source>
          <target state="translated">コンマ (,)</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Precedes the Assembly name.</source>
          <target state="translated">アセンブリ名の前にします。</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Period (.)</source>
          <target state="translated">ピリオド (.)</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">名前空間の識別子を表します。</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Plus sign (+)</source>
          <target state="translated">プラス記号 (+)</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Precedes a nested class.</source>
          <target state="translated">入れ子になったクラスが前に付きます。</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, the fully qualified name for a class might look like this:</source>
          <target state="translated">たとえば、クラスの完全修飾名は、次のようになります。</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">名前空間が TopNamespace.Sub+Namespace としている場合、文字列がエスケープ文字をプラス記号 (+) を前に指定する必要があります (<ph id="ph1">\\</ph>)、入れ子の区切り記号として解釈されないようにします。</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Reflection emits this string as follows:</source>
          <target state="translated">リフレクションでは、次のようにこの文字列を生成します。</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">この修飾名を永続化し、読み込みに使用された後で、<ph id="ph1">&lt;xref:System.Type&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">検索して読み込む、<ph id="ph1">&lt;xref:System.Type&gt;</ph>を使用して<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>のみまたはアセンブリ修飾型名を持つという名前を型のいずれか。</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 型と名前のみが検索、<ph id="ph2">&lt;xref:System.Type&gt;</ph>呼び出し元のアセンブリにし、システム アセンブリです。</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> アセンブリ修飾型名は探します、<ph id="ph2">&lt;xref:System.Type&gt;</ph>任意のアセンブリにします。</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">型名には、型は、参照型、ポインター型または配列型かどうかの種類に関する追加情報を示す末尾の文字が含まれます。</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">このような末尾の文字型の名前を取得する<ph id="ph1">`t.GetElementType().ToString()`</ph>ここで、<ph id="ph2">`t`</ph>型です。</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">アセンブリ名に ',' 区切り記号の前にスペースは、関連するが、',' 区切り記号の後のスペースは無視されます。</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
          <target state="translated">ジェネリック型の名前は、バッククォートで終わる (<ph id="ph1">\`</ph>) 後にジェネリック型引数の数を表す数字です。</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
          <target state="translated">この名前のマングルの目的は、ジェネリック型と同じ名前が、型パラメーターの数値が異なる同じスコープ内で発生しているをサポートするためにコンパイラを許可します。</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
          <target state="translated">たとえば、リフレクションは完全修飾名を返します<ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>組<ph id="ph3">`2`</ph>ジェネリック メソッドから<ph id="ph4">`Tuple(Of T)`</ph>と<ph id="ph5">`Tuple(Of T0, T1)`</ph>Visual basic でまたは<ph id="ph6">`Tuple&lt;T&gt;`</ph>と組<ph id="ph7">`\&lt;T0, T1&gt;`</ph>Visual C# の場合。</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
          <target state="translated">ジェネリック型の型引数リストが角かっこで囲まれているし、型引数がコンマで区切られます。</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
          <target state="translated">たとえば、ジェネリック<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>2 つの型パラメーターです。</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>の<ph id="ph2">`MyType`</ph>型のキーを持つ<ph id="ph3">&lt;xref:System.String&gt;</ph>次のように表される可能性があります。</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
          <target state="translated">型引数リスト内のアセンブリ修飾の型を指定するには、角かっこ内のアセンブリ修飾型を囲みます。</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
          <target state="translated">それ以外の場合、アセンブリ修飾名の部分を区切るコンマは、追加の型引数を区切るとして解釈されます。</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> from MyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
          <target state="translated">たとえば、<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>の<ph id="ph2">`MyType`</ph>型のキーを持つ、MyAssembly.dll から<ph id="ph3">&lt;xref:System.String&gt;</ph>、次のように指定する場合があります。</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
          <target state="translated">アセンブリ修飾の型は、型パラメーター リスト内に表示されるときにのみ、角かっこで囲むことができます。</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
          <target state="translated">型パラメーター リストで修飾し、非修飾の型のアセンブリを検索するための規則は、修飾および非修飾の非ジェネリック型の規則と同じです。</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Nullable types are a special case of generic types.</source>
          <target state="translated">Null 許容型は、ジェネリック型の特殊なケースです。</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
          <target state="translated">たとえば、null 許容<ph id="ph1">&lt;xref:System.Int32&gt;</ph>"System.Nullable'1[System.Int32]"の文字列として表されます。</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
          <target state="translated">C#、C++、および Visual Basic で、型の演算子を使用して、null 許容型を取得することもできます。</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
          <target state="translated">たとえば、null 値を許容<ph id="ph1">&lt;xref:System.Boolean&gt;</ph>によって型が返される<ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph>、C# の場合は、によって<ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph>C++ では、および<ph id="ph4">`GetType(Nullable(Of Boolean))`</ph>Visual Basic でします。</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
          <target state="translated">次の表で使用する構文を示しています。<ph id="ph1">`GetType`</ph>さまざまな種類です。</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To Get</source>
          <target state="translated">取得するには</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Use</source>
          <target state="translated">使用</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
          <target state="translated">Null 許容型 <ph id="ph1">&lt;xref:System.Int32&gt;</ph></target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">アンマネージ ポインター <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">ポインターへのアンマネージ ポインター <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">マネージ ポインターまたは参照先 <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>。</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Note that unlike pointers, references are limited to one level.</source>
          <target state="translated">ポインターとは異なり、参照は 1 つのレベルに制限されます。</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A parent class and a nested class</source>
          <target state="translated">親クラスと入れ子になったクラス</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A one-dimensional array with a lower bound of 0</source>
          <target state="translated">下限を 0 と 1 次元配列</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A one-dimensional array with an unknown lower bound</source>
          <target state="translated">不明な下限を持つ 1 次元配列</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An n-dimensional array</source>
          <target state="translated">N 次元の配列</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
          <target state="translated">合計 n-1 回角かっこ内のコンマ (,) です。</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
          <target state="translated">たとえば、 <ph id="ph1">`System.Object[,,]`</ph> 、3 次元を表す<ph id="ph2">`Object`</ph>配列。</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A two-dimensional array's array</source>
          <target state="translated">2 次元配列の配列</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
          <target state="translated">不明な下限四角形の 2 次元配列</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type with one type argument</source>
          <target state="translated">1 つの型引数を持つジェネリック型</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type with two type arguments</source>
          <target state="translated">2 つの型引数を持つジェネリック型</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type with two assembly-qualified type arguments</source>
          <target state="translated">2 つのアセンブリ修飾型引数を持つジェネリック型</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
          <target state="translated">アセンブリ修飾型引数を持つアセンブリ修飾の汎用型</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
          <target state="translated">型引数が 2 つの型引数を持つジェネリック型のジェネリック型</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The following example retrieves the type of <ph id="ph1">`System.Int32`</ph> and uses that type object to display the <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> property of <ph id="ph3">`System.Int32`</ph>.</source>
          <target state="translated">次の例の種類を取得する<ph id="ph1">`System.Int32`</ph>し、その型のオブジェクトを使用して、表示、<ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph>プロパティ<ph id="ph3">`System.Int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If a type object refers to an assembly that does not exist, this example throws an exception.</source>
          <target state="translated">型オブジェクトは、存在しないアセンブリを参照して、この例は、例外をスローします。</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">クラス初期化子が呼び出され、例外をスローします。</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、型は見つかりません。</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> に埋め込まれたタブなどの無効な文字が含まれています。</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> が空の文字列です。</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> が無効なサイズの配列型を表しています。</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は、<ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> の配列を表します。</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> に無効な構文が含まれています。</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, "MyType[,*,]".</source>
          <target state="translated">例: "MyType[,*,]"。</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は、型引数の 1 つとしてポインター型、<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>、または <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> を持つジェネリック型を表しています。</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> が、正しい数の型引数が格納されていないジェネリック型を表しています。</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> がジェネリック型を表しており、その型引数の 1 つが対応する型パラメーターの制約を満たしていません。</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated"><bpt id="p1">[</bpt>Windows ストア アプリ用 .NET<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> または<bpt id="p2">[</bpt>ポータブル クラス ライブラリ<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>では、基本クラスの例外である <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph> を代わりにキャッチします。</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">アセンブリまたはその依存関係のうちの 1 つが正しくありません。</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
          <target state="translated">共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly-qualified name of the type to get.</source>
          <target state="translated">取得する型のアセンブリ修飾名。</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</source>
          <target state="translated">「<ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">型が現在実行中のアセンブリまたは Mscorlib.dll 内にある場合は、名前空間で修飾された型名を指定するだけで十分です。</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.Specifying <ph id="ph4">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">型が見つからないときに例外をスローする場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。<ph id="ph2">&lt;see langword="false" /&gt;</ph> を返す場合は <ph id="ph3">&lt;see langword="null" /&gt;</ph>。<ph id="ph4">&lt;see langword="false" /&gt;</ph> を指定すると、他の一部の例外条件も抑制されることがあります。</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">「例外」を参照してください。</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a case-insensitive search for <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>, <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">大文字と小文字を区別せずに <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> の検索を実行するには <ph id="ph1">&lt;see langword="true" /&gt;</ph>。大文字と小文字を区別して <ph id="ph2">&lt;see langword="false" /&gt;</ph> の検索を実行するには <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</source>
          <target state="translated">指定した名前を持つ <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> を取得します。型が見つからない場合に例外をスローするかどうかと、大文字と小文字を区別する検索を実行するかどうかも指定します。</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">指定した名前を持つ型。</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">型が見つからない場合、<ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> パラメーターで <ph id="ph2">&lt;see langword="null" /&gt;</ph> を返すか例外をスローするかを指定します。</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">一部の場合は、<ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> の値に関係なく、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">「例外」を参照してください。</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if the you know its namespace-qualified name.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>を取得するメソッド、<ph id="ph2">&lt;xref:System.Type&gt;</ph>わかっている場合、その名前空間で修飾された名前に、別のアセンブリ内の型のオブジェクトします。</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 指定されたアセンブリの読み込みを発生させます<ph id="ph2">`typeName`</ph>です。</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated">使用してアセンブリを読み込むことも、<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>メソッド、およびしを使用して、<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph>のメソッド、<ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph>クラスを取得する<ph id="ph5">&lt;xref:System.Type&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use <ph id="ph1">`typeof`</ph> in C#, <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or <ph id="ph3">`typeid`</ph> in C++.</source>
          <target state="translated">使用する方が効率的では、型がコンパイル時に、プログラムを既知のアセンブリ内にある場合は、 <ph id="ph1">`typeof`</ph> 、C# の場合は、 <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> Visual basic、または<ph id="ph3">`typeid`</ph>C++ でします。</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> only works on assemblies loaded from disk.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> ディスクから読み込まれるアセンブリでのみ機能します。</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If you call <ph id="ph1">`GetType`</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
          <target state="translated">呼び出す場合<ph id="ph1">`GetType`</ph>を使用して定義された動的アセンブリで定義された型を検索する、 <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, 一貫性のない動作を取得する可能性があります。</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">動作するかどうか、動的はアセンブリが、永続的なによって異なりますを使用して作成、<ph id="ph1">`RunAndSave`</ph>または<ph id="ph2">`Save`</ph>アクセスのモード、<ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph>列挙します。</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
          <target state="translated">かどうか、動的アセンブリが永続的なとが前にディスクに書き込まれた<ph id="ph1">`GetType`</ph>が呼び出されると、ローダー ディスク上の保存されたアセンブリを検索、そのアセンブリが読み込まれ、そのアセンブリから型を取得します。</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">アセンブリがディスクに保存されていない場合<ph id="ph1">`GetType`</ph>が呼び出されると、このメソッドを返します<ph id="ph2">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> 一時動的アセンブリ; は理解していませんそのため、<ph id="ph2">`GetType`</ph>動的アセンブリを返しますを一時的に型を取得する<ph id="ph3">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
          <target state="translated">使用する<ph id="ph1">`GetType`</ph>動的モジュールのサブスクライブ、<ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph>イベントと呼び出し<ph id="ph3">`GetType`</ph>保存する前にします。</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
          <target state="translated">それ以外の場合、メモリ内アセンブリの 2 つのコピーが表示されます。</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
          <target state="translated"><ph id="ph1">`throwOnError`</ph>パラメーターは、例外セクションで説明した型が見つからないし、もその他の特定の例外条件を抑制ときの動作を指定します。</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwOnError`</ph>.</source>
          <target state="translated">値に関係なく一部の例外がスローされた<ph id="ph1">`throwOnError`</ph>です。</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, if the type is found but cannot be loaded, a <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">たとえば、種類が見つかりましたが、アンロードすることはできません、<ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph>スローされる場合でも<ph id="ph2">`throwOnError`</ph>は<ph id="ph3">`false`</ph>します。</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">次の表は、基本クラスのメンバーがによって返される、<ph id="ph1">`Get`</ph>メソッドへのリフレクション型とします。</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Member Type</source>
          <target state="translated">メンバーの型</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Static</source>
          <target state="translated">スタティック</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Non-Static</source>
          <target state="translated">静的でないです。</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Constructor</source>
          <target state="translated">コンストラクター</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Field</source>
          <target state="translated">フィールド</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">フィールドは、常に、名前とシグネチャによって隠ぺいです。</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Method</source>
          <target state="translated">メソッド</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">はい。</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">(仮想および非仮想の両方) のメソッドは、名前による隠ぺいまたは名前とシグネチャによって隠ぺいできます。</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Nested Type</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">利用不可</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">共通型システムの規則は、継承は、プロパティを実装するメソッドと同じです。</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">プロパティは、リフレクションは、名前とシグネチャによって隠ぺいとして扱います。</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">下記のメモ 2 を参照してください。</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">名前とシグネチャによって隠ぺいは、すべてのカスタム修飾子を含む、シグネチャの一部の種類、および返されるパラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>This is a binary comparison.</source>
          <target state="translated">これは、バイナリ比較です。</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">リフレクションの場合、プロパティおよびイベントは名前とシグネチャによって隠ぺいされます。</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Get と set アクセサーの両方を持つプロパティはあるが、基底クラスでは、派生クラスには、get アクセサーだけ、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">カスタム属性は、共通型システムの一部ではありません。</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
          <target state="translated">配列または COM 型は検索されませんの使用可能なクラスのテーブルに読み込まれていない限り、します。</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
          <target state="translated"><ph id="ph1">`typeName`</ph> 型名で修飾できます、名前空間またはアセンブリ修飾名はアセンブリ名の指定が含まれています。</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">「<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
          <target state="translated">場合<ph id="ph1">`typeName`</ph>には、名前空間が、アセンブリ名ではなく、このメソッドは、呼び出し元のオブジェクトのアセンブリと、Mscorlib.dll のみがこの順序で検索します。</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
          <target state="translated">TypeName は、部分的または完全なアセンブリ名を持つ完全に修飾されている場合、このメソッドは、指定したアセンブリで検索します。</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
          <target state="translated">アセンブリの厳密な名前が、アセンブリの完全名が必要です。</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>プロパティは入れ子にされた型、アセンブリ名と型引数を含む完全修飾型名を返します。</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">共通言語ランタイムをサポートするすべてのコンパイラでは、入れ子になったクラスの簡易名を出力し、リフレクションは、次の規則に従って、照会されたときに、完全修飾名を構築します。</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">.NET Framework version 2.0 では、プロセッサのアーキテクチャは、アセンブリ id に追加され、アセンブリ名の文字列の一部として指定できます。</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">たとえば、"ProcessorArchitecture = msil"です。</target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">ただし、これが含まれていませんによって返される文字列で、<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>互換性のためのプロパティです。</target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">作成することで、型を読み込むことも、<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>オブジェクトとの適切なオーバー ロードに渡す、<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method to load types from the assembly.</source>
          <target state="translated">使用してできます、<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>アセンブリから型のメソッドを読み込めません。</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">「<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>」も参照してください。</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Delimiter</source>
          <target state="translated">区切り記号</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Meaning</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">円記号 (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Escape character.</source>
          <target state="translated">文字をエスケープします。</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Backtick (`)</source>
          <target state="translated">バッククォート (')</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
          <target state="translated">ジェネリック型の名前の末尾にある、型パラメーターの数を表す 1 つ以上の数字を先頭に付きます。</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Brackets ([])</source>
          <target state="translated">角かっこ ()</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
          <target state="translated">構築されたジェネリック型のジェネリック型引数リストを囲む型引数リスト内で、アセンブリ修飾型を囲みます。</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Comma (,)</source>
          <target state="translated">コンマ (,)</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Precedes the Assembly name.</source>
          <target state="translated">アセンブリ名の前にします。</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Period (.)</source>
          <target state="translated">ピリオド (.)</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">名前空間の識別子を表します。</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Plus sign (+)</source>
          <target state="translated">プラス記号 (+)</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Precedes a nested class.</source>
          <target state="translated">入れ子になったクラスが前に付きます。</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, the fully qualified name for a class might look like this:</source>
          <target state="translated">たとえば、クラスの完全修飾名は、次のようになります。</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">名前空間が TopNamespace.Sub+Namespace としている場合、文字列がエスケープ文字をプラス記号 (+) を前に指定する必要があります (<ph id="ph1">\\</ph>)、入れ子の区切り記号として解釈されないようにします。</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Reflection emits this string as follows:</source>
          <target state="translated">リフレクションでは、次のようにこの文字列を生成します。</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">この修飾名を永続化し、読み込みに使用された後で、<ph id="ph1">&lt;xref:System.Type&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">検索して読み込む、<ph id="ph1">&lt;xref:System.Type&gt;</ph>を使用して<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>のみまたはアセンブリ修飾型名を持つという名前を型のいずれか。</target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> 型と名前のみが検索、<ph id="ph2">&lt;xref:System.Type&gt;</ph>呼び出し元のアセンブリにし、システム アセンブリです。</target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> アセンブリ修飾型名は探します、<ph id="ph2">&lt;xref:System.Type&gt;</ph>任意のアセンブリにします。</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">型名には、型は、参照型、ポインター型または配列型かどうかの種類に関する追加情報を示す末尾の文字が含まれます。</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">このような末尾の文字型の名前を取得する<ph id="ph1">`t.GetElementType().ToString()`</ph>ここで、<ph id="ph2">`t`</ph>型です。</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">アセンブリ名に ',' 区切り記号の前にスペースは、関連するが、',' 区切り記号の後のスペースは無視されます。</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
          <target state="translated">ジェネリック型の名前は、バッククォートで終わる (<ph id="ph1">\`</ph>) 後にジェネリック型引数の数を表す数字です。</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
          <target state="translated">この名前のマングルの目的は、ジェネリック型と同じ名前が、型パラメーターの数値が異なる同じスコープ内で発生しているをサポートするためにコンパイラを許可します。</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
          <target state="translated">たとえば、リフレクションは完全修飾名を返します<ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>組<ph id="ph3">`2`</ph>ジェネリック メソッドから<ph id="ph4">`Tuple(Of T)`</ph>と<ph id="ph5">`Tuple(Of T0, T1)`</ph>Visual basic でまたは<ph id="ph6">`Tuple&lt;T&gt;`</ph>と組<ph id="ph7">`\&lt;T0, T1&gt;`</ph>Visual C# の場合。</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
          <target state="translated">ジェネリック型の型引数リストが角かっこで囲まれているし、型引数がコンマで区切られます。</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
          <target state="translated">たとえば、ジェネリック<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>2 つの型パラメーターです。</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>の<ph id="ph2">`MyType`</ph>型のキーを持つ<ph id="ph3">&lt;xref:System.String&gt;</ph>次のように表される可能性があります。</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
          <target state="translated">型引数リスト内のアセンブリ修飾の型を指定するには、角かっこ内のアセンブリ修飾型を囲みます。</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
          <target state="translated">それ以外の場合、アセンブリ修飾名の部分を区切るコンマは、追加の型引数を区切るとして解釈されます。</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> from MyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
          <target state="translated">たとえば、<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>の<ph id="ph2">`MyType`</ph>型のキーを持つ、MyAssembly.dll から<ph id="ph3">&lt;xref:System.String&gt;</ph>、次のように指定する場合があります。</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
          <target state="translated">アセンブリ修飾の型は、型パラメーター リスト内に表示されるときにのみ、角かっこで囲むことができます。</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
          <target state="translated">型パラメーター リストで修飾し、非修飾の型のアセンブリを検索するための規則は、修飾および非修飾の非ジェネリック型の規則と同じです。</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Nullable types are a special case of generic types.</source>
          <target state="translated">Null 許容型は、ジェネリック型の特殊なケースです。</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
          <target state="translated">たとえば、null 許容<ph id="ph1">&lt;xref:System.Int32&gt;</ph>"System.Nullable'1[System.Int32]"の文字列として表されます。</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
          <target state="translated">C#、C++、および Visual Basic で、型の演算子を使用して、null 許容型を取得することもできます。</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
          <target state="translated">たとえば、null 値を許容<ph id="ph1">&lt;xref:System.Boolean&gt;</ph>によって型が返される<ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph>、C# の場合は、によって<ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph>C++ では、および<ph id="ph4">`GetType(Nullable(Of Boolean))`</ph>Visual Basic でします。</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
          <target state="translated">次の表で使用する構文を示しています。<ph id="ph1">`GetType`</ph>さまざまな種類です。</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To Get</source>
          <target state="translated">取得するには</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Use</source>
          <target state="translated">使用</target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
          <target state="translated">Null 許容型 <ph id="ph1">&lt;xref:System.Int32&gt;</ph></target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">アンマネージ ポインター <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">ポインターへのアンマネージ ポインター <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">マネージ ポインターまたは参照先 <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>。</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Note that unlike pointers, references are limited to one level.</source>
          <target state="translated">ポインターとは異なり、参照は 1 つのレベルに制限されます。</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A parent class and a nested class</source>
          <target state="translated">親クラスと入れ子になったクラス</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A one-dimensional array with a lower bound of 0</source>
          <target state="translated">下限を 0 と 1 次元配列</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A one-dimensional array with an unknown lower bound</source>
          <target state="translated">不明な下限を持つ 1 次元配列</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An n-dimensional array</source>
          <target state="translated">N 次元の配列</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
          <target state="translated">合計 n-1 回角かっこ内のコンマ (,) です。</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
          <target state="translated">たとえば、 <ph id="ph1">`System.Object[,,]`</ph> 、3 次元を表す<ph id="ph2">`Object`</ph>配列。</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A two-dimensional array's array</source>
          <target state="translated">2 次元配列の配列</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
          <target state="translated">不明な下限四角形の 2 次元配列</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type with one type argument</source>
          <target state="translated">1 つの型引数を持つジェネリック型</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type with two type arguments</source>
          <target state="translated">2 つの型引数を持つジェネリック型</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type with two assembly-qualified type arguments</source>
          <target state="translated">2 つのアセンブリ修飾型引数を持つジェネリック型</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
          <target state="translated">アセンブリ修飾型引数を持つアセンブリ修飾の汎用型</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
          <target state="translated">型引数が 2 つの型引数を持つジェネリック型のジェネリック型</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">クラス初期化子が呼び出され、例外をスローします。</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、型は見つかりません。</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> に埋め込まれたタブなどの無効な文字が含まれています。</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> が空の文字列です。</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> が無効なサイズの配列型を表しています。</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は、<ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> の配列を表します。</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> に無効な構文が含まれています。</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, "MyType[,*,]".</source>
          <target state="translated">例: "MyType[,*,]"。</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は、型引数の 1 つとしてポインター型、<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>、または <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> を持つジェネリック型を表しています。</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> が、正しい数の型引数が格納されていないジェネリック型を表しています。</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> がジェネリック型を表しており、その型引数の 1 つが対応する型パラメーターの制約を満たしていません。</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">アセンブリ、またはその依存関係のうちの 1 つは見つかりましたが、読み込めませんでした。</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">アセンブリまたはその依存関係のうちの 1 つが正しくありません。</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
          <target state="translated">共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The name of the type to get.</source>
          <target state="translated">取得する型の名前。</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> is capable of resolving.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> パラメーターを指定する場合は、<bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> が解決できる任意の文字列を型名として使用できます。</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> must be an assembly-qualified name (see <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> パラメーターを指定する場合、または標準の型解決を使用する場合は、<bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> をアセンブリ修飾名にする必要があります (<ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>を参照)。ただし、現在実行されているアセンブリ内または Mscorlib.dll に型がある場合は、名前空間で修飾された型名を指定するだけで十分です。</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> で指定されたアセンブリを特定して返すメソッド。</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly name is passed to <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> as an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> には、アセンブリ名が <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> オブジェクトとして渡されます。</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> is not called.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> にアセンブリの名前が含まれていない場合、<bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> は呼び出されません。</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> を指定しない場合は、標準のアセンブリ解決が実行されます。</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
          <target state="translated">渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">指定したメソッドまたは使い慣れているメソッドだけを使用してください。</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> or by standard assembly resolution.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> で指定された型を、<bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> または標準のアセンブリ解決によって返されたアセンブリから特定して返すメソッド。</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If no assembly is provided, the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> method can provide one.</source>
          <target state="translated">アセンブリが指定されていない場合は、<bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> メソッドで指定できます。</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; <ph id="ph1">&lt;see langword="false" /&gt;</ph> is passed to that parameter.</source>
          <target state="translated">このメソッドは、大文字と小文字を区別せずに検索を実行するかどうかを指定するパラメーターも受け取ります。そのパラメーターには <ph id="ph1">&lt;see langword="false" /&gt;</ph> が渡されます。</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</source>
          <target state="translated">指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The type with the specified name, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the type is not found.</source>
          <target state="translated">指定された名前の型。型が見つからない場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Usage scenarios for this method and details about the <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> parameters can be found in the <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">このメソッドの詳細な使用シナリオ、<ph id="ph1">`assemblyResolver`</ph>と<ph id="ph2">`typeResolver`</ph>パラメーターは含まれて、<ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If <ph id="ph1">`typeName`</ph> cannot be found, the call to the <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> method returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">場合<ph id="ph1">`typeName`</ph>が見つからないことを呼び出し、<ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph>メソッドを返します。<ph id="ph3">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>It does not throw an exception.</source>
          <target state="translated">例外はスローされません。</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>To control whether an exception is thrown, call an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that has a <ph id="ph2">`throwOnError`</ph> parameter.</source>
          <target state="translated">制御するかどうか、例外がスローされますのオーバー ロードを呼び出して、<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>メソッドが、<ph id="ph2">`throwOnError`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`false`</ph> for the <ph id="ph3">`throwOnError`</ph> and <ph id="ph4">`ignoreCase`</ph> parameters.</source>
          <target state="translated">呼び出した場合と同じではこのメソッドのオーバー ロードを呼び出して、<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>メソッドのオーバー ロードを指定して<ph id="ph2">`false`</ph>の<ph id="ph3">`throwOnError`</ph>と<ph id="ph4">`ignoreCase`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">クラス初期化子が呼び出され、例外をスローします。</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>An error occurs when <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> が型名とアセンブリ名に解析されるとき、エラーが発生します (たとえば、単純な型名にエスケープされない特殊文字が含まれている場合)。 </target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は、型引数の 1 つとしてポインター型、<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>、または <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> を持つジェネリック型を表しています。</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> が、正しい数の型引数が格納されていないジェネリック型を表しています。</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> がジェネリック型を表しており、その型引数の 1 つが対応する型パラメーターの制約を満たしていません。</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は、<ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> の配列を表します。</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contains an invalid assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> には無効なアセンブリ名が含まれています。</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is a valid assembly name without a type name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は、型名のない有効なアセンブリ名です。</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">アセンブリ、またはその依存関係のうちの 1 つが無効です。</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The name of the type to get.</source>
          <target state="translated">取得する型の名前。</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> is capable of resolving.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> パラメーターを指定する場合は、<bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> が解決できる任意の文字列を型名として使用できます。</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> must be an assembly-qualified name (see <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> パラメーターを指定する場合、または標準の型解決を使用する場合は、<bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> をアセンブリ修飾名にする必要があります (<ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>を参照)。ただし、現在実行されているアセンブリ内または Mscorlib.dll に型がある場合は、名前空間で修飾された型名を指定するだけで十分です。</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> で指定されたアセンブリを特定して返すメソッド。</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly name is passed to <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> as an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> には、アセンブリ名が <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> オブジェクトとして渡されます。</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> is not called.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> にアセンブリの名前が含まれていない場合、<bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> は呼び出されません。</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> を指定しない場合は、標準のアセンブリ解決が実行されます。</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
          <target state="translated">渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">指定したメソッドまたは使い慣れているメソッドだけを使用してください。</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> or by standard assembly resolution.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> で指定された型を、<bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> または標準のアセンブリ解決によって返されたアセンブリから特定して返すメソッド。</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If no assembly is provided, the method can provide one.</source>
          <target state="translated">アセンブリが指定されていない場合は、このメソッドで指定できます。</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; <ph id="ph1">&lt;see langword="false" /&gt;</ph> is passed to that parameter.</source>
          <target state="translated">このメソッドは、大文字と小文字を区別せずに検索を実行するかどうかを指定するパラメーターも受け取ります。そのパラメーターには <ph id="ph1">&lt;see langword="false" /&gt;</ph> が渡されます。</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">型が見つからなかったときに例外をスローする場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。<ph id="ph2">&lt;see langword="false" /&gt;</ph> を返す場合は <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">また、<ph id="ph1">&lt;see langword="false" /&gt;</ph> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">「例外」を参照してください。</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</source>
          <target state="translated">型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">指定した名前を持つ型。</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">型が見つからない場合、<ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> パラメーターで <ph id="ph2">&lt;see langword="null" /&gt;</ph> を返すか例外をスローするかを指定します。</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">一部の場合は、<ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> の値に関係なく、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">「例外」を参照してください。</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Usage scenarios for this method and details about the <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> parameters can be found in the <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">このメソッドの詳細な使用シナリオ、<ph id="ph1">`assemblyResolver`</ph>と<ph id="ph2">`typeResolver`</ph>パラメーターは含まれて、<ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`false`</ph> for the <ph id="ph3">`ignoreCase`</ph> parameter.</source>
          <target state="translated">このメソッドのオーバー ロードを呼び出すことは、呼び出し元と同じ、<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>メソッドのオーバー ロードを指定して<ph id="ph2">`false`</ph>の<ph id="ph3">`ignoreCase`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">クラス初期化子が呼び出され、例外をスローします。</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、型は見つかりません。</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> に埋め込まれたタブなどの無効な文字が含まれています。</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> が空の文字列です。</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> が無効なサイズの配列型を表しています。</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は、<ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> の配列を表します。</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>An error occurs when <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> が型名とアセンブリ名に解析されるとき、エラーが発生します (たとえば、単純な型名にエスケープされない特殊文字が含まれている場合)。 </target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax (for example, "MyType[,*,]").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> は <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> には無効な構文 (たとえば、"MyType[,*,]") が含まれています。</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は、型引数の 1 つとしてポインター型、<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>、または <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> を持つジェネリック型を表しています。</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> が、正しい数の型引数が格納されていないジェネリック型を表しています。</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> がジェネリック型を表しており、その型引数の 1 つが対応する型パラメーターの制約を満たしていません。</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contains an invalid assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> には無効なアセンブリ名が含まれています。</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is a valid assembly name without a type name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は、型名のない有効なアセンブリ名です。</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">アセンブリまたはその依存関係のうちの 1 つが正しくありません。</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The name of the type to get.</source>
          <target state="translated">取得する型の名前。</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> is capable of resolving.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> パラメーターを指定する場合は、<bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> が解決できる任意の文字列を型名として使用できます。</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> must be an assembly-qualified name (see <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> パラメーターを指定する場合、または標準の型解決を使用する場合は、<bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> をアセンブリ修飾名にする必要があります (<ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>を参照)。ただし、現在実行されているアセンブリ内または Mscorlib.dll に型がある場合は、名前空間で修飾された型名を指定するだけで十分です。</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> で指定されたアセンブリを特定して返すメソッド。</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly name is passed to <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> as an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> には、アセンブリ名が <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> オブジェクトとして渡されます。</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> is not called.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> にアセンブリの名前が含まれていない場合、<bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> は呼び出されません。</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> を指定しない場合は、標準のアセンブリ解決が実行されます。</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
          <target state="translated">渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">指定したメソッドまたは使い慣れているメソッドだけを使用してください。</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> or by standard assembly resolution.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> で指定された型を、<bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> または標準のアセンブリ解決によって返されたアセンブリから特定して返すメソッド。</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If no assembly is provided, the method can provide one.</source>
          <target state="translated">アセンブリが指定されていない場合は、このメソッドで指定できます。</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <bpt id="p1">&lt;c&gt;</bpt>ignoreCase<ept id="p1">&lt;/c&gt;</ept> is passed to that parameter.</source>
          <target state="translated">このメソッドは、大文字小文字を区別せずに検索を実行するかどうかを指定するパラメーターも受け取ります。そのパラメーターには、<bpt id="p1">&lt;c&gt;</bpt>ignoreCase<ept id="p1">&lt;/c&gt;</ept> の値が渡されます。</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">型が見つからなかったときに例外をスローする場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。<ph id="ph2">&lt;see langword="false" /&gt;</ph> を返す場合は <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">また、<ph id="ph1">&lt;see langword="false" /&gt;</ph> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">「例外」を参照してください。</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a case-insensitive search for <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>, <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">大文字と小文字を区別せずに <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> の検索を実行するには <ph id="ph1">&lt;see langword="true" /&gt;</ph>。大文字と小文字を区別して <ph id="ph2">&lt;see langword="false" /&gt;</ph> の検索を実行するには <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</source>
          <target state="translated">大文字と小文字を区別せずに検索を実行するかどうか、および型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">指定した名前を持つ型。</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">型が見つからない場合、<ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> パラメーターで <ph id="ph2">&lt;see langword="null" /&gt;</ph> を返すか例外をスローするかを指定します。</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">一部の場合は、<ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> の値に関係なく、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">「例外」を参照してください。</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Use this method overload and its associated overloads (<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29&gt;</ph>) to replace the default implementation of the <ph id="ph3">&lt;xref:System.Type.GetType%2A&gt;</ph> method with more flexible implementations.</source>
          <target state="translated">このメソッドのオーバー ロードと関連付けられているオーバー ロードを使用して (<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph>と<ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29&gt;</ph>) の既定の実装を置き換える、<ph id="ph3">&lt;xref:System.Type.GetType%2A&gt;</ph>より柔軟な実装を持つメソッドです。</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</source>
          <target state="translated">型名およびこれらを含むアセンブリの名前を解決するメソッドを提供するには、次の操作を行います。</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Control which version of an assembly a type is loaded from.</source>
          <target state="translated">型が読み込まれたアセンブリのバージョンを制御します。</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Provide another place to look for a type name that does not include an assembly name.</source>
          <target state="translated">アセンブリ名を含まない型名を検索する別の場所を提供します。</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Load assemblies using partial assembly names.</source>
          <target state="translated">部分アセンブリ名を使用してアセンブリを読み込みます。</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Return subclasses of <ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> that are not created by the common language runtime (CLR).</source>
          <target state="translated">サブクラスを返す<ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph>を共通言語ランタイム (CLR) では作成されません。</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</source>
          <target state="translated">たとえば、バージョン トレラントなシリアル化でこのメソッドを使用する部分名を使用して"best fit"のアセンブリを検索します。</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Other overloads of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method require an assembly-qualified type name, which includes the version number.</source>
          <target state="translated">他のオーバー ロード、<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>メソッドに必要なアセンブリ修飾型名、バージョン番号が含まれています。</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Alternate implementations of the type system may need to return subclasses of <ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> that are not created by the CLR; all types that are returned by other overloads of the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> method are runtime types.</source>
          <target state="translated">型システムの代替実装のサブクラスを返す必要があります<ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph>は、CLR では作成されません。 すべての型の他のオーバー ロードによって返される、<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>メソッドはランタイム型。</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Usage Notes</source>
          <target state="translated">使用上の注意</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>This method overload and its associated overloads parse <ph id="ph1">`typeName`</ph> into the name of a type and the name of an assembly, and then resolve the names.</source>
          <target state="translated">このメソッドのオーバー ロードと関連付けられているオーバー ロードを解析<ph id="ph1">`typeName`</ph>型と、アセンブリの名前の名前にし、名前を解決します。</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</source>
          <target state="translated">アセンブリ名の解決は、アセンブリのコンテキストで、型名を解決する必要があるために、型名の解決の前に発生します。</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If you are unfamiliar with the concept of assembly-qualified type names, see the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property.</source>
          <target state="translated">アセンブリ修飾型名の概念を理解されていない場合、<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> is not an assembly-qualified name, assembly resolution is skipped.</source>
          <target state="translated">場合<ph id="ph1">`typeName`</ph>アセンブリ修飾名ではないアセンブリの解決はスキップされます。</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the <ph id="ph1">`typeResolver`</ph> parameter.</source>
          <target state="translated">Mscorlib.dll または実行中のアセンブリのコンテキストでの非修飾型名を解決することも、内のアセンブリを使用できます必要に応じて、<ph id="ph1">`typeResolver`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section.</source>
          <target state="translated">などのさまざまな種類の名前解決はで表形式で表示されているは、アセンブリ名を省略すると効果、<bpt id="p1">[</bpt>混合名前解決<ept id="p1">](#mixed_name_resolution)</ept>セクションです。</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>General usage notes:</source>
          <target state="translated">一般的な使用法に関する注意事項:</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Do not pass methods to <ph id="ph1">`assemblyResolver`</ph> or <ph id="ph2">`typeResolver`</ph> if they come from unknown or untrusted callers.</source>
          <target state="translated">メソッドは渡さないように<ph id="ph1">`assemblyResolver`</ph>または<ph id="ph2">`typeResolver`</ph>不明または信頼されていない呼び出し元から送られてきた場合。</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">指定したメソッドまたは使い慣れているメソッドだけを使用してください。</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</source>
          <target state="translated">不明または信頼されていない呼び出し元からのメソッドを使用すると、悪意のあるコードの特権の昇格が発生する可能性があります。</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If you omit the <ph id="ph1">`assemblyResolver`</ph> and/or <ph id="ph2">`typeResolver`</ph> parameters, the value of the <ph id="ph3">`throwOnError`</ph> parameter is passed to the methods that perform the default resolution.</source>
          <target state="translated">省略した場合、<ph id="ph1">`assemblyResolver`</ph>や<ph id="ph2">`typeResolver`</ph>パラメーター、値の<ph id="ph3">`throwOnError`</ph>パラメーターは既定の解決を実行するメソッドに渡されます。</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`throwOnError`</ph> is <ph id="ph2">`true`</ph>, this method throws a <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> when <ph id="ph4">`typeResolver`</ph> returns <ph id="ph5">`null`</ph>, and a <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> when <ph id="ph7">`assemblyResolver`</ph> returns <ph id="ph8">`null`</ph>.</source>
          <target state="translated">場合<ph id="ph1">`throwOnError`</ph>は<ph id="ph2">`true`</ph>、このメソッドがスローされます、<ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph>とき<ph id="ph4">`typeResolver`</ph>を返します<ph id="ph5">`null`</ph>、および<ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph>とき<ph id="ph7">`assemblyResolver`</ph>を返します<ph id="ph8">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>This method does not catch exceptions thrown by <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph>.</source>
          <target state="translated">このメソッドによってスローされる例外をキャッチしません<ph id="ph1">`assemblyResolver`</ph>と<ph id="ph2">`typeResolver`</ph>です。</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>You are responsible for any exceptions that are thrown by the resolver methods.</source>
          <target state="translated">リゾルバー メソッドによってスローされる例外を担当しています。</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Assemblies</source>
          <target state="translated">アセンブリの解決</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method receives an <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object, which is produced by parsing the string assembly name that is included in <ph id="ph3">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph>メソッドは受信、<ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph>オブジェクトに含まれている文字列のアセンブリ名を解析することによって生成される<ph id="ph3">`typeName`</ph>です。</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> does not contain an assembly name, <ph id="ph2">`assemblyResolver`</ph> is not called and <ph id="ph3">`null`</ph> is passed to <ph id="ph4">`typeResolver`</ph>.</source>
          <target state="translated">場合<ph id="ph1">`typeName`</ph>アセンブリ名を含まない<ph id="ph2">`assemblyResolver`</ph>が呼び出されないと<ph id="ph3">`null`</ph>に渡される<ph id="ph4">`typeResolver`</ph>。</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is not supplied, standard assembly probing is used to locate the assembly.</source>
          <target state="translated">場合<ph id="ph1">`assemblyResolver`</ph>が指定された、標準のアセンブリのプローブを使用してアセンブリを見つけます。</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> method does not do standard probing; in that case you must ensure that your <ph id="ph3">`assemblyResolver`</ph> can handle all the assemblies you pass to it.</source>
          <target state="translated">場合<ph id="ph1">`assemblyResolver`</ph>が指定されて、<ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph>メソッドでは、標準のプローブは実行しません。 その場合はことを確認、<ph id="ph3">`assemblyResolver`</ph>渡すするすべてのアセンブリを処理することができます。</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method should return <ph id="ph2">`null`</ph> if the assembly cannot be resolved.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph>メソッドが返す<ph id="ph2">`null`</ph>場合は、アセンブリを解決することはできません。</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> returns <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> is not called and no further processing occurs; additionally, if <ph id="ph4">`throwOnError`</ph> is <ph id="ph5">`true`</ph>, a <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">場合<ph id="ph1">`assemblyResolver`</ph>を返します<ph id="ph2">`null`</ph>、<ph id="ph3">`typeResolver`</ph>は呼び出されませんそれ以上の処理が行われます。 さらに、場合<ph id="ph4">`throwOnError`</ph>は<ph id="ph5">`true`</ph>、<ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> that is passed to <ph id="ph2">`assemblyResolver`</ph> is a partial name, one or more of its parts are <ph id="ph3">`null`</ph>.</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>に渡される<ph id="ph2">`assemblyResolver`</ph>部分は、名前、1 つ以上の一部が<ph id="ph3">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, if it has no version, the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> property is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">たとえば、バージョン、設定されていない場合、<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph>プロパティは<ph id="ph2">`null`</ph>します。</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> property, the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CultureInfo%2A&gt;</ph> property, and the <ph id="ph3">&lt;xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A&gt;</ph> method all return <ph id="ph4">`null`</ph>, then only the simple name of the assembly was supplied.</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph>プロパティ、<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CultureInfo%2A&gt;</ph>プロパティ、および<ph id="ph3">&lt;xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A&gt;</ph>メソッドのすべての戻り<ph id="ph4">`null`</ph>、アセンブリの簡易名だけが指定されました。</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method can use or ignore all parts of the assembly name.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph>メソッドを使用したり、アセンブリ名のすべての部分を無視します。</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The effects of different assembly resolution options are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section, for simple and assembly-qualified type names.</source>
          <target state="translated">別のアセンブリ解決のオプションの効果が内でテーブルとして表示されます、<bpt id="p1">[</bpt>混合名前解決<ept id="p1">](#mixed_name_resolution)</ept>セクション、および単純なアセンブリ修飾型名にします。</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Types</source>
          <target state="translated">型の解決</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> does not specify an assembly name, <ph id="ph2">`typeResolver`</ph> is always called.</source>
          <target state="translated">場合<ph id="ph1">`typeName`</ph>、アセンブリ名を指定しない<ph id="ph2">`typeResolver`</ph>は必ず呼び出されます。</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> specifies an assembly name, <ph id="ph2">`typeResolver`</ph> is called only when the assembly name is successfully resolved.</source>
          <target state="translated">場合<ph id="ph1">`typeName`</ph>、アセンブリ名を指定<ph id="ph2">`typeResolver`</ph>はアセンブリ名が正常に解決された場合にのみ呼び出されます。</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> or standard assembly probing returns <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> is not called.</source>
          <target state="translated">場合<ph id="ph1">`assemblyResolver`</ph>または標準のアセンブリのプローブを返します<ph id="ph2">`null`</ph>、<ph id="ph3">`typeResolver`</ph>は呼び出されません。</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`typeResolver`</ph> method receives three arguments:</source>
          <target state="translated"><ph id="ph1">`typeResolver`</ph>メソッドが 3 つの引数を受け取ります。</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly to search or <ph id="ph1">`null`</ph> if <ph id="ph2">`typeName`</ph> does not contain an assembly name.</source>
          <target state="translated">検索するアセンブリまたは<ph id="ph1">`null`</ph>場合<ph id="ph2">`typeName`</ph>にアセンブリ名がありません。</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The simple name of the type.</source>
          <target state="translated">型の簡易名。</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In the case of a nested type, this is the outermost containing type.</source>
          <target state="translated">入れ子にされた型の場合、これは、最も外側の格納先の型です。</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In the case of a generic type, this is the simple name of the generic type.</source>
          <target state="translated">ジェネリック型の場合、ジェネリック型の単純名です。</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A Boolean value that is <ph id="ph1">`true`</ph> if the case of type names is to be ignored.</source>
          <target state="translated">ブール値である<ph id="ph1">`true`</ph>場合型名の大文字と小文字は無視されます。</target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The implementation determines the way these arguments are used.</source>
          <target state="translated">実装では、これらの引数の使用方法を決定します。</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`typeResolver`</ph> method should return <ph id="ph2">`null`</ph> if it cannot resolve the type.</source>
          <target state="translated"><ph id="ph1">`typeResolver`</ph>メソッドが返す<ph id="ph2">`null`</ph>型を解決できない場合。</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeResolver`</ph> returns <ph id="ph2">`null`</ph> and <ph id="ph3">`throwOnError`</ph> is <ph id="ph4">`true`</ph>, this overload of <ph id="ph5">&lt;xref:System.Type.GetType%2A&gt;</ph> throws a <ph id="ph6">&lt;xref:System.TypeLoadException&gt;</ph>.</source>
          <target state="translated">場合<ph id="ph1">`typeResolver`</ph>返します<ph id="ph2">`null`</ph>と<ph id="ph3">`throwOnError`</ph>は<ph id="ph4">`true`</ph>のこのオーバー ロード<ph id="ph5">&lt;xref:System.Type.GetType%2A&gt;</ph>をスロー、<ph id="ph6">&lt;xref:System.TypeLoadException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The effects of different type resolution options are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section, for simple and assembly-qualified type names.</source>
          <target state="translated">別の型解決オプションの効果が内でテーブルとして表示されます、<bpt id="p1">[</bpt>混合名前解決<ept id="p1">](#mixed_name_resolution)</ept>セクション、および単純なアセンブリ修飾型名にします。</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Nested Types</source>
          <target state="translated">入れ子にされた型を解決します。</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> is a nested type, only the name of the outermost containing type is passed to <ph id="ph2">`typeResolver`</ph>.</source>
          <target state="translated">場合<ph id="ph1">`typeName`</ph>は入れ子にされた型、最も外側の名前だけに渡される型を含む<ph id="ph2">`typeResolver`</ph>です。</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>When <ph id="ph1">`typeResolver`</ph> returns this type, the <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> method is called recursively until the innermost nested type has been resolved.</source>
          <target state="translated">ときに<ph id="ph1">`typeResolver`</ph>この型を返します、<ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>メソッドは再帰的に最も内側の入れ子にされた型が解決するまでです。</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Generic Types</source>
          <target state="translated">ジェネリック型の解決</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>のジェネリック型を解決するのには再帰呼び出しは: 自体には、ジェネリック型を解決するのには、最初にし、型引数を解決するのには、します。</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If a type argument is generic, <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> is called recursively to resolve its type arguments, and so on.</source>
          <target state="translated">場合は、型引数はジェネリック<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>再帰的に、型引数を解決するためには、呼び出されます。</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The combination of <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> that you provide must be capable of resolving all levels of this recursion.</source>
          <target state="translated">組み合わせ<ph id="ph1">`assemblyResolver`</ph>と<ph id="ph2">`typeResolver`</ph>この再帰のすべてのレベルの解決に対応する必要がありますを指定することです。</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, suppose you supply an <ph id="ph1">`assemblyResolver`</ph> that controls the loading of <ph id="ph2">`MyAssembly`</ph>.</source>
          <target state="translated">たとえば、指定した、<ph id="ph1">`assemblyResolver`</ph>の読み込みを制御する<ph id="ph2">`MyAssembly`</ph>です。</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Suppose you want to resolve the generic type <ph id="ph1">`Dictionary&lt;string, MyType&gt;`</ph> (<ph id="ph2">`Dictionary(Of String, MyType)`</ph> in Visual Basic).</source>
          <target state="translated">ジェネリック型を解決する対象とすると<ph id="ph1">`Dictionary&lt;string, MyType&gt;`</ph>(<ph id="ph2">`Dictionary(Of String, MyType)`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>You might pass the following generic type name:</source>
          <target state="translated">次のジェネリック型の名前を渡すことがあります。</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Notice that <ph id="ph1">`MyType`</ph> is the only assembly-qualified type argument.</source>
          <target state="translated">注意して<ph id="ph1">`MyType`</ph>のみのアセンブリ修飾の型引数です。</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The names of the <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> and <ph id="ph2">&lt;xref:System.String&gt;</ph> classes are not assembly-qualified.</source>
          <target state="translated">名前、<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>と<ph id="ph2">&lt;xref:System.String&gt;</ph>クラスは、アセンブリ修飾します。</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Your <ph id="ph1">`typeResolver`</ph> must be able handle either an assembly or <ph id="ph2">`null`</ph>, because it will receive <ph id="ph3">`null`</ph> for <ph id="ph4">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> and <ph id="ph5">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`typeResolver`</ph>できるハンドルである必要があります、どちらかのアセンブリまたは<ph id="ph2">`null`</ph>を受信するため、<ph id="ph3">`null`</ph>の<ph id="ph4">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>と<ph id="ph5">&lt;xref:System.String&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>It can handle that case by calling an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</source>
          <target state="translated">オーバー ロードを呼び出すことによってそのケースを処理できる、<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>を両方の非修飾型名は Mscorlib.dll にあるため、文字列を受け取るメソッド。</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph>辞書の型と文字列型に対しては、それらの型名はアセンブリ修飾ではないためメソッドは呼び出されません。</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Now suppose that instead of <ph id="ph1">`System.String`</ph>, the first generic argument type is <ph id="ph2">`YourType`</ph>, from <ph id="ph3">`YourAssembly`</ph>:</source>
          <target state="translated">現在の代わりにするものとします<ph id="ph1">`System.String`</ph>、最初の汎用引数の型が<ph id="ph2">`YourType`</ph>から<ph id="ph3">`YourAssembly`</ph>:</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve <ph id="ph1">`YourType`</ph> without an assembly-qualified name.</source>
          <target state="translated">このアセンブリは、Mscorlib.dll も実行中のアセンブリには、解決できない場合は<ph id="ph1">`YourType`</ph>アセンブリ修飾名がない場合。</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Because your <ph id="ph1">`assemblyResolve`</ph> will be called recursively, it must be able to handle this case.</source>
          <target state="translated"><ph id="ph1">`assemblyResolve`</ph>は再帰的に呼び出されると、その必要がありますこのケースを処理することができます。</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Instead of returning <ph id="ph1">`null`</ph> for assemblies other than <ph id="ph2">`MyAssembly`</ph>, it now performs an assembly load using the supplied <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object.</source>
          <target state="translated">返す代わりに<ph id="ph1">`null`</ph>以外のアセンブリの<ph id="ph2">`MyAssembly`</ph>を使用して、指定されたアセンブリの読み込みを今すぐ実行<ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Back to <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>.</source>
          <target state="translated">戻る<bpt id="p1">[</bpt>使用上の注意<ept id="p1">](#usage_notes)</ept>です。</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Type Names with Special Characters</source>
          <target state="translated">特殊文字を含む型名の解決</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Certain characters have special meanings in assembly-qualified names.</source>
          <target state="translated">特定の文字では、アセンブリ修飾名で特殊な意味があります。</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</source>
          <target state="translated">単純な型名にこれらの文字が含まれている場合、文字では、簡易名は、アセンブリ修飾名の一部で、解析エラーが発生します。</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method.</source>
          <target state="translated">解析エラーを避けるためをアセンブリ修飾名を渡す前に、円記号と特殊文字をエスケープする必要があります、<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, if a type is named <ph id="ph1">`Strange]Type`</ph>, the escape character must be added ahead of the square bracket as follows: <ph id="ph2">`Strange\]Type`</ph>.</source>
          <target state="translated">たとえば、型が名前付き<ph id="ph1">`Strange]Type`</ph>、エスケープ文字を次のように、角かっこの前追加する必要があります:<ph id="ph2">`Strange\]Type`</ph>です。</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</source>
          <target state="translated">などの特殊文字が付いているは、Visual Basic または C# の場合で作成することはできませんが、Microsoft intermediate language (MSIL) を使用するか、動的アセンブリを生成することによって作成されたことができます。</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The following table shows the special characters for type names.</source>
          <target state="translated">次の表は、型名に特殊文字を示しています。</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Character</source>
          <target state="translated">文字</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Meaning</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`,`</ph> (comma)</source>
          <target state="translated"><ph id="ph1">`,`</ph> (コンマ)</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Delimiter for assembly-qualified names.</source>
          <target state="translated">アセンブリ修飾名の区切り記号。</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`[]`</ph> (square brackets)</source>
          <target state="translated"><ph id="ph1">`[]`</ph> (角かっこ)</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</source>
          <target state="translated">サフィックス ペアとして、配列型を示します区切り記号のペアとして、汎用引数リストとアセンブリ修飾名を囲みます。</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`&amp;`</ph> (ampersand)</source>
          <target state="translated"><ph id="ph1">`&amp;`</ph> (アンパサンド)</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>As a suffix, indicates that a type is a reference type.</source>
          <target state="translated">サフィックスとして、種類が参照型であることを示します。</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`*`</ph> (asterisk)</source>
          <target state="translated"><ph id="ph1">`*`</ph> (アスタリスク付き)</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>As a suffix, indicates that a type is a pointer type.</source>
          <target state="translated">サフィックスとして、型、ポインター型であることを示します。</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`+`</ph> (plus)</source>
          <target state="translated"><ph id="ph1">`+`</ph> (プラス)</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Delimiter for nested types.</source>
          <target state="translated">入れ子にされた型の区切り記号。</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`\`</ph> (backslash)</source>
          <target state="translated"><ph id="ph1">`\`</ph> (円記号)</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Escape character.</source>
          <target state="translated">文字をエスケープします。</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Properties such as <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> return correctly escaped strings.</source>
          <target state="translated">などのプロパティ<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>正しくエスケープされた文字列を返します。</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>You must pass correctly escaped strings to the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method.</source>
          <target state="translated">正しくエスケープされた文字列を渡す必要があります、<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In turn, the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method passes correctly escaped names to <ph id="ph2">`typeResolver`</ph> and to the default type resolution methods.</source>
          <target state="translated">さらに、<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>メソッドは成功を正しくエスケープされた名前<ph id="ph2">`typeResolver`</ph>と既定値の型解決方法です。</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If you need to compare a name to an unescaped name in <ph id="ph1">`typeResolver`</ph>, you must remove the escape characters.</source>
          <target state="translated">内のエスケープ解除された名に名前を比較する必要があるかどうかは<ph id="ph1">`typeResolver`</ph>、エスケープ文字を削除する必要があります。</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Back to <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>.</source>
          <target state="translated">戻る<bpt id="p1">[</bpt>使用上の注意<ept id="p1">](#usage_notes)</ept>です。</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Mixed Name Resolution</source>
          <target state="translated">混合名前解決</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The following table summarizes the interactions between <ph id="ph1">`assemblyResolver`</ph>, <ph id="ph2">`typeResolver`</ph>, and default name resolution, for all combinations of type name and assembly name in <ph id="ph3">`typeName`</ph>:</source>
          <target state="translated">次の表に、間の相互作用<ph id="ph1">`assemblyResolver`</ph>、 <ph id="ph2">`typeResolver`</ph>、型名とアセンブリ名のすべての組み合わせに対して、既定の名前解決および<ph id="ph3">`typeName`</ph>:</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Contents of type name</source>
          <target state="translated">型名の内容</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Assembly resolver method</source>
          <target state="translated">アセンブリ リゾルバー メソッド</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Type resolver method</source>
          <target state="translated">型競合回避モジュールのメソッド</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Result</source>
          <target state="translated">結果</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">アセンブリの種類</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">null</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">null</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">呼び出すことと同等、<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">アセンブリの種類</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">指定されました。</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">null</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`assemblyResolver`</ph> returns the assembly or returns <ph id="ph2">`null`</ph> if it cannot resolve the assembly.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph> アセンブリを返しますまたは、返す<ph id="ph2">`null`</ph>アセンブリを解決できない場合。</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the assembly is resolved, the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</source>
          <target state="translated">アセンブリが解決される場合、<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph>メソッドのオーバー ロードがアセンブリから型の読み込みに使用される。 それ以外の場合、型の解決を試行は不要です。</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">アセンブリの種類</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">null</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">指定されました。</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Equivalent to converting the assembly name to an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and calling the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType&gt;</ph> method overload to get the assembly.</source>
          <target state="translated">アセンブリ名を変換と同じ、<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>オブジェクトと呼び出し元、<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType&gt;</ph>アセンブリを取得するメソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the assembly is resolved, it is passed to <ph id="ph1">`typeResolver`</ph>; otherwise, <ph id="ph2">`typeResolver`</ph> is not called and there is no further attempt to resolve the type.</source>
          <target state="translated">渡されるが、アセンブリが解決した場合は、 <ph id="ph1">`typeResolver`</ph>、それ以外の<ph id="ph2">`typeResolver`</ph>は呼び出されません型の解決を試行することはありません。</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">アセンブリの種類</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">指定されました。</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">指定されました。</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`assemblyResolver`</ph> returns the assembly or returns <ph id="ph2">`null`</ph> if it cannot resolve the assembly.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph> アセンブリを返しますまたは、返す<ph id="ph2">`null`</ph>アセンブリを解決できない場合。</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the assembly is resolved, it is passed to <ph id="ph1">`typeResolver`</ph>; otherwise, <ph id="ph2">`typeResolver`</ph> is not called and there is no further attempt to resolve the type.</source>
          <target state="translated">渡されるが、アセンブリが解決した場合は、 <ph id="ph1">`typeResolver`</ph>、それ以外の<ph id="ph2">`typeResolver`</ph>は呼び出されません型の解決を試行することはありません。</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type</source>
          <target state="translated">型</target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">null に指定されました。</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">null</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">呼び出すことと同等、<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.</source>
          <target state="translated">アセンブリ名が指定されていないために、Mscorlib.dll および実行中のアセンブリのみが検索されます。</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, it is ignored.</source>
          <target state="translated">場合<ph id="ph1">`assemblyResolver`</ph>は、指定した場合は無視されます。</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type</source>
          <target state="translated">型</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">null に指定されました。</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">指定されました。</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`typeResolver`</ph> is called, and <ph id="ph2">`null`</ph> is passed for the assembly.</source>
          <target state="translated"><ph id="ph1">`typeResolver`</ph> 呼び出されると<ph id="ph2">`null`</ph>アセンブリが渡されました。</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`typeResolver`</ph> can provide a type from any assembly, including assemblies it loads for the purpose.</source>
          <target state="translated"><ph id="ph1">`typeResolver`</ph> 目的のロード アセンブリも含め、任意のアセンブリから型を提供できます。</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, it is ignored.</source>
          <target state="translated">場合<ph id="ph1">`assemblyResolver`</ph>は、指定した場合は無視されます。</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>assembly</source>
          <target state="translated">アセンブリ</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">null に指定されました。</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">null に指定されました。</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph>スローされると、アセンブリ修飾型名の場合と同様に、アセンブリ名が解析されるためです。</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>This results in an invalid assembly name.</source>
          <target state="translated">これは、結果、無効なアセンブリ名。</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Back to: <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>, <bpt id="p2">[</bpt>Resolving Assemblies<ept id="p2">](#resolving_assemblies)</ept>, <bpt id="p3">[</bpt>Resolving Types<ept id="p3">](#resolving_types)</ept>.</source>
          <target state="translated">戻る:<bpt id="p1">[</bpt>使用上の注意<ept id="p1">](#usage_notes)</ept>、<bpt id="p2">[</bpt>アセンブリを解決する<ept id="p2">](#resolving_assemblies)</ept>、<bpt id="p3">[</bpt>型の解決<ept id="p3">](#resolving_types)</ept>です。</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">クラス初期化子が呼び出され、例外をスローします。</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、型は見つかりません。</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> に埋め込まれたタブなどの無効な文字が含まれています。</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> が空の文字列です。</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> が無効なサイズの配列型を表しています。</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は、<ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> の配列を表します。</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>An error occurs when <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> が型名とアセンブリ名に解析されるとき、エラーが発生します (たとえば、単純な型名にエスケープされない特殊文字が含まれている場合)。 </target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax (for example, "MyType[,*,]").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> は <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> には無効な構文 (たとえば、"MyType[,*,]") が含まれています。</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は、型引数の 1 つとしてポインター型、<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>、または <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> を持つジェネリック型を表しています。</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> が、正しい数の型引数が格納されていないジェネリック型を表しています。</target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> がジェネリック型を表しており、その型引数の 1 つが対応する型パラメーターの制約を満たしていません。</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">アセンブリ、またはその依存関係のうちの 1 つが見つかったが、読み込めませんでした。</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contains an invalid assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> には無効なアセンブリ名が含まれています。</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is a valid assembly name without a type name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は、型名のない有効なアセンブリ名です。</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">アセンブリ、またはその依存関係のうちの 1 つが無効です。</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>An array of objects whose types to determine.</source>
          <target state="translated">型を確認する対象のオブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>Gets the types of the objects in the specified array.</source>
          <target state="translated">指定した配列内のオブジェクトの型を取得します。</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the types of the corresponding elements in <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="args" /&gt;</ph> 内の対応する要素の型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> method to list the types of the elements of an array.</source>
          <target state="translated">次のコード例を使用する方法を示しています、<ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph>メソッドを配列の要素の種類を一覧表示します。</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source><ph id="ph1">&lt;paramref name="args" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>One or more of the elements in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> の要素の 1 つ以上が <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>The class initializers are invoked and at least one throws an exception.</source>
          <target state="translated">クラスの初期化子が呼び出され、少なくとも 1 つは例外をスローします。</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>The type whose underlying type code to get.</source>
          <target state="translated">基になる型コードを取得する対象となる型。</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>Gets the underlying type code of the specified <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の基になる型コードを取得します。</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>The code of the underlying type, or <ph id="ph1">&lt;see cref="F:System.TypeCode.Empty" /&gt;</ph> if <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="type" /&gt;</ph> が <ph id="ph3">&lt;see langword="null" /&gt;</ph> の場合、基になる型または <ph id="ph1">&lt;see cref="F:System.TypeCode.Empty" /&gt;</ph> のコード。</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>When you inherit from <ph id="ph1">&lt;xref:System.Type&gt;</ph>, you can change the behavior of this method by overriding the <ph id="ph2">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph> method.</source>
          <target state="translated">継承する場合<ph id="ph1">&lt;xref:System.Type&gt;</ph>、オーバーライドしてこのメソッドの動作を変更することができます、<ph id="ph2">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>The following code example demonstrates how the <ph id="ph1">&lt;xref:System.TypeCode&gt;</ph> enumeration can be used.</source>
          <target state="translated">次のコード例を示しています、<ph id="ph1">&lt;xref:System.TypeCode&gt;</ph>列挙体を使用することができます。</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>In a decision block inside the <ph id="ph1">`WriteObjectInfo`</ph> method, the <ph id="ph2">&lt;xref:System.TypeCode&gt;</ph> of an <ph id="ph3">&lt;xref:System.Object&gt;</ph> parameter is examined, and an appropriate message is written to the console.</source>
          <target state="translated">内の判断ブロックで、 <ph id="ph1">`WriteObjectInfo`</ph> 、メソッド、<ph id="ph2">&lt;xref:System.TypeCode&gt;</ph>の<ph id="ph3">&lt;xref:System.Object&gt;</ph>パラメーターが調べられ、適切なメッセージがコンソールに書き込まれます。</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCodeImpl">
          <source>Returns the underlying type code of this <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> instance.</source>
          <target state="translated">この <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> インスタンスの基になる型コードを返します。</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCodeImpl">
          <source>The type code of the underlying type.</source>
          <target state="translated">基になる型の型コード。</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCodeImpl">
          <source>This method provides the implementation for the <ph id="ph1">`static`</ph> (in C#) or <ph id="ph2">`Shared`</ph> (in Visual Basic) <ph id="ph3">&lt;xref:System.Type.GetTypeCode%28System.Type%29&gt;</ph> method.</source>
          <target state="translated">このメソッドの実装を提供する、 <ph id="ph1">`static`</ph> (C# の場合) または<ph id="ph2">`Shared`</ph>(Visual Basic) の<ph id="ph3">&lt;xref:System.Type.GetTypeCode%28System.Type%29&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCodeImpl">
          <source>When you inherit from <ph id="ph1">&lt;xref:System.Type&gt;</ph>, you can override this method to provide your own implementation of <ph id="ph2">&lt;xref:System.Type.GetTypeCode%2A&gt;</ph>.</source>
          <target state="translated">継承する場合<ph id="ph1">&lt;xref:System.Type&gt;</ph>、独自の実装を提供するには、このメソッドをオーバーライドすることができます<ph id="ph2">&lt;xref:System.Type.GetTypeCode%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the type associated with the specified class identifier (CLSID).</source>
          <target state="translated">指定したクラス識別子 (CLSID) に関連付けられている型を取得します。</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">取得する型の CLSID。</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Gets the type associated with the specified class identifier (CLSID).</source>
          <target state="translated">指定したクラス識別子 (CLSID) に関連付けられている型を取得します。</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated">CLSID が有効かどうかに関係なく <ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>メソッドをサポートしている遅延バインディング アクセス アンマネージ COM オブジェクトを .NET Framework アプリから COM オブジェクトのクラス id (CLSID) がわかっている場合。</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">COM クラスのクラス識別子は、レジストリの hkey_classes_root \clsid キーで定義されます。</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">値を取得することができます、<ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph>プロパティは、このメソッドによって返される型が COM オブジェクトであるかどうかを判別します。</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">呼び出すことができます、 <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> COM に遅延バインディング アクセスの方法がわかっているプログラム id (ProgID) のオブジェクトします。</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">2 段階のプロセスには、CLSID からアンマネージの COM オブジェクトをインスタンス化します。</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the<ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">取得、<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表すオブジェクト、<ph id="ph2">`__ComObject`</ph>呼び出すことによって、CLSID に対応する、<ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">呼び出す、 <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> COM オブジェクトをインスタンス化するメソッド。</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>See the example for an illustration.</source>
          <target state="translated">図については、例を参照してください。</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%28System.Guid%29&gt;</ph> overload ignores any exception that may occur when instantiating a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object based on the <ph id="ph3">`clsid`</ph> argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%28System.Guid%29&gt;</ph>オーバー ロードには、インスタンス化するときに発生する可能性がありますのある任意の例外が無視されます、<ph id="ph2">&lt;xref:System.Type&gt;</ph>オブジェクトに基づいて、<ph id="ph3">`clsid`</ph>引数。</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Note that no exception is thrown if <ph id="ph1">`clsid`</ph> is not found in the registry.</source>
          <target state="translated">例外はスローされません注<ph id="ph1">`clsid`</ph>はレジストリに存在しません。</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application.</source>
          <target state="translated">次の例は、Microsoft Word の CLSID<bpt id="p1">[</bpt>アプリケーション オブジェクト<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept>Microsoft Word アプリケーションを表す COM 型を取得します。</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">呼び出して、型をインスタンス化、<ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph>メソッドを呼び出すことによってが閉じると、 <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept>メソッドです。</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">このメソッドは、.NET Framework オブジェクトではなく、COM オブジェクトを使用する場合、使用するものはします。</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">管理されているすべてのオブジェクト、COM 参照可能なものも含め (つまり、その<ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph>属性は<ph id="ph2">&lt;see langword="true" /&gt;</ph>) によって返される GUID を持つ、<ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Although the method returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for .NET Framework objects, you can't use that <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">メソッドを返しますが、 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> .NET Framework の GUID に対応するオブジェクトがオブジェクトを使用することはできません<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>を呼び出すことによって、型のインスタンスを作成するオブジェクト、<ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph>メソッドを次の例のようにします。</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">代わりに、<ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph>アンマネージ COM オブジェクト、および結果の GUID を取得するのみ使用する必要があります<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>に渡されるオブジェクト、<ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph>メソッドがアンマネージ COM オブジェクトを表す必要があります。</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">取得する型の CLSID。</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated">発生した例外をすべてスローする場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated">発生した例外をすべて無視する場合は <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したクラス ID (CLSID) に関連付けられた型を取得します。</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated">CLSID が有効かどうかに関係なく <ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>メソッドをサポートしている遅延バインディング アクセス アンマネージ COM オブジェクトを .NET Framework アプリから COM オブジェクトのクラス id (CLSID) がわかっている場合。</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">COM クラスのクラス識別子は、レジストリの hkey_classes_root \clsid キーで定義されます。</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">値を取得することができます、<ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph>プロパティは、このメソッドによって返される型が COM オブジェクトであるかどうかを判別します。</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">呼び出すことができます、 <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> COM に遅延バインディング アクセスの方法がわかっているプログラム id (ProgID) のオブジェクトします。</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">2 段階のプロセスには、CLSID からアンマネージの COM オブジェクトをインスタンス化します。</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">取得、<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表すオブジェクト、<ph id="ph2">`__ComObject`</ph>呼び出すことによって、CLSID に対応する、<ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">呼び出す、 <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> COM オブジェクトをインスタンス化するメソッド。</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>See the example for an illustration.</source>
          <target state="translated">図については、例を参照してください。</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> will be thrown when specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnError`</ph>, but it will not fail for unregistered CLSIDs.</source>
          <target state="translated">ような例外<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>を指定する場合にスローされる<ph id="ph2">`true`</ph>の<ph id="ph3">`throwOnError`</ph>、未登録の Clsid に対しては失敗しませんが、します。</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application.</source>
          <target state="translated">次の例は、Microsoft Word の CLSID<bpt id="p1">[</bpt>アプリケーション オブジェクト<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept>Microsoft Word アプリケーションを表す COM 型を取得します。</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">呼び出して、型をインスタンス化、<ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph>メソッドを呼び出すことによってが閉じると、 <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept>メソッドです。</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>An exception is thrown if an error occurs while loading the type.</source>
          <target state="translated">型の読み込み中にエラーが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">このメソッドは、.NET Framework オブジェクトではなく、COM オブジェクトを使用する場合、使用するものはします。</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">管理されているすべてのオブジェクト、COM 参照可能なものも含め (つまり、その<ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph>属性は<ph id="ph2">&lt;see langword="true" /&gt;</ph>) によって返される GUID を持つ、<ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Although the method returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for .NET Framework objects, you can't use that <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">メソッドを返しますが、 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> .NET Framework の GUID に対応するオブジェクトがオブジェクトを使用することはできません<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>を呼び出すことによって、型のインスタンスを作成するオブジェクト、<ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph>メソッドを次の例のようにします。</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">代わりに、<ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph>アンマネージ COM オブジェクト、および結果の GUID を取得するのみ使用する必要があります<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>に渡されるオブジェクト、<ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph>メソッドがアンマネージ COM オブジェクトを表す必要があります。</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">取得する型の CLSID。</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The server from which to load the type.</source>
          <target state="translated">型の読み込み元のサーバー。</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">サーバー名が <ph id="ph1">&lt;see langword="null" /&gt;</ph> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Gets the type associated with the specified class identifier (CLSID) from the specified server.</source>
          <target state="translated">指定したサーバーから、指定したクラス ID (CLSID) に関連付けられている型を取得します。</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated">CLSID が有効かどうかに関係なく <ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>メソッドをサポートしている遅延バインディング アクセス アンマネージ COM オブジェクトを .NET Framework アプリから COM オブジェクトのクラス id (CLSID) がわかっている場合。</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">COM クラスのクラス識別子は、レジストリの hkey_classes_root \clsid キーで定義されます。</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">値を取得することができます、<ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph>プロパティは、このメソッドによって返される型が COM オブジェクトであるかどうかを判別します。</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">呼び出すことができます、 <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> COM に遅延バインディング アクセスの方法がわかっているプログラム id (ProgID) のオブジェクトします。</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">2 段階のプロセスには、CLSID からアンマネージの COM オブジェクトをインスタンス化します。</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">取得、<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表すオブジェクト、<ph id="ph2">`__ComObject`</ph>呼び出すことによって、CLSID に対応する、<ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">呼び出す、 <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> COM オブジェクトをインスタンス化するメソッド。</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">次の例は、Microsoft Word の CLSID<bpt id="p1">[</bpt>アプリケーション オブジェクト<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept>computer17.central.contoso.com をという名前のサーバーから Microsoft Word アプリケーションを表す COM 型を取得します。呼び出して、型をインスタンス化、<ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph>メソッドを呼び出すことによってが閉じると、 <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept>メソッドです。</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">このメソッドは、.NET Framework オブジェクトではなく、COM オブジェクトを使用する場合、使用するものはします。</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">管理されているすべてのオブジェクト、COM 参照可能なものも含め (つまり、その<ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph>属性は<ph id="ph2">&lt;see langword="true" /&gt;</ph>) によって返される GUID を持つ、<ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Although the method returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for .NET Framework objects, you can't use that <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">メソッドを返しますが、 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> .NET Framework の GUID に対応するオブジェクトがオブジェクトを使用することはできません<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>を呼び出すことによって、型のインスタンスを作成するオブジェクト、<ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph>メソッドを次の例のようにします。</target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">代わりに、<ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph>アンマネージ COM オブジェクト、および結果の GUID を取得するのみ使用する必要があります<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>に渡されるオブジェクト、<ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph>メソッドがアンマネージ COM オブジェクトを表す必要があります。</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">取得する型の CLSID。</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The server from which to load the type.</source>
          <target state="translated">型の読み込み元のサーバー。</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">サーバー名が <ph id="ph1">&lt;see langword="null" /&gt;</ph> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated">発生した例外をすべてスローする場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated">発生した例外をすべて無視する場合は <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したサーバーの指定したクラス ID (CLSID) に関連付けられた型を取得します。</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated">CLSID が有効かどうかに関係なく <ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>メソッドをサポートしている遅延バインディング アクセス アンマネージ COM オブジェクトを .NET Framework アプリから COM オブジェクトのクラス id (CLSID) がわかっている場合。</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">COM クラスのクラス識別子は、レジストリの hkey_classes_root \clsid キーで定義されます。</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">値を取得することができます、<ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph>プロパティは、このメソッドによって返される型が COM オブジェクトであるかどうかを判別します。</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">呼び出すことができます、 <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> COM に遅延バインディング アクセスの方法がわかっているプログラム id (ProgID) のオブジェクトします。</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">2 段階のプロセスには、CLSID からアンマネージの COM オブジェクトをインスタンス化します。</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">取得、<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表すオブジェクト、<ph id="ph2">`__ComObject`</ph>呼び出すことによって、CLSID に対応する、<ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">呼び出す、 <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> COM オブジェクトをインスタンス化するメソッド。</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> will be thrown when specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnError`</ph>, but it will not fail for unregistered CLSIDs.</source>
          <target state="translated">ような例外<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>を指定する場合にスローされる<ph id="ph2">`true`</ph>の<ph id="ph3">`throwOnError`</ph>、未登録の Clsid に対しては失敗しませんが、します。</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">次の例は、Microsoft Word の CLSID<bpt id="p1">[</bpt>アプリケーション オブジェクト<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept>computer17.central.contoso.com をという名前のサーバーから Microsoft Word アプリケーションを表す COM 型を取得します。呼び出して、型をインスタンス化、<ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph>メソッドを呼び出すことによってが閉じると、 <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept>メソッドです。</target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>An exception is thrown if an error occurs while loading the type.</source>
          <target state="translated">型の読み込み中にエラーが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">このメソッドは、.NET Framework オブジェクトではなく、COM オブジェクトを使用する場合、使用するものはします。</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">管理されているすべてのオブジェクト、COM 参照可能なものも含め (つまり、その<ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph>属性は<ph id="ph2">&lt;see langword="true" /&gt;</ph>) によって返される GUID を持つ、<ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Although the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> method returns a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for a particular managed object, you can't use that <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph4">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">ただし、<ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph>メソッドを返します、 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 、特定の管理オブジェクトの GUID に対応するオブジェクトを使用することはできません<ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>を呼び出すことによって、型のインスタンスを作成するオブジェクト、<ph id="ph4">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph>メソッドは、次の例として。示しています。</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">代わりに、<ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph>アンマネージ COM オブジェクト、および結果の GUID を取得するのみ使用する必要があります<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>に渡されるオブジェクト、<ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph>メソッドがアンマネージ COM オブジェクトを表す必要があります。</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The object that refers to the type.</source>
          <target state="translated">型を参照するオブジェクト。</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>Gets the type referenced by the specified type handle.</source>
          <target state="translated">指定した型ハンドルによって参照される型を取得します。</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The type referenced by the specified <ph id="ph1">&lt;see cref="T:System.RuntimeTypeHandle" /&gt;</ph>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the <ph id="ph3">&lt;see cref="P:System.RuntimeTypeHandle.Value" /&gt;</ph> property of <ph id="ph4">&lt;paramref name="handle" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.RuntimeTypeHandle" /&gt;</ph> によって参照される型。または <ph id="ph2">&lt;see langword="null" /&gt;</ph> の <ph id="ph3">&lt;see cref="P:System.RuntimeTypeHandle.Value" /&gt;</ph> プロパティが <ph id="ph4">&lt;paramref name="handle" /&gt;</ph> の場合は <ph id="ph5">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">ハンドルは、取得されたアプリケーション ドメイン内でのみ有効です。</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> method to get a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object from a <ph id="ph3">&lt;xref:System.RuntimeTypeHandle&gt;</ph> provided by the <ph id="ph4">&lt;xref:System.Type.GetTypeHandle%2A&gt;</ph> method.</source>
          <target state="translated">次の例では、<ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph>取得するメソッド、<ph id="ph2">&lt;xref:System.Type&gt;</ph>オブジェクトから、<ph id="ph3">&lt;xref:System.RuntimeTypeHandle&gt;</ph>によって提供される、<ph id="ph4">&lt;xref:System.Type.GetTypeHandle%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">クラス初期化子が呼び出され、例外をスローします。</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the type associated with the specified program identifier (ProgID).</source>
          <target state="translated">指定したプログラム ID (ProgID) に関連付けられている型を取得します。</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>The ProgID of the type to get.</source>
          <target state="translated">取得する型の ProgID。</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">指定したプログラム ID (ProgID) に関連付けられている型を取得し、<ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の読み込み中にエラーが発生した場合は null を返します。</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>The type associated with the specified ProgID, if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したクラス ProgID に関連付けられている型。それ以外の場合は <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>This method is provided for COM support.</source>
          <target state="translated">このメソッドは提供の COM サポートします。</target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">Progid は、名前空間の概念によって置き換えられたため、Microsoft .NET Framework では使用されません。</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The ProgID of the type to get.</source>
          <target state="translated">取得する型の ProgID。</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated">発生した例外をすべてスローする場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated">発生した例外をすべて無視する場合は <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定されたプログラム ID (ProgID) に関連付けられた型を取得します。</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The type associated with the specified program identifier (ProgID), if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したプログラム ID (ProgID) に関連付けられている型。それ以外の場合は <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>This method is provided for COM support.</source>
          <target state="translated">このメソッドは提供の COM サポートします。</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">プログラム Id は、名前空間の概念によって置き換えられたために、Microsoft .NET Framework では使用されません。</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid.</source>
          <target state="translated">次の例では、ProgID が有効でない場合は、例外をスローするかどうかを指定する、ProgID を渡すことによって、型を取得します。</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The example then displays the ClassID related to the ProgID, along with any applicable exception message.</source>
          <target state="translated">すべての該当する例外のメッセージと共に、ProgID に関連する ClassID を表示します。</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The specified ProgID is not registered.</source>
          <target state="translated">指定された ProgID が登録されていません。</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The progID of the type to get.</source>
          <target state="translated">取得する型の progID。</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The server from which to load the type.</source>
          <target state="translated">型の読み込み元のサーバー。</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">サーバー名が <ph id="ph1">&lt;see langword="null" /&gt;</ph> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</source>
          <target state="translated">指定したサーバーから、指定したプログラム ID (progID) に関連付けられている型を取得し、型の読み込み中にエラーが発生した場合は null を返します。</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The type associated with the specified program identifier (progID), if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したプログラム ID (progID) に関連付けられている型。それ以外の場合は <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>This method is provided for COM support.</source>
          <target state="translated">このメソッドは提供の COM サポートします。</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">プログラム Id は、名前空間の概念によって置き換えられたために、Microsoft .NET Framework では使用されません。</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The following example retrieves a type by passing a ProgID and server name.</source>
          <target state="translated">次の例では、ProgID とサーバー名を渡すことによって、型を取得します。</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</source>
          <target state="translated">例は、クラス ProgID に関連する ClassID を表示または、ProgID、またはサーバー名が有効でない場合は、例外をスローします。</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="prodID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="prodID" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The progID of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">取得する <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のプログラム ID。</target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The server from which to load the type.</source>
          <target state="translated">型の読み込み元のサーバー。</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">サーバー名が <ph id="ph1">&lt;see langword="null" /&gt;</ph> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated">発生した例外をすべてスローする場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated">発生した例外をすべて無視する場合は <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したサーバーの指定したプログラム ID (progID) に関連付けられた型を取得します。</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The type associated with the specified program identifier (progID), if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したプログラム ID (progID) に関連付けられている型。それ以外の場合は <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>This method is provided for COM support.</source>
          <target state="translated">このメソッドは提供の COM サポートします。</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">プログラム Id は、名前空間の概念によって置き換えられたために、Microsoft .NET Framework では使用されません。</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The following example retrieves a type by passing a ProgID and server name.</source>
          <target state="translated">次の例では、ProgID とサーバー名を渡すことによって、型を取得します。</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</source>
          <target state="translated">プログラム Id、ProgID、またはサーバー名が有効でない場合は、例外をスローするかどうかを指定することに関連する ClassID を表示します。</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The specified progID is not registered.</source>
          <target state="translated">指定された progID が登録されていません。</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The object for which to get the type handle.</source>
          <target state="translated">型ハンドルの取得対象となるオブジェクト。</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>Gets the handle for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of a specified object.</source>
          <target state="translated">指定したオブジェクトの <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のハンドルを取得します。</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The handle for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> のハンドル。</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">ハンドルは、取得されたアプリケーション ドメイン内でのみ有効です。</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The following example defines the class <ph id="ph1">`MyClass1`</ph>, gets an instance of it, and retrieves the runtime handle of the object.</source>
          <target state="translated">次の例は、クラスを定義<ph id="ph1">`MyClass1`</ph>のインスタンスを取得し、オブジェクトのランタイム ハンドルを取得します。</target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" uid="P:System.Type.GUID">
          <source>Gets the GUID associated with the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> に関連付けられている GUID を取得します。</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GUID">
          <source>The GUID associated with the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> に関連付けられている GUID。</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GUID">
          <source>A GUID is associated with a type using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GuidAttribute&gt;</ph> attribute.</source>
          <target state="translated">GUID は型を使用して、関連付け、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.GuidAttribute&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GUID">
          <source>The following example creates the class <ph id="ph1">`MyClass1`</ph> with a public method, creates a <ph id="ph2">`Type`</ph> object corresponding to <ph id="ph3">`MyClass1`</ph>, and gets the <ph id="ph4">&lt;xref:System.Guid&gt;</ph> structure using the <ph id="ph5">`GUID`</ph> property of the <ph id="ph6">`Type`</ph> class.</source>
          <target state="translated">次の例は、クラスを作成<ph id="ph1">`MyClass1`</ph>のパブリック メソッドを作成、<ph id="ph2">`Type`</ph>オブジェクトに対応する<ph id="ph3">`MyClass1`</ph>を取得し、<ph id="ph4">&lt;xref:System.Guid&gt;</ph>構造体を使用して、<ph id="ph5">`GUID`</ph>のプロパティ、<ph id="ph6">`Type`</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" uid="P:System.Type.HasElementType">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> encompasses or refers to another type; that is, whether the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が別の型を包含または参照しているかどうか、つまり現在の <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> が配列、ポインター、または参照渡しかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が配列やポインターであるか、参照渡しである場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>For example, Type.GetType("Int32[]").HasElementType returns <ph id="ph1">`true`</ph>, but Type.GetType("Int32").HasElementType returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">For example, Type.GetType("Int32[]").HasElementType returns <ph id="ph1">`true`</ph>, but Type.GetType("Int32").HasElementType returns <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>HasElementType also returns <ph id="ph1">`true`</ph> for "Int32*" and "Int32&amp;".</source>
          <target state="translated">HasElementType も返します<ph id="ph1">`true`</ph>の「Int32 *」と"Int32 (&amp; a)"です。</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますがジェネリック型またはジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>The following example returns <ph id="ph1">`true`</ph> or <ph id="ph2">`false`</ph> depending on whether or not the object is an array, a reference type, or a pointer.</source>
          <target state="translated">次の例を返します<ph id="ph1">`true`</ph>または<ph id="ph2">`false`</ph>オブジェクトは、配列、参照型またはポインターかどうかによって異なります。</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" uid="M:System.Type.HasElementTypeImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.HasElementType" /&gt;</ph> property and determines whether the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> encompasses or refers to another type; that is, whether the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference.</source>
          <target state="translated">派生クラスによってオーバーライドされた場合、<ph id="ph1">&lt;see cref="P:System.Type.HasElementType" /&gt;</ph> プロパティを実装し、現在の <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> が別の型を包含または参照しているかどうか、つまり現在の <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> が配列やポインターであるか、参照渡しかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" uid="M:System.Type.HasElementTypeImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が配列やポインターであるか、参照渡しである場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>For example, Type.GetType("Int32[]").HasElementTypeImpl returns <ph id="ph1">`true`</ph>, but Type.GetType("Int32").HasElementTypeImpl returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">For example, Type.GetType("Int32[]").HasElementTypeImpl returns <ph id="ph1">`true`</ph>, but Type.GetType("Int32").HasElementTypeImpl returns <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>HasElementTypeImpl also returns <ph id="ph1">`true`</ph> for "Int32*" and "Int32&amp;".</source>
          <target state="translated">HasElementTypeImpl も返します<ph id="ph1">`true`</ph>の「Int32 *」と"Int32 (&amp; a)"です。</target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>The following example defines the class <ph id="ph1">`MyTypeDelegator`</ph>, which overrides the <ph id="ph2">`HasElementTypeImpl`</ph> method.</source>
          <target state="translated">次の例は、クラスを定義<ph id="ph1">`MyTypeDelegator`</ph>が優先、<ph id="ph2">`HasElementTypeImpl`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>The main class checks for the <ph id="ph1">`HasElementType`</ph> property and displays the element type.</source>
          <target state="translated">メイン クラスには、チェック、<ph id="ph1">`HasElementType`</ph>要素が型プロパティを表示します。</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Invokes a specific member of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の特定のメンバーを呼び出します。</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
          <target state="translated">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An empty string ("") to invoke the default member.</source>
          <target state="translated">既定メンバーを呼び出すための空の文字列 ("")。</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>For <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
          <target state="translated"><ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> メンバーの場合は、"[DispID=3]" のように DispID を表す文字列。</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The access can be one of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> such as <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, and so on.</source>
          <target state="translated">アクセスは、<ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>、<ph id="ph2">&lt;see langword="Public" /&gt;</ph>、<ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>、<ph id="ph4">&lt;see langword="Private" /&gt;</ph>、<ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph> など、<ph id="ph6">&lt;see langword="GetField" /&gt;</ph> のうちの 1 つになります。</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The type of lookup need not be specified.</source>
          <target state="translated">検索の種類を指定する必要はありません。</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>If the type of lookup is omitted, <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> are used.</source>
          <target state="translated">検索の種類が省略されている場合は、<ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> を使用します。</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> を使用する場合は、null 参照 (Visual Basic の場合は <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Note that explicitly defining a <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
          <target state="translated">可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> オブジェクトを明示的に定義することが必要な場合があるので注意してください。</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">指定したメンバーを呼び出す対象となるオブジェクト。</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An array containing the arguments to pass to the member to invoke.</source>
          <target state="translated">呼び出すメンバーに渡される引数を格納する配列。</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Invokes the specified member, using the specified binding constraints and matching the specified argument list.</source>
          <target state="translated">指定したバインディング制約を使用し、指定した引数リストと照合して、指定したメンバーを呼び出します。</target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An object representing the return value of the invoked member.</source>
          <target state="translated">呼び出されるメンバーの戻り値を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
          <target state="translated">使用することはできません<ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>ジェネリック メソッドを呼び出すためです。</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック メンバーを含める。</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private and protected members) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索に含める非パブリック メンバー (つまり、プライベートおよびプロテクト メンバー)、します。</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>の上位階層の静的メンバーを含めます。</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 小文字を区別しない<ph id="ph2">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されたメンバーのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたメンバーされません。</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>呼び出しフラグは、メンバーを取得するには、どのような操作を表すために使用できます。</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
          <target state="translated"><ph id="ph1">`CreateInstance`</ph> コンス トラクターを呼び出す。</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
          <target state="translated"><ph id="ph1">`name`</ph> 無視されます。</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with other invocation flags.</source>
          <target state="translated">他の呼び出しフラグは無効です。</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
          <target state="translated"><ph id="ph1">`InvokeMethod`</ph> メソッドがないコンス トラクターまたは型の初期化子を呼び出す。</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
          <target state="translated">有効でない<ph id="ph1">`SetField`</ph>または<ph id="ph2">`SetProperty`</ph>です。</target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
          <target state="translated">場合<ph id="ph1">`InvokeMethod`</ph>自体は、指定された<ph id="ph2">`BindingFlags.Public`</ph>、 <ph id="ph3">`BindingFlags.Instance`</ph>、および<ph id="ph4">`BindingFlags.Static`</ph>が自動的に含まれています。</target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
          <target state="translated"><ph id="ph1">`GetField`</ph> フィールドの値を取得します。</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
          <target state="translated">有効でない<ph id="ph1">`SetField`</ph>です。</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
          <target state="translated"><ph id="ph1">`SetField`</ph> フィールドの値を設定します。</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
          <target state="translated">有効でない<ph id="ph1">`GetField`</ph>です。</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
          <target state="translated"><ph id="ph1">`GetProperty`</ph> プロパティを取得します。</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
          <target state="translated">有効でない<ph id="ph1">`SetProperty`</ph>です。</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
          <target state="translated"><ph id="ph1">`SetProperty`</ph> プロパティを設定します。</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
          <target state="translated">有効でない<ph id="ph1">`GetProperty`</ph>です。</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>A method will be invoked if both of the following conditions are true:</source>
          <target state="translated">次の条件の両方に該当する場合、メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
          <target state="translated">メソッドの宣言のパラメーターの数の引数の数に等しければ、<ph id="ph1">`args`</ph>配列 (メンバーの既定の引数が定義されている場合を除き、および<ph id="ph2">`BindingFlags.OptionalParamBinding`</ph>が指定されている)。</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">各引数の型は、バインダーによってパラメーターの型に変換できます。</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">バインダーは、すべての一致するメソッドに紹介します。</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
          <target state="translated">要求されたバインディングの種類に基づくこれらのメソッドが検出された (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>値<ph id="ph2">`InvokeMethod`</ph>、<ph id="ph3">`GetProperty`</ph>など)。</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">メソッドのセットは、名前、引数の数と、バインダーで定義されている検索修飾子のセットによってフィルターされています。</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>After the method is selected, it is invoked.</source>
          <target state="translated">メソッドを選択した後に呼び出されます。</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">ユーザー補助機能がその時点でチェックされます。</target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">検索では、メソッドに関連付けられているユーザー補助属性に基づいて、メソッドのセットを検索するかを制御できます。</target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph>のメソッド、<ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph>クラスが呼び出されるメソッドを選択するを担当します。</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">既定のバインダーは、最も具体的な一致を選択します。</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> whenever the code is fully trusted.</source>
          <target state="translated">完全に信頼されたコードのアクセスの制限は無視されます。つまり、private のコンス トラクター、メソッド、フィールド、およびプロパティにアクセスしてを通じて呼び出された<ph id="ph1">&lt;xref:System.Reflection&gt;</ph>コードが完全に信頼されるたびにします。</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">使用することができます<ph id="ph1">`Type.InvokeMember`</ph>に設定するフィールドに特定の値を指定して<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph>, you can use code such as:</source>
          <target state="translated">たとえば、C、および F クラス F をという名前のパブリック インスタンス フィールドを設定する場合は、<ph id="ph1">`String`</ph>などのコードを使用することができます。</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
          <target state="translated">F の場合、<ph id="ph1">`String[]`</ph>などのコードを使用することができます。</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>which will initialize the field F to this new array.</source>
          <target state="translated">この新しい配列にフィールド F が初期化されます。</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
          <target state="translated">使用することも<ph id="ph1">`Type.InvokeMember`</ph>を次のようなコードを使用して、値とし、[次へ] の値のインデックスを指定することによって、配列内の位置を設定します。</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>This will change string "z" in the array that F holds to string "b".</source>
          <target state="translated">これにより、F は、"b"の文字列を保持する配列内の文字列"z"が変更されます。</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
          <target state="translated">呼び出した場合、<ph id="ph1">`IDispatch`</ph>メンバー、文字列形式を使用して、メンバー名の代わりに DispID を指定することができます"[DispID = ##]"です。</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
          <target state="translated">たとえば、MyComMethod の DispID が 3 の場合は、文字列を指定できます"[DispID = 3]""MyComMethod"の代わりにします。</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
          <target state="translated">DispID でメンバーの呼び出しは、名前で、メンバーを調べるよりも高速です。</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
          <target state="translated">複雑な集計のシナリオで、DispID は必要なメンバーを呼び出す唯一の方法でがあります。</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">以降で、 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>、このメソッドは、呼び出し元が許可されている場合は、非パブリック メンバーをアクセスに使用できます<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>で、<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>フラグし、非パブリック メンバーの許可セットが、呼び出し元に制限されている場合は、セット、またはそのサブセットを付与します。</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(を参照してください<bpt id="p1">[</bpt>リフレクションに関するセキュリティの考慮事項<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>)。</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">この機能を使用するには、アプリケーションで <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 以降を対象とする必要があります。</target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following example uses <ph id="ph1">`InvokeMember`</ph> to access members of a type.</source>
          <target state="translated">次の例で<ph id="ph1">`InvokeMember`</ph>型のメンバーにアクセスします。</target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> and <ph id="ph3">&lt;paramref name="name" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> が含まれておらず、<ph id="ph3">&lt;paramref name="name" /&gt;</ph> が <ph id="ph4">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> が有効な <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 属性ではありません。</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に、<ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>、<ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>、<ph id="ph4">&lt;see langword="GetField" /&gt;</ph>、<ph id="ph5">&lt;see langword="SetField" /&gt;</ph>、<ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>、<ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph> のいずれかのバインディング フラグが格納されていません。</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に、<ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph>、<ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>、<ph id="ph4">&lt;see langword="GetField" /&gt;</ph>、<ph id="ph5">&lt;see langword="SetField" /&gt;</ph>、または <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> と組み合わされた <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph> が格納されています。</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に、<ph id="ph2">&lt;see langword="GetField" /&gt;</ph> と <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> が格納されています。</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に、<ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> と <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph> が格納されています。</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> or <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に、<ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> または <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> と組み合わされた <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph> が格納されています。</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> and <ph id="ph3">&lt;paramref name="args" /&gt;</ph> has more than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> が格納されていて、<ph id="ph3">&lt;paramref name="args" /&gt;</ph> に複数の要素があります。</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>, or <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</source>
          <target state="translated">このメソッドは COM オブジェクトに対して呼び出され、バインディング フラグ <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>、<ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>、<ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>、<ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>、または <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph> が渡されませんでした。</target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">名前付きパラメーター配列の 1 つには、<ph id="ph1">&lt;see langword="null" /&gt;</ph> の文字列が含まれています。</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The specified member is a class initializer.</source>
          <target state="translated">指定されたメンバーは、クラス初期化子です。</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The field or property cannot be found.</source>
          <target state="translated">フィールドまたはプロパティが見つかりません。</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>No method can be found that matches the arguments in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> 内の引数と一致するメソッドが見つかりません。</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> が <ph id="ph3">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The specified member cannot be invoked on <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</source>
          <target state="translated">指定されたメンバーを <ph id="ph1">&lt;paramref name="target" /&gt;</ph> で呼び出すことができません。</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>More than one method matches the binding criteria.</source>
          <target state="translated">複数のメソッドがバインディングの基準と一致します。</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The .NET Compact Framework does not currently support this method.</source>
          <target state="translated">現在、.NET Compact Framework は、このメソッドをサポートしていません。</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The method represented by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> has one or more unspecified generic type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>That is, the method's <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">つまり、このメソッドの <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> プロパティが <ph id="ph2">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>for accessing non-public members regardless of their grant set.</source>
          <target state="translated">アクセス許可に関係なく、非パブリック メンバーの次のように設定します。</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">関連する列挙。 <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>to call unmanaged code.</source>
          <target state="translated">アンマネージ コードを呼び出します。</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">関連する列挙。 <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
          <target state="translated">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An empty string ("") to invoke the default member.</source>
          <target state="translated">既定メンバーを呼び出すための空の文字列 ("")。</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>For <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
          <target state="translated"><ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> メンバーの場合は、"[DispID=3]" のように DispID を表す文字列。</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The access can be one of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> such as <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, and so on.</source>
          <target state="translated">アクセスは、<ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>、<ph id="ph2">&lt;see langword="Public" /&gt;</ph>、<ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>、<ph id="ph4">&lt;see langword="Private" /&gt;</ph>、<ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph> など、<ph id="ph6">&lt;see langword="GetField" /&gt;</ph> のうちの 1 つになります。</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of lookup need not be specified.</source>
          <target state="translated">検索の種類を指定する必要はありません。</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>If the type of lookup is omitted, <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> are used.</source>
          <target state="translated">検索の種類が省略されている場合は、<ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> を使用します。</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> を使用する場合は、null 参照 (Visual Basic の場合は <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Note that explicitly defining a <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
          <target state="translated">可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> オブジェクトを明示的に定義することが必要な場合があるので注意してください。</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">指定したメンバーを呼び出す対象となるオブジェクト。</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An array containing the arguments to pass to the member to invoke.</source>
          <target state="translated">呼び出すメンバーに渡される引数を格納する配列。</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>.</source>
          <target state="translated">使用するグローバリゼーション ロケールを表すオブジェクト。これは、<ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 型の数値を <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> に変換するなど、ロケール固有の変換を実行するために必要となる場合があります。</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) to use the current thread's <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</source>
          <target state="translated">現在のスレッドの <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> を使用する場合は、null 参照 (Visual Basic の場合は <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</source>
          <target state="translated">指定したバインディング制約を使用し、指定したメンバーのうち、指定した引数リストおよびカルチャと一致するメンバーを呼び出します。</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An object representing the return value of the invoked member.</source>
          <target state="translated">呼び出されるメンバーの戻り値を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (the <ph id="ph2">`culture`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`culture`</ph>.</source>
          <target state="translated">既定のバインダーが処理されませんが<ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>(、<ph id="ph2">`culture`</ph>パラメーター)、abstract を使用することができます<ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>を処理することはカスタムのバインダーを記述するクラス<ph id="ph4">`culture`</ph>です。</target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
          <target state="translated">使用することはできません<ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>ジェネリック メソッドを呼び出すためです。</target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック メンバーを含める。</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索に含める非パブリック メンバー (つまり、プライベート、内部、およびプロテクト メンバー)、します。</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>の上位階層の静的メンバーを含めます。</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 小文字を区別しない<ph id="ph2">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されたメンバーのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたメンバーされません。</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>呼び出しフラグは、メンバーを取得するには、どのような操作を表すために使用できます。</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
          <target state="translated"><ph id="ph1">`CreateInstance`</ph> コンス トラクターを呼び出す。</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
          <target state="translated"><ph id="ph1">`name`</ph> 無視されます。</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with other invocation flags.</source>
          <target state="translated">他の呼び出しフラグは無効です。</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
          <target state="translated"><ph id="ph1">`InvokeMethod`</ph> メソッドがないコンス トラクターまたは型の初期化子を呼び出す。</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
          <target state="translated">有効でない<ph id="ph1">`SetField`</ph>または<ph id="ph2">`SetProperty`</ph>です。</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
          <target state="translated">場合<ph id="ph1">`InvokeMethod`</ph>自体は、指定された<ph id="ph2">`BindingFlags.Public`</ph>、 <ph id="ph3">`BindingFlags.Instance`</ph>、および<ph id="ph4">`BindingFlags.Static`</ph>が自動的に含まれています。</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
          <target state="translated"><ph id="ph1">`GetField`</ph> フィールドの値を取得します。</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
          <target state="translated">有効でない<ph id="ph1">`SetField`</ph>です。</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
          <target state="translated"><ph id="ph1">`SetField`</ph> フィールドの値を設定します。</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
          <target state="translated">有効でない<ph id="ph1">`GetField`</ph>です。</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
          <target state="translated"><ph id="ph1">`GetProperty`</ph> プロパティを取得します。</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
          <target state="translated">有効でない<ph id="ph1">`SetProperty`</ph>です。</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
          <target state="translated"><ph id="ph1">`SetProperty`</ph> プロパティを設定します。</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
          <target state="translated">有効でない<ph id="ph1">`GetProperty`</ph>です。</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A method will be invoked if both of the following conditions are true:</source>
          <target state="translated">次の条件の両方に該当する場合、メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
          <target state="translated">メソッドの宣言のパラメーターの数の引数の数に等しければ、<ph id="ph1">`args`</ph>配列 (メンバーの既定の引数が定義されている場合を除き、および<ph id="ph2">`BindingFlags.OptionalParamBinding`</ph>が指定されている)。</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">各引数の型は、バインダーによってパラメーターの型に変換できます。</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">バインダーは、すべての一致するメソッドに紹介します。</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
          <target state="translated">要求されたバインディングの種類に基づくこれらのメソッドが検出された (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>値<ph id="ph2">`InvokeMethod`</ph>、<ph id="ph3">`GetProperty`</ph>など)。</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">メソッドのセットは、名前、引数の数と、バインダーで定義されている検索修飾子のセットによってフィルターされています。</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>After the method is selected, it is invoked.</source>
          <target state="translated">メソッドを選択した後に呼び出されます。</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">ユーザー補助機能がその時点でチェックされます。</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">検索では、メソッドに関連付けられているユーザー補助属性に基づいて、メソッドのセットを検索するかを制御できます。</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph>のメソッド、<ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph>クラスが呼び出されるメソッドを選択するを担当します。</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">既定のバインダーは、最も具体的な一致を選択します。</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</source>
          <target state="translated">完全に信頼されたコードのアクセスの制限は無視されます。つまり、private のコンス トラクター、メソッド、フィールド、およびプロパティにアクセスして、コードが完全に信頼されるリフレクションを通じて呼び出されました。</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">使用することができます<ph id="ph1">`Type.InvokeMember`</ph>に設定するフィールドに特定の値を指定して<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph> you can use code such as:</source>
          <target state="translated">たとえば、C、および F クラス F をという名前のパブリック インスタンス フィールドを設定する場合は、<ph id="ph1">`String`</ph>などのコードを使用することができます。</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
          <target state="translated">F の場合、<ph id="ph1">`String[]`</ph>などのコードを使用することができます。</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>which will initialize the field F to this new array.</source>
          <target state="translated">この新しい配列にフィールド F が初期化されます。</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
          <target state="translated">使用することも<ph id="ph1">`Type.InvokeMember`</ph>を次のようなコードを使用して、値とし、[次へ] の値のインデックスを指定することによって、配列内の位置を設定します。</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>This will change string "z" in the array that F holds to string "b".</source>
          <target state="translated">これにより、F は、"b"の文字列を保持する配列内の文字列"z"が変更されます。</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
          <target state="translated">呼び出した場合、<ph id="ph1">`IDispatch`</ph>メンバーの文字列形式を使用して、メンバー名の代わりに DispID を指定する"[DispID = ##]"です。</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
          <target state="translated">たとえば、MyComMethod の DispID が 3 の場合は、文字列を指定できます"[DispID = 3]""MyComMethod"の代わりにします。</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
          <target state="translated">DispID でメンバーの呼び出しは、名前で、メンバーを調べるよりも高速です。</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
          <target state="translated">複雑な集計のシナリオで、DispID は必要なメンバーを呼び出す唯一の方法でがあります。</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">以降で、 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>、このメソッドは、呼び出し元が許可されている場合は、非パブリック メンバーをアクセスに使用できます<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>で、<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>フラグし、非パブリック メンバーの許可セットが、呼び出し元に制限されている場合は、セット、またはそのサブセットを付与します。</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(を参照してください<bpt id="p1">[</bpt>リフレクションに関するセキュリティの考慮事項<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>)。</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">この機能を使用するには、アプリケーションで <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 以降を対象とする必要があります。</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> and <ph id="ph3">&lt;paramref name="name" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> が含まれておらず、<ph id="ph3">&lt;paramref name="name" /&gt;</ph> が <ph id="ph4">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> が有効な <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 属性ではありません。</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に、<ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>、<ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>、<ph id="ph4">&lt;see langword="GetField" /&gt;</ph>、<ph id="ph5">&lt;see langword="SetField" /&gt;</ph>、<ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>、<ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph> のいずれかのバインディング フラグが格納されていません。</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に、<ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph>、<ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>、<ph id="ph4">&lt;see langword="GetField" /&gt;</ph>、<ph id="ph5">&lt;see langword="SetField" /&gt;</ph>、または <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> と組み合わされた <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph> が格納されています。</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に、<ph id="ph2">&lt;see langword="GetField" /&gt;</ph> と <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> が格納されています。</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に、<ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> と <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph> が格納されています。</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> or <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に、<ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> または <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> と組み合わされた <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph> が格納されています。</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> and <ph id="ph3">&lt;paramref name="args" /&gt;</ph> has more than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> が格納されていて、<ph id="ph3">&lt;paramref name="args" /&gt;</ph> に複数の要素があります。</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>, or <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</source>
          <target state="translated">このメソッドは COM オブジェクトに対して呼び出され、バインディング フラグ <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>、<ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>、<ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>、<ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>、または <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph> が渡されませんでした。</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">名前付きパラメーター配列の 1 つには、<ph id="ph1">&lt;see langword="null" /&gt;</ph> の文字列が含まれています。</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The specified member is a class initializer.</source>
          <target state="translated">指定されたメンバーは、クラス初期化子です。</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The field or property cannot be found.</source>
          <target state="translated">フィールドまたはプロパティが見つかりません。</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>No method can be found that matches the arguments in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> 内の引数と一致するメソッドが見つかりません。</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> が <ph id="ph3">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The specified member cannot be invoked on <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</source>
          <target state="translated">指定されたメンバーを <ph id="ph1">&lt;paramref name="target" /&gt;</ph> で呼び出すことができません。</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>More than one method matches the binding criteria.</source>
          <target state="translated">複数のメソッドがバインディングの基準と一致します。</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The method represented by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> has one or more unspecified generic type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, the method's <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">つまり、このメソッドの <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> プロパティが <ph id="ph2">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>for accessing non-public members regardless of their grant set.</source>
          <target state="translated">アクセス許可に関係なく、非パブリック メンバーの次のように設定します。</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">関連する列挙。 <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>to call unmanaged code.</source>
          <target state="translated">アンマネージ コードを呼び出します。</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">関連する列挙。 <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
          <target state="translated">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An empty string ("") to invoke the default member.</source>
          <target state="translated">既定メンバーを呼び出すための空の文字列 ("")。</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
          <target state="translated"><ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> メンバーの場合は、"[DispID=3]" のように DispID を表す文字列。</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The access can be one of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> such as <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, and so on.</source>
          <target state="translated">アクセスは、<ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>、<ph id="ph2">&lt;see langword="Public" /&gt;</ph>、<ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>、<ph id="ph4">&lt;see langword="Private" /&gt;</ph>、<ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph> など、<ph id="ph6">&lt;see langword="GetField" /&gt;</ph> のうちの 1 つになります。</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The type of lookup need not be specified.</source>
          <target state="translated">検索の種類を指定する必要はありません。</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the type of lookup is omitted, <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> are used.</source>
          <target state="translated">検索の種類が省略されている場合は、<ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> を使用します。</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A null reference (Nothing in Visual Basic), to use the <ph id="ph1">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph> を使用する場合は、null 参照 (Visual Basic の場合は Nothing)。</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Note that explicitly defining a <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
          <target state="translated">可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> オブジェクトを明示的に定義することが必要な場合があるので注意してください。</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">指定したメンバーを呼び出す対象となるオブジェクト。</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array containing the arguments to pass to the member to invoke.</source>
          <target state="translated">呼び出すメンバーに渡される引数を格納する配列。</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt> args <ept id="p1">&lt;/c&gt;</ept> 配列内の対応する要素に関連付けられている属性を表す <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A parameter's associated attributes are stored in the member's signature.</source>
          <target state="translated">パラメーターに関連付けられた属性は、メンバーのシグネチャに格納されます。</target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder processes this parameter only when calling a COM component.</source>
          <target state="translated">既定のバインダーは、COM コンポーネントを呼び出す場合のみ、このパラメーターを処理します。</target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</source>
          <target state="translated">使用するロケールを表す <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> オブジェクト。これは、String 型の数値を Double に変換するなど、ロケール固有の変換を実行するために必要となる場合があります。</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) to use the current thread's <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</source>
          <target state="translated">現在のスレッドの <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> を使用する場合は、null 参照 (Visual Basic の場合は <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array containing the names of the parameters to which the values in the <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> array are passed.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt> args <ept id="p1">&lt;/c&gt;</ept> 配列内の値が渡されるパラメーターの名前を格納する配列。</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</source>
          <target state="translated">派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用し、指定した引数リスト、修飾子、カルチャと照合して、指定されたメンバーを呼び出します。</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object representing the return value of the invoked member.</source>
          <target state="translated">呼び出されるメンバーの戻り値を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`InvokeMember`</ph> calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</source>
          <target state="translated"><ph id="ph1">`InvokeMember`</ph> コンス トラクター メンバーまたはメソッドのメンバーを呼び出してを取得またはプロパティのメンバーを設定を取得またはデータ フィールドのメンバーを設定または取得または設定が配列のメンバーの要素。</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
          <target state="translated">使用することはできません<ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>ジェネリック メソッドを呼び出すためです。</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
          <target state="translated">呼び出した場合、<ph id="ph1">`IDispatch`</ph>メンバーの文字列形式を使用して、メンバー名の代わりに DispID を指定する"[DispID = ##]"です。</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
          <target state="translated">たとえば、MyComMethod の DispID が 3 の場合は、文字列を指定できます"[DispID = 3]""MyComMethod"の代わりにします。</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
          <target state="translated">DispID でメンバーの呼び出しは、名前で、メンバーを調べるよりも高速です。</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
          <target state="translated">複雑な集計のシナリオで、DispID は必要なメンバーを呼び出す唯一の方法でがあります。</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> or <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (the <ph id="ph3">`modifiers`</ph> and <ph id="ph4">`culture`</ph> parameters), you can use the abstract <ph id="ph5">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph6">`modifiers`</ph> and <ph id="ph7">`culture`</ph>.</source>
          <target state="translated">既定のバインダーが処理されませんが<ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph>または<ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph>(、<ph id="ph3">`modifiers`</ph>と<ph id="ph4">`culture`</ph>パラメーター)、abstract を使用することができます<ph id="ph5">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>を処理することはカスタムのバインダーを記述するクラス<ph id="ph6">`modifiers`</ph>と<ph id="ph7">`culture`</ph>です。</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> COM 相互運用機能を通じて呼び出すときにのみ使用し、参照によって渡されるパラメーターのみを処理します。</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Each parameter in the <ph id="ph1">`namedParameters`</ph> array gets the value in the corresponding element in the <ph id="ph2">`args`</ph> array.</source>
          <target state="translated"><ph id="ph1">`namedParameters`</ph> 配列内の各パラメーターは、<ph id="ph2">`args`</ph> 配列内の対応する要素の値を取得します。</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the length of <ph id="ph1">`args`</ph> is greater than the length of <ph id="ph2">`namedParameters`</ph>, the remaining argument values are passed in order.</source>
          <target state="translated"><ph id="ph1">`args`</ph> の長さが <ph id="ph2">`namedParameters`</ph> の長さを超える場合は、残った引数の値が順に渡されます。</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">`namedParameters`</ph> array can be used to change the order of arguments in an input array.</source>
          <target state="translated"><ph id="ph1">`namedParameters`</ph>入力配列内の引数の順序を変更する配列を使用することができます。</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, given the method <ph id="ph1">`M(string a, int b)`</ph> (<ph id="ph2">`M(ByVal a As String, ByVal b As Integer)`</ph> in Visual Basic) and the input array <ph id="ph3">`{ 42, "x" }`</ph>, the input array can be passed unchanged to <ph id="ph4">`args`</ph> if the array <ph id="ph5">`{ "b", "a" }`</ph> is supplied for <ph id="ph6">`namedParameters`</ph>.</source>
          <target state="translated">たとえば、メソッドを指定<ph id="ph1">`M(string a, int b)`</ph>(<ph id="ph2">`M(ByVal a As String, ByVal b As Integer)`</ph> Visual Basic で) 入力配列と<ph id="ph3">`{ 42, "x" }`</ph>、入力配列が unchanged に渡すことができます<ph id="ph4">`args`</ph>場合配列<ph id="ph5">`{ "b", "a" }`</ph>が指定されて<ph id="ph6">`namedParameters`</ph>です。</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.Public`</ph>検索にパブリック メンバーを含める。</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.NonPublic`</ph>検索に含める非パブリック メンバー (つまり、プライベート、内部、およびプロテクト メンバー)、します。</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
          <target state="translated">指定<ph id="ph1">`BindingFlags.FlattenHierarchy`</ph>の上位階層の静的メンバーを含めます。</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>修飾子フラグは、検索の動作を変更するために使用できます。</target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> 小文字を区別しない<ph id="ph2">`name`</ph>です。</target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> 宣言されたメンバーのみを検索する、 <ph id="ph2">&lt;xref:System.Type&gt;</ph>、継承されたメンバーされません。</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>呼び出しフラグは、メンバーを取得するには、どのような操作を表すために使用できます。</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
          <target state="translated"><ph id="ph1">`CreateInstance`</ph> コンス トラクターを呼び出す。</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
          <target state="translated"><ph id="ph1">`name`</ph> 無視されます。</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with other invocation flags.</source>
          <target state="translated">他の呼び出しフラグは無効です。</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
          <target state="translated"><ph id="ph1">`InvokeMethod`</ph> メソッドがないコンス トラクターまたは型の初期化子を呼び出す。</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
          <target state="translated">有効でない<ph id="ph1">`SetField`</ph>または<ph id="ph2">`SetProperty`</ph>です。</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
          <target state="translated">場合<ph id="ph1">`InvokeMethod`</ph>自体は、指定された<ph id="ph2">`BindingFlags.Public`</ph>、 <ph id="ph3">`BindingFlags.Instance`</ph>、および<ph id="ph4">`BindingFlags.Static`</ph>が自動的に含まれています。</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
          <target state="translated"><ph id="ph1">`GetField`</ph> フィールドの値を取得します。</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
          <target state="translated">有効でない<ph id="ph1">`SetField`</ph>です。</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
          <target state="translated"><ph id="ph1">`SetField`</ph> フィールドの値を設定します。</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
          <target state="translated">有効でない<ph id="ph1">`GetField`</ph>です。</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
          <target state="translated"><ph id="ph1">`GetProperty`</ph> プロパティを取得します。</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
          <target state="translated">有効でない<ph id="ph1">`SetProperty`</ph>です。</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
          <target state="translated"><ph id="ph1">`SetProperty`</ph> プロパティを設定します。</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
          <target state="translated">有効でない<ph id="ph1">`GetProperty`</ph>です。</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">詳細については、「<ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A method will be invoked if both of the following conditions are true:</source>
          <target state="translated">次の条件の両方に該当する場合、メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
          <target state="translated">メソッドの宣言のパラメーターの数の引数の数に等しければ、<ph id="ph1">`args`</ph>配列 (メンバーの既定の引数が定義されている場合を除き、および<ph id="ph2">`BindingFlags.OptionalParamBinding`</ph>が指定されている)。</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">各引数の型は、バインダーによってパラメーターの型に変換できます。</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">バインダーは、すべての一致するメソッドに紹介します。</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
          <target state="translated">要求されたバインディングの種類に基づくこれらのメソッドが検出された (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>値<ph id="ph2">`InvokeMethod`</ph>、<ph id="ph3">`GetProperty`</ph>など)。</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">メソッドのセットは、名前、引数の数と、バインダーで定義されている検索修飾子のセットによってフィルターされています。</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>After the method is selected, it is invoked.</source>
          <target state="translated">メソッドを選択した後に呼び出されます。</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">ユーザー補助機能がその時点でチェックされます。</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">検索では、メソッドに関連付けられているユーザー補助属性に基づいて、メソッドのセットを検索するかを制御できます。</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph>のメソッド、<ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph>クラスが呼び出されるメソッドを選択するを担当します。</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">既定のバインダーは、最も具体的な一致を選択します。</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`InvokeMember`</ph> can be used to invoke methods with parameters that have default values.</source>
          <target state="translated"><ph id="ph1">`InvokeMember`</ph> 既定値を持つパラメーターを持つメソッドを呼び出すために使用します。</target>       </trans-unit>
        <trans-unit id="3471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>To bind to these methods, Reflection requires <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType&gt;</ph> to be specified.</source>
          <target state="translated">リフレクションではこれらのメソッドにバインドするに<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType&gt;</ph>を指定できます。</target>       </trans-unit>
        <trans-unit id="3472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For a parameter that has a default value, you can either supply a different value, or supply <ph id="ph1">&lt;xref:System.Reflection.Missing.Value?displayProperty=nameWithType&gt;</ph> to use the default value.</source>
          <target state="translated">既定値を持つパラメーターの場合、別の値を指定するかを指定<ph id="ph1">&lt;xref:System.Reflection.Missing.Value?displayProperty=nameWithType&gt;</ph>既定値を使用します。</target>       </trans-unit>
        <trans-unit id="3473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, consider a method such as MyMethod(int x, float y = 2.0).</source>
          <target state="translated">たとえば、MyMethod などのメソッド (x, y の float int 2.0 を =)。</target>       </trans-unit>
        <trans-unit id="3474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and <ph id="ph1">`Missing.Value`</ph> for the second argument.</source>
          <target state="translated">Mymethod (4) として最初の引数のみには、このメソッドを呼び出すには、上記のバインディング フラグのいずれかを渡すし、最初の引数は 4、2 つの引数を渡すと<ph id="ph1">`Missing.Value`</ph>に対する 2 番目の引数。</target>       </trans-unit>
        <trans-unit id="3475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Unless you use <ph id="ph1">`Missing.Value`</ph>, you may not omit optional parameters with the <ph id="ph2">`Invoke`</ph> method.</source>
          <target state="translated">使用する場合を除き、 <ph id="ph1">`Missing.Value`</ph>、省略可能なパラメーターを省略することはできません、<ph id="ph2">`Invoke`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If you must do so, use <ph id="ph1">`InvokeMember`</ph> instead.</source>
          <target state="translated">使用する場合はこれを行う必要があります、<ph id="ph1">`InvokeMember`</ph>代わりにします。</target>       </trans-unit>
        <trans-unit id="3477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> whenever the code is fully trusted.</source>
          <target state="translated">完全に信頼されたコードのアクセスの制限は無視されます。つまり、private のコンス トラクター、メソッド、フィールド、およびプロパティにアクセスしてを通じて呼び出された<ph id="ph1">&lt;xref:System.Reflection&gt;</ph>コードが完全に信頼されるたびにします。</target>       </trans-unit>
        <trans-unit id="3478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">使用することができます<ph id="ph1">`Type.InvokeMember`</ph>に設定するフィールドに特定の値を指定して<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph>, you can use code such as:</source>
          <target state="translated">たとえば、C、および F クラス F をという名前のパブリック インスタンス フィールドを設定する場合は、<ph id="ph1">`String`</ph>などのコードを使用することができます。</target>       </trans-unit>
        <trans-unit id="3480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
          <target state="translated">F の場合、<ph id="ph1">`String[]`</ph>などのコードを使用することができます。</target>       </trans-unit>
        <trans-unit id="3481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>which will initialize the field F to this new array.</source>
          <target state="translated">この新しい配列にフィールド F が初期化されます。</target>       </trans-unit>
        <trans-unit id="3482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
          <target state="translated">使用することも<ph id="ph1">`Type.InvokeMember`</ph>を次のようなコードを使用して、値とし、[次へ] の値のインデックスを指定することによって、配列内の位置を設定します。</target>       </trans-unit>
        <trans-unit id="3483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This will change string "z" in the array that F holds to string "b".</source>
          <target state="translated">これにより、F は、"b"の文字列を保持する配列内の文字列"z"が変更されます。</target>       </trans-unit>
        <trans-unit id="3484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">以降で、 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>、このメソッドは、呼び出し元が許可されている場合は、非パブリック メンバーをアクセスに使用できます<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>で、<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>フラグし、非パブリック メンバーの許可セットが、呼び出し元に制限されている場合は、セット、またはそのサブセットを付与します。</target>       </trans-unit>
        <trans-unit id="3485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(を参照してください<bpt id="p1">[</bpt>リフレクションに関するセキュリティの考慮事項<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>)。</target>       </trans-unit>
        <trans-unit id="3486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">この機能を使用するには、アプリケーションで <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 以降を対象とする必要があります。</target>       </trans-unit>
        <trans-unit id="3487" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> and <ph id="ph3">&lt;paramref name="name" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> が含まれておらず、<ph id="ph3">&lt;paramref name="name" /&gt;</ph> が <ph id="ph4">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="3488" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="args" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> と <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> の長さが異なります。</target>       </trans-unit>
        <trans-unit id="3489" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3490" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> が有効な <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 属性ではありません。</target>       </trans-unit>
        <trans-unit id="3491" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3492" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に、<ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>、<ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>、<ph id="ph4">&lt;see langword="GetField" /&gt;</ph>、<ph id="ph5">&lt;see langword="SetField" /&gt;</ph>、<ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>、<ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph> のいずれかのバインディング フラグが格納されていません。</target>       </trans-unit>
        <trans-unit id="3493" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3494" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に、<ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph>、<ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>、<ph id="ph4">&lt;see langword="GetField" /&gt;</ph>、<ph id="ph5">&lt;see langword="SetField" /&gt;</ph>、または <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> と組み合わされた <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph> が格納されています。</target>       </trans-unit>
        <trans-unit id="3495" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3496" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に、<ph id="ph2">&lt;see langword="GetField" /&gt;</ph> と <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> が格納されています。</target>       </trans-unit>
        <trans-unit id="3497" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3498" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に、<ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> と <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph> が格納されています。</target>       </trans-unit>
        <trans-unit id="3499" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3500" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> or <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に、<ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> または <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> と組み合わされた <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph> が格納されています。</target>       </trans-unit>
        <trans-unit id="3501" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3502" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> and <ph id="ph3">&lt;paramref name="args" /&gt;</ph> has more than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> に <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> が格納されていて、<ph id="ph3">&lt;paramref name="args" /&gt;</ph> に複数の要素があります。</target>       </trans-unit>
        <trans-unit id="3503" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3504" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The named parameter array is larger than the argument array.</source>
          <target state="translated">名前付きパラメーター配列が、引数配列よりも長くなっています。</target>       </trans-unit>
        <trans-unit id="3505" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3506" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>, or <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</source>
          <target state="translated">このメソッドは COM オブジェクトに対して呼び出され、バインディング フラグ <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>、<ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>、<ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>、<ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>、または <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph> が渡されませんでした。</target>       </trans-unit>
        <trans-unit id="3507" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3508" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">名前付きパラメーター配列の 1 つには、<ph id="ph1">&lt;see langword="null" /&gt;</ph> の文字列が含まれています。</target>       </trans-unit>
        <trans-unit id="3509" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The specified member is a class initializer.</source>
          <target state="translated">指定されたメンバーは、クラス初期化子です。</target>       </trans-unit>
        <trans-unit id="3510" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The field or property cannot be found.</source>
          <target state="translated">フィールドまたはプロパティが見つかりません。</target>       </trans-unit>
        <trans-unit id="3511" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>No method can be found that matches the arguments in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> 内の引数と一致するメソッドが見つかりません。</target>       </trans-unit>
        <trans-unit id="3512" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3513" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>No member can be found that has the argument names supplied in <ph id="ph1">&lt;paramref name="namedParameters" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="namedParameters" /&gt;</ph> の中で引数名が指定されているメンバーが見つかりません。</target>       </trans-unit>
        <trans-unit id="3514" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3515" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> が <ph id="ph3">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="3516" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The specified member cannot be invoked on <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</source>
          <target state="translated">指定されたメンバーを <ph id="ph1">&lt;paramref name="target" /&gt;</ph> で呼び出すことができません。</target>       </trans-unit>
        <trans-unit id="3517" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>More than one method matches the binding criteria.</source>
          <target state="translated">複数のメソッドがバインディングの基準と一致します。</target>       </trans-unit>
        <trans-unit id="3518" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The method represented by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> has one or more unspecified generic type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。</target>       </trans-unit>
        <trans-unit id="3519" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>That is, the method's <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">つまり、このメソッドの <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> プロパティが <ph id="ph2">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="3520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>for accessing non-public members regardless of their grant set.</source>
          <target state="translated">アクセス許可に関係なく、非パブリック メンバーの次のように設定します。</target>       </trans-unit>
        <trans-unit id="3521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">関連する列挙。 <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>to call unmanaged code.</source>
          <target state="translated">アンマネージ コードを呼び出します。</target>       </trans-unit>
        <trans-unit id="3523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">関連する列挙。 <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3524" translate="yes" xml:space="preserve" uid="P:System.Type.IsAbstract">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is abstract and must be overridden.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が抽象型で、オーバーライドする必要があるかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3525" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is abstract; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> が抽象である場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3526" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsAbstract%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> in the following cases:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsAbstract%2A&gt;</ph>プロパティから返される<ph id="ph2">`true`</ph>次の場合。</target>       </trans-unit>
        <trans-unit id="3527" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</source>
          <target state="translated">現在の型が抽象です。つまり、インスタンス化できませんが、派生クラスの基底クラスとしてのみ使用できます。</target>       </trans-unit>
        <trans-unit id="3528" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>In C#, abstract classes are marked with the <bpt id="p1">[</bpt>abstract<ept id="p1">](~/docs/csharp/language-reference/keywords/abstract.md)</ept> keyword; in Visual Basic, they are marked with the <bpt id="p2">[</bpt>MustInherit<ept id="p2">](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)</ept> keyword.</source>
          <target state="translated">C# の場合は、抽象クラスが付いている、<bpt id="p1">[</bpt>抽象<ept id="p1">](~/docs/csharp/language-reference/keywords/abstract.md)</ept>というキーワードでマークされている Visual basic で、 <bpt id="p2">[</bpt>MustInherit<ept id="p2">](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)</ept>キーワード。</target>       </trans-unit>
        <trans-unit id="3529" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The current type is an interface.</source>
          <target state="translated">現在の型は、インターフェイスです。</target>       </trans-unit>
        <trans-unit id="3530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3531" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The following example creates an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects that represent the following types:contains type returns <ph id="ph2">`true`</ph> if the specified object is <ph id="ph3">`abstract`</ph>; otherwise, it returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">配列を作成する例を次<ph id="ph1">&lt;xref:System.Type&gt;</ph>を次の種類を表すオブジェクト: 戻り値が含まれています<ph id="ph2">`true`</ph>場合は、指定したオブジェクトが<ph id="ph3">`abstract`</ph>、それ以外を返します<ph id="ph4">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3532" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`AbstractClass`</ph>, an abstract class (a class marked as <ph id="ph2">`abstract`</ph> in C# and <ph id="ph3">`MustInherit`</ph> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">`AbstractClass`</ph>、抽象クラス (としてマークされているクラス<ph id="ph2">`abstract`</ph>C# の場合と<ph id="ph3">`MustInherit`</ph>Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="3533" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`DerivedClass`</ph>, a class that inherits from <ph id="ph2">`AbstractClass`</ph>.</source>
          <target state="translated"><ph id="ph1">`DerivedClass`</ph>、から継承するクラスを<ph id="ph2">`AbstractClass`</ph>です。</target>       </trans-unit>
        <trans-unit id="3534" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`SingleClass`</ph>, a non-inheritable class.</source>
          <target state="translated"><ph id="ph1">`SingleClass`</ph>を非継承可能なクラスです。</target>       </trans-unit>
        <trans-unit id="3535" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>It is defined as <ph id="ph1">`sealed`</ph> in C# and <ph id="ph2">`NotInheritable`</ph> in Visual Basic.</source>
          <target state="translated">として定義されて<ph id="ph1">`sealed`</ph>C# の場合と<ph id="ph2">`NotInheritable`</ph>Visual Basic でします。</target>       </trans-unit>
        <trans-unit id="3536" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`ITypeInfo`</ph>, an interface.</source>
          <target state="translated"><ph id="ph1">`ITypeInfo`</ph>、インターフェイスです。</target>       </trans-unit>
        <trans-unit id="3537" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`ImplementingClass`</ph>, a class that implements the <ph id="ph2">`ITypeInfo`</ph> interface.</source>
          <target state="translated"><ph id="ph1">`ImplementingClass`</ph>を実装するクラス、<ph id="ph2">`ITypeInfo`</ph>インターフェイスです。</target>       </trans-unit>
        <trans-unit id="3538" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The method returns <ph id="ph1">`true`</ph> only for <ph id="ph2">`AbstractClass`</ph>, the abstract class, and <ph id="ph3">`ITypeInfo`</ph>, the interface.</source>
          <target state="translated">メソッドを返します<ph id="ph1">`true`</ph>に対してのみ<ph id="ph2">`AbstractClass`</ph>、抽象クラス、および<ph id="ph3">`ITypeInfo`</ph>、インターフェイスです。</target>       </trans-unit>
        <trans-unit id="3539" translate="yes" xml:space="preserve" uid="P:System.Type.IsAnsiClass">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">&lt;see langword="AnsiClass" /&gt;</ph> is selected for the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="AnsiClass" /&gt;</ph> の文字列書式属性として <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> が選択されているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the string format attribute <ph id="ph2">&lt;see langword="AnsiClass" /&gt;</ph> is selected for the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>に、文字列書式属性として<ph id="ph2">&lt;see langword="AnsiClass" /&gt;</ph> が選択されている場合は <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3541" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> selects the string format attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph>文字列書式属性を選択します。</target>       </trans-unit>
        <trans-unit id="3542" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
          <target state="translated">文字列形式の属性では、文字列の解釈方法を定義することで相互運用性が向上します。</target>       </trans-unit>
        <trans-unit id="3543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型を構築する元になるジェネリック型定義に関連する、ジェネリック型をこのプロパティを表します。</target>       </trans-unit>
        <trans-unit id="3544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">たとえば場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表します<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph> Visual Basic で)、このプロパティの値はによって決まります<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="3545" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>The following example gets the field information and checks for the <ph id="ph1">`AnsiClass`</ph> attribute.</source>
          <target state="translated">次の例は、フィールド情報を取得し、確認、<ph id="ph1">`AnsiClass`</ph>属性。</target>       </trans-unit>
        <trans-unit id="3547" translate="yes" xml:space="preserve" uid="P:System.Type.IsArray">
          <source>Gets a value that indicates whether the type is an array.</source>
          <target state="translated">型が配列かどうかを示す値を返します。</target>       </trans-unit>
        <trans-unit id="3548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is an array; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の型が配列である場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for the <ph id="ph3">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph>プロパティから返される<ph id="ph2">`false`</ph>の<ph id="ph3">&lt;xref:System.Array&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="3550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>It also returns <ph id="ph1">`false`</ph> if the current instance is a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a collection type or an interface designed to work with collections, such as <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id="ph4">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</source>
          <target state="translated">返します<ph id="ph1">`false`</ph>、現在のインスタンスがある場合、<ph id="ph2">&lt;xref:System.Type&gt;</ph>型はコレクションまたはコレクションで作業をように設計されたインターフェイスを表すオブジェクト<ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph>または<ph id="ph4">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3551" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>To check for an array, use code such as:</source>
          <target state="translated">配列を確認するには、ようコードを使用します。</target>       </trans-unit>
        <trans-unit id="3552" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">現在の型がジェネリック型またはジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す場合、このプロパティは常に返します<ph id="ph1">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3553" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>This property is read-only.</source>
          <target state="translated">このプロパティは読み取り専用です。</target>       </trans-unit>
        <trans-unit id="3554" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>The following example demonstrates using the <ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph> property.</source>
          <target state="translated">次の例では、使用方法を示します、<ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3555" translate="yes" xml:space="preserve" uid="M:System.Type.IsArrayImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsArray" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array.</source>
          <target state="translated">派生クラスによってオーバーライドされるときに、<ph id="ph1">&lt;see cref="P:System.Type.IsArray" /&gt;</ph> プロパティを実装し、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> が配列かどうかを判断します。</target>       </trans-unit>
        <trans-unit id="3556" translate="yes" xml:space="preserve" uid="M:System.Type.IsArrayImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が配列である場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsArrayImpl">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class must return <ph id="ph2">`false`</ph> because it is an object, not an array.</source>
          <target state="translated">インスタンス、<ph id="ph1">&lt;xref:System.Array&gt;</ph>クラスを返す必要があります<ph id="ph2">`false`</ph>オブジェクト、配列ではなくなっているためです。</target>       </trans-unit>
        <trans-unit id="3558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsArrayImpl">
          <source>The following example overrides the <ph id="ph1">`IsArrayImpl`</ph> method in the <ph id="ph2">`MyTypeDelegator`</ph> class, checks if a variable is an array, and displays the result.</source>
          <target state="translated">次の例よりも優先、<ph id="ph1">`IsArrayImpl`</ph>メソッドで、<ph id="ph2">`MyTypeDelegator`</ph>クラス、かをチェックする変数は、配列と、結果が表示されます。</target>       </trans-unit>
        <trans-unit id="3559" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The type to compare with the current type.</source>
          <target state="translated">現在の型と比較する型。</target>       </trans-unit>
        <trans-unit id="3560" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>Determines whether an instance of a specified type can be assigned to an instance of the current type.</source>
          <target state="translated">指定された型のインスタンスを現在の型インスタンスに割り当てることができるかどうかを判定します。</target>       </trans-unit>
        <trans-unit id="3561" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が返されるのは、以下のいずれかの条件が満たされる場合です。</target>       </trans-unit>
        <trans-unit id="3562" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> and the current instance represent the same type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> と現在のインスタンスが同じ型を表す。</target>       </trans-unit>
        <trans-unit id="3563" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is derived either directly or indirectly from the current instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> が、現在のインスタンスから直接または間接に派生している。</target>       </trans-unit>
        <trans-unit id="3564" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is derived directly from the current instance if it inherits from the current instance; <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> が現在のインスタンスから継承している場合は、現在のインスタンスから直接派生し、<ph id="ph2">&lt;paramref name="c" /&gt;</ph> が現在のインスタンスから継承している 1 つ以上のクラスの連続から継承している場合は、現在のインスタンスから間接的に派生します。</target>       </trans-unit>
        <trans-unit id="3565" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The current instance is an interface that <ph id="ph1">&lt;paramref name="c" /&gt;</ph> implements.</source>
          <target state="translated">現在のインスタンスが、<ph id="ph1">&lt;paramref name="c" /&gt;</ph> が実装するインターフェイスである。</target>       </trans-unit>
        <trans-unit id="3566" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is a generic type parameter, and the current instance represents one of the constraints of <ph id="ph2">&lt;paramref name="c" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> がジェネリック型パラメーターであり、現在のインスタンスが <ph id="ph2">&lt;paramref name="c" /&gt;</ph> の定数の 1 つを表している。</target>       </trans-unit>
        <trans-unit id="3567" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>In the following example, the current instance is a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> class.</source>
          <target state="translated">次の例では、現在のインスタンスは、<ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> クラスを表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトです。</target>       </trans-unit>
        <trans-unit id="3568" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>GenericWithConstraint<ept id="p1">&lt;/c&gt;</ept> is a generic type whose generic type parameter must be of type    <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>GenericWithConstraint<ept id="p1">&lt;/c&gt;</ept> は、ジェネリック型パラメーターを <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> 型にする必要があるジェネリック型です。</target>       </trans-unit>
        <trans-unit id="3569" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>Passing its generic type parameter to the <ph id="ph1">&lt;see cref="M:System.Type.IsAssignableFrom(System.Type)" /&gt;</ph> indicates that  an instance of the generic type parameter can be assigned to an <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object.</source>
          <target state="translated">ジェネリック型パラメーターを <ph id="ph1">&lt;see cref="M:System.Type.IsAssignableFrom(System.Type)" /&gt;</ph> に渡すことで、ジェネリック型パラメーターのインスタンスを <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> オブジェクトに割り当てられることを示します。</target>       </trans-unit>
        <trans-unit id="3570" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> represents a value type, and the current instance represents <bpt id="p1">&lt;c&gt;</bpt>Nullable<ph id="ph2">&amp;lt;</ph>c<ph id="ph3">&amp;gt;</ph><ept id="p1">&lt;/c&gt;</ept> (<bpt id="p2">&lt;c&gt;</bpt>Nullable(Of c)<ept id="p2">&lt;/c&gt;</ept> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> が値型を表し、現在のインスタンスが <bpt id="p1">&lt;c&gt;</bpt>Nullable<ph id="ph2">&amp;lt;</ph>c<ph id="ph3">&amp;gt;</ph><ept id="p1">&lt;/c&gt;</ept> (Visual Basic では <bpt id="p2">&lt;c&gt;</bpt>Nullable(Of c)<ept id="p2">&lt;/c&gt;</ept>) を表している。</target>       </trans-unit>
        <trans-unit id="3571" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if none of these conditions are true, or if <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> が返されるのは、これらの条件がいずれも満たされない場合、または <ph id="ph2">&lt;paramref name="c" /&gt;</ph> が <ph id="ph3">&lt;see langword="null" /&gt;</ph> である場合です。</target>       </trans-unit>
        <trans-unit id="3572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> method can be used to determine whether an instance of <ph id="ph2">`c`</ph> can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph>のインスタンスかどうかを判断するメソッドを使用できます<ph id="ph2">`c`</ph>割り当てることができる、現在の型のインスタンスに、メソッド型を持つが、デザイン時に認識されていないオブジェクトを処理するときに、最も役に立つとでは、次の例のように、条件付き割り当てします。</target>       </trans-unit>
        <trans-unit id="3573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>This method thus ensures that a line of code like the following will execute at runtime without throwing an <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> exception or a similar exception:</source>
          <target state="translated">このメソッドしたがって確実にスローされることがなく実行時に実行、次のようなコードの行、<ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph>例外または同様の例外。</target>       </trans-unit>
        <trans-unit id="3574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">このメソッドは、派生クラスでオーバーライドできます。</target>       </trans-unit>
        <trans-unit id="3575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>A generic type definition is not assignable from a closed constructed type.</source>
          <target state="translated">ジェネリック型定義は、クローズ構築型から割り当てることはできません。</target>       </trans-unit>
        <trans-unit id="3576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>That is, you cannot assign the closed constructed type <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> in Visual Basic) to a variable of type <ph id="ph3">`MyGenericList&lt;T&gt;`</ph>.</source>
          <target state="translated">つまり、クローズ構築型を割り当てることはできません<ph id="ph1">`MyGenericList&lt;int&gt;`</ph>(<ph id="ph2">`MyGenericList(Of Integer)`</ph> Visual Basic で) 型の変数に<ph id="ph3">`MyGenericList&lt;T&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="3577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>If the <ph id="ph1">`c`</ph> parameter is of type <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>, the result is based on the type that is to be built.</source>
          <target state="translated">場合、<ph id="ph1">`c`</ph>パラメーターの型は<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>結果が構築される型に基づきます。</target>       </trans-unit>
        <trans-unit id="3578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The following code example demonstrates this using a built type named <ph id="ph1">`B`</ph>.</source>
          <target state="translated">次のコード例を示しますこのという名前の組み込み型を使用して<ph id="ph1">`B`</ph>です。</target>       </trans-unit>
        <trans-unit id="3579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The following example demonstrates the <ph id="ph1">`IsAssignableFrom`</ph> method using defined classes, integer arrays, and generics.</source>
          <target state="translated">次の例で、<ph id="ph1">`IsAssignableFrom`</ph>クラス、整数の配列、およびジェネリック メソッドを使用して定義します。</target>       </trans-unit>
        <trans-unit id="3580" translate="yes" xml:space="preserve" uid="P:System.Type.IsAutoClass">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">&lt;see langword="AutoClass" /&gt;</ph> is selected for the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="AutoClass" /&gt;</ph> の文字列書式属性として <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> が選択されているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the string format attribute <ph id="ph2">&lt;see langword="AutoClass" /&gt;</ph> is selected for the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>に、文字列書式属性として<ph id="ph2">&lt;see langword="AutoClass" /&gt;</ph> が選択されている場合は <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> selects the string format attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph>文字列書式属性を選択します。</target>       </trans-unit>
        <trans-unit id="3583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
          <target state="translated">文字列形式の属性では、文字列の解釈方法を定義することで相互運用性が向上します。</target>       </trans-unit>
        <trans-unit id="3584" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。</target>       </trans-unit>
        <trans-unit id="3585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">たとえば場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表します<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph> Visual Basic で)、このプロパティの値はによって決まります<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="3586" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3587" translate="yes" xml:space="preserve" uid="P:System.Type.IsAutoLayout">
          <source>Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</source>
          <target state="translated">現在の型のフィールドが、共通言語ランタイムによって自動的に配置されているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3588" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property of the current type includes <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.AutoLayout" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の型の <ph id="ph1">&lt;see langword="true" /&gt;</ph> プロパティに <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> が含まれる場合は <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.AutoLayout" /&gt;</ph>。それ以外の場合は <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>This property is provided as a convenience.</source>
          <target state="translated">このプロパティは、便宜上指定します。</target>       </trans-unit>
        <trans-unit id="3590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> is set.</source>
          <target state="translated">また、使用することができます、<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph>型レイアウト属性とし、テストをするかどうかを選択する列挙値<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>設定されています。</target>       </trans-unit>
        <trans-unit id="3591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>,<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>、<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>、および<ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph>列挙値が、型のフィールドがメモリにレイアウトする方法を示します。</target>       </trans-unit>
        <trans-unit id="3592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> when you create the type.</source>
          <target state="translated">動的な型を指定できます<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>型を作成する場合。</target>       </trans-unit>
        <trans-unit id="3593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType&gt;</ph> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</source>
          <target state="translated">コードでは、適用、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>属性が、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType&gt;</ph>型にランタイムに適切なクラスをレイアウトする方法を決定する列挙値。</target>       </trans-unit>
        <trans-unit id="3594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
          <target state="translated">使用することはできません、<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph>メソッドを呼び出せば確認するかどうか、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>型に適用されています。</target>       </trans-unit>
        <trans-unit id="3595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。</target>       </trans-unit>
        <trans-unit id="3596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></source>
          <target state="translated">たとえば場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表します<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph> Visual Basic で)、このプロパティの値はによって決まります <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></target>       </trans-unit>
        <trans-unit id="3597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>The following example creates an instance of the type and displays the <ph id="ph1">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph> property.</source>
          <target state="translated">次の例は、型のインスタンスを作成し、表示、<ph id="ph1">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3599" translate="yes" xml:space="preserve" uid="P:System.Type.IsByRef">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が参照渡しかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3600" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> が参照渡しである場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3601" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>To get to the actual type, dereference the type that was passed by reference, and then call <ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> on that type.</source>
          <target state="translated">表示する実際の型に、参照によって渡された型を逆参照しを呼び出す<ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph>でその型にします。</target>       </trans-unit>
        <trans-unit id="3602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsByRef`</ph> property to check whether a specified type is passed by reference.</source>
          <target state="translated">次の例での使用、<ph id="ph1">`IsByRef`</ph>プロパティを指定した型が参照によって渡されるかどうかを確認します。</target>       </trans-unit>
        <trans-unit id="3603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>The example defines the class <ph id="ph1">`MyTypeDelegator`</ph>, which overrides the <ph id="ph2">`HasElementTypeImpl`</ph> method.</source>
          <target state="translated">例では、クラスを定義する<ph id="ph1">`MyTypeDelegator`</ph>が優先、<ph id="ph2">`HasElementTypeImpl`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3604" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>The main class checks for the <ph id="ph1">`HasElementType`</ph> property and displays the element type.</source>
          <target state="translated">メイン クラスには、チェック、<ph id="ph1">`HasElementType`</ph>要素が型プロパティを表示します。</target>       </trans-unit>
        <trans-unit id="3605" translate="yes" xml:space="preserve" uid="M:System.Type.IsByRefImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference.</source>
          <target state="translated">派生クラスによってオーバーライドされるときに、<ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> プロパティを実装し、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> が参照渡しかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="3606" translate="yes" xml:space="preserve" uid="M:System.Type.IsByRefImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> が参照渡しである場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3607" translate="yes" xml:space="preserve" uid="P:System.Type.IsClass">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a class or a delegate; that is, not a value type or interface.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> がクラスまたはデリゲートである (つまり値型やインターフェイスではない) かどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3608" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a class; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> がクラスである場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>This property returns <ph id="ph1">`true`</ph> for classes as well as delegates.</source>
          <target state="translated">このプロパティを返します<ph id="ph1">`true`</ph>クラスとしてのデリゲート。</target>       </trans-unit>
        <trans-unit id="3610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>It returns <ph id="ph1">`false`</ph> for value types (for structures and enumerations) even if they are boxed.</source>
          <target state="translated">返します<ph id="ph1">`false`</ph>値型の構造および列挙体) (ボックス化されている場合でもです。</target>       </trans-unit>
        <trans-unit id="3611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`true`</ph>.If the current <ph id="ph3">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns <ph id="ph4">`true`</ph> if the generic type definition is a class definition; that is, it does not define an interface or a value type.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<ph id="ph2">`true`</ph>です。場合、現在<ph id="ph3">&lt;xref:System.Type&gt;</ph>このプロパティを返しますが構築ジェネリック型を表す<ph id="ph4">`true`</ph>場合は、ジェネリック型定義は、クラス定義です。 つまり、は定義しませんインターフェイスまたは値型です。</target>       </trans-unit>
        <trans-unit id="3612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>This property returns <ph id="ph1">`true`</ph> for <ph id="ph2">`Type`</ph> instances that represent the <ph id="ph3">&lt;xref:System.Enum&gt;</ph> and <ph id="ph4">&lt;xref:System.ValueType&gt;</ph> classes.</source>
          <target state="translated">このプロパティを返します<ph id="ph1">`true`</ph>の<ph id="ph2">`Type`</ph>インスタンスを表す、<ph id="ph3">&lt;xref:System.Enum&gt;</ph>と<ph id="ph4">&lt;xref:System.ValueType&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="3613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</source>
          <target state="translated">これら 2 つのクラスは、列挙型の基本型および値型では、それぞれが列挙型または値型自体ではありません。</target>       </trans-unit>
        <trans-unit id="3614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.IsEnum%2A&gt;</ph> properties.</source>
          <target state="translated">詳細については、次を参照してください。、<ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Type.IsEnum%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph> enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph>列挙値としてクラスまたはインターフェイスの型宣言を区別します。ただし、クラスおよび値型の両方が付いて、<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="3616" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>If you retrieve the value of a type's Attributes property and use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph> value to determine whether a type is a class instead of a value type, you must also call the <ph id="ph2">&lt;xref:System.Type.IsValueType%2A&gt;</ph> property.</source>
          <target state="translated">型の属性のプロパティと使用の値を取得する場合、<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph>も呼び出す必要がありますが、型が値型ではなくクラスかどうかを決定する値、<ph id="ph2">&lt;xref:System.Type.IsValueType%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>The example for the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration contains additional information as well as anexample.</source>
          <target state="translated">例を<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph>列挙型には、追加情報と例が含まれています。</target>       </trans-unit>
        <trans-unit id="3618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>This property is read-only.</source>
          <target state="translated">このプロパティは読み取り専用です。</target>       </trans-unit>
        <trans-unit id="3619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>The following example creates an instance of a type and indicates whether the type is a class.</source>
          <target state="translated">次の例では、型のインスタンスを作成し、型がクラスであるかどうかを示します。</target>       </trans-unit>
        <trans-unit id="3620" translate="yes" xml:space="preserve" uid="P:System.Type.IsCOMObject">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が COM オブジェクトかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が COM オブジェクトである場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>This method returns <ph id="ph1">`false`</ph> for COM interfaces because they are not objects.</source>
          <target state="translated">このメソッドが戻る<ph id="ph1">`false`</ph>の COM インターフェイスのオブジェクトではないためです。</target>       </trans-unit>
        <trans-unit id="3623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>COM interfaces can be implemented by Microsoft .NET Framework objects.</source>
          <target state="translated">Microsoft .NET Framework オブジェクトによっては、COM インターフェイスを実装することができます。</target>       </trans-unit>
        <trans-unit id="3624" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>You can also load a COM class and get a <ph id="ph1">`Type`</ph> object for that COM class by using the <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool.</source>
          <target state="translated">COM クラスの読み込みおよび取得することができますも、<ph id="ph1">`Type`</ph>を使用している COM クラスのオブジェクト、 <bpt id="p1">[</bpt>Tlbimp.exe (タイプ ライブラリ インポーター)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept>ツールです。</target>       </trans-unit>
        <trans-unit id="3625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。</target>       </trans-unit>
        <trans-unit id="3626" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int`</ph>&gt; (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">たとえば場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表します<ph id="ph2">`MyGenericType&lt;int`</ph>&gt; (<ph id="ph3">`MyGenericType(Of Integer)`</ph> Visual Basic で)、このプロパティの値はによって決まります<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="3627" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3628" translate="yes" xml:space="preserve" uid="M:System.Type.IsCOMObjectImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsCOMObject" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object.</source>
          <target state="translated">派生クラスによってオーバーライドされるときに、<ph id="ph1">&lt;see cref="P:System.Type.IsCOMObject" /&gt;</ph> プロパティを実装し、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> が COM オブジェクトかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="3629" translate="yes" xml:space="preserve" uid="M:System.Type.IsCOMObjectImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が COM オブジェクトである場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsCOMObjectImpl">
          <source>This method returns <ph id="ph1">`false`</ph> for COM interfaces because they are not objects.</source>
          <target state="translated">このメソッドが戻る<ph id="ph1">`false`</ph>の COM インターフェイスのオブジェクトではないためです。</target>       </trans-unit>
        <trans-unit id="3631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsCOMObjectImpl">
          <source>COM interfaces can be implemented by Microsoft .NET Framework objects.</source>
          <target state="translated">Microsoft .NET Framework オブジェクトによっては、COM インターフェイスを実装することができます。</target>       </trans-unit>
        <trans-unit id="3632" translate="yes" xml:space="preserve" uid="P:System.Type.IsConstructedGenericType">
          <source>Gets a value that indicates whether this object represents a constructed generic type.</source>
          <target state="translated">このオブジェクトが構築ジェネリック型かどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3633" translate="yes" xml:space="preserve" uid="P:System.Type.IsConstructedGenericType">
          <source>You can create instances of a constructed generic type.</source>
          <target state="translated">構築ジェネリック型のインスタンスを作成できます。</target>       </trans-unit>
        <trans-unit id="3634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this object represents a constructed generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">このオブジェクトが構築ジェネリック型を表している場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source>A constructed generic type has had explicit types supplied for all of its generic type parameters.</source>
          <target state="translated">構築されたジェネリック型は、明示的な型のすべてのジェネリック型パラメーターに指定されました。</target>       </trans-unit>
        <trans-unit id="3636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source>It is also referred to as a closed generic type.</source>
          <target state="translated">クローズ ジェネリック型とも呼ばれます。</target>       </trans-unit>
        <trans-unit id="3637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source>When this property is <ph id="ph1">`true`</ph>, you can create instances of the current type; when it is <ph id="ph2">`false`</ph>, you can't.</source>
          <target state="translated">このプロパティが<ph id="ph1">`true`</ph>、現在の型のインスタンスを作成することができます。 これはと<ph id="ph2">`false`</ph>、することはできません。</target>       </trans-unit>
        <trans-unit id="3638" translate="yes" xml:space="preserve" uid="P:System.Type.IsContextful">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> をコンテキスト内で管理できるかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> をコンテキスト内でホストできる場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</source>
          <target state="translated">コンテキストは、クラス メンバーへの呼び出しをインターセプトし、同期など、クラスに適用されるポリシーを強制します。</target>       </trans-unit>
        <trans-unit id="3641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>For more detailed information on remoting contexts, see <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.Context&gt;</ph>.</source>
          <target state="translated">リモート処理コンテキストについて詳細を参照してください。<ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.Context&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>The following example demonstrates the <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> properties of the <ph id="ph4">&lt;xref:System.Type&gt;</ph> class.</source>
          <target state="translated">次の例で、 <ph id="ph1">`IsContextful`</ph>、 <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>、および<ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph>のプロパティ、<ph id="ph4">&lt;xref:System.Type&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="3644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</source>
          <target state="translated">これは、型がプリミティブ データ型であるかどうかと、参照によってマーシャ リングできるかどうか、コンテキストでは、指定された型をホストすることができるかどうかを確認します。</target>       </trans-unit>
        <trans-unit id="3645" translate="yes" xml:space="preserve" uid="M:System.Type.IsContextfulImpl">
          <source>Implements the <ph id="ph1">&lt;see cref="P:System.Type.IsContextful" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.IsContextful" /&gt;</ph> プロパティを実装し、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> をコンテキスト内で管理できるかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="3646" translate="yes" xml:space="preserve" uid="M:System.Type.IsContextfulImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> をコンテキスト内でホストできる場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsContextfulImpl">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">このメソッドは、派生クラスでオーバーライドできます。</target>       </trans-unit>
        <trans-unit id="3648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsContextfulImpl">
          <source>A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</source>
          <target state="translated">コンテキストは、クラス メンバーへの呼び出しをインターセプトし、同期など、クラスに適用されるポリシーを適用します。</target>       </trans-unit>
        <trans-unit id="3649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsContextfulImpl">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsContextfulImpl`</ph> method.</source>
          <target state="translated">次の例での使用、<ph id="ph1">`IsContextfulImpl`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3650" translate="yes" xml:space="preserve" uid="P:System.Type.IsEnum">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents an enumeration.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が列挙体であるどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> represents an enumeration; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see langword="true" /&gt;</ph> が列挙体を表している場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>This property returns <ph id="ph1">`true`</ph> for an enumeration, but not for the <ph id="ph2">&lt;xref:System.Enum&gt;</ph> type itself.</source>
          <target state="translated">このプロパティを返します<ph id="ph1">`true`</ph>、列挙型対応のではなく、<ph id="ph2">&lt;xref:System.Enum&gt;</ph>自体を入力します。</target>       </trans-unit>
        <trans-unit id="3653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。</target>       </trans-unit>
        <trans-unit id="3654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">たとえば場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表します<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph> Visual Basic で)、このプロパティの値はによって決まります<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="3655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>This property is read-only.</source>
          <target state="translated">このプロパティは読み取り専用です。</target>       </trans-unit>
        <trans-unit id="3657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>The following example demonstrates how to use the <ph id="ph1">`IsEnum`</ph> property.</source>
          <target state="translated">次の例で使用する方法、<ph id="ph1">`IsEnum`</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3658" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source>The value to be tested.</source>
          <target state="translated">テスト対象の値。</target>       </trans-unit>
        <trans-unit id="3659" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source>Returns a value that indicates whether the specified value exists in the current enumeration type.</source>
          <target state="translated">指定された値が現在の列挙型に存在するかどうかを示す値を返します。</target>       </trans-unit>
        <trans-unit id="3660" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified value is a member of the current enumeration type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">指定された値が現在の列挙型のメンバーである場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3661" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source>The current type is not an enumeration.</source>
          <target state="translated">現在の型は列挙型ではありません。</target>       </trans-unit>
        <trans-unit id="3662" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3663" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that cannot be the underlying type of an enumeration.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> は、列挙体の基になる型になることができない型です。</target>       </trans-unit>
        <trans-unit id="3664" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>The COM type that is tested for equivalence with the current type.</source>
          <target state="translated">現在の型と等しいかどうかをテストする COM 型。</target>       </trans-unit>
        <trans-unit id="3665" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Determines whether two COM types have the same identity and are eligible for type equivalence.</source>
          <target state="translated">2 つの COM 型が同じ ID を持ち、型の同値の対象になるかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="3666" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the COM types are equivalent; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">両方の COM 型が等しい場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3667" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>This method also returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</source>
          <target state="translated">このメソッドは、一方の型が実行のために読み込まれたアセンブリに存在し、もう一方の型がリフレクションのみのコンテキストに読み込まれたアセンブリに存在する場合にも <ph id="ph1">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="3668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</source>
          <target state="translated">以降で、 <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>、共通言語ランタイムは、COM 型のマネージ アセンブリ相互運用機能アセンブリからの COM 型の型情報を取得するを必要とするのではなく、マネージ アセンブリに直接の型情報の埋め込みをサポートしています。</target>       </trans-unit>
        <trans-unit id="3669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</source>
          <target state="translated">埋め込まれる型情報にはマネージ アセンブリに実際に使用される型とメンバーのみが含まれるため、2 つのマネージ アセンブリで同じ COM 型の表示が非常に異なることが考えられます。</target>       </trans-unit>
        <trans-unit id="3670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Each managed assembly has a different <ph id="ph1">&lt;xref:System.Type&gt;</ph> object to represent its view of the COM type.</source>
          <target state="translated">マネージ アセンブリごとに、COM 型の表示を表す異なる <ph id="ph1">&lt;xref:System.Type&gt;</ph> オブジェクトが与えられます。</target>       </trans-unit>
        <trans-unit id="3671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</source>
          <target state="translated">共通言語ランタイムでは、インターフェイス、構造、列挙、委任といった異なる表示間で型の等価性が与えられます。</target>       </trans-unit>
        <trans-unit id="3672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</source>
          <target state="translated">型の等価性とは、マネージ アセンブリ間で渡される COM オブジェクトを受け取り側のアセンブリで適切なマネージ型に変換できることを意味します。</target>       </trans-unit>
        <trans-unit id="3673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph>メソッド、アセンブリを別のアセンブリから取得した COM オブジェクトが、COM と同じ id の最初のアセンブリの独自埋め込まれた相互運用機能型のいずれかであると判断でき、したがって、その型にキャストすることができます。</target>       </trans-unit>
        <trans-unit id="3674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>For more information, see <bpt id="p1">[</bpt>Type Equivalence and Embedded Interop Types<ept id="p1">](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。<bpt id="p1">[</bpt>型の等価性と埋め込まれた相互運用機能型<ept id="p1">](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="3675" translate="yes" xml:space="preserve" uid="P:System.Type.IsExplicitLayout">
          <source>Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</source>
          <target state="translated">現在の型のフィールドが、明示的に指定したオフセット位置に配置されているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property of the current type includes <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の型の <ph id="ph1">&lt;see langword="true" /&gt;</ph> プロパティに <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> が含まれる場合は <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /&gt;</ph>。それ以外の場合は <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>This property is provided as a convenience.</source>
          <target state="translated">このプロパティは、便宜上指定します。</target>       </trans-unit>
        <trans-unit id="3678" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> is set.</source>
          <target state="translated">また、使用することができます、<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph>型レイアウト属性とし、テストをするかどうかを選択する列挙値<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>設定されています。</target>       </trans-unit>
        <trans-unit id="3679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>、 <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>、および<ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph>列挙値が、型のフィールドがメモリにレイアウトする方法を示します。</target>       </trans-unit>
        <trans-unit id="3680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> when you create the type.</source>
          <target state="translated">動的な型を指定できます<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>型を作成する場合。</target>       </trans-unit>
        <trans-unit id="3681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</source>
          <target state="translated">コードでは、適用、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>属性が、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>型にフィールドを開始するオフセットが明示的に指定されているを指定する列挙値。</target>       </trans-unit>
        <trans-unit id="3682" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
          <target state="translated">使用することはできません、<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph>メソッドを呼び出せば確認するかどうか、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>型に適用されています。</target>       </trans-unit>
        <trans-unit id="3683" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。</target>       </trans-unit>
        <trans-unit id="3684" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">たとえば場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表します<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph> Visual Basic で)、このプロパティの値はによって決まります<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="3685" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3686" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>The following example creates an instance of a type and displays the value of its <ph id="ph1">&lt;xref:System.Type.IsExplicitLayout%2A&gt;</ph> property.</source>
          <target state="translated">次の例は、型のインスタンスを作成しの値を表示、<ph id="ph1">&lt;xref:System.Type.IsExplicitLayout%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3687" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>It uses the <ph id="ph1">`MySystemTime`</ph> class, which is also in the code example for <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>.</source>
          <target state="translated">使用して、<ph id="ph1">`MySystemTime`</ph>クラスは、コードの例でも<ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="3688" translate="yes" xml:space="preserve" uid="P:System.Type.IsGenericParameter">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter in the definition of a generic type or method.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表しているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3689" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type parameter of a generic type definition or generic method definition; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトがジェネリック型定義またはジェネリック メソッド定義の型パラメーターを表している場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3690" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source><ph id="ph1">&lt;xref:System.Type&gt;</ph> objects that represent generic type parameters can be obtained by calling the <ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method of a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object that represents a generic type definition, or the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> method of a <ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a generic method definition.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph> ジェネリック型パラメーターを表すオブジェクトを呼び出すことによって取得できます、<ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph>のメソッド、 <ph id="ph3">&lt;xref:System.Type&gt;</ph> 、ジェネリック型定義を表しているオブジェクトまたは<ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph>のメソッド、<ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph>ジェネリック メソッドを表すオブジェクト定義です。</target>       </trans-unit>
        <trans-unit id="3691" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For a generic type or method definition, the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for every element of the resulting array.</source>
          <target state="translated">ジェネリック型またはジェネリック メソッド定義の<ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>プロパティから返される<ph id="ph2">`true`</ph>の結果の配列のすべての要素。</target>       </trans-unit>
        <trans-unit id="3692" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For a closed constructed type or method, the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for every element of the array returned by the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method.</source>
          <target state="translated">クローズ構築型またはメソッドに対して、<ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>プロパティから返される<ph id="ph2">`false`</ph>によって返される配列の各要素に対して、<ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3693" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</source>
          <target state="translated">オープン構築型またはメソッドは、いくつかの要素の配列の特定の種類があり、型パラメーターがあります。</target>       </trans-unit>
        <trans-unit id="3694" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> returns <ph id="ph2">`false`</ph> for the types and <ph id="ph3">`true`</ph> for the type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> 返します<ph id="ph2">`false`</ph>の型と<ph id="ph3">`true`</ph>の型パラメーターです。</target>       </trans-unit>
        <trans-unit id="3695" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>The code example for the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property demonstrates a generic class with a mixture of types and type parameters.</source>
          <target state="translated">コード例、<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>プロパティ型と型パラメーターの組み合わせがあるジェネリック クラスをについて説明します。</target>       </trans-unit>
        <trans-unit id="3696" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> プロパティの解説を参照してください。</target>       </trans-unit>
        <trans-unit id="3697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to test for generic type parameters in a generic type.</source>
          <target state="translated">次の例では、<ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>プロパティをジェネリック型のジェネリック型パラメーターをテストします。</target>       </trans-unit>
        <trans-unit id="3698" translate="yes" xml:space="preserve" uid="P:System.Type.IsGenericType">
          <source>Gets a value indicating whether the current type is a generic type.</source>
          <target state="translated">現在の型がジェネリック型かどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is a generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 現在の型がジェネリック型である場合それ以外の場合、<ph id="ph2">&lt;see langword="false" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property to determine whether a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object represents a generic type.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>プロパティを決定するかどうか、<ph id="ph2">&lt;xref:System.Type&gt;</ph>オブジェクトがジェネリック型を表します。</target>       </trans-unit>
        <trans-unit id="3701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property to determine whether a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object represents an open constructed type or a closed constructed type.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>プロパティを決定するかどうか、<ph id="ph2">&lt;xref:System.Type&gt;</ph>オブジェクトは、オープン構築型またはクローズ構築型を表します。</target>       </trans-unit>
        <trans-unit id="3702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> if the immediate type is not generic.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>プロパティから返される<ph id="ph2">`false`</ph>即時の型がジェネリックでない場合。</target>       </trans-unit>
        <trans-unit id="3703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For example, an array whose elements are of type <ph id="ph1">`A&lt;int&gt;`</ph> (<ph id="ph2">`A(Of Integer)`</ph> in Visual Basic) is not itself a generic type.</source>
          <target state="translated">たとえば、配列の要素の型は<ph id="ph1">`A&lt;int&gt;`</ph>(<ph id="ph2">`A(Of Integer)`</ph> Visual Basic で) 自体ではなく、ジェネリック型です。</target>       </trans-unit>
        <trans-unit id="3704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following table summarizes the invariant conditions for common terms used in generic reflection.</source>
          <target state="translated">次の表では、汎用のリフレクションで使用される一般的な用語に対するインバリアント条件をまとめたものです。</target>       </trans-unit>
        <trans-unit id="3705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Term</source>
          <target state="translated">用語</target>       </trans-unit>
        <trans-unit id="3706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Invariant</source>
          <target state="translated">インバリアント</target>       </trans-unit>
        <trans-unit id="3707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type definition</source>
          <target state="translated">ジェネリック型定義</target>       </trans-unit>
        <trans-unit id="3708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> プロパティが <ph id="ph2">`true`</ph> です。</target>       </trans-unit>
        <trans-unit id="3709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Defines a generic type.</source>
          <target state="translated">ジェネリック型を定義します。</target>       </trans-unit>
        <trans-unit id="3710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>A constructed type is created by calling the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a generic type definition and specifying an array of type arguments.</source>
          <target state="translated">呼び出すことによって構築された型を作成、<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>メソッドを<ph id="ph2">&lt;xref:System.Type&gt;</ph>ジェネリック型定義を表すオブジェクトを型引数の配列を指定します。</target>       </trans-unit>
        <trans-unit id="3711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> can be called only on generic type definitions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> ジェネリック型定義でのみ呼び出すことができます。</target>       </trans-unit>
        <trans-unit id="3712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Any generic type definition is a generic type (the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property is <ph id="ph2">`true`</ph>), but the converse is not true.</source>
          <target state="translated">任意のジェネリック型定義は、ジェネリック型 (、<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>プロパティは<ph id="ph2">`true`</ph>) がその逆は true ではありません。</target>       </trans-unit>
        <trans-unit id="3713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type</source>
          <target state="translated">ジェネリック型</target>       </trans-unit>
        <trans-unit id="3714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> プロパティが <ph id="ph2">`true`</ph> です。</target>       </trans-unit>
        <trans-unit id="3715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Can be a generic type definition, an open constructed type, or a closed constructed type.</source>
          <target state="translated">ジェネリック型定義、オープン構築型またはクローズ構築型を指定できます。</target>       </trans-unit>
        <trans-unit id="3716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Note that an array type whose element type is generic is not itself a generic type.</source>
          <target state="translated">配列型要素型がジェネリック自体ではなく、ジェネリック型です。</target>       </trans-unit>
        <trans-unit id="3717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The same is true of a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing a pointer to a generic type.</source>
          <target state="translated">場合も、同様、<ph id="ph1">&lt;xref:System.Type&gt;</ph>ジェネリック型へのポインターを表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="3718" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>open constructed type</source>
          <target state="translated">オープン構築型</target>       </trans-unit>
        <trans-unit id="3719" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> プロパティが <ph id="ph2">`true`</ph> です。</target>       </trans-unit>
        <trans-unit id="3720" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">例としては、ジェネリック型の型パラメーターが割り当てられていないこと、またはジェネリック型定義で、オープン構築型で入れ子になっている型またはジェネリック型を型引数を持つ、<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>プロパティは<ph id="ph2">`true`</ph>します。</target>       </trans-unit>
        <trans-unit id="3721" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>It is not possible to create an instance of an open constructed type.</source>
          <target state="translated">オープン構築型のインスタンスを作成することはできません。</target>       </trans-unit>
        <trans-unit id="3722" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Note that not all open constructed types are generic.</source>
          <target state="translated">開いているすべての構築された型が汎用的なことに注意してください。</target>       </trans-unit>
        <trans-unit id="3723" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</source>
          <target state="translated">たとえば、配列要素型がジェネリック型定義はジェネリックではありませんし、オープン構築型へのポインターはジェネリックではありません。</target>       </trans-unit>
        <trans-unit id="3724" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>closed constructed type</source>
          <target state="translated">クローズ構築型</target>       </trans-unit>
        <trans-unit id="3725" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> プロパティが <ph id="ph2">`false`</ph> です。</target>       </trans-unit>
        <trans-unit id="3726" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>When examined recursively, the type has no unassigned generic parameters.</source>
          <target state="translated">ときに検証した再帰、型では、未割り当てのジェネリック パラメーターはありません。</target>       </trans-unit>
        <trans-unit id="3727" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type parameter</source>
          <target state="translated">ジェネリック型パラメーター</target>       </trans-unit>
        <trans-unit id="3728" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> プロパティが <ph id="ph2">`true`</ph> です。</target>       </trans-unit>
        <trans-unit id="3729" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> プロパティが <ph id="ph2">`true`</ph> です。</target>       </trans-unit>
        <trans-unit id="3730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>In a generic type definition, a placeholder for a type that will be assigned later.</source>
          <target state="translated">ジェネリック型定義では、後で割り当てられる型のプレース ホルダーです。</target>       </trans-unit>
        <trans-unit id="3731" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type argument</source>
          <target state="translated">ジェネリック型引数</target>       </trans-unit>
        <trans-unit id="3732" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Can be any type, including a generic type parameter.</source>
          <target state="translated">ジェネリック型パラメーターを含む任意の型を指定できます。</target>       </trans-unit>
        <trans-unit id="3733" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Type arguments are specified as an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects passed to the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method when creating a constructed generic type.</source>
          <target state="translated">型引数の配列として指定されます<ph id="ph1">&lt;xref:System.Type&gt;</ph>にオブジェクトが渡される、<ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>メソッドが構築ジェネリック型を作成するときにします。</target>       </trans-unit>
        <trans-unit id="3734" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>If instances of the resulting type are to be created, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property must be <ph id="ph2">`false`</ph> for all the type arguments.</source>
          <target state="translated">結果の型のインスタンスを作成する場合、<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>プロパティである必要があります<ph id="ph2">`false`</ph>のすべての型引数。</target>       </trans-unit>
        <trans-unit id="3735" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following code example and table illustrate some of these terms and invariants.</source>
          <target state="translated">次のコード例と表は、これらの条項と不変式の一部を示しています。</target>       </trans-unit>
        <trans-unit id="3736" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">`Derived`</ph> class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</source>
          <target state="translated"><ph id="ph1">`Derived`</ph>クラス特に関心があるは、その基本型が構築された型を型引数リスト内の型と型パラメーターの組み合わせを持つためです。</target>       </trans-unit>
        <trans-unit id="3737" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following table shows examples that use and build on the classes <ph id="ph1">`Base`</ph>, <ph id="ph2">`Derived`</ph>, and <ph id="ph3">`G`</ph>.</source>
          <target state="translated">次の表を使用し、クラスを構築する例を示します<ph id="ph1">`Base`</ph>、 <ph id="ph2">`Derived`</ph>、および<ph id="ph3">`G`</ph>です。</target>       </trans-unit>
        <trans-unit id="3738" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>When the C++ and C# code is the same, only one entry is shown.</source>
          <target state="translated">C++ および c# のコードが同じ場合は、1 つのエントリが表示されます。</target>       </trans-unit>
        <trans-unit id="3739" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Example</source>
          <target state="translated">例</target>       </trans-unit>
        <trans-unit id="3740" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Invariants</source>
          <target state="translated">インバリアント</target>       </trans-unit>
        <trans-unit id="3741" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For this type:</source>
          <target state="translated">この型には。</target>       </trans-unit>
        <trans-unit id="3742" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> は <ph id="ph2">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="3743" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> は <ph id="ph2">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="3744" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> は <ph id="ph2">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="3745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For this type:</source>
          <target state="translated">この型には。</target>       </trans-unit>
        <trans-unit id="3746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> は <ph id="ph2">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="3747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> は <ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> は <ph id="ph2">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="3749" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For the type of variable <ph id="ph1">`d`</ph>:</source>
          <target state="translated">変数の型の<ph id="ph1">`d`</ph>:</target>       </trans-unit>
        <trans-unit id="3750" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`false`</ph> because <ph id="ph3">`d`</ph> is an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> <ph id="ph2">`false`</ph>ため<ph id="ph3">`d`</ph>配列です。</target>       </trans-unit>
        <trans-unit id="3751" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> は <ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3752" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> は <ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3753" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">`T`</ph>, <ph id="ph2">`U`</ph>, and <ph id="ph3">`V`</ph> (everywhere they appear)</source>
          <target state="translated"><ph id="ph1">`T`</ph>、 <ph id="ph2">`U`</ph>、および<ph id="ph3">`V`</ph>(すべての場所で表示される)</target>       </trans-unit>
        <trans-unit id="3754" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> は <ph id="ph2">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="3755" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`false`</ph> because there is no way to constrain a type parameter to generic types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> <ph id="ph2">`false`</ph>ジェネリック型の型パラメーターを制約する方法がないためです。</target>       </trans-unit>
        <trans-unit id="3756" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> は <ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3757" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because <ph id="ph3">`T`</ph>, <ph id="ph4">`U`</ph>, and <ph id="ph5">`V`</ph> are themselves generic type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> <ph id="ph2">`true`</ph>ため<ph id="ph3">`T`</ph>、 <ph id="ph4">`U`</ph>、および<ph id="ph5">`V`</ph>それ自体がジェネリック型パラメーターです。</target>       </trans-unit>
        <trans-unit id="3758" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>This does not imply anything about type arguments that are assigned to them later.</source>
          <target state="translated">後でそれらに割り当てられている型の引数について何もこの意味しません。</target>       </trans-unit>
        <trans-unit id="3759" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The type of field <ph id="ph1">`F`</ph></source>
          <target state="translated">フィールドの種類 <ph id="ph1">`F`</ph></target>       </trans-unit>
        <trans-unit id="3760" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> は <ph id="ph2">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="3761" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph> because a type has been assigned to the type parameter of <ph id="ph3">`G`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> <ph id="ph2">`false`</ph>の型パラメーターに型が割り当てられているため<ph id="ph3">`G`</ph>です。</target>       </trans-unit>
        <trans-unit id="3762" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Note that this is equivalent to having called the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method.</source>
          <target state="translated">これを呼び出すことと同じことに注意してください、<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3763" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because the type of field <ph id="ph3">`F`</ph> has a type argument that is an open constructed type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> <ph id="ph2">`true`</ph>ためのフィールドの種類<ph id="ph3">`F`</ph>オープン構築型を型引数を持ちます。</target>       </trans-unit>
        <trans-unit id="3764" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The constructed type is open because its type argument (that is, <ph id="ph1">`Base`</ph>) is a generic type definition.</source>
          <target state="translated">構築された型がオープンための型引数 (つまり、 <ph id="ph1">`Base`</ph>) は、ジェネリック型定義。</target>       </trans-unit>
        <trans-unit id="3765" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>This illustrates the recursive nature of the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
          <target state="translated">これは、再帰的な性質を示しています、<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3766" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The nested class <ph id="ph1">`Nested`</ph></source>
          <target state="translated">入れ子になったクラス <ph id="ph1">`Nested`</ph></target>       </trans-unit>
        <trans-unit id="3767" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>, even though the <ph id="ph3">`Nested`</ph> class has no generic type parameters of its own, because it is nested in a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> <ph id="ph2">`true`</ph>場合でも、<ph id="ph3">`Nested`</ph>クラスには、独自のジェネリック型パラメーターがないジェネリック型に入れ子にされているためです。</target>       </trans-unit>
        <trans-unit id="3768" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> は <ph id="ph2">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="3769" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>That is, you can call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method and supply the type parameter of the enclosing type, <ph id="ph2">`Derived`</ph>.</source>
          <target state="translated">つまり、呼び出すことができます、<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>メソッドと外側の型の型パラメーターを供給<ph id="ph2">`Derived`</ph>です。</target>       </trans-unit>
        <trans-unit id="3770" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because the enclosing type, <ph id="ph3">`Derived`</ph>, has generic type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> <ph id="ph2">`true`</ph>型、それを囲むため<ph id="ph3">`Derived`</ph>、ジェネリック型パラメーターを持ちます。</target>       </trans-unit>
        <trans-unit id="3771" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>This illustrates the recursive nature of the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">これは、再帰的な性質を示しています、<ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3772" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following code example displays the value of the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> properties for the types described in the Remarks section.</source>
          <target state="translated">次のコード例の値を表示する、 <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>、および<ph id="ph4">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>「解説」セクションで説明されている型のプロパティです。</target>       </trans-unit>
        <trans-unit id="3773" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For explanations of the property values, see the accompanying table in Remarks.</source>
          <target state="translated">プロパティ値の詳細については、「解説」表を参照してください。</target>       </trans-unit>
        <trans-unit id="3774" translate="yes" xml:space="preserve" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a generic type definition, from which other generic types can be constructed.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が、他のジェネリック型を構築できるジェネリック型の定義を表しているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3775" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object represents a generic type definition; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> オブジェクトがジェネリック型定義を表している場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3776" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>A generic type definition is a template from which other types can be constructed.</source>
          <target state="translated">ジェネリック型定義は、他の型を構築するためのテンプレートです。</target>       </trans-unit>
        <trans-unit id="3777" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>For example, from the generic type definition <ph id="ph1">`G&lt;T&gt;`</ph> (expressed in C# syntax; <ph id="ph2">`G(Of T)`</ph> in Visual Basic or <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> in C++) you can construct and instantiate the type <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> in Visual Basic), by calling the <ph id="ph6">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with a generic argument list containing the <ph id="ph7">&lt;xref:System.Int32&gt;</ph> type.</source>
          <target state="translated">たとえば、ジェネリック型定義から<ph id="ph1">`G&lt;T&gt;`</ph>(c# の構文で表現します。<ph id="ph2">`G(Of T)`</ph> Visual Basic でまたは<ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph>C++ で) を構築し、型のインスタンスを作成できます<ph id="ph4">`G&lt;int&gt;`</ph>(<ph id="ph5">`G(Of Integer)`</ph> Visual Basic で)、呼び出すことによって、<ph id="ph6">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>メソッドを含む汎用引数リストを<ph id="ph7">&lt;xref:System.Int32&gt;</ph>型です。</target>       </trans-unit>
        <trans-unit id="3778" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Given a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing this constructed type, the <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method gets the generic type definition back again.</source>
          <target state="translated">指定された、<ph id="ph1">&lt;xref:System.Type&gt;</ph>これを表すオブジェクトの構築型を<ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>メソッドは、取得、ジェネリック型定義戻るもう一度です。</target>       </trans-unit>
        <trans-unit id="3779" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property to determine whether you can create new types from the current type.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>プロパティが現在の型から新しい型を作成できるかどうかを決定します。</target>       </trans-unit>
        <trans-unit id="3780" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>If the <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, you can call the <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method to create new generic types.</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>プロパティから返される<ph id="ph2">`true`</ph>、呼び出すことができます、<ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>新しいジェネリック型を作成します。</target>       </trans-unit>
        <trans-unit id="3781" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> プロパティの解説を参照してください。</target>       </trans-unit>
        <trans-unit id="3782" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>The following example displays information about a type, including whether or not it is a generic type definition.</source>
          <target state="translated">次の例では、ジェネリック型定義であるかどうかなど、型に関する情報を表示します。</target>       </trans-unit>
        <trans-unit id="3783" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</source>
          <target state="translated">構築された型、ジェネリック型定義、および通常の型は、情報が表示されます。</target>       </trans-unit>
        <trans-unit id="3784" translate="yes" xml:space="preserve" uid="P:System.Type.IsImport">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> has a <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph> attribute applied, indicating that it was imported from a COM type library.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> に <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph> 属性が適用されているかどうかを示す (つまり、COM タイプ ライブラリからインポートされたかどうかを示す) 値を取得します。</target>       </trans-unit>
        <trans-unit id="3785" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> has a <ph id="ph3">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> を持っている場合は <ph id="ph3">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph>。それ以外の場合は <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。</target>       </trans-unit>
        <trans-unit id="3787" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></source>
          <target state="translated">たとえば場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表します<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph> Visual Basic で)、このプロパティの値はによって決まります <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></target>       </trans-unit>
        <trans-unit id="3788" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3789" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>The object to compare with the current type.</source>
          <target state="translated">現在の型と比較するオブジェクト。</target>       </trans-unit>
        <trans-unit id="3790" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>Determines whether the specified object is an instance of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">指定したオブジェクトが現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のインスタンスかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="3791" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see langword="Type" /&gt;</ph> is in the inheritance hierarchy of the object represented by <ph id="ph3">&lt;paramref name="o" /&gt;</ph>, or if the current <ph id="ph4">&lt;see langword="Type" /&gt;</ph> is an interface that <ph id="ph5">&lt;paramref name="o" /&gt;</ph> implements.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が返されるのは、現在の <ph id="ph2">&lt;see langword="Type" /&gt;</ph> が <ph id="ph3">&lt;paramref name="o" /&gt;</ph> によって表されるオブジェクトの継承可能な階層内にある場合、または現在の <ph id="ph4">&lt;see langword="Type" /&gt;</ph> が <ph id="ph5">&lt;paramref name="o" /&gt;</ph> によって実装されているインターフェイスである場合です。</target>       </trans-unit>
        <trans-unit id="3792" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if neither of these conditions is the case, if <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, or if the current <ph id="ph4">&lt;see langword="Type" /&gt;</ph> is an open generic type (that is, <ph id="ph5">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph6">&lt;see langword="true" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> が返されるのは、これらの条件のいずれも満たされない場合、または <ph id="ph2">&lt;paramref name="o" /&gt;</ph> が <ph id="ph3">&lt;see langword="null" /&gt;</ph> であるか、現在の <ph id="ph4">&lt;see langword="Type" /&gt;</ph> がオープン ジェネリック型である (つまり、<ph id="ph5">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> が <ph id="ph6">&lt;see langword="true" /&gt;</ph> を返す) 場合です。</target>       </trans-unit>
        <trans-unit id="3793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">このメソッドは、派生クラスでオーバーライドできます。</target>       </trans-unit>
        <trans-unit id="3794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>A constructed type is not an instance of its generic type definition.</source>
          <target state="translated">構築された型は、そのジェネリック型定義のインスタンスではありません。</target>       </trans-unit>
        <trans-unit id="3795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>That is, <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> in Visual Basic) is not an instance of <ph id="ph3">`MyGenericList&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericList(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">つまり、 <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> Visual Basic で) のインスタンスではない<ph id="ph3">`MyGenericList&lt;T&gt;`</ph>(<ph id="ph4">`MyGenericList(Of T)`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="3796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>The following example demonstrates the use of the <ph id="ph1">`IsInstanceOfType`</ph> method.</source>
          <target state="translated"><ph id="ph1">`IsInstanceOfType`</ph> メソッドの使用例を次に示します。</target>       </trans-unit>
        <trans-unit id="3797" translate="yes" xml:space="preserve" uid="P:System.Type.IsInterface">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is an interface; that is, not a class or a value type.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> がインターフェイスである (つまり値型やクラスではない) ことを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3798" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an interface; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> がインターフェイスである場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3799" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask&gt;</ph> distinguishes a type declaration as class, interface or value type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask&gt;</ph>クラス、インターフェイスまたは値の型として型の宣言を区別します。</target>       </trans-unit>
        <trans-unit id="3800" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3801" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>This property is read-only.</source>
          <target state="translated">このプロパティは読み取り専用です。</target>       </trans-unit>
        <trans-unit id="3802" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>The following example creates an interface, checks for the interface type, and indicates whether a class has the <ph id="ph1">`IsInterface`</ph> property set.</source>
          <target state="translated">次の例は、インターフェイスを作成、インターフェイス型をチェックし、クラスがあるかどうかを示す、<ph id="ph1">`IsInterface`</ph>プロパティ セットです。</target>       </trans-unit>
        <trans-unit id="3803" translate="yes" xml:space="preserve" uid="P:System.Type.IsLayoutSequential">
          <source>Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</source>
          <target state="translated">現在の型のフィールドが、定義済みまたはメタデータに対して出力された順序で、連続して配置されているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3804" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property of the current type includes <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の型の <ph id="ph1">&lt;see langword="true" /&gt;</ph> プロパティに <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> が含まれる場合は <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /&gt;</ph>。それ以外の場合は <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3805" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>This property is provided as a convenience.</source>
          <target state="translated">このプロパティは、便宜上指定します。</target>       </trans-unit>
        <trans-unit id="3806" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> is set.</source>
          <target state="translated">また、使用することができます、<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph>型レイアウト属性とし、テストをするかどうかを選択する列挙値<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph>設定されています。</target>       </trans-unit>
        <trans-unit id="3807" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>、 <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>、および<ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph>列挙値が、型のフィールドがメモリにレイアウトする方法を示します。</target>       </trans-unit>
        <trans-unit id="3808" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> when you create the type.</source>
          <target state="translated">動的な型を指定できます<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph>型を作成する場合。</target>       </trans-unit>
        <trans-unit id="3809" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> enumeration value to the type, to specify that layout is sequential.</source>
          <target state="translated">コードでは、適用、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>属性が、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>型にそのレイアウトもシーケンシャルに実行を指定する列挙値。</target>       </trans-unit>
        <trans-unit id="3810" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
          <target state="translated">使用することはできません、<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph>メソッドを呼び出せば確認するかどうか、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>型に適用されています。</target>       </trans-unit>
        <trans-unit id="3811" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">詳細については、仕様」のセクション 9.1.2、共通言語基盤 (CLI) ドキュメントについては、「Partition II:: Metadata Definition and Semantics」を参照してください。</target>       </trans-unit>
        <trans-unit id="3812" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">ドキュメントはオンラインで入手できます。MSDN の「<bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「<bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="3813" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。</target>       </trans-unit>
        <trans-unit id="3814" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">たとえば場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表します<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph> Visual Basic で)、このプロパティの値はによって決まります<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="3815" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3816" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>The following example creates an instance of a class for which the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> enumeration value in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> class has been set, checks for the <ph id="ph3">&lt;xref:System.Type.IsLayoutSequential%2A&gt;</ph> property, and displays the result.</source>
          <target state="translated">次の例では、クラスのインスタンスを作成する、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>の列挙値に、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>クラスが設定されている、確認、<ph id="ph3">&lt;xref:System.Type.IsLayoutSequential%2A&gt;</ph>プロパティ、し、結果を表示します。</target>       </trans-unit>
        <trans-unit id="3817" translate="yes" xml:space="preserve" uid="P:System.Type.IsMarshalByRef">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が参照渡しでマーシャリングされるかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3818" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsMarshalByRef">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が参照渡しでマーシャリングされる場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3819" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsMarshalByRef">
          <source>The following example demonstrates the <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> properties of the <ph id="ph4">&lt;xref:System.Type&gt;</ph> class.</source>
          <target state="translated">次の例で、 <ph id="ph1">`IsContextful`</ph>、 <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>、および<ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph>のプロパティ、<ph id="ph4">&lt;xref:System.Type&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="3820" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsMarshalByRef">
          <source>It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</source>
          <target state="translated">これは、型がプリミティブ データ型であるかどうかと、参照によってマーシャ リングできるかどうか、コンテキストでは、指定された型をホストすることができるかどうかを確認します。</target>       </trans-unit>
        <trans-unit id="3821" translate="yes" xml:space="preserve" uid="M:System.Type.IsMarshalByRefImpl">
          <source>Implements the <ph id="ph1">&lt;see cref="P:System.Type.IsMarshalByRef" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.IsMarshalByRef" /&gt;</ph> プロパティを実装し、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> が参照渡しでマーシャリングされるかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="3822" translate="yes" xml:space="preserve" uid="M:System.Type.IsMarshalByRefImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が参照渡しでマーシャリングされる場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsMarshalByRefImpl">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">このメソッドは、派生クラスでオーバーライドできます。</target>       </trans-unit>
        <trans-unit id="3824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsMarshalByRefImpl">
          <source>The following example determines whether the given type is marshaled by reference and displays the result.</source>
          <target state="translated">次の例では、指定された型が参照によってマーシャ リングし、結果を表示するかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="3825" translate="yes" xml:space="preserve" uid="P:System.Type.IsNested">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type whose definition is nested inside the definition of another type.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトが、別の型の定義内に入れ子になっている定義で定義された型を表しているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested inside another type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が別の型に入れ子になっている場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsNested%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for all nested types, regardless of visibility.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsNested%2A&gt;</ph>プロパティから返される<ph id="ph2">`true`</ph>すべての型の可視性に関係なく、入れ子にします。</target>       </trans-unit>
        <trans-unit id="3828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>To test for nesting and visibility at the same time, use the related properties <ph id="ph1">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsNestedFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.IsNestedFamANDAssem%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>, or <ph id="ph6">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>.</source>
          <target state="translated">をテストする入れ子構造と可視性と同時に、関連するプロパティを使用して<ph id="ph1">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Type.IsNestedFamily%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Type.IsNestedFamANDAssem%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph>、 <ph id="ph5">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>、または<ph id="ph6">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3829" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask&gt;</ph> enumeration member selects the visibility attributes for a type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask&gt;</ph>列挙体のメンバーが型の可視性属性を選択します。</target>       </trans-unit>
        <trans-unit id="3830" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">次の例では、可視性のさまざまな型を持つ入れ子になったクラスの数が、外側のクラスを作成します。</target>       </trans-unit>
        <trans-unit id="3831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">可視性に関連する数の値を取得し<ph id="ph1">&lt;xref:System.Type&gt;</ph>親の型およびその入れ子にされた型の各プロパティ。</target>       </trans-unit>
        <trans-unit id="3832" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedAssembly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own assembly.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が入れ子になっていて、それ自体が属するアセンブリ内でだけ参照可能かどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3833" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own assembly; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が入れ子になっていて、それ自体が属するアセンブリ内でだけ参照可能な場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3835" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> 可視属性を選択します。</target>       </trans-unit>
        <trans-unit id="3836" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">次の例では、可視性のさまざまな型を持つ入れ子になったクラスの数が、外側のクラスを作成します。</target>       </trans-unit>
        <trans-unit id="3837" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">可視性に関連する数の値を取得し<ph id="ph1">&lt;xref:System.Type&gt;</ph>親の型およびその入れ子にされた型の各プロパティ。</target>       </trans-unit>
        <trans-unit id="3838" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedFamANDAssem">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to both its own family and its own assembly.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が入れ子になっていて、それ自体が属するファミリとアセンブリの両方に属しているクラスだけから参照可能かどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3839" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> が入れ子になっていて、それ自体が属するファミリとアセンブリの両方に属しているクラスだけから参照可能な場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3840" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3841" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> 可視属性を選択します。</target>       </trans-unit>
        <trans-unit id="3842" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</source>
          <target state="translated">C# および Visual Basic 言語では、独自のアセンブリで保護された型だけに表示されている入れ子にされた型を定義するためのセマンティクスは含まれません。</target>       </trans-unit>
        <trans-unit id="3843" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source><ph id="ph1">`protected internal`</ph> visibility in C# and <ph id="ph2">`Protected Friend`</ph> visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</source>
          <target state="translated"><ph id="ph1">`protected internal`</ph> c# での可視性と<ph id="ph2">`Protected Friend`</ph>Visual Basic での可視性が保護されている型と同じアセンブリ内の型の両方に表示されている入れ子にされた型を定義します。</target>       </trans-unit>
        <trans-unit id="3844" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクトのファミリが同じすべてのオブジェクトとして定義されている<ph id="ph2">&lt;xref:System.Type&gt;</ph>とそのサブタイプ。</target>       </trans-unit>
        <trans-unit id="3845" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">次の例では、可視性のさまざまな型を持つ入れ子になったクラスの数が、外側のクラスを作成します。</target>       </trans-unit>
        <trans-unit id="3846" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">可視性に関連する数の値を取得し<ph id="ph1">&lt;xref:System.Type&gt;</ph>親の型およびその入れ子にされた型の各プロパティ。</target>       </trans-unit>
        <trans-unit id="3847" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedFamily">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own family.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が入れ子になっていて、それ自体が属するファミリ内でだけ参照可能かどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3848" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own family; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が入れ子になっていて、それ自体が属するファミリ内でだけ参照可能な場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3849" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3850" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> 可視属性を選択します。</target>       </trans-unit>
        <trans-unit id="3851" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the exact same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクトのファミリがの正確なすべてのオブジェクトとして定義されている同じ<ph id="ph2">&lt;xref:System.Type&gt;</ph>とそのサブタイプ。</target>       </trans-unit>
        <trans-unit id="3852" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">次の例では、可視性のさまざまな型を持つ入れ子になったクラスの数が、外側のクラスを作成します。</target>       </trans-unit>
        <trans-unit id="3853" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">可視性に関連する数の値を取得し<ph id="ph1">&lt;xref:System.Type&gt;</ph>親の型およびその入れ子にされた型の各プロパティ。</target>       </trans-unit>
        <trans-unit id="3854" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedFamORAssem">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to either its own family or to its own assembly.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が入れ子になっていて、それ自体が属するファミリまたはアセンブリのいずれかに属しているクラスだけから参照可能かどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3855" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が入れ子になっていて、それ自体が属するファミリまたはアセンブリのいずれかに属しているクラスだけから参照可能な場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3856" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>If the visibility of a type is <ph id="ph1">`protected internal`</ph> in C# or <ph id="ph2">`Protected Friend`</ph> in Visual Basic, the <ph id="ph3">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">型の可視性が場合<ph id="ph1">`protected internal`</ph>(C#) または<ph id="ph2">`Protected Friend`</ph>Visual basic で、<ph id="ph3">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph>プロパティから返される<ph id="ph4">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="3857" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3858" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> 可視属性を選択します。</target>       </trans-unit>
        <trans-unit id="3859" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the exact same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクトのファミリがの正確なすべてのオブジェクトとして定義されている同じ<ph id="ph2">&lt;xref:System.Type&gt;</ph>とそのサブタイプ。</target>       </trans-unit>
        <trans-unit id="3860" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">次の例では、可視性のさまざまな型を持つ入れ子になったクラスの数が、外側のクラスを作成します。</target>       </trans-unit>
        <trans-unit id="3861" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">可視性に関連する数の値を取得し<ph id="ph1">&lt;xref:System.Type&gt;</ph>親の型およびその入れ子にされた型の各プロパティ。</target>       </trans-unit>
        <trans-unit id="3862" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedPrivate">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and declared private.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が入れ子になっていて、プライベートとして宣言されているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3863" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and declared private; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が入れ子になっていて、プライベートとして宣言されている場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3864" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3865" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> 可視属性を選択します。</target>       </trans-unit>
        <trans-unit id="3866" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">次の例では、可視性のさまざまな型を持つ入れ子になったクラスの数が、外側のクラスを作成します。</target>       </trans-unit>
        <trans-unit id="3867" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">可視性に関連する数の値を取得し<ph id="ph1">&lt;xref:System.Type&gt;</ph>親の型およびその入れ子にされた型の各プロパティ。</target>       </trans-unit>
        <trans-unit id="3868" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedPublic">
          <source>Gets a value indicating whether a class is nested and declared public.</source>
          <target state="translated">クラスが入れ子になっていて、パブリックとして宣言されているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3869" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the class is nested and declared public; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">クラスが入れ子になっていて、パブリックとして宣言されている場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3870" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3871" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> 可視属性を選択します。</target>       </trans-unit>
        <trans-unit id="3872" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">次の例では、可視性のさまざまな型を持つ入れ子になったクラスの数が、外側のクラスを作成します。</target>       </trans-unit>
        <trans-unit id="3873" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">可視性に関連する数の値を取得し<ph id="ph1">&lt;xref:System.Type&gt;</ph>親の型およびその入れ子にされた型の各プロパティ。</target>       </trans-unit>
        <trans-unit id="3874" translate="yes" xml:space="preserve" uid="P:System.Type.IsNotPublic">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is not declared public.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> がパブリックとして宣言されていないかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3875" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is not declared public and is not a nested type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> がパブリックとして宣言されていなくて、入れ子にされた型でない場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3876" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>Do not use this property with nested types; use the <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> property instead.</source>
          <target state="translated">入れ子にされた型です。 このプロパティを使用しないでください。使用して、<ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>プロパティ代わりにします。</target>       </trans-unit>
        <trans-unit id="3877" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このプロパティを返しますがジェネリック型の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3878" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>This example usesthe <ph id="ph1">`IsNotPublic`</ph> property to get the visibility of the type.</source>
          <target state="translated">この例のポイント<ph id="ph1">`IsNotPublic`</ph>型の可視性を取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="3879" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>The following code example demonstrates why you cannot use <ph id="ph1">`IsPublic`</ph> and <ph id="ph2">`IsNotPublic`</ph> for nested classes.</source>
          <target state="translated">次のコード例では、使用できない理由を示します<ph id="ph1">`IsPublic`</ph>と<ph id="ph2">`IsNotPublic`</ph>の入れ子になったクラスです。</target>       </trans-unit>
        <trans-unit id="3880" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>For nested classes, ignore the results of <ph id="ph1">`IsPublic`</ph> and <ph id="ph2">`IsNotPublic`</ph> and pay attention only to the results of <ph id="ph3">`IsNestedPublic`</ph> and <ph id="ph4">`IsNestedPrivate`</ph>.</source>
          <target state="translated">入れ子になったクラスは、結果を無視する<ph id="ph1">`IsPublic`</ph>と<ph id="ph2">`IsNotPublic`</ph>のみの結果に注意を払って<ph id="ph3">`IsNestedPublic`</ph>と<ph id="ph4">`IsNestedPrivate`</ph>です。</target>       </trans-unit>
        <trans-unit id="3881" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>The reflection output for this code fragment would be as follows:</source>
          <target state="translated">次のコードのリフレクション出力に次のようになります。</target>       </trans-unit>
        <trans-unit id="3882" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>Class</source>
          <target state="translated">クラス</target>       </trans-unit>
        <trans-unit id="3883" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsNotPublic</source>
          <target state="translated">IsNotPublic</target>       </trans-unit>
        <trans-unit id="3884" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsPublic</source>
          <target state="translated">IsPublic</target>       </trans-unit>
        <trans-unit id="3885" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsNestedPublic</source>
          <target state="translated">IsNestedPublic</target>       </trans-unit>
        <trans-unit id="3886" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsNestedPrivate</source>
          <target state="translated">IsNestedPrivate</target>       </trans-unit>
        <trans-unit id="3887" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>A</source>
          <target state="translated">A</target>       </trans-unit>
        <trans-unit id="3888" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3889" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>TRUE</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="3890" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3891" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3892" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>B</source>
          <target state="translated">B</target>       </trans-unit>
        <trans-unit id="3893" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3894" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3895" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>TRUE</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="3896" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3897" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="3898" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3899" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3900" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3901" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>TRUE</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="3902" translate="yes" xml:space="preserve" uid="P:System.Type.IsPointer">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> がポインターかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3903" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> がポインターである場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3904" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますがジェネリック型またはジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3905" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source>This property is read-only.</source>
          <target state="translated">このプロパティは読み取り専用です。</target>       </trans-unit>
        <trans-unit id="3906" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source>The following example shows a use of the <ph id="ph1">`IsPointer`</ph> property.</source>
          <target state="translated">次の例を使用して、<ph id="ph1">`IsPointer`</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3907" translate="yes" xml:space="preserve" uid="M:System.Type.IsPointerImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer.</source>
          <target state="translated">派生クラスによってオーバーライドされるときに、<ph id="ph1">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> プロパティを実装し、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> がポインターかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="3908" translate="yes" xml:space="preserve" uid="M:System.Type.IsPointerImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> がポインターである場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3909" translate="yes" xml:space="preserve" uid="P:System.Type.IsPrimitive">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> がプリミティブ型の 1 つかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3910" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> がプリミティブ型の 1 つである場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3911" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>The primitive types are <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph11">&lt;xref:System.UIntPtr&gt;</ph>, <ph id="ph12">&lt;xref:System.Char&gt;</ph>, <ph id="ph13">&lt;xref:System.Double&gt;</ph>, and <ph id="ph14">&lt;xref:System.Single&gt;</ph>.</source>
          <target state="translated">プリミティブ型は<ph id="ph1">&lt;xref:System.Boolean&gt;</ph>、 <ph id="ph2">&lt;xref:System.Byte&gt;</ph>、 <ph id="ph3">&lt;xref:System.SByte&gt;</ph>、 <ph id="ph4">&lt;xref:System.Int16&gt;</ph>、 <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>、 <ph id="ph6">&lt;xref:System.Int32&gt;</ph>、 <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>、 <ph id="ph8">&lt;xref:System.Int64&gt;</ph>、 <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>、 <ph id="ph10">&lt;xref:System.IntPtr&gt;</ph>、 <ph id="ph11">&lt;xref:System.UIntPtr&gt;</ph>、 <ph id="ph12">&lt;xref:System.Char&gt;</ph>、<ph id="ph13">&lt;xref:System.Double&gt;</ph>、および<ph id="ph14">&lt;xref:System.Single&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3912" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますがジェネリック型またはジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3913" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>The following example demonstrates the <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> properties of the <ph id="ph4">&lt;xref:System.Type&gt;</ph> class.</source>
          <target state="translated">次の例で、 <ph id="ph1">`IsContextful`</ph>、 <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>、および<ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph>のプロパティ、<ph id="ph4">&lt;xref:System.Type&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="3914" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</source>
          <target state="translated">これは、型がプリミティブ データ型であるかどうかと、参照によってマーシャ リングできるかどうか、コンテキストでは、指定された型をホストすることができるかどうかを確認します。</target>       </trans-unit>
        <trans-unit id="3915" translate="yes" xml:space="preserve" uid="M:System.Type.IsPrimitiveImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsPrimitive" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types.</source>
          <target state="translated">派生クラスによってオーバーライドされるときに、<ph id="ph1">&lt;see cref="P:System.Type.IsPrimitive" /&gt;</ph> プロパティを実装し、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> がプリミティブ型の 1 つかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="3916" translate="yes" xml:space="preserve" uid="M:System.Type.IsPrimitiveImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> がプリミティブ型の 1 つである場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsPrimitiveImpl">
          <source>The primitive types are <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.Char&gt;</ph>, <ph id="ph11">&lt;xref:System.Double&gt;</ph>, and <ph id="ph12">&lt;xref:System.Single&gt;</ph>.</source>
          <target state="translated">プリミティブ型は<ph id="ph1">&lt;xref:System.Boolean&gt;</ph>、 <ph id="ph2">&lt;xref:System.Byte&gt;</ph>、 <ph id="ph3">&lt;xref:System.SByte&gt;</ph>、 <ph id="ph4">&lt;xref:System.Int16&gt;</ph>、 <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>、 <ph id="ph6">&lt;xref:System.Int32&gt;</ph>、 <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>、 <ph id="ph8">&lt;xref:System.Int64&gt;</ph>、 <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>、 <ph id="ph10">&lt;xref:System.Char&gt;</ph>、 <ph id="ph11">&lt;xref:System.Double&gt;</ph>、および<ph id="ph12">&lt;xref:System.Single&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsPrimitiveImpl">
          <source>The following example determines whether the given type is a primitive type and displays the result.</source>
          <target state="translated">次の例では、指定された型はプリミティブ型であり結果を表示するかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="3919" translate="yes" xml:space="preserve" uid="P:System.Type.IsPublic">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is declared public.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> がパブリックとして宣言されているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3920" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is declared public and is not a nested type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> がパブリックとして宣言されていて、入れ子にされた型でない場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3921" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>Do not use with nested types; use <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> instead.</source>
          <target state="translated">入れ子にされた型は使用しないでください。使用して<ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>代わりにします。</target>       </trans-unit>
        <trans-unit id="3922" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このプロパティを返しますがジェネリック型の型パラメーターを表す<ph id="ph2">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="3923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> 可視属性を選択します。</target>       </trans-unit>
        <trans-unit id="3924" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>The following example creates an instance of <ph id="ph1">`MyTestClass`</ph>, checks for the <ph id="ph2">`IsPublic`</ph> property, and displays the result.</source>
          <target state="translated">次の例のインスタンスを作成する<ph id="ph1">`MyTestClass`</ph>、確認、<ph id="ph2">`IsPublic`</ph>プロパティ、し、結果を表示します。</target>       </trans-unit>
        <trans-unit id="3925" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>For nested classes, ignore the results of <ph id="ph1">`IsPublic`</ph> and <ph id="ph2">`IsNotPublic`</ph> and pay attention only to the results of <ph id="ph3">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>.</source>
          <target state="translated">入れ子になったクラスは、結果を無視する<ph id="ph1">`IsPublic`</ph>と<ph id="ph2">`IsNotPublic`</ph>のみの結果に注意を払って<ph id="ph3">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>と<ph id="ph4">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3926" translate="yes" xml:space="preserve" uid="P:System.Type.IsSealed">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is declared sealed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が sealed として宣言されているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3927" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSealed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is declared sealed; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が sealed として宣言されている場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3928" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSealed">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますがジェネリック型の型パラメーターを表す<ph id="ph2">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="3929" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSealed">
          <source>The following example creates an instance of a <ph id="ph1">`sealed`</ph> class, checks for the <ph id="ph2">`IsSealed`</ph> property, and displays the result.</source>
          <target state="translated">次の例のインスタンスを作成する、<ph id="ph1">`sealed`</ph>クラスのチェック、<ph id="ph2">`IsSealed`</ph>プロパティ、し、結果を表示します。</target>       </trans-unit>
        <trans-unit id="3930" translate="yes" xml:space="preserve" uid="P:System.Type.IsSecurityCritical">
          <source>Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</source>
          <target state="translated">現在の型が現在の信頼レベルでセキュリティ クリティカルまたはセキュリティ セーフ クリティカルであり、重要な操作を実行できるかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3931" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-critical or security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated">現在の型が現在の信頼レベルでセキュリティ クリティカルまたはセキュリティ セーフ クリティカルである場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。現在の型が透過的な場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3932" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>、および<ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph>プロパティが共通言語ランタイム (CLR) によって決定される、現在の信頼レベルの種類の透明度を報告します。</target>       </trans-unit>
        <trans-unit id="3933" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">これらのプロパティの組み合わせは、次の表に示します。</target>       </trans-unit>
        <trans-unit id="3934" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">セキュリティ レベル</target>       </trans-unit>
        <trans-unit id="3935" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="3936" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="3937" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="3938" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">重大</target>       </trans-unit>
        <trans-unit id="3939" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Safe critical</source>
          <target state="translated">セーフ クリティカル</target>       </trans-unit>
        <trans-unit id="3940" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">透明</target>       </trans-unit>
        <trans-unit id="3941" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。</target>       </trans-unit>
        <trans-unit id="3942" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">部分的に信頼されたアセンブリでは、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。</target>       </trans-unit>
        <trans-unit id="3943" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">アセンブリがドメインに読み込まれて、部分的に信頼されたアプリケーション (たとえば、サンド ボックス アプリケーション ドメイン) の場合、ランタイムはアセンブリのセキュリティの注釈を無視します。</target>       </trans-unit>
        <trans-unit id="3944" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">アセンブリとそのすべての型は透明として扱われます。</target>       </trans-unit>
        <trans-unit id="3945" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">ランタイムは、そのアセンブリが、完全に信頼されたアプリケーション ドメイン (たとえば、デスクトップ アプリケーションの既定のアプリケーション ドメイン) に読み込まれている場合にのみ、部分信頼アセンブリのセキュリティの注釈に注意を支払います。</target>       </trans-unit>
        <trans-unit id="3946" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">これに対し、信頼されたアセンブリ (つまり、厳密な名前付きアセンブリをグローバル アセンブリ キャッシュにインストールされている) は常にアプリケーション ドメインの信頼レベルに関係なく、完全信頼で読み込まれたため、現在の信頼レベルは完全に信頼された常にします。</target>       </trans-unit>
        <trans-unit id="3947" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">使用して、アセンブリとアプリケーション ドメインの現在の信頼レベルを指定できます、<ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>と<ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3948" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">リフレクションと透過性の詳細については、次を参照してください。<bpt id="p1">[</bpt>リフレクションに関するセキュリティの考慮事項<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="3949" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">透過性の詳細については、次を参照してください。<bpt id="p1">[</bpt>セキュリティの変更点<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="3950" translate="yes" xml:space="preserve" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">現在の型が現在の信頼レベルでセキュリティ セーフ クリティカルであり、重要な操作を実行でき、透過的なコードからアクセスできるかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3951" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated">現在の型が現在の信頼レベルでセキュリティ セーフ クリティカルである場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。現在の型がセキュリティ クリティカルまたは透過的な場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3952" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>、および<ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph>プロパティが共通言語ランタイム (CLR) によって決定される、現在の信頼レベルの種類の透明度を報告します。</target>       </trans-unit>
        <trans-unit id="3953" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">これらのプロパティの組み合わせは、次の表に示します。</target>       </trans-unit>
        <trans-unit id="3954" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">セキュリティ レベル</target>       </trans-unit>
        <trans-unit id="3955" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="3956" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="3957" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="3958" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">重大</target>       </trans-unit>
        <trans-unit id="3959" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Safe critical</source>
          <target state="translated">セーフ クリティカル</target>       </trans-unit>
        <trans-unit id="3960" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">透明</target>       </trans-unit>
        <trans-unit id="3961" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。</target>       </trans-unit>
        <trans-unit id="3962" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">部分的に信頼されたアセンブリでは、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。</target>       </trans-unit>
        <trans-unit id="3963" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">アセンブリがドメインに読み込まれて、部分的に信頼されたアプリケーション (たとえば、サンド ボックス アプリケーション ドメイン) の場合、ランタイムはアセンブリのセキュリティの注釈を無視します。</target>       </trans-unit>
        <trans-unit id="3964" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">アセンブリとそのすべての型は透明として扱われます。</target>       </trans-unit>
        <trans-unit id="3965" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">ランタイムは、そのアセンブリが、完全に信頼されたアプリケーション ドメイン (たとえば、デスクトップ アプリケーションの既定のアプリケーション ドメイン) に読み込まれている場合にのみ、部分信頼アセンブリのセキュリティの注釈に注意を支払います。</target>       </trans-unit>
        <trans-unit id="3966" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">これに対し、信頼されたアセンブリ (つまり、厳密な名前付きアセンブリをグローバル アセンブリ キャッシュにインストールされている) は常にアプリケーション ドメインの信頼レベルに関係なく、完全信頼で読み込まれたため、現在の信頼レベルは完全に信頼された常にします。</target>       </trans-unit>
        <trans-unit id="3967" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">使用して、アセンブリとアプリケーション ドメインの現在の信頼レベルを指定できます、<ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>と<ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3968" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">リフレクションと透過性の詳細については、次を参照してください。<bpt id="p1">[</bpt>リフレクションに関するセキュリティの考慮事項<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="3969" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">透過性の詳細については、次を参照してください。<bpt id="p1">[</bpt>セキュリティの変更点<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="3970" translate="yes" xml:space="preserve" uid="P:System.Type.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</source>
          <target state="translated">現在の型が現在の信頼レベルで透過的であり、重要な操作を実行できないかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3971" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type is security-transparent at the current trust level; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の型が現在の信頼レベルで透過的セキュリティである場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3972" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>If this property returns <ph id="ph1">`true`</ph>, the <ph id="ph2">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph> properties return <ph id="ph4">`false`</ph>.</source>
          <target state="translated">このプロパティを返す場合<ph id="ph1">`true`</ph>、<ph id="ph2">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>と<ph id="ph3">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>プロパティの戻り値<ph id="ph4">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3973" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>、および<ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph>プロパティが共通言語ランタイム (CLR) によって決定される、現在の信頼レベルの種類の透明度を報告します。</target>       </trans-unit>
        <trans-unit id="3974" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。</target>       </trans-unit>
        <trans-unit id="3975" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">部分的に信頼されたアセンブリでは、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。</target>       </trans-unit>
        <trans-unit id="3976" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">アセンブリがドメインに読み込まれて、部分的に信頼されたアプリケーション (たとえば、サンド ボックス アプリケーション ドメイン) の場合、ランタイムはアセンブリのセキュリティの注釈を無視します。</target>       </trans-unit>
        <trans-unit id="3977" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">アセンブリとそのすべての型は透明として扱われます。</target>       </trans-unit>
        <trans-unit id="3978" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">ランタイムは、そのアセンブリが、完全に信頼されたアプリケーション ドメイン (たとえば、デスクトップ アプリケーションの既定のアプリケーション ドメイン) に読み込まれている場合にのみ、部分信頼アセンブリのセキュリティの注釈に注意を支払います。</target>       </trans-unit>
        <trans-unit id="3979" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">これに対し、信頼されたアセンブリ (つまり、厳密な名前付きアセンブリをグローバル アセンブリ キャッシュにインストールされている) は常にアプリケーション ドメインの信頼レベルに関係なく、完全信頼で読み込まれたため、現在の信頼レベルは完全に信頼された常にします。</target>       </trans-unit>
        <trans-unit id="3980" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">使用して、アセンブリとアプリケーション ドメインの現在の信頼レベルを指定できます、<ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>と<ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3981" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">リフレクションと透過性の詳細については、次を参照してください。<bpt id="p1">[</bpt>リフレクションに関するセキュリティの考慮事項<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="3982" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">透過性の詳細については、次を参照してください。<bpt id="p1">[</bpt>セキュリティの変更点<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="3983" translate="yes" xml:space="preserve" uid="P:System.Type.IsSerializable">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is serializable.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> をシリアル化できるかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3984" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is serializable; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> をシリアル化できる場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3985" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>Types that are defined in the .NET Standard are not marked with <ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph>.</source>
          <target state="translated">.NET 標準で定義されている型がでマークされていない<ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3986" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>Instead, each .NET implementation determines whether a type is serializable.</source>
          <target state="translated">代わりに、各 .NET 実装では、型がシリアル化できるかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="3987" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>At run time, you can use the <ph id="ph1">&lt;xref:System.Type.IsSerializable%2A&gt;</ph> property to determine whether that implementation supports serialization of an instance of the type.</source>
          <target state="translated">使用することができます、実行時に、<ph id="ph1">&lt;xref:System.Type.IsSerializable%2A&gt;</ph>プロパティを実装するが、型のインスタンスのシリアル化をサポートするかどうかを確認します。</target>       </trans-unit>
        <trans-unit id="3988" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>For more information and an example, see <bpt id="p1">[</bpt>How to determine if a .NET Standard object is serializable<ept id="p1">](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)</ept>.</source>
          <target state="translated">例および詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET 標準オブジェクトがシリアル化可能な場合を判断する方法<ept id="p1">](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="3989" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。</target>       </trans-unit>
        <trans-unit id="3990" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">たとえば場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表します<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph> Visual Basic で)、このプロパティの値はによって決まります<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="3991" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3992" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>The following example creates an instance of <ph id="ph1">`MyTestClass`</ph> class, sets the [Serializable] attribute, and checks the <ph id="ph2">`IsSerializable`</ph> property for <ph id="ph3">`true`</ph> or <ph id="ph4">`false`</ph>.</source>
          <target state="translated">次の例のインスタンスを作成する<ph id="ph1">`MyTestClass`</ph>クラスは、[Serializable] 属性を設定し、チェック、<ph id="ph2">`IsSerializable`</ph>プロパティ<ph id="ph3">`true`</ph>または<ph id="ph4">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3993" translate="yes" xml:space="preserve" uid="P:System.Type.IsSpecialName">
          <source>Gets a value indicating whether the type has a name that requires special handling.</source>
          <target state="translated">型が特別な処理を必要とする名前を持っているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3994" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type has a name that requires special handling; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">型の名前が特別な処理を必要とする場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3995" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</source>
          <target state="translated">始まるか、アンダー スコア文字 (_)、プロパティ アクセサー、および演算子のオーバー ロードが含まれている名前は、一部のコンパイラで特別な処理が必要となる型の例を示します。</target>       </trans-unit>
        <trans-unit id="3996" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。</target>       </trans-unit>
        <trans-unit id="3997" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">たとえば場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表します<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph> Visual Basic で)、このプロパティの値はによって決まります<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="3998" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="3999" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>The type to compare with the current type.</source>
          <target state="translated">現在の型と比較する型。</target>       </trans-unit>
        <trans-unit id="4000" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Determines whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> derives from the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が、指定した <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> から派生しているかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="4001" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see langword="Type" /&gt;</ph> derives from <ph id="ph3">&lt;paramref name="c" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph2">&lt;see langword="Type" /&gt;</ph> が <ph id="ph3">&lt;paramref name="c" /&gt;</ph> から派生している場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4002" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>This method also returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if <ph id="ph2">&lt;paramref name="c" /&gt;</ph> and the current <ph id="ph3">&lt;see langword="Type" /&gt;</ph> are equal.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> と現在の <ph id="ph2">&lt;paramref name="c" /&gt;</ph> とが等価の場合も、このメソッドは <ph id="ph3">&lt;see langword="Type" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="4003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method to determine any of the following:</source>
          <target state="translated">呼び出すことができます、<ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph>メソッドを次のいずれかを判断します。</target>       </trans-unit>
        <trans-unit id="4004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether one class derives from another.</source>
          <target state="translated">かどうか別の 1 つのクラスが派生します。</target>       </trans-unit>
        <trans-unit id="4005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether a type derives from <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</source>
          <target state="translated">型がから派生するかどうか<ph id="ph1">&lt;xref:System.ValueType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="4006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>However, the <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph> is a more efficient way to determine whether a type is a value type.</source>
          <target state="translated">ただし、<ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph>は、型が値型であるかどうかを決定するより効率的な方法です。</target>       </trans-unit>
        <trans-unit id="4007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether a type derives from <ph id="ph1">&lt;xref:System.Enum&gt;</ph>.</source>
          <target state="translated">型がから派生するかどうか<ph id="ph1">&lt;xref:System.Enum&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="4008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>However, the <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph> method is a more efficient way to determine whether a type is an enumeration.</source>
          <target state="translated">ただし、<ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph>メソッドは、型が列挙体であるかどうかを決定するより効率的な方法です。</target>       </trans-unit>
        <trans-unit id="4009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether a type is a delegate, that is, whether it derives from either <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> or <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph>.</source>
          <target state="translated">かどうか、型がデリゲート、つまり、いずれかから派生しているかどうか<ph id="ph1">&lt;xref:System.Delegate&gt;</ph>または<ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="4010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph>インターフェイスが、別のインターフェイスから派生しているかどうか、またはクラスがインターフェイスを実装するかどうかを判断するメソッドを使用できません。</target>       </trans-unit>
        <trans-unit id="4011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> method for that purpose, as the following example shows.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph>次の例のように、そのような目的のメソッドです。</target>       </trans-unit>
        <trans-unit id="4012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> if it has no class constraint.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>型パラメーターを表す、ジェネリック型またはジェネリック メソッドの定義内またはそのクラスの制約から派生して<ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>クラスの制約が存在しない場合。</target>       </trans-unit>
        <trans-unit id="4013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Except when used with interfaces, <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> is the converse of <ph id="ph2">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph>.</source>
          <target state="translated">以外の場合に、インターフェイスで使用される<ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph>反対の<ph id="ph2">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="4014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>That is, if <ph id="ph1">`t1.IsSubclassOf(t2)`</ph> is <ph id="ph2">`true`</ph>, then <ph id="ph3">`t2.IsAssignableFrom(t1)`</ph> is also <ph id="ph4">`true`</ph>.</source>
          <target state="translated">つまり場合、<ph id="ph1">`t1.IsSubclassOf(t2)`</ph>は<ph id="ph2">`true`</ph>、し<ph id="ph3">`t2.IsAssignableFrom(t1)`</ph>も<ph id="ph4">`true`</ph>します。</target>       </trans-unit>
        <trans-unit id="4015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">このメソッドは、派生クラスでオーバーライドできます。</target>       </trans-unit>
        <trans-unit id="4016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>The following example creates a class named <ph id="ph1">`Class1`</ph> and a derived class named <ph id="ph2">`DerivedC1`</ph>.</source>
          <target state="translated">次の例は、という名前のクラスを作成<ph id="ph1">`Class1`</ph>およびという名前の派生クラス<ph id="ph2">`DerivedC1`</ph>です。</target>       </trans-unit>
        <trans-unit id="4017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>It calls the <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method to show that <ph id="ph2">`DerivedC1`</ph> is a subclass of <ph id="ph3">`Class1`</ph>.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph>を表示するメソッド<ph id="ph2">`DerivedC1`</ph>のサブクラスは、<ph id="ph3">`Class1`</ph>です。</target>       </trans-unit>
        <trans-unit id="4018" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="4019" translate="yes" xml:space="preserve" uid="P:System.Type.IsUnicodeClass">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">&lt;see langword="UnicodeClass" /&gt;</ph> is selected for the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="UnicodeClass" /&gt;</ph> の文字列書式属性として <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> が選択されているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="4020" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the string format attribute <ph id="ph2">&lt;see langword="UnicodeClass" /&gt;</ph> is selected for the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>に、文字列書式属性として<ph id="ph2">&lt;see langword="UnicodeClass" /&gt;</ph> が選択されている場合は <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4021" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> is used to select the string format attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph>を使用して、文字列書式属性を選択します。</target>       </trans-unit>
        <trans-unit id="4022" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
          <target state="translated">文字列形式の属性では、文字列の解釈方法を定義することで相互運用性が向上します。</target>       </trans-unit>
        <trans-unit id="4023" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。</target>       </trans-unit>
        <trans-unit id="4024" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">たとえば場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表します<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph> Visual Basic で)、このプロパティの値はによって決まります<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="4025" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="4026" translate="yes" xml:space="preserve" uid="P:System.Type.IsValueType">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a value type.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が値型かどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="4027" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a value type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が値型である場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4028" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</source>
          <target state="translated">値の型は、ビットの数値のシーケンスとして表される型値の型は、クラスまたはインターフェイスではありません。</target>       </trans-unit>
        <trans-unit id="4029" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Value types are referred to as "structs" in some programming languages.</source>
          <target state="translated">値の型は、一部のプログラミング言語で「構造体」と呼びます。</target>       </trans-unit>
        <trans-unit id="4030" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Enums are a special case of value types.</source>
          <target state="translated">列挙型は、値型の特殊なケースです。</target>       </trans-unit>
        <trans-unit id="4031" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This property returns <ph id="ph1">`false`</ph> for the <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> class, because <ph id="ph3">&lt;xref:System.ValueType&gt;</ph> is not a value type itself.</source>
          <target state="translated">このプロパティを返します<ph id="ph1">`false`</ph>の<ph id="ph2">&lt;xref:System.ValueType&gt;</ph>クラス、ため<ph id="ph3">&lt;xref:System.ValueType&gt;</ph>自体の値型ではありません。</target>       </trans-unit>
        <trans-unit id="4032" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>It is the base class for all value types, and therefore any value type can be assigned to it.</source>
          <target state="translated">これは、すべての値の型の基本クラスとする任意の値型を割り当てることがそのためです。</target>       </trans-unit>
        <trans-unit id="4033" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This would not be possible if <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> itself was a value type.</source>
          <target state="translated">これができない場合<ph id="ph1">&lt;xref:System.ValueType&gt;</ph>自体は値型ででした。</target>       </trans-unit>
        <trans-unit id="4034" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Value types are boxed when they are assigned to a field of type <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</source>
          <target state="translated">型のフィールドに割り当てられているときに、値の型がボックス化<ph id="ph1">&lt;xref:System.ValueType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="4035" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This property returns <ph id="ph1">`true`</ph> for enumerations, but not for the <ph id="ph2">&lt;xref:System.Enum&gt;</ph> type itself.</source>
          <target state="translated">このプロパティを返します<ph id="ph1">`true`</ph>列挙体の場合のではなく、<ph id="ph2">&lt;xref:System.Enum&gt;</ph>自体を入力します。</target>       </trans-unit>
        <trans-unit id="4036" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>For an example that demonstrates this behavior, see <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph>.</source>
          <target state="translated">この動作を示す例を次を参照してください。<ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="4037" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This property is read-only.</source>
          <target state="translated">このプロパティは読み取り専用です。</target>       </trans-unit>
        <trans-unit id="4038" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>The following example creates a variable of type <ph id="ph1">`MyEnum`</ph>, checks for the <ph id="ph2">`IsValueType`</ph> property, and displays the result.</source>
          <target state="translated">次の例は、型の変数を作成<ph id="ph1">`MyEnum`</ph>、確認、<ph id="ph2">`IsValueType`</ph>プロパティ、し、結果を表示します。</target>       </trans-unit>
        <trans-unit id="4039" translate="yes" xml:space="preserve" uid="M:System.Type.IsValueTypeImpl">
          <source>Implements the <ph id="ph1">&lt;see cref="P:System.Type.IsValueType" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a value type; that is, not a class or an interface.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.IsValueType" /&gt;</ph> プロパティを実装するとともに、<ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> が値型である (つまり、クラスやインターフェイスでない) かどうかを判断します。</target>       </trans-unit>
        <trans-unit id="4040" translate="yes" xml:space="preserve" uid="M:System.Type.IsValueTypeImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a value type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が値型である場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsValueTypeImpl">
          <source>This method is provided to enable the implementation of alternate type systems.</source>
          <target state="translated">このメソッドは、代替の型システムの実装を有効にするものです。</target>       </trans-unit>
        <trans-unit id="4042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsValueTypeImpl">
          <source>It is not generally used in application code.</source>
          <target state="translated">これはアプリケーション コードでは、通常使用されません。</target>       </trans-unit>
        <trans-unit id="4043" translate="yes" xml:space="preserve" uid="P:System.Type.IsVisible">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> can be accessed by code outside the assembly.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> にアセンブリの外側のコードからアクセスできるかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="4044" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsVisible">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a public type or a public nested type such that all the enclosing types are public; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の<ph id="ph1">&lt;see langword="true" /&gt;</ph> がパブリック型である場合、またはすべての包含する型がパブリックであるような入れ子にされたパブリック型である場合は <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4045" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsVisible">
          <source>Use this property to determine whether a type is part of the public interface of a component assembly.</source>
          <target state="translated">このプロパティを使用して、型がコンポーネント アセンブリのパブリック インターフェイスの一部であるかどうかを判別します。</target>       </trans-unit>
        <trans-unit id="4046" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsVisible">
          <source>The following code example tests two classes, only one of which is visible outside the assembly.</source>
          <target state="translated">次のコード例では、一方のみが、アセンブリ外部から参照できる、2 つのクラスをテストします。</target>       </trans-unit>
        <trans-unit id="4047" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents an array of the current type.</source>
          <target state="translated">現在の型の配列を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="4048" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a one-dimensional array of the current type, with a lower bound of zero.</source>
          <target state="translated">下限を 0 に設定して現在の型の 1 次元配列を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="4049" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a one-dimensional array of the current type, with a lower bound of zero.</source>
          <target state="translated">下限を 0 に設定して現在の型の 1 次元配列を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="4050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method provides a way to generate array types whose element types are computed at run time.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>メソッドは実行時に計算は要素型を持つ配列型を生成する方法を提供します。</target>       </trans-unit>
        <trans-unit id="4051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</source>
          <target state="translated"><bpt id="p1">**</bpt>注<ept id="p1">**</ept>共通言語ランタイムではベクトル (つまり、1 次元配列は常に 0 から始まる) を区別や多次元配列です。</target>       </trans-unit>
        <trans-unit id="4052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</source>
          <target state="translated">ベクターは、常に 1 つだけディメンションを持つは、多次元配列を 1 つだけディメンションを持っているのと同じではないです。</target>       </trans-unit>
        <trans-unit id="4053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>This method overload can only be used to create vector types, and it is the only way to create a vector type.</source>
          <target state="translated">このメソッドのオーバー ロードは、ベクター型を作成する場合にのみ使用でき、ベクター型を作成する唯一の方法であります。</target>       </trans-unit>
        <trans-unit id="4054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.MakeArrayType%28System.Int32%29&gt;</ph> method overload to create multidimensional array types.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Type.MakeArrayType%28System.Int32%29&gt;</ph>多次元配列型を作成するメソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="4055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">次のコード例は、配列を作成<ph id="ph1">`ref`</ph>(<ph id="ph2">`ByRef`</ph> Visual Basic で)、およびポインター型の<ph id="ph3">`Test`</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="4056" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">呼び出されたメソッドは基底クラスでサポートされていません。</target>       </trans-unit>
        <trans-unit id="4057" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">派生クラスには実装を指定しなければなりません。</target>       </trans-unit>
        <trans-unit id="4058" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">現在の型が <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="4059" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="4060" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">現在の型が <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> 型です。</target>       </trans-unit>
        <trans-unit id="4061" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">つまり、<ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> は <ph id="ph2">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="4062" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The number of dimensions for the array.</source>
          <target state="translated">配列の次元数。</target>       </trans-unit>
        <trans-unit id="4063" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>This number must be less than or equal to 32.</source>
          <target state="translated">この数値は 32 以下である必要があります。</target>       </trans-unit>
        <trans-unit id="4064" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing an array of the current type, with the specified number of dimensions.</source>
          <target state="translated">次元数を指定して現在の型の配列を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="4065" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>An object representing an array of the current type, with the specified number of dimensions.</source>
          <target state="translated">次元数を指定して現在の型の配列を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="4066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method provides a way to generate array types whose element types are computed at run time.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>メソッドは実行時に計算は要素型を持つ配列型を生成する方法を提供します。</target>       </trans-unit>
        <trans-unit id="4067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</source>
          <target state="translated">共通言語ランタイムではベクトル (つまり、1 次元配列は常に 0 から始まる) を区別や多次元配列です。</target>       </trans-unit>
        <trans-unit id="4068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</source>
          <target state="translated">ベクターは、常に 1 つだけディメンションを持つは、多次元配列を 1 つだけディメンションを持っているのと同じではないです。</target>       </trans-unit>
        <trans-unit id="4069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>You cannot use this method overload to create a vector type; if <ph id="ph1">`rank`</ph> is 1, this method overload returns a multidimensional array type that happens to have one dimension.</source>
          <target state="translated">このメソッドのオーバー ロードを使用して、ベクター型を作成することはできません。場合<ph id="ph1">`rank`</ph>1 の場合は、このメソッドのオーバー ロードが 1 つのディメンションを持つ多次元配列の型を返します。</target>       </trans-unit>
        <trans-unit id="4070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.MakeArrayType&gt;</ph> method overload to create vector types.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Type.MakeArrayType&gt;</ph>ベクター型を作成するメソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="4071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">次のコード例は、配列を作成<ph id="ph1">`ref`</ph>(<ph id="ph2">`ByRef`</ph> Visual Basic で)、およびポインター型の<ph id="ph3">`Test`</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="4072" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> が無効です。</target>       </trans-unit>
        <trans-unit id="4073" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>For example, 0 or negative.</source>
          <target state="translated">たとえば、0 または負の値です。</target>       </trans-unit>
        <trans-unit id="4074" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">呼び出されたメソッドは基底クラスでサポートされていません。</target>       </trans-unit>
        <trans-unit id="4075" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">現在の型が <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="4076" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="4077" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">現在の型が <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> 型です。</target>       </trans-unit>
        <trans-unit id="4078" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">つまり、<ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> は <ph id="ph2">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="4079" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="4080" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> is greater than 32.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> が 32 を超えています。</target>       </trans-unit>
        <trans-unit id="4081" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> parameter in Visual Basic).</source>
          <target state="translated"><ph id="ph2">&lt;see langword="ref" /&gt;</ph> パラメーター (Visual Basic の場合は <ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> パラメーター) として渡されるときに現在の型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="4082" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> parameter in Visual Basic).</source>
          <target state="translated"><ph id="ph2">&lt;see langword="ref" /&gt;</ph> パラメーター (Visual Basic の場合は <ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> パラメーター) として渡されるときに現在の型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="4083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeByRefType">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> method provides a way to generate <ph id="ph2">`ref`</ph> types (<ph id="ph3">`ByRef`</ph> in Visual Basic) for parameter lists.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph>メソッドを生成する方法を提供する<ph id="ph2">`ref`</ph>型 (<ph id="ph3">`ByRef`</ph> Visual Basic で) パラメーター リストが表示されます。</target>       </trans-unit>
        <trans-unit id="4084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeByRefType">
          <source>Using the syntax of Microsoft intermediate language (MSIL), if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, this method returns a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object representing <ph id="ph4">`Int32&amp;`</ph>.</source>
          <target state="translated">場合は、Microsoft intermediate language (MSIL) の構文を使用して、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクトが表す<ph id="ph2">&lt;xref:System.Int32&gt;</ph>、このメソッドが戻る、<ph id="ph3">&lt;xref:System.Type&gt;</ph>オブジェクトを表す<ph id="ph4">`Int32&amp;`</ph>です。</target>       </trans-unit>
        <trans-unit id="4085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeByRefType">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">次のコード例は、配列を作成<ph id="ph1">`ref`</ph>(<ph id="ph2">`ByRef`</ph> Visual Basic で)、およびポインター型の<ph id="ph3">`Test`</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="4086" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">呼び出されたメソッドは基底クラスでサポートされていません。</target>       </trans-unit>
        <trans-unit id="4087" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">現在の型が <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="4088" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="4089" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">現在の型が <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> 型です。</target>       </trans-unit>
        <trans-unit id="4090" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">つまり、<ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> は <ph id="ph2">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="4091" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>An array of types to be substituted for the type parameters of the current generic type.</source>
          <target state="translated">現在のジェネリック型の型パラメーターに置き換えられる型の配列。</target>       </trans-unit>
        <trans-unit id="4092" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the resulting constructed type.</source>
          <target state="translated">型の配列の要素を現在のジェネリック型定義の型パラメーターで置き換え、結果の構築型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="4093" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the constructed type formed by substituting the elements of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> for the type parameters of the current generic type.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> の要素を現在のジェネリック型の型パラメーターで置き換えることによって作られる構築型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a particular constructed type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>メソッドでは、特定の種類を作成するため、ジェネリック型定義の型パラメーターに代入するコードを記述することができます、<ph id="ph2">&lt;xref:System.Type&gt;</ph>を特定の構築型を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="4095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You can use this <ph id="ph1">&lt;xref:System.Type&gt;</ph> object to create run-time instances of the constructed type.</source>
          <target state="translated">これを行うこともできます<ph id="ph1">&lt;xref:System.Type&gt;</ph>の構築型の実行時のインスタンスを作成するオブジェクト。</target>       </trans-unit>
        <trans-unit id="4096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Types constructed with <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</source>
          <target state="translated">構築された型<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>開くことができる、型引数のいくつかは、ジェネリック メソッドまたは型を外側の型パラメーターを指定できます。</target>       </trans-unit>
        <trans-unit id="4097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You might use such open constructed types when you emit dynamic assemblies.</source>
          <target state="translated">動的アセンブリを生成するときに、このようなオープン構築型を使用する場合があります。</target>       </trans-unit>
        <trans-unit id="4098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>For example, consider the classes <ph id="ph1">`Base`</ph> and <ph id="ph2">`Derived`</ph> in the following code.</source>
          <target state="translated">たとえば、クラス<ph id="ph1">`Base`</ph>と<ph id="ph2">`Derived`</ph>次のコードにします。</target>       </trans-unit>
        <trans-unit id="4099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To generate <ph id="ph1">`Derived`</ph> in a dynamic assembly, it is necessary to construct its base type.</source>
          <target state="translated">生成する<ph id="ph1">`Derived`</ph>動的アセンブリではその基本型を構築するために必要です。</target>       </trans-unit>
        <trans-unit id="4100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To do this, call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing the class <ph id="ph3">`Base`</ph>, using the generic type arguments <ph id="ph4">&lt;xref:System.Int32&gt;</ph> and the type parameter <ph id="ph5">`V`</ph> from <ph id="ph6">`Derived`</ph>.</source>
          <target state="translated">これを行うには、呼び出し、<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>メソッドを<ph id="ph2">&lt;xref:System.Type&gt;</ph>クラスを表すオブジェクトを<ph id="ph3">`Base`</ph>、ジェネリック型引数を使用して<ph id="ph4">&lt;xref:System.Int32&gt;</ph>、型パラメーター<ph id="ph5">`V`</ph>から<ph id="ph6">`Derived`</ph>です。</target>       </trans-unit>
        <trans-unit id="4101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Because types and generic type parameters are both represented by <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects, an array containing both can be passed to the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method.</source>
          <target state="translated">型およびジェネリック型パラメーターの両方がによって表されるため<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクトに両方を含む配列を渡すことが、<ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="4102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>A constructed type such as <ph id="ph1">`Base&lt;int, V&gt;`</ph> is useful when emitting code, but you cannot call the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on this type because it is not a generic type definition.</source>
          <target state="translated">など、構築された型<ph id="ph1">`Base&lt;int, V&gt;`</ph>場合に便利ですが、コードの出力が、呼び出すことはできません、<ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>この型のメソッドがジェネリック型定義ではないためです。</target>       </trans-unit>
        <trans-unit id="4103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To create a closed constructed type that can be instantiated, first call the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method to get a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing the generic type definition and then call <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> with the desired type arguments.</source>
          <target state="translated">インスタンス化できるクローズ構築型を作成するには、まず、<ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>取得するメソッド、 <ph id="ph2">&lt;xref:System.Type&gt;</ph> 、ジェネリック型定義を表すオブジェクトを呼び出す<ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>目的の型引数を使用します。</target>       </trans-unit>
        <trans-unit id="4104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object returned by <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> is the same as the <ph id="ph3">&lt;xref:System.Type&gt;</ph> obtained by calling the <ph id="ph4">&lt;xref:System.Object.GetType%2A&gt;</ph> method of the resulting constructed type, or the <ph id="ph5">&lt;xref:System.Object.GetType%2A&gt;</ph> method of any constructed type that was created from the same generic type definition using the same type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph>によって返されるオブジェクト<ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>と同じ、<ph id="ph3">&lt;xref:System.Type&gt;</ph>呼び出すことによって取得、<ph id="ph4">&lt;xref:System.Object.GetType%2A&gt;</ph>メソッド結果の構築型、または<ph id="ph5">&lt;xref:System.Object.GetType%2A&gt;</ph>のいずれかのメソッドから作成された同じジェネリック型の構築同じ型引数を使用して、定義を入力します。</target>       </trans-unit>
        <trans-unit id="4105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>An array of generic types is not itself a generic type.</source>
          <target state="translated">ジェネリック型の配列自体ではなく、ジェネリック型です。</target>       </trans-unit>
        <trans-unit id="4106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You cannot call <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> on an array type such as <ph id="ph2">`C&lt;T&gt;[]`</ph> (<ph id="ph3">`Dim ac() As C(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">呼び出すことはできません<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>ように、配列で入力<ph id="ph2">`C&lt;T&gt;[]`</ph>(<ph id="ph3">`Dim ac() As C(Of T)`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="4107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To construct a closed generic type from <ph id="ph1">`C&lt;T&gt;[]`</ph>, call <ph id="ph2">&lt;xref:System.Type.GetElementType%2A&gt;</ph> to obtain the generic type definition <ph id="ph3">`C&lt;T&gt;`</ph>; call <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> on the generic type definition to create the constructed type; and finally call the <ph id="ph5">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method on the constructed type to create the array type.</source>
          <target state="translated">クローズ ジェネリック型を構築するために<ph id="ph1">`C&lt;T&gt;[]`</ph>、呼び出す<ph id="ph2">&lt;xref:System.Type.GetElementType%2A&gt;</ph>ジェネリック型定義を取得する<ph id="ph3">`C&lt;T&gt;`</ph>; を呼び出す<ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>を最後に構築された型を作成し、ジェネリック型定義で、<ph id="ph5">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>配列型の作成に構築された型のメソッドです。</target>       </trans-unit>
        <trans-unit id="4108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The same is true of pointer types and <ph id="ph1">`ref`</ph> types (<ph id="ph2">`ByRef`</ph> in Visual Basic).</source>
          <target state="translated">ポインター型の場合も、同様と<ph id="ph1">`ref`</ph>型 (<ph id="ph2">`ByRef`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="4109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> プロパティの解説を参照してください。</target>       </trans-unit>
        <trans-unit id="4110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Nested Types</source>
          <target state="translated">入れ子にされた型</target>       </trans-unit>
        <trans-unit id="4111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</source>
          <target state="translated">C#、C++、または Visual Basic を使用して、ジェネリック型が定義されている場合、入れ子にされた型はすべてジェネリックです。</target>       </trans-unit>
        <trans-unit id="4112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</source>
          <target state="translated">これは、入れ子にされた型には、独自の型パラメーターがあるない 3 つすべての言語は、入れ子にされた型の型パラメーター リストの包含する型の型パラメーターを含むため場合でも当てはまります。</target>       </trans-unit>
        <trans-unit id="4113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Consider the following classes:</source>
          <target state="translated">次のクラスについて考えてみます。</target>       </trans-unit>
        <trans-unit id="4114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The type parameter list of the nested class <ph id="ph1">`Inner`</ph> has two type parameters, <ph id="ph2">`T`</ph> and <ph id="ph3">`U`</ph>, the first of which is the type parameter of its enclosing class.</source>
          <target state="translated">入れ子になったクラスの型パラメーター リスト<ph id="ph1">`Inner`</ph>2 つの型パラメーターを持ち<ph id="ph2">`T`</ph>と<ph id="ph3">`U`</ph>最初は、その外側のクラスの型パラメーターです。</target>       </trans-unit>
        <trans-unit id="4115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Similarly, the type parameter list of the nested class <ph id="ph1">`Innermost1`</ph> has three type parameters, <ph id="ph2">`T`</ph>, <ph id="ph3">`U`</ph>, and <ph id="ph4">`V`</ph>, with <ph id="ph5">`T`</ph> and <ph id="ph6">`U`</ph> coming from its enclosing classes.</source>
          <target state="translated">入れ子になったクラスの型パラメーター リスト同様に、 <ph id="ph1">`Innermost1`</ph> 3 つの型パラメーターを持ちます<ph id="ph2">`T`</ph>、 <ph id="ph3">`U`</ph>、および<ph id="ph4">`V`</ph>で<ph id="ph5">`T`</ph>と<ph id="ph6">`U`</ph>外側のクラスからのものです。</target>       </trans-unit>
        <trans-unit id="4116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The nested class <ph id="ph1">`Innermost2`</ph> has two type parameters, <ph id="ph2">`T`</ph> and <ph id="ph3">`U`</ph>, which come from its enclosing classes.</source>
          <target state="translated">入れ子になったクラス<ph id="ph1">`Innermost2`</ph>2 つの型パラメーターを持ち<ph id="ph2">`T`</ph>と<ph id="ph3">`U`</ph>、その外側のクラスから取得します。</target>       </trans-unit>
        <trans-unit id="4117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</source>
          <target state="translated">それを囲む型のパラメーター リストは、1 つ以上の型パラメーターを持つ、入れ子にされた型の型パラメーター リスト内の順序ですべての型パラメーターが含まれます。</target>       </trans-unit>
        <trans-unit id="4118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To construct a generic type from the generic type definition for a nested type, call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</source>
          <target state="translated">入れ子にされた型のジェネリック型定義のジェネリック型を構築するために呼び出す、<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>すべての包含する型、最も外側のジェネリック型で始まると、入れ子になったの型引数の配列で終了するまでの型引数の配列を連結して形成される配列を持つメソッド型そのものに、独自の型パラメーターがある場合。</target>       </trans-unit>
        <trans-unit id="4119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To create an instance of <ph id="ph1">`Innermost1`</ph>, call the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with an array containing three types, to be assigned to T, U, and V. To create an instance of <ph id="ph3">`Innermost2`</ph>, call the <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with an array containing two types, to be assigned to T and U.</source>
          <target state="translated">インスタンスを作成する<ph id="ph1">`Innermost1`</ph>を呼び出して、 <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> T、U、および V に割り当てられるに、次の 3 つの型を含む配列を持つメソッドです。インスタンスを作成する<ph id="ph3">`Innermost2`</ph>を呼び出して、 <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> T と U に割り当てられる、2 つの型を含む配列を持つメソッド</target>       </trans-unit>
        <trans-unit id="4120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</source>
          <target state="translated">言語は、外側の型のこのような方法で入れ子にされた型のフィールドの定義にそれを囲む型の型パラメーターを使用できるように、型パラメーターを伝達します。</target>       </trans-unit>
        <trans-unit id="4121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Otherwise, the type parameters would not be in scope within the bodies of the nested types.</source>
          <target state="translated">それ以外の場合、型パラメーターは、入れ子にされた型の本文内のスコープにはできません。</target>       </trans-unit>
        <trans-unit id="4122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">外側の型の動的アセンブリでコードを出力するかを使用して、型パラメーターを伝達することがなく、入れ子にされた型を定義することは、 <bpt id="p1">[</bpt>Ilasm.exe (IL アセンブラー)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="4123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Consider the following code for the MSIL assembler:</source>
          <target state="translated">MSIL アセンブラーは、次のコードを考慮してください。</target>       </trans-unit>
        <trans-unit id="4124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>In this example, it is not possible to define a field of type <ph id="ph1">`T`</ph> or <ph id="ph2">`U`</ph> in class <ph id="ph3">`Innermost`</ph>, because those type parameters are not in scope.</source>
          <target state="translated">この例では型のフィールドを定義する<ph id="ph1">`T`</ph>または<ph id="ph2">`U`</ph>クラスで<ph id="ph3">`Innermost`</ph>これらの型パラメーターのスコープ内ではないため、します。</target>       </trans-unit>
        <trans-unit id="4125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</source>
          <target state="translated">次のアセンブラー コードでは、C++、Visual Basic および c# で定義されている場合と同じように動作する入れ子になったクラスを定義します。</target>       </trans-unit>
        <trans-unit id="4126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine nested classes defined in the high-level languages and observe this naming scheme.</source>
          <target state="translated">使用することができます、 <bpt id="p1">[</bpt>Ildasm.exe (IL 逆アセンブラー)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>を高水準言語で定義された入れ子になったクラスを調査して、この名前付けスキームを確認します。</target>       </trans-unit>
        <trans-unit id="4127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method to create a constructed type from the generic type definition for the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> type.</source>
          <target state="translated">次の例では、<ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>のジェネリック型定義から構築された型を作成する方法、<ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>型です。</target>       </trans-unit>
        <trans-unit id="4128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The constructed type represents a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`Test`</ph> objects with string keys.</source>
          <target state="translated">構築された型を表し、<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>の<ph id="ph2">`Test`</ph>文字列キーを持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="4129" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The current type does not represent a generic type definition.</source>
          <target state="translated">現在の型はジェネリック型の定義を表していません。</target>       </trans-unit>
        <trans-unit id="4130" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericTypeDefinition" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">つまり、<ph id="ph1">&lt;see cref="P:System.Type.IsGenericTypeDefinition" /&gt;</ph> は <ph id="ph2">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="4131" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="4132" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="4133" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> のどの要素も <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="4134" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The number of elements in <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is not the same as the number of type parameters in the current generic type definition.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> の要素の数が現在のジェネリック型定義の型パラメーターの数と同じではありません。</target>       </trans-unit>
        <trans-unit id="4135" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="4136" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> の要素が、現在のジェネリック型の対応する型パラメーターに指定された制約を満たしていません。</target>       </trans-unit>
        <trans-unit id="4137" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="4138" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> contains an element that is a pointer type (<ph id="ph2">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>), a by-ref type (<ph id="ph4">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph5">&lt;see langword="true" /&gt;</ph>), or <ph id="ph6">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> に含まれる要素は、ポインター型 (<ph id="ph2">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> は <ph id="ph3">&lt;see langword="true" /&gt;</ph> を返す)、"参照渡し" 型 (<ph id="ph4">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> は<ph id="ph5">&lt;see langword="true" /&gt;</ph> を返す)、または <ph id="ph6">&lt;see cref="T:System.Void" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="4139" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">呼び出されたメソッドは基底クラスでサポートされていません。</target>       </trans-unit>
        <trans-unit id="4140" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">派生クラスには実装を指定しなければなりません。</target>       </trans-unit>
        <trans-unit id="4141" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a pointer to the current type.</source>
          <target state="translated">現在の型へのポインターを表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="4142" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a pointer to the current type.</source>
          <target state="translated">現在の型へのポインターを表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="4143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakePointerType">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> method provides a way to generate pointer types for parameter lists.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>メソッドはパラメーター リストのポインター型を生成する方法を提供します。</target>       </trans-unit>
        <trans-unit id="4144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakePointerType">
          <source>Using the syntax of Microsoft intermediate language (MSIL), if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, this method returns a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object representing <ph id="ph4">`Int32*`</ph>.</source>
          <target state="translated">場合は、Microsoft intermediate language (MSIL) の構文を使用して、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクトが表す<ph id="ph2">&lt;xref:System.Int32&gt;</ph>、このメソッドが戻る、<ph id="ph3">&lt;xref:System.Type&gt;</ph>オブジェクトを表す<ph id="ph4">`Int32*`</ph>です。</target>       </trans-unit>
        <trans-unit id="4145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakePointerType">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">次のコード例は、配列を作成<ph id="ph1">`ref`</ph>(<ph id="ph2">`ByRef`</ph> Visual Basic で)、およびポインター型の<ph id="ph3">`Test`</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="4146" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">呼び出されたメソッドは基底クラスでサポートされていません。</target>       </trans-unit>
        <trans-unit id="4147" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">現在の型が <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="4148" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="4149" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">現在の型が <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> 型です。</target>       </trans-unit>
        <trans-unit id="4150" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">つまり、<ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> は <ph id="ph2">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="4151" translate="yes" xml:space="preserve" uid="P:System.Type.MemberType">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a type or a nested type.</source>
          <target state="translated">このメンバーが型であるか、または入れ子にされた型であるかを示す <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> 値を取得します。</target>       </trans-unit>
        <trans-unit id="4152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a type or a nested type.</source>
          <target state="translated">このメンバーが型であるか、または入れ子にされた型であるかを示す <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> 値。</target>       </trans-unit>
        <trans-unit id="4153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>This property overrides <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">このプロパティのオーバーライド<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="4154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>Therefore, when you examine a set of <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects—for example, the array returned by <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph>—the <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> property returns <ph id="ph4">&lt;xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType&gt;</ph> when a given member is a nested type.</source>
          <target state="translated">セットを確認すると、そのため、<ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph>オブジェクト — たとえば、によって返される配列<ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph>—、<ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph>プロパティから返される<ph id="ph4">&lt;xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType&gt;</ph>入れ子にされた型が指定されたメンバーの場合。</target>       </trans-unit>
        <trans-unit id="4155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表す型を構築する元になるジェネリック型定義に構築されたジェネリック型、このプロパティが適用されます。</target>       </trans-unit>
        <trans-unit id="4156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">たとえば場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表します<ph id="ph2">`MyGenericType&lt;int&gt;`</ph>(<ph id="ph3">`MyGenericType(Of Integer)`</ph> Visual Basic で)、このプロパティの値はによって決まります<ph id="ph4">`MyGenericType&lt;T&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="4157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">&lt;xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>常にこのプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<ph id="ph2">&lt;xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="4158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>The following code example shows the <ph id="ph1">`MemberType`</ph> field as a parameter to the <ph id="ph2">`GetMember`</ph> method:</source>
          <target state="translated">次のコード例は、<ph id="ph1">`MemberType`</ph>フィールドへのパラメーターとして、<ph id="ph2">`GetMember`</ph>メソッド。</target>       </trans-unit>
        <trans-unit id="4159" translate="yes" xml:space="preserve" uid="F:System.Type.Missing">
          <source>Represents a missing value in the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> information.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 情報に不足している値を表します。</target>       </trans-unit>
        <trans-unit id="4160" translate="yes" xml:space="preserve" uid="F:System.Type.Missing">
          <source>This field is read-only.</source>
          <target state="translated">このフィールドは読み取り専用です。</target>       </trans-unit>
        <trans-unit id="4161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>Use the <ph id="ph1">`Missing`</ph> field for invocation through reflection to obtain the default value of a parameter.</source>
          <target state="translated">使用して、<ph id="ph1">`Missing`</ph>パラメーターの既定値を取得するリフレクションの呼び出しに対応するフィールドです。</target>       </trans-unit>
        <trans-unit id="4162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>If the <ph id="ph1">`Missing`</ph> field is passed in for a parameter value and there is no default value for that parameter, an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> is thrown.</source>
          <target state="translated">場合、<ph id="ph1">`Missing`</ph>フィールド、パラメーター値が渡され、そのパラメーターの既定値はありません、<ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="4163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>The following code example shows the use of the <ph id="ph1">`Missing`</ph> field to invoke a method with its default arguments.</source>
          <target state="translated">次のコード例の使用を示しています、<ph id="ph1">`Missing`</ph>フィールドを既定の引数を持つメソッドを呼び出します。</target>       </trans-unit>
        <trans-unit id="4164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>This code produces the following output:</source>
          <target state="translated">このコードを実行すると、次の出力が生成されます。</target>       </trans-unit>
        <trans-unit id="4165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>a = 10 b = 55.3 c = 12</source>
          <target state="translated">10 を = b 55.3 c = 12 を =</target>       </trans-unit>
        <trans-unit id="4166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>a = 10 b = 1.3 c = 1</source>
          <target state="translated">a = 10 b = 1.3 c = 1</target>       </trans-unit>
        <trans-unit id="4167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>a = 10 b = 1.2 c = 1</source>
          <target state="translated">a = 10 b = 1.2 c = 1</target>       </trans-unit>
        <trans-unit id="4168" translate="yes" xml:space="preserve" uid="P:System.Type.Module">
          <source>Gets the module (the DLL) in which the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is defined.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が定義されているモジュール (DLL) を取得します。</target>       </trans-unit>
        <trans-unit id="4169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>The module in which the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is defined.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> が定義されているモジュールです。</target>       </trans-unit>
        <trans-unit id="4170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>表します構築されたジェネリック型、このプロパティは、ジェネリック型定義が定義されているモジュールを返します。</target>       </trans-unit>
        <trans-unit id="4171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>For example, if you create an instance of <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph>, the <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> property for the constructed type returns the module in which <ph id="ph3">`MyGenericStack&lt;T&gt;`</ph> is defined.</source>
          <target state="translated">インスタンスを作成する場合など<ph id="ph1">`MyGenericStack&lt;int&gt;`</ph>、<ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph>構築された型のプロパティでは、モジュールを返しますを<ph id="ph3">`MyGenericStack&lt;T&gt;`</ph>が定義されています。</target>       </trans-unit>
        <trans-unit id="4172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic parameter <ph id="ph2">`T`</ph>, this property returns the assembly that contains the generic type that defines <ph id="ph3">`T`</ph>.</source>
          <target state="translated">同様に場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>ジェネリック パラメーターを表す<ph id="ph2">`T`</ph>、このプロパティを定義するジェネリック型を含むアセンブリを返します<ph id="ph3">`T`</ph>です。</target>       </trans-unit>
        <trans-unit id="4173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>This following example demonstrates a use of the <ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph> and <ph id="ph2">`Module`</ph> properties and the <ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph> method of <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">この次の例を使用して、<ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph>と<ph id="ph2">`Module`</ph>プロパティおよび<ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph>メソッドの<ph id="ph4">&lt;xref:System.Type&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="4174" translate="yes" xml:space="preserve" uid="P:System.Type.Namespace">
          <source>Gets the namespace of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の名前空間を取得します。</target>       </trans-unit>
        <trans-unit id="4175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>The namespace of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>; <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the current instance has no namespace or represents a generic parameter.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の名前空間。現在のインスタンスに名前空間がない場合、または現在のインスタンスがジェネリック パラメーターを表す場合は <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</source>
          <target state="translated">名前空間は、論理デザイン時名前付け利便性のため、主に、アプリケーションでスコープを定義し、クラスと他の型に 1 つの階層構造を整理するために使用します。</target>       </trans-unit>
        <trans-unit id="4177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>From the viewpoint of the runtime, there are no namespaces.</source>
          <target state="translated">ランタイムの視点からは、名前空間はありません。</target>       </trans-unit>
        <trans-unit id="4178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>構築されたジェネリック型を表し、このプロパティは、ジェネリック型定義を含む名前空間を返します。</target>       </trans-unit>
        <trans-unit id="4179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic parameter <ph id="ph2">`T`</ph>, this property returns the namespace that contains the generic type definition that defines <ph id="ph3">`T`</ph>.</source>
          <target state="translated">同様に場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>ジェネリック パラメーターを表す<ph id="ph2">`T`</ph>、このプロパティを定義するジェネリック型定義を含む名前空間が返されます<ph id="ph3">`T`</ph>です。</target>       </trans-unit>
        <trans-unit id="4180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a generic parameter, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクトは、ジェネリック パラメーターを表す、このプロパティを返します<ph id="ph2">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="4181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>This following example demonstrates a use of the <ph id="ph1">`Namespace`</ph> and <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> properties and the <ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph> method of <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">この次の例を使用して、<ph id="ph1">`Namespace`</ph>と<ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph>プロパティおよび<ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph>メソッドの<ph id="ph4">&lt;xref:System.Type&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="4182" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source>The first object to compare.</source>
          <target state="translated">比較する最初のオブジェクト。</target>       </trans-unit>
        <trans-unit id="4183" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source>The second object to compare.</source>
          <target state="translated">比較する 2 番目のオブジェクト。</target>       </trans-unit>
        <trans-unit id="4184" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects are equal.</source>
          <target state="translated">2 つの <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトが等しいかどうかを示します。</target>       </trans-unit>
        <trans-unit id="4185" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が <ph id="ph2">&lt;paramref name="left" /&gt;</ph> に等しい場合は <ph id="ph3">&lt;paramref name="right" /&gt;</ph>。それ以外の場合は <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4186" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source>The first object to compare.</source>
          <target state="translated">比較する最初のオブジェクト。</target>       </trans-unit>
        <trans-unit id="4187" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source>The second object to compare.</source>
          <target state="translated">比較する 2 番目のオブジェクト。</target>       </trans-unit>
        <trans-unit id="4188" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects are not equal.</source>
          <target state="translated">2 つの <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトが等しくないかどうかを示します。</target>       </trans-unit>
        <trans-unit id="4189" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> が <ph id="ph2">&lt;paramref name="left" /&gt;</ph> と等しくない場合は <ph id="ph3">&lt;paramref name="right" /&gt;</ph>。それ以外の場合は <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4190" translate="yes" xml:space="preserve" uid="P:System.Type.ReflectedType">
          <source>Gets the class object that was used to obtain this member.</source>
          <target state="translated">このメンバーを取得するために使用したクラス オブジェクトを取得します。</target>       </trans-unit>
        <trans-unit id="4191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ReflectedType">
          <source>The <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object through which this <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object was obtained.</source>
          <target state="translated">この <ph id="ph1">&lt;see langword="Type" /&gt;</ph> オブジェクトを取得するために使用した <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="4192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ReflectedType">
          <source>For <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects, the value of this property is always the same as the value of the <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクト、このプロパティの値は、の値と同じでは常に、<ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="4193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ReflectedType">
          <source>This example displays the reflected type of a nested class.</source>
          <target state="translated">この例では、入れ子になったクラスのリフレクションされた型を表示します。</target>       </trans-unit>
        <trans-unit id="4194" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly-qualified name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">取得する <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のアセンブリ修飾名。</target>       </trans-unit>
        <trans-unit id="4195" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw a <ph id="ph2">&lt;see cref="T:System.TypeLoadException" /&gt;</ph> if the type cannot be found; <ph id="ph3">&lt;see langword="false" /&gt;</ph> to return <ph id="ph4">&lt;see langword="null" /&gt;</ph> if the type cannot be found.</source>
          <target state="translated">型が見つからない場合に <ph id="ph2">&lt;see cref="T:System.TypeLoadException" /&gt;</ph> をスローするには <ph id="ph1">&lt;see langword="true" /&gt;</ph>。型が見つからない場合に <ph id="ph3">&lt;see langword="false" /&gt;</ph> を返すには <ph id="ph4">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4196" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">また、<ph id="ph1">&lt;see langword="false" /&gt;</ph> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。</target>       </trans-unit>
        <trans-unit id="4197" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">「例外」を参照してください。</target>       </trans-unit>
        <trans-unit id="4198" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a case-insensitive search for <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">大文字と小文字を区別せずに <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> の検索を実行するには <ph id="ph1">&lt;see langword="true" /&gt;</ph>。大文字と小文字を区別して <ph id="ph2">&lt;see langword="false" /&gt;</ph> の検索を実行するには <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="4199" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</source>
          <target state="translated">大文字と小文字を区別する検索を実行し、型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> を取得します。</target>       </trans-unit>
        <trans-unit id="4200" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The type is loaded for reflection only, not for execution.</source>
          <target state="translated">型は実行ではなくリフレクションのためだけに読み込まれます。</target>       </trans-unit>
        <trans-unit id="4201" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The type with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">存在する場合は、指定した名前を持つ型。それ以外の場合は <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4202" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">型が見つからない場合、<ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> パラメーターで <ph id="ph2">&lt;see langword="null" /&gt;</ph> を返すか例外をスローするかを指定します。</target>       </trans-unit>
        <trans-unit id="4203" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph>.</source>
          <target state="translated">一部の場合は、<ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> の値に関係なく、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="4204" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">「例外」を参照してください。</target>       </trans-unit>
        <trans-unit id="4205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly containing the type is not already loaded into the reflection-only context, using the <ph id="ph1">&lt;xref:System.Type.ReflectionOnlyGetType%2A&gt;</ph> method is equivalent to first loading the assembly for reflection only, using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> method, and then loading the type by calling the assembly's <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">使用して型を含むアセンブリがリフレクションのみのコンテキスト読み込まれない場合、<ph id="ph1">&lt;xref:System.Type.ReflectionOnlyGetType%2A&gt;</ph>メソッドは、最初のと同じアセンブリの読み込み、リフレクションのためだけを使用して、<ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph>メソッド、およびアセンブリの呼び出すことによって、型を読み込む<ph id="ph3">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="4206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For information about assembly-qualified names, see the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">アセンブリ修飾名については、次を参照してください。、<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="4207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For additional details on specifying type names, see the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">型名の指定の詳細については、次を参照してください。、<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="4208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</source>
          <target state="translated">アセンブリが既に実行のために読み込まれている場合は、別のコピーがリフレクションのみのコンテキストに読み込まれます。</target>       </trans-unit>
        <trans-unit id="4209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwIfNotFound`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
          <target state="translated"><ph id="ph1">`throwIfNotFound`</ph>パラメーターは、例外セクションで説明した型が見つからないし、もその他の特定の例外条件を抑制ときの動作を指定します。</target>       </trans-unit>
        <trans-unit id="4210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwIfNotFound`</ph>.</source>
          <target state="translated">値に関係なく一部の例外がスローされた<ph id="ph1">`throwIfNotFound`</ph>です。</target>       </trans-unit>
        <trans-unit id="4211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, if the assembly is not valid, a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph> is thrown even if <ph id="ph2">`throwIfNotFound`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">たとえば、アセンブリが有効でない場合、<ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>スローされる場合でも<ph id="ph2">`throwIfNotFound`</ph>は<ph id="ph3">`false`</ph>します。</target>       </trans-unit>
        <trans-unit id="4212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For more information about using the reflection-only context, see <bpt id="p1">[</bpt>How to: Load Assemblies into the Reflection-Only Context<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)</ept>.</source>
          <target state="translated">詳細については、リフレクションのみのコンテキストを使用して、次を参照してください。<bpt id="p1">[</bpt>する方法: リフレクション コンテキストにアセンブリをロード<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="4213" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="4214" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">クラス初期化子が呼び出され、例外をスローします。</target>       </trans-unit>
        <trans-unit id="4215" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、型は見つかりません。</target>       </trans-unit>
        <trans-unit id="4216" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="4217" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> に埋め込まれたタブなどの無効な文字が含まれています。</target>       </trans-unit>
        <trans-unit id="4218" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="4219" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> が空の文字列です。</target>       </trans-unit>
        <trans-unit id="4220" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="4221" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> が無効なサイズの配列型を表しています。</target>       </trans-unit>
        <trans-unit id="4222" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="4223" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は、<ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> オブジェクトの配列を表します。</target>       </trans-unit>
        <trans-unit id="4224" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> does not include the assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> にはアセンブリ名は含まれません。</target>       </trans-unit>
        <trans-unit id="4225" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="4226" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax; for example, "MyType[,*,]".</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> は <ph id="ph2">&lt;see langword="true" /&gt;</ph> であり、<ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> には無効な構文 (たとえば、"MyType[,*,]") が含まれています。</target>       </trans-unit>
        <trans-unit id="4227" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="4228" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> は、型引数の 1 つとしてポインター型、<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>、または <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> を持つジェネリック型を表しています。</target>       </trans-unit>
        <trans-unit id="4229" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="4230" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> が、正しい数の型引数が格納されていないジェネリック型を表しています。</target>       </trans-unit>
        <trans-unit id="4231" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="4232" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> がジェネリック型を表しており、その型引数の 1 つが対応する型パラメーターの制約を満たしていません。</target>       </trans-unit>
        <trans-unit id="4233" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</target>       </trans-unit>
        <trans-unit id="4234" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">アセンブリ、またはその依存関係のうちの 1 つは見つかりましたが、読み込めませんでした。</target>       </trans-unit>
        <trans-unit id="4235" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">アセンブリまたはその依存関係のうちの 1 つが正しくありません。</target>       </trans-unit>
        <trans-unit id="4236" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="4237" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</target>       </trans-unit>
        <trans-unit id="4238" translate="yes" xml:space="preserve" uid="P:System.Type.StructLayoutAttribute">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> that describes the layout of the current type.</source>
          <target state="translated">現在の型のレイアウトを説明する <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> を取得します。</target>       </trans-unit>
        <trans-unit id="4239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> that describes the gross layout features of the current type.</source>
          <target state="translated">現在の型のレイアウト機能全体を説明する <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> を取得します。</target>       </trans-unit>
        <trans-unit id="4240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> is not returned by the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> によって返されない、<ph id="ph2">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="4241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>Instead, use this property to get it.</source>
          <target state="translated">代わりに、このプロパティを使用して、これを取得します。</target>       </trans-unit>
        <trans-unit id="4242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class).</source>
          <target state="translated">次のコード例は、まず、クラス、構造体、および特殊なレイアウト属性 (構造体は、クラス内で入れ子になった) を持つ構造体を定義します。</target>       </trans-unit>
        <trans-unit id="4243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>The example then uses the <ph id="ph1">&lt;xref:System.Type.StructLayoutAttribute%2A&gt;</ph> property to obtain a <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> for each type, and displays the properties of the attributes.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Type.StructLayoutAttribute%2A&gt;</ph>を取得するプロパティ、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>各型、および属性のプロパティが表示されます。</target>       </trans-unit>
        <trans-unit id="4244" translate="yes" xml:space="preserve" uid="P:System.Type.StructLayoutAttribute">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">呼び出されたメソッドは基底クラスでサポートされていません。</target>       </trans-unit>
        <trans-unit id="4245" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">将来使用するために予約されています。</target>       </trans-unit>
        <trans-unit id="4246" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">IID_NULL にする必要があります。</target>       </trans-unit>
        <trans-unit id="4247" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">マッピング対象として渡される名前の配列。</target>       </trans-unit>
        <trans-unit id="4248" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">マッピングされる名前のカウント。</target>       </trans-unit>
        <trans-unit id="4249" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">名前を解釈するロケール コンテキスト。</target>       </trans-unit>
        <trans-unit id="4250" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</target>       </trans-unit>
        <trans-unit id="4251" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">一連の名前を対応する一連のディスパッチ識別子に割り当てます。</target>       </trans-unit>
        <trans-unit id="4252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。</target>       </trans-unit>
        <trans-unit id="4253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">詳細については<ph id="ph1">`IDispatch::GetIDsOfNames`</ph>、MSDN ライブラリを参照してください。</target>       </trans-unit>
        <trans-unit id="4254" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</target>       </trans-unit>
        <trans-unit id="4255" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">返される型情報。</target>       </trans-unit>
        <trans-unit id="4256" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">型情報のロケール ID。</target>       </trans-unit>
        <trans-unit id="4257" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>A pointer to the requested type information object.</source>
          <target state="translated">要求された型情報オブジェクトへのポインター。</target>       </trans-unit>
        <trans-unit id="4258" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</target>       </trans-unit>
        <trans-unit id="4259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。</target>       </trans-unit>
        <trans-unit id="4260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">詳細については<ph id="ph1">`IDispatch::GetTypeInfo`</ph>、MSDN ライブラリを参照してください。</target>       </trans-unit>
        <trans-unit id="4261" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</target>       </trans-unit>
        <trans-unit id="4262" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</target>       </trans-unit>
        <trans-unit id="4263" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">オブジェクトが提供する型情報インターフェイスの数 (0 または 1) を取得します。</target>       </trans-unit>
        <trans-unit id="4264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。</target>       </trans-unit>
        <trans-unit id="4265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">詳細については<ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>、MSDN ライブラリを参照してください。</target>       </trans-unit>
        <trans-unit id="4266" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</target>       </trans-unit>
        <trans-unit id="4267" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">メンバーを識別します。</target>       </trans-unit>
        <trans-unit id="4268" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">将来使用するために予約されています。</target>       </trans-unit>
        <trans-unit id="4269" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">IID_NULL にする必要があります。</target>       </trans-unit>
        <trans-unit id="4270" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">引数を解釈する対象のロケール コンテキスト。</target>       </trans-unit>
        <trans-unit id="4271" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">呼び出しのコンテキストを記述するフラグ。</target>       </trans-unit>
        <trans-unit id="4272" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</target>       </trans-unit>
        <trans-unit id="4273" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">結果が格納される場所へのポインター。</target>       </trans-unit>
        <trans-unit id="4274" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">例外情報を格納する構造体へのポインター。</target>       </trans-unit>
        <trans-unit id="4275" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">エラーが存在する最初の引数のインデックス。</target>       </trans-unit>
        <trans-unit id="4276" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</target>       </trans-unit>
        <trans-unit id="4277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。</target>       </trans-unit>
        <trans-unit id="4278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">詳細については<ph id="ph1">`IDispatch::Invoke`</ph>、MSDN ライブラリを参照してください。</target>       </trans-unit>
        <trans-unit id="4279" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</target>       </trans-unit>
        <trans-unit id="4280" translate="yes" xml:space="preserve" uid="M:System.Type.ToString">
          <source>Returns a <ph id="ph1">&lt;see langword="String" /&gt;</ph> representing the name of the current <ph id="ph2">&lt;see langword="Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see langword="String" /&gt;</ph> の名前を表す <ph id="ph2">&lt;see langword="Type" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="4281" translate="yes" xml:space="preserve" uid="M:System.Type.ToString">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> representing the name of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> の名前を表す <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>This method returns the fully qualified common language runtime namespace and name for all primitive types.</source>
          <target state="translated">このメソッドは、すべてのプリミティブ型の名前と共通言語ランタイムの完全修飾名前空間を返します。</target>       </trans-unit>
        <trans-unit id="4283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>For example, the C# instruction, <ph id="ph1">`(long)0.Type().ToString()`</ph> returns "System.Int64" instead of merely "Int64".</source>
          <target state="translated">たとえば、c# の命令<ph id="ph1">`(long)0.Type().ToString()`</ph>"Int64"だけではなく"System.Int64"を返します。</target>       </trans-unit>
        <trans-unit id="4284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>名前空間と入れ子にされた型がアセンブリではなく、ジェネリック型、型と型引数が修飾名を表します。</target>       </trans-unit>
        <trans-unit id="4285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>を表すジェネリック型またはジェネリック メソッドでこのメソッドの定義の型パラメーターが、型パラメーターの非修飾名を返します。</target>       </trans-unit>
        <trans-unit id="4286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>This following example demonstrates a use of the <ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> properties and the <ph id="ph3">`ToString`</ph> method of <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">この次の例を使用して、<ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph>プロパティおよび<ph id="ph3">`ToString`</ph>メソッドの<ph id="ph4">&lt;xref:System.Type&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="4287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>The following example compares the strings returned by the <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> method and the <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> properties.</source>
          <target state="translated">次の例で返される文字列の比較、<ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph>メソッドおよび<ph id="ph2">`Name`</ph>、 <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>、および<ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="4288" translate="yes" xml:space="preserve" uid="P:System.Type.TypeHandle">
          <source>Gets the handle for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のハンドルを取得します。</target>       </trans-unit>
        <trans-unit id="4289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>The handle for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のハンドル。</target>       </trans-unit>
        <trans-unit id="4290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source><ph id="ph1">`TypeHandle`</ph> encapsulates a pointer to an internal data structure that represents the type.</source>
          <target state="translated"><ph id="ph1">`TypeHandle`</ph> 型を表す内部データ構造体へのポインターをカプセル化します。</target>       </trans-unit>
        <trans-unit id="4291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>This handle is unique during the process lifetime.</source>
          <target state="translated">このハンドルは、プロセスの有効期間中には一意です。</target>       </trans-unit>
        <trans-unit id="4292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>The handle is valid only in the application domain in which it was obtained.</source>
          <target state="translated">ハンドルは、取得されているアプリケーション ドメイン内でのみ有効です。</target>       </trans-unit>
        <trans-unit id="4293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</source>
          <target state="translated">次の例では、対応する型のハンドルを返し、ハンドルをハンドルから型を取得し、それを表示するメソッドに渡します。</target>       </trans-unit>
        <trans-unit id="4294" translate="yes" xml:space="preserve" uid="P:System.Type.TypeHandle">
          <source>The .NET Compact Framework does not currently support this property.</source>
          <target state="translated">現在、.NET Compact Framework は、このプロパティをサポートしていません。</target>       </trans-unit>
        <trans-unit id="4295" translate="yes" xml:space="preserve" uid="P:System.Type.TypeInitializer">
          <source>Gets the initializer for the type.</source>
          <target state="translated">型の初期化子を取得します。</target>       </trans-unit>
        <trans-unit id="4296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeInitializer">
          <source>An object that contains the name of the class constructor for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> のクラス コンストラクターの名前を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="4297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeInitializer">
          <source>Class initializers are also available through the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method, or through overloads of the <ph id="ph2">&lt;xref:System.Type.GetMember%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> methods that take <ph id="ph6">&lt;xref:System.Reflection.BindingFlags&gt;</ph> as a parameter.</source>
          <target state="translated">クラス初期化子は、使用、<ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph>メソッド、またはのオーバー ロードを通じて、 <ph id="ph2">&lt;xref:System.Type.GetMember%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Type.GetMembers%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>、および<ph id="ph5">&lt;xref:System.Type.GetConstructors%2A&gt;</ph>を受け取るメソッド<ph id="ph6">&lt;xref:System.Reflection.BindingFlags&gt;</ph>をパラメーターとして。</target>       </trans-unit>
        <trans-unit id="4298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeInitializer">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Type&gt;</ph>このプロパティを返しますのジェネリック型またはジェネリック メソッド定義の型パラメーターを表す<ph id="ph2">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="4299" translate="yes" xml:space="preserve" uid="P:System.Type.UnderlyingSystemType">
          <source>Indicates the type provided by the common language runtime that represents this type.</source>
          <target state="translated">この型を表す共通言語ランタイムによって提供された型を示します。</target>       </trans-unit>
        <trans-unit id="4300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.UnderlyingSystemType">
          <source>The underlying system type for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> の基になるシステム型。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>