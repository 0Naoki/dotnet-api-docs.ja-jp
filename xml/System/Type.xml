<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cfbb89f918f9b835f4ce991805da7b50f1738352" /><Meta Name="ms.sourcegitcommit" Value="0d09f5af167c53ca4797424c362e6c2616a36009" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="02/05/2019" /><Meta Name="ms.locfileid" Value="55739834" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>型宣言を表します。型には、クラス型、インターフェイス型、配列型、値型、列挙型、型パラメーター、ジェネリック型定義、およびオープン構築ジェネリック型またはクローズ構築ジェネリック型があります。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` ルートである、<xref:System.Reflection>機能メタデータにアクセスする主な方法です。 メンバーを使用して<xref:System.Type>だけでなく、モジュールおよびアセンブリのクラスがデプロイされている (など、コンス トラクター、メソッド、フィールド、プロパティ、およびクラスのイベント)、型のメンバーについての型の宣言に関する情報を取得します。  
  
 権限をコードでリフレクションを使用して、そのアクセス レベルに関係なく、型とメンバーに関する情報を取得する必要はありません。 アクセス許可はリフレクションを使用して、パブリック メンバー、またはアクセス レベルは変更を表示する通常のコンパイル中に他のメンバーにアクセスするコードは必要ありません。 ただし、クラス、継承されていないメンバーは通常プライベートまたは内部のメソッドなど、アクセスできない、または保護の種類のフィールドへのアクセスにリフレクションを使用して、コードの順序で、コードが必要<xref:System.Security.Permissions.ReflectionPermission>します。 参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)します。  
  
 `Type` 抽象基本クラスにより、複数の実装です。 システムには、派生クラスは常に提供`RuntimeType`します。 リフレクション、システムとサポートの比較演算でオブジェクトあたり 1 回だけ実行時の word で始まるすべてのクラスが作成されます。  
  
> [!NOTE]
>  マルチ スレッドのシナリオではロックされません<xref:System.Type>オブジェクトへのアクセスを同期するために`static`データ。 コントロールで他のコードは、クラス型をロックも可能性がありません。 これにより、デッドロック可能性があります。 代わりに、静的データへのアクセスを同期してプライベートのロック`static`オブジェクト。  
  
> [!NOTE]
>  派生クラスは、呼び出し元のコードの基本クラスのプロテクト メンバーにアクセスできます。 また、呼び出し元のコードのアセンブリのアセンブリのメンバーにアクセスが許可されます。 原則として、事前バインドのコードにアクセスできる場合は、遅延バインドのコードでもアクセスできます。  
  
> [!NOTE]
>  その他のインターフェイスを拡張するインターフェイスは、拡張インターフェイスで定義されているメソッドを継承しません。  
  
 このセクションの内容:  
  
 [型のオブジェクトはどのような型を表しているのか](#WhatTypes)   
 [型オブジェクトを取得します。](#Retrieve)   
 [型のオブジェクトの等価性を比較します。](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>型のオブジェクトはどのような型を表しているのか  
 このクラスはスレッド セーフであります。複数のスレッドは、この型のインスタンスから同時に読み取ることができます。 インスタンス、<xref:System.Type>クラスには、次の種類を表すことができます。  
  
-   クラス  
  
-   値型  
  
-   配列  
  
-   インターフェイス  
  
-   列挙  
  
-   デリゲート  
  
-   構築されたジェネリック型とジェネリック型定義  
  
-   引数を入力して、構築されたジェネリック型、ジェネリック型定義、およびジェネリック メソッド定義のパラメーターを入力  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>型オブジェクトを取得します。  
 <xref:System.Type>特定の種類に関連付けられているオブジェクトを取得するには、次の方法で。  
  
-   インスタンス<xref:System.Object.GetType%2A?displayProperty=nameWithType>メソッドを返します。 を<xref:System.Type>インスタンスの型を表すオブジェクト。 すべてのマネージ型が派生するため<xref:System.Object>、<xref:System.Object.GetType%2A>メソッドは、任意の型のインスタンスで呼び出すことができます。  
  
     次の例では、<xref:System.Object.GetType%2A?displayProperty=nameWithType>オブジェクト配列内の各オブジェクトのランタイム型を判断するメソッド。  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   静的な<xref:System.Type.GetType%2A?displayProperty=nameWithType>メソッドを返す、<xref:System.Type>その完全修飾名で指定された型を表すオブジェクト。  
  
-   <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>、 <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>、および<xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType>メソッドが返す`Type`モジュールで定義された型を表すオブジェクト。 配列を取得する最初のメソッドを使用できる<xref:System.Type>モジュールで定義されたすべてのパブリックおよびプライベート型のオブジェクト。 (のインスタンスを取得する`Module`を通じて、<xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType>または<xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType>メソッド、または、<xref:System.Type.Module%2A?displayProperty=nameWithType>プロパティです)。  
  
-   <xref:System.Reflection.Assembly?displayProperty=nameWithType>オブジェクトには数含む、アセンブリで定義されたクラスを取得するメソッドにはが含まれています<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>、 <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>、および<xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>します。  
  
-   <xref:System.Type.FindInterfaces%2A>メソッドの種類でサポートされているインターフェイスの種類のフィルター処理された一覧を返します。  
  
-   <xref:System.Type.GetElementType%2A>メソッドを返します。 を`Type`要素を表すオブジェクト。  
  
-   <xref:System.Type.GetInterfaces%2A>と<xref:System.Type.GetInterface%2A>メソッドが返す<xref:System.Type>型でサポートされているインターフェイスの型を表すオブジェクト。  
  
-   <xref:System.Type.GetTypeArray%2A>メソッドの配列を返します<xref:System.Type>オブジェクトの任意のセットで指定された型を表すオブジェクト。 オブジェクトは型の配列で指定<xref:System.Object>します。  
  
-   <xref:System.Type.GetTypeFromProgID%2A>と<xref:System.Type.GetTypeFromCLSID%2A>COM 相互運用性のメソッドが用意されています。 返される、<xref:System.Type>で指定された型を表すオブジェクトを`ProgID`または`CLSID`します。  
  
-   <xref:System.Type.GetTypeFromHandle%2A>メソッドの相互運用性が提供されます。 返します、`Type`クラスのハンドルで指定された型を表すオブジェクト。  
  
-   C#`typeof`演算子、C++`typeid`演算子、および Visual Basic`GetType`演算子を取得、`Type`型のオブジェクト。  
  
-   <xref:System.Type.MakeGenericType%2A>メソッドを返します。 を<xref:System.Type>場合オープン構築型である構築ジェネリック型を表すオブジェクト、<xref:System.Type.ContainsGenericParameters%2A>プロパティを返します。 `true`、閉じている構築された型がそれ以外の場合とします。 閉じている場合にのみ、ジェネリック型をインスタンス化できます。  
  
-   <xref:System.Type.MakeArrayType%2A>、 <xref:System.Type.MakePointerType%2A>、および<xref:System.Type.MakeByRefType%2A>メソッドが返す<xref:System.Type>、それぞれに、指定した型、指定された型と参照パラメーターの型へのポインターの配列を表すオブジェクトを (`ref` c# で`ByRef`Visual Basic で)。  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>型のオブジェクトの等価性を比較します。  
 A<xref:System.Type>オブジェクトが表す型が一意である。 2 つつまり<xref:System.Type>同じ型を表している場合にのみ、オブジェクト参照が同じオブジェクトを参照しています。 これにより、比較の<xref:System.Type>オブジェクト参照の等価性を使用します。 次の例では、比較、<xref:System.Type>数かを確認するかどうか、同じ型の整数値を表すオブジェクト。  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 次の例では、いくつかの代表的な機能の<xref:System.Type>します。 C#`typeof`演算子 (`GetType` Visual basic の演算子`typeid`Visual C での演算子) を取得するために使用、<xref:System.Type>オブジェクトを表す<xref:System.String>します。 これから<xref:System.Type>オブジェクト、<xref:System.Type.GetMethod%2A>メソッドを使用して、取得、<xref:System.Reflection.MethodInfo>を表す、<xref:System.String.Substring%2A>を開始位置と長さを受け取るオーバー ロードします。  
  
 2 つを格納する一時配列を作成するコード例をオーバー ロードのシグネチャを識別する<xref:System.Type>オブジェクトを表す`int`(`Integer` Visual Basic で)。  
  
> [!NOTE]
>  正確に言うと、配列にはインスタンスに 2 つの参照が含まれています<xref:System.Type>を表す`int`で現在のアプリケーション ドメイン。 任意の種類は、1 つだけ<xref:System.Type>アプリケーション ドメインごと。  
  
 コード例では、<xref:System.Reflection.MethodInfo>を呼び出す、 <xref:System.String.Substring%2A> 「こんにちは, World!」を文字列でメソッド結果を表示します。  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <block subset="none" type="overrides"><para>継承する場合<see langword="Type" />、次のメンバーをオーバーライドする必要があります。 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md">型情報の表示</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Type" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターは、型のオブジェクトの構築時に、派生クラスによって呼び出されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型が宣言される <see cref="T:System.Reflection.Assembly" /> を取得します。 ジェネリック型の場合は、ジェネリック型が定義される <see cref="T:System.Reflection.Assembly" /> を取得します。</summary>
        <value>現在の型を含むアセンブリを説明する <see cref="T:System.Reflection.Assembly" /> インスタンス。 ジェネリック型の場合、インスタンスは特定の構築型を作成および使用するアセンブリではなく、ジェネリック型定義を含むアセンブリを説明します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>オブジェクトが構築されたジェネリック型を表す、このプロパティは、ジェネリック型定義を含むアセンブリを返します。 たとえば、ジェネリック型定義を含む MyGenerics.dll という名前のアセンブリを作成する`MyGenericStack<T>`(`MyGenericStack(Of T)` Visual basic で`generic<T> ref class MyGenericStack`C++ で)。 インスタンスを作成する場合`MyGenericStack<int>`(`MyGenericStack(Of Integer)` Visual Basic で) 別のアセンブリ内、<xref:System.Type.Assembly%2A>構築された型のプロパティを返します、 <xref:System.Reflection.Assembly> MyGenerics.dll を表すオブジェクト。  
  
 同様に場合、現在<xref:System.Type>オブジェクトは、未割り当てのジェネリック パラメーターを表す`T`、このプロパティを定義するジェネリック型を含むアセンブリを返します`T`します。  
  
 場合、<xref:System.Type.Assembly%2A?displayProperty=nameWithType>プロパティは .NET Core またはユニバーサル Windows プラットフォームなど、特定の .NET 実装では使用できませんを使用して、<xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType>プロパティ代わりにします。      
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、クラスに関連付けられているアセンブリの名前と型の完全修飾名が表示されます。  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> オブジェクトの読み込み元であるアセンブリの名前を含む型のアセンブリ修飾名を取得します。</summary>
        <value><see cref="T:System.Type" /> の読み込み元であるアセンブリの名前を含む、<see cref="T:System.Type" /> のアセンブリ修飾名。現在のインスタンスがジェネリック型パラメーターを表す場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型のアセンブリ修飾名は、コンマの後に、アセンブリの表示名の後にその名前空間を含む、型名で構成されます。 使用して、アセンブリの表示名を取得、<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>プロパティ。  
  
> [!NOTE]
>  .NET Framework version 2.0 では、プロセッサ アーキテクチャは、アセンブリの id に追加され、アセンブリ名の文字列の一部として指定できます。 たとえば、"ProcessorArchitecture = msil"です。 ただし、これが含まれていませんによって返される文字列で、<xref:System.Type.AssemblyQualifiedName%2A>互換性のためのプロパティ。 以下を参照してください。<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>  
  
 共通言語ランタイムをサポートするすべてのコンパイラは、入れ子になったクラスの簡易名を出力し、リフレクションは、次の規則に従って、照会されたときに、完全修飾名を構築します。  
  
|区切り記号|説明|  
|---------------|-------------|  
|円記号 (\\)|文字をエスケープします。|  
|コンマ (,)|アセンブリ名の前にします。|  
|プラス記号 (+)|入れ子になったクラスの前にします。|  
|ピリオド (.)|名前空間の識別子を表します。|  
|角かっこ ()|型名の後に、その型の配列を表します。<br /><br /> または<br /><br /> ジェネリック型の場合は、ジェネリック型引数リストを囲みます。<br /><br /> または<br /><br /> 型引数リスト内で、アセンブリ修飾型を囲みます。|  
  
 たとえば、クラスのアセンブリ修飾名は次のようになります。  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 名前空間には、たとえば TopNamespace.Sub+Namespace、プラス記号が含まれているかどうかは、エスケープ文字はプラス記号 (+) を前と (\\) 入れ子の区切り記号として解釈されないようにします。 リフレクションは、次のように、この文字列を出力は。  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 A"では"が"\\+\\+"、および"\\「が」\\\\"。  
  
 この修飾名を保存し、後で読み込みに使用される、<xref:System.Type>します。 検索して読み込む、<xref:System.Type>を使用して、<xref:System.Type.GetType%2A>のみ、またはアセンブリ修飾型名を持つ型のいずれかの名前します。 <xref:System.Type.GetType%2A> 型と名前のみが検索、<xref:System.Type>呼び出し元のアセンブリで、システム アセンブリでし。 <xref:System.Type.GetType%2A> アセンブリ修飾型名が探して、<xref:System.Type>で任意のアセンブリ。  
  
 型名には、参照型、ポインター型または配列型、型であるかどうかなど、型に関する追加情報を示す後続の文字を含めることができます。 このような末尾の文字型の名前を取得する`t.GetElementType().ToString()`ここで、`t`型です。  
  
 スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。 アセンブリ名では、',' 区切り記号の前にスペースは、関連するが、',' 区切り記号の後のスペースは無視されます。  
  
 ジェネリック型のジェネリック引数はアセンブリ名で修飾します。 などのアセンブリ修飾型名で`MyGenericClass<int>`(`MyGenericClass(Of Integer)` Visual basic)、`int`を拡張して、アセンブリ修飾型名を<xref:System.Int32>します。  
  
 場合、現在<xref:System.Type>オブジェクトは、ジェネリック パラメーターを表す、このプロパティを返します`null`します。  
  
   
  
## Examples  
 次の例では、クラスに関連付けられているアセンブリの名前と型の完全修飾名が表示されます。  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 次の例によって返される文字列の比較、<xref:System.Type.ToString%2A>メソッドと`Name`、 <xref:System.Type.FullName%2A>、および<xref:System.Type.AssemblyQualifiedName%2A>プロパティ。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">完全修飾型名の指定</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> に関連付けられている属性を取得します。</summary>
        <value><see cref="T:System.Reflection.TypeAttributes" /> の属性セットを表す <see cref="T:System.Type" /> オブジェクト。ただし、<see cref="T:System.Type" /> がジェネリック型パラメーターを表す場合、値は未指定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 いくつかのメンバー、<xref:System.Reflection.TypeAttributes>列挙体は値のグループを表すマスク。 各グループには、基になる値が 0、1 つのメンバーが含まれています。 たとえば、基になる値の<xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType>内のメンバー、<xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>グループが 0 の場合は、<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>内のメンバー、<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>グループ。 このため、これらの値をテストする前に、マスクを使用する必要があります。 具体的な例を次に示します。  
  
> [!TIP]
>  などのプロパティのほとんどの場合、 <xref:System.Type.IsClass%2A>、<xref:System.Type.IsAutoLayout%2A>、および<xref:System.Type.IsSpecialName%2A>型の属性より簡単に使用されます。  
  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、ジェネリック型定義の属性を返します。 たとえば、属性に対して返される`MyGenericClass<int>`(`MyGenericClass(Of Integer)` Visual Basic で) の属性`MyGenericClass<T>`(`MyGenericClass(Of T)` Visual Basic で)。  
  
 場合、現在<xref:System.Type>場合は、ジェネリック型パラメーター - を表します、<xref:System.Type.IsGenericParameter%2A>プロパティが返す`true`-<xref:System.Reflection.TypeAttributes>このプロパティによって返される値は指定されていません。  
  
   
  
## Examples  
 次の例のポイント<xref:System.Type.Attributes%2A>プロパティ。  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の直接の継承元である型を取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> の直接の継承元の <see cref="T:System.Type" />。現在の <see langword="null" /> が <see langword="Type" /> クラスまたはインターフェイスを表す場合は <see cref="T:System.Object" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基本型は、現在の型の直接の継承元となる型です。 <xref:System.Object> そのため、基本データ型をいない唯一の種類は、`null`の基本型として返される<xref:System.Object>します。  
  
 0 個以上の基底インターフェイスから継承するインターフェイスしたがって、このプロパティが返されます`null`場合、`Type`オブジェクトのインターフェイスを表します。 基底インターフェイスを決定できる<xref:System.Type.GetInterfaces%2A>または<xref:System.Type.FindInterfaces%2A>します。  
  
 場合、現在<xref:System.Type>構築ジェネリック型を表し、基本データ型はジェネリック引数を反映します。 たとえば、次のような宣言があるとします。  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 構築された型の`C<int>`(`C(Of Integer)` Visual basic)、<xref:System.Type.BaseType%2A>プロパティが返す`B<int>`します。  
  
 場合、現在<xref:System.Type>、ジェネリック型定義の型パラメーターを表して<xref:System.Type.BaseType%2A>クラス制約、型パラメーターを継承する必要があります、クラスを返します。 クラスの制約がない場合<xref:System.Type.BaseType%2A>返します<xref:System.Object?displayProperty=nameWithType>します。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例を使用して、<xref:System.Type.BaseType%2A>プロパティ。  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 次の例では、再帰を使用して、アセンブリで見つかった各クラスの完全な継承階層を一覧表示します。 例では、という名前のクラスを定義する`C`という名前のクラスから派生した`B`であり、という名前のクラスから派生、`A`します。  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> オブジェクトが特定の型で置き換えられていない型パラメーターを持っているかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> オブジェクト自体がジェネリック型パラメーターであるか、特定の型が指定されていない型パラメーターを持っている場合は <see cref="T:System.Type" />。そうでない場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型のインスタンスを作成するために必要がありますいないジェネリック型定義または型そのものの外側のジェネリック型またはいずれかの要素型の型引数でオープン構築型。 言い換えると、別の方法は、再帰的を調べたときに、型はジェネリック型パラメーターを含める必要がありますではありません。  
  
 型は任意に複雑になるために、この決定を行うは困難です。 便宜上、およびエラーの可能性を低減する、<xref:System.Type.ContainsGenericParameters%2A>プロパティは、インスタンス化できる、クローズ構築型を区別するために標準的な方法を提供し、オープン構築型で、このことはできません。 場合、<xref:System.Type.ContainsGenericParameters%2A>プロパティが返す`true`型をインスタンス化することはできません。  
  
 <xref:System.Type.ContainsGenericParameters%2A>プロパティは再帰的に、型パラメーターを検索します。 たとえばを返します`true`配列の要素が型`A<T>`(`A(Of T)` Visual Basic で)、配列はジェネリック自体がないにもかかわらず。 動作とは対照的、<xref:System.Type.IsGenericType%2A>を返すプロパティ`false`の配列。  
  
 例のクラスと、テーブルの値を示す一連の<xref:System.Type.ContainsGenericParameters%2A>プロパティを参照してください<xref:System.Type.IsGenericType%2A>します。  
  
   
  
## Examples  
 次の例では、2 つの型パラメーターを持つジェネリック クラスを定義し、最初のクラスから派生した 2 つ目のジェネリック クラスを定義します。 派生クラスの基本クラスは、2 つの型引数を持つ: 1 つは<xref:System.Int32>2 番目の派生型の型パラメーター。 によって報告される位置を含む、例では、これらのジェネリック クラスの概要情報を表示、<xref:System.Type.GenericParameterPosition%2A>プロパティ。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Reflection.MethodBase" /> がジェネリック メソッドの型パラメーターを表している場合に、宣言するメソッドを表す <see cref="T:System.Type" /> を取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> がジェネリック メソッドの型パラメーターを表している場合は、宣言メソッドを表す <see cref="T:System.Reflection.MethodBase" />。それ以外の場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 宣言するメソッドは、ジェネリック メソッド定義です。 場合<xref:System.Type.DeclaringMethod%2A>返さない`null`、し`DeclaringMethod.IsGenericMethodDefinition`返します`true`します。  
  
 <xref:System.Type.DeclaringType%2A>と<xref:System.Type.DeclaringMethod%2A>プロパティは、ジェネリック型定義またはジェネリック型パラメーターが定義された最初のジェネリック メソッド定義を識別します。  
  
-   場合、<xref:System.Type.DeclaringMethod%2A>プロパティが返す、 <xref:System.Reflection.MethodInfo>、その<xref:System.Reflection.MethodInfo>ジェネリック メソッド定義を表し、現在<xref:System.Type>オブジェクトのジェネリック メソッド定義の型パラメーターを表します。  
  
-   場合、<xref:System.Type.DeclaringMethod%2A>プロパティが返す`null`、<xref:System.Type.DeclaringType%2A>プロパティは常に返します、 <xref:System.Type> 、ジェネリック型定義と、現在を表すオブジェクト<xref:System.Type>オブジェクトは、そのジェネリック型の型パラメーターを表します。定義。  
  
-   取得する、<xref:System.Type.DeclaringMethod%2A>型のプロパティを持つ<xref:System.Type.IsGenericParameter%2A>プロパティは`false`がスローされます、 <xref:System.InvalidOperationException>。  
  
 <xref:System.Reflection.MethodBase>によって返される、<xref:System.Type.DeclaringMethod%2A>プロパティが、<xref:System.Reflection.MethodInfo>ジェネリック メソッドの場合、または<xref:System.Reflection.ConstructorInfo>ジェネリック コンス トラクターの場合。  
  
> [!NOTE]
>  .NET Framework version 2.0 では、ジェネリック コンス トラクターはサポートされていません。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次のコード例では、ジェネリック メソッドがありますし、メソッドに型引数を割り当てます、構築されたジェネリック メソッドを呼び出すクラスを定義します。 ジェネリック メソッド定義および構築されるメソッドに関する情報も表示されます。 ジェネリック メソッド定義の型パラメーターに関する情報を表示するときに、`DisplayGenericMethodInfo`メソッドの値を表示するコード例、<xref:System.Type.DeclaringMethod%2A>メソッドのジェネリック型パラメーターのプロパティ。  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の入れ子にされた型またはジェネリック型パラメーターを宣言する型を取得します。</summary>
        <value>現在の型が入れ子にされた型である場合、包含する型を表す <see cref="T:System.Type" /> オブジェクト。現在の型がジェネリック型の型パラメーターである場合、ジェネリック型定義。現在の型がジェネリック メソッドの型パラメーターである場合、ジェネリック メソッドを宣言する型。それ以外の場合、<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>オブジェクトがジェネリック型の型パラメーターを表す、このプロパティは、ジェネリック型定義を返します。  
  
 場合、現在<xref:System.Type>オブジェクトがジェネリック メソッドの型パラメーターを表す、このプロパティは、ジェネリック メソッド定義を含む型を返します。 型がジェネリックの場合は、ジェネリック型定義が返されます。 つまり、次のコードはのジェネリック型定義を返します、<xref:System.Collections.Generic.List%601>ジェネリック クラスが含まれている<xref:System.Collections.Generic.List%601.ConvertAll%2A>ジェネリック メソッド。  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 場合、現在<xref:System.Type>、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す、<xref:System.Type.DeclaringType%2A>と<xref:System.Type.DeclaringMethod%2A>プロパティは、ジェネリック型パラメーター、ジェネリック型定義またはジェネリック メソッド定義を識別定義されていました。  
  
-   場合、<xref:System.Type.DeclaringMethod%2A>プロパティが返す、 <xref:System.Reflection.MethodInfo>、その<xref:System.Reflection.MethodInfo>ジェネリック メソッド定義を表し、現在<xref:System.Type>オブジェクトのジェネリック メソッド定義の型パラメーターを表します。  
  
-   場合、<xref:System.Type.DeclaringMethod%2A>プロパティが返す`null`、<xref:System.Type.DeclaringType%2A>プロパティは常に返します、 <xref:System.Type> 、ジェネリック型定義と、現在を表すオブジェクト<xref:System.Type>オブジェクトは、そのジェネリック型の型パラメーターを表します。定義。  
  
-   取得する、<xref:System.Type.DeclaringType%2A>型のプロパティを持つ<xref:System.Type.IsGenericParameter%2A>プロパティは`false`がスローされます、 <xref:System.InvalidOperationException>。  
  
   
  
## Examples  
 この例では、派生クラスでメソッドの宣言型が表示されます。  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既定のバインダーへの参照を取得します。このバインダーは、<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> によって呼び出される適切なメンバーを選択するための内部規則を実装します。</summary>
        <value>システムで使用される既定のバインダーへの参照。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 共通言語ランタイムで提供される既定のバインダーでは、非常に特殊な状況がすべてに該当します。 派生した型バインダーとは異なる、指定された既定のバインダーの次のようにルールを定義する必要がある場合、<xref:System.Reflection.Binder>クラスし、を使用する型のインスタンスを渡す、`binder`のいずれかのパラメーター、<xref:System.Type.InvokeMember%2A>オーバー ロードします。  
  
 リフレクションは、共通型システムのアクセシビリティ規則をモデル化します。 たとえば、呼び出し元が同じアセンブリ内にある場合は、呼び出し元は必要ありません特殊なアクセス許可内部メンバー。 それ以外の場合、呼び出し元が必要な<xref:System.Security.Permissions.ReflectionPermission>します。 これは、保護されているメンバーの参照で一貫性のある、プライベート、およびなど。  
  
 一般原則を<xref:System.Reflection.Binder.ChangeType%2A>拡大変換で、データが失われることだけを実行する必要があります。 拡大変換の例では、64 ビット符号付き整数である値を 32 ビット符号付き整数である値を変換です。 これは、縮小変換にデータを失う可能性がありますから区別されます。 縮小変換の例は、64 ビット符号付き整数を 32 ビット符号付き整数に変換です。  
  
 次の表では、既定のバインダーでサポートされる変換を示します。  
  
|ソースの種類|ターゲットの種類|  
|-----------------|-----------------|  
|任意の型|その基本型。|  
|任意の型|実装するインターフェイスです。|  
|Char|Unt16、UInt32、Int32、UInt64、Int64 を Single、Double|  
|Byte|Char、Unt16、Int16、UInt32、Int32、UInt64、Int64、Single、Double|  
|SByte|Int16、Int32、Int64、Single、Double|  
|UInt16|UInt32、Int32、UInt64、Int64、Single、Double|  
|Int16|Int32、Int64、Single、Double|  
|UInt32|UInt64、Int64、Single、Double|  
|Int32|Int64、Single、Double|  
|UInt64|Single、Double|  
|Int64|Single、Double|  
|Single|倍精度浮動小数点型|  
|非参照|参照渡しされます。|  
  
   
  
## Examples  
 次の例から、既定のバインダーを取得する、`DefaultBinder`プロパティを渡すことによって、MyClass の単なるメンバーを呼び出すと、`DefaultBinder`へのパラメーターとして値<xref:System.Type.InvokeMember%2A>。  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> の名前空間で、複数の名前を区切ります。 このフィールドは読み取り専用です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> 型の空の配列を表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、`EmptyTypes`のいずれかで使用されるフィールド、`GetConstructor`メソッド パラメーターをとらないコンス トラクターを取得します。  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の基になるシステム型が、指定した <see cref="T:System.Object" /> または <see cref="T:System.Type" /> の基になるシステム型と同じかどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">基になるシステム型が、現在の <see cref="T:System.Type" /> の基になるシステム型との比較対象になるオブジェクト。 比較を成功させるには、<paramref name="o" /> をキャストまたは型 <see cref="T:System.Type" /> のオブジェクトに変換できる必要があります。</param>
        <summary>現在の <see cref="T:System.Type" /> オブジェクトの基になるシステム型が、指定した <see cref="T:System.Object" /> の基になるシステム型と同じかどうかを判断します。</summary>
        <returns><see langword="true" /> の基になるシステム型が現在の <paramref name="o" /> の基になるシステム型と同じである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。 次の場合にも、このメソッドは <see langword="false" /> を返します。  
  
-   <paramref name="o" /> は <see langword="null" /> です。  
  
-   <paramref name="o" /> をキャストまたは <see cref="T:System.Type" /> オブジェクトに変換できない。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Object.Equals%2A?displayProperty=nameWithType> をオーバーライドします。 キャストして`o`型のオブジェクトに<xref:System.Type>を呼び出すと、<xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType>メソッド。  
  
   
  
## Examples  
 次の例では<xref:System.Type.Equals%28System.Object%29>さまざまなを比較する<xref:System.Type>オブジェクト インスタンスと各種<xref:System.Object>インスタンス。  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 次の 2 つは、例では、について注目すべき特には。  
  
-   比較、<xref:System.Type>を表す整数を表すオブジェクトを<xref:System.Reflection.TypeInfo>戻り値の整数を表すオブジェクトを`true`ため<xref:System.Reflection.TypeInfo>から派生<xref:System.Type>します。  
  
-   比較、<xref:System.Type>を表すオブジェクトを<xref:System.Collections.Generic.IList%601>オブジェクト (オープン ジェネリック型)、`List(Of String)`オブジェクト (クローズ ジェネリック型) を返します`false`します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">基になるシステム型が、現在の <see cref="T:System.Type" /> の基になるシステム型との比較対象になるオブジェクト。</param>
        <summary>現在の <see cref="T:System.Type" /> の基になるシステム型が、指定した <see cref="T:System.Type" /> の基になるシステム型と同じかどうかを判断します。</summary>
        <returns><see langword="true" /> の基になるシステム型が現在の <paramref name="o" /> の基になるシステム型と同じである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では`Equals`2 つの型を比較します。  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>属性に適用するメンバー フィルターを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィールドによって使用されるデリゲートへの参照を保持する、<xref:System.Type.FindMembers%2A>メソッド。 このデリゲートによってカプセル化されるメソッドは 2 つのパラメーターを受け取ります。 1 つは、<xref:System.Reflection.MemberInfo>オブジェクトと、2 つ目は、、 `Object`。 メソッドを決定するかどうか、`MemberInfo`オブジェクトによって指定された条件に一致する、 `Object`。 `Object`クラスのフィールドのいずれかの値を割り当てることができます<xref:System.Reflection.FieldAttributes>、 <xref:System.Reflection.MethodAttributes>、または<xref:System.Reflection.MethodImplAttributes>します。  
  
 たとえば、`Object`からフィールドの値を割り当てることができる`FieldAttributes`Public など。 その場合は、`FilterAttribute`デリゲートの呼び出しが返されます`true`によって表されるメソッドの場合にのみ、`MemberInfo`オブジェクトはメタデータにパブリック フィールドの属性で修飾されます。  
  
   
  
## Examples  
 次の例では、取得、`FilterAttribute`デリゲート、パラメーターとして渡します、<xref:System.Type.FindMembers%2A>メソッド、し、指定されたメンバーとその属性を表示します。  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前に適用され、大文字と小文字を区別するメンバー フィルターを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィールドによって使用されるデリゲートへの参照を保持する、<xref:System.Type.FindMembers%2A>メソッド。 このデリゲートによってカプセル化されるメソッドは 2 つのパラメーターを受け取ります。 1 つは、<xref:System.Reflection.MemberInfo>オブジェクトと、2 つ目は、、 `Object`。 メソッドを決定するかどうか、`MemberInfo`オブジェクトによって指定された条件に一致する、 `Object`。 `Object` 、末尾を含む文字列値が割り当てられている"*"のワイルドカード文字です。 のみワイルドカード終了文字列の比較がサポートされています。  
  
 たとえば、 `Object` 「バイト *」、値を割り当てることができます。 その場合は、`FilterName`デリゲートの呼び出しが返されます`true`によって表されるメソッドの場合にのみ、 `MemberInfo` "Byte"で始まる名前が付きます。  
  
   
  
## Examples  
 次のコード例は、ユーザー定義に関連付けられているメソッドを取得します。`Application`型。  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前に適用され、大文字と小文字を区別しないメンバー フィルターを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィールドによって使用されるデリゲートへの参照を保持する、<xref:System.Type.FindMembers%2A>メソッド。 このデリゲートによってカプセル化されるメソッドは 2 つのパラメーターを受け取ります。 1 つは、<xref:System.Reflection.MemberInfo>オブジェクトと、2 つ目は、、 `Object`。 メソッドを決定するかどうか、`MemberInfo`オブジェクトによって指定された条件に一致する、 `Object`。 `Object` 、末尾を含む文字列値が割り当てられている"*"のワイルドカード文字です。 のみワイルドカード終了文字列の比較がサポートされています。  
  
 たとえば、 `Object` 「バイト *」、値を割り当てることができます。 その場合は、`FilterName`デリゲートが呼び出される、true を返しますのみによって表されるメソッド、 `MemberInfo` "byte"、大文字と小文字で始まる名前が付きます。  
  
   
  
## Examples  
 次の例では、取得、`MemberFilter`デリゲート、パラメーターとして渡します、<xref:System.Type.FindMembers%2A>メソッド、メソッドとその属性の表示と、`String`大文字と小文字を無視すると、文字"c"で始まるクラス。  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">インターフェイスを <paramref name="filterCriteria" /> と比較するデリゲート。</param>
        <param name="filterCriteria">返される配列に、検出したインターフェイスを含めるかどうかを判断する検索条件。</param>
        <summary>現在の <see cref="T:System.Type" /> によって実装または継承されているインターフェイスのフィルター適用済みリストを表す、<see cref="T:System.Type" /> オブジェクトの配列を返します。</summary>
        <returns>現在の <see cref="T:System.Type" /> によって実装または継承されたインターフェイスのフィルター処理されたリストを表している <see cref="T:System.Type" /> オブジェクトの配列。フィルターに一致するインターフェイスが現在の <see cref="T:System.Type" /> によって実装または継承されていない場合は、型 <see cref="T:System.Type" /> の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType>と<xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType>によって提供されるデリゲート、<xref:System.Reflection.Module?displayProperty=nameWithType>の lieu で、クラスを使用も可能性があります、<xref:System.Reflection.TypeFilter?displayProperty=nameWithType>を委任します。  
  
 基底クラスまたはこのクラス自体で宣言されているかどうか、検索中にこのクラスによって実装されるインターフェイスのすべてと見なされます。  
  
 このメソッドは、これらのインターフェイスの実装の各クラスは、すべての一致すると、一致するインターフェイスの各インターフェイスを返す、基底クラスの階層を検索 (つまり、一致するインターフェイスの推移閉包が返されます)。 重複するインターフェイスは返されません。  
  
 場合、現在<xref:System.Type>型パラメーター、ジェネリック型またはジェネリック メソッドの定義を表して<xref:System.Type.FindInterfaces%2A>型パラメーターの制約で宣言されているすべてのインターフェイスを検索し、インターフェイスによって継承されたすべてのインターフェイス制約で宣言されています。 場合、現在<xref:System.Type>、ジェネリック型の引数の型を表す<xref:System.Type.FindInterfaces%2A>制約に一致するかどうか、型によって実装されるすべてのインターフェイスを検索します。  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> 一般的ではない型であっても、ジェネリック インターフェイスを返すことができます。 たとえば、非ジェネリック型を実装`IEnumerable<int>`(`IEnumerable(Of Integer)` Visual Basic で)。  
  
   
  
## Examples  
 次の例では、指定したインターフェイスが実装または、指定した型によって継承され、インターフェイス名を表示しを検索します。  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">静的初期化子が呼び出され、例外をスローします。</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">検索するメンバーの型を示すオブジェクト。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <param name="filter">比較を実行して、現在調べているメンバーが <see langword="true" /> に一致する場合は <paramref name="filterCriteria" /> を返し、それ以外の場合は <see langword="false" /> を返すデリゲート。 このクラスで提供される <see langword="FilterAttribute" /> デリゲート、<see langword="FilterName" /> デリゲート、および <see langword="FilterNameIgnoreCase" /> デリゲートを使用できます。 1 つ目のデリゲートは、検索条件として <see langword="FieldAttributes" />、<see langword="MethodAttributes" />、<see langword="MethodImplAttributes" /> の各フィールドを使用し、他の 2 つのデリゲートは、検索条件として <see langword="String" /> オブジェクトを使用します。</param>
        <param name="filterCriteria"><see langword="MemberInfo" /> オブジェクトの配列でメンバーが返されたかどうかを判断する検索条件。  
  
<see langword="FieldAttributes" />、<see langword="MethodAttributes" />、<see langword="MethodImplAttributes" /> の各フィールドは、このクラスで提供される <see langword="FilterAttribute" /> デリゲートと組み合わせて使用できます。</param>
        <summary>指定したメンバー型の <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列にフィルターを適用して返します。</summary>
        <returns>指定したメンバー型の <see cref="T:System.Reflection.MemberInfo" /> オブジェクトのフィルター適用済みの配列。  
  
または 
現在の <see cref="T:System.Reflection.MemberInfo" /> に、フィルター条件に一致する <see cref="T:System.Type" /> 型のメンバーが存在しない場合は、<paramref name="memberType" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Instance`インスタンス メンバーを検索に含める。  
  
-   指定`BindingFlags.Static`検索に静的メンバーを含める。  
  
-   指定`BindingFlags.Public`検索にパブリック メンバーを含める。  
  
-   指定`BindingFlags.NonPublic`検索条件に非パブリック メンバー (つまり、プライベート、内部、および保護されたメンバー) を含める。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたメンバーのみを検索する、 <xref:System.Type>、継承されたメンバーされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 有効な値<xref:System.Type.MemberType%2A>で定義された<xref:System.Reflection.MemberInfo>します。 このようなメンバーが見つからない場合は、空の配列が返されます。  
  
 このメソッドを使用してクラス初期化子 (.cctor) を取得することを指定する必要があります<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic で)。 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティ。  
  
 場合、現在<xref:System.Type>、ジェネリック型またはジェネリック メソッドの型パラメーターを表して<xref:System.Type.FindMembers%2A>クラスの制約と型パラメーターのインターフェイスの制約で宣言されたすべてのメンバーを処理します。  
  
   
  
## Examples  
 次の例では、指定した検索条件に一致したクラス内のすべてのメンバーを検索し、一致するメンバーを表示します。  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の完全修飾名を取得します。その名前空間を含みますが、アセンブリは含みません。</summary>
        <value>型の完全修飾名で、名前空間を含むが、アセンブリは含まないもの。現在のインスタンスが、ジェネリック型パラメーター、配列型、ポインター型、または型パラメーターに基づく<see langword="null" /> 型、またはジェネリック型定義ではないが未解決の型パラメーターを含むジェネリック型を表す場合は、<see langword="byref" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば、完全修飾名の<xref:System.String>型は`System.String`します。 これによって返されるアセンブリ修飾名に対し、<xref:System.Type.AssemblyQualifiedName%2A>プロパティで、完全な名前と完全なアセンブリ名で構成されます。  
  
 文字列の型引数がによって返される現在の型はクローズ ジェネリック型を表している場合、<xref:System.Type.FullName%2A>プロパティは、その完全では、ジェネリック型パラメーター自体の文字列表現は修飾されていない場合でも、アセンブリの完全な名前によって修飾されますアセンブリ名。 次の例は、ジェネリック型定義を表す型とクローズ ジェネリック型を表す 1 つの FullName プロパティの違いを示しています。  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 このプロパティを返します`null`場合。  
  
-   現在<xref:System.Type>オブジェクトがジェネリック型の型パラメーターを表します。  
  
     次の例の型パラメーターの取得、<xref:System.Nullable%601>型と、表示しようとその<xref:System.Type.FullName%2A>プロパティ。  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   現在<xref:System.Type>オブジェクトは、ポインター型、配列型を表しますまたは`byref`ジェネリック型パラメーターに基づいている型。  
  
     次の例は、ジェネリック型を定義`Generictype1<T>`、3 つのメソッド: `Display(T[])`T 型の配列に渡します`HandleT(T)`、T は渡されると`ChangeValue(ref T)`T のオブジェクト参照によって渡されます。 C# および Visual Basic が内のポインターとして T を定義することに許可されないため、`HandleT`を呼び出すメソッドがある、<xref:System.Type.MakePointerType%2A>メソッドを<xref:System.Type>ジェネリック型へのポインターを作成するメソッドのパラメーターの型を表すオブジェクト。 例の出力は 3 つのすべてのケースで、<xref:System.Type.FullName%2A>プロパティは`null`します。  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   現在の型には、特定の型で置き換えられていないジェネリック型パラメーターが含まれています (つまり、<xref:System.Type.ContainsGenericParameters%2A>プロパティを返します。 `true`)、型がジェネリック型定義ではないが、(は、、<xref:System.Type.IsGenericTypeDefinition%2A>プロパティを返します。 `false`  
  
     次の例では、`Derived<T>`継承`Base<T>`します。 <xref:System.Type.BaseType%2A>プロパティを取得、<xref:System.Type>の基本型を表すオブジェクトを`Derived<T>`、およびその<xref:System.Type.FullName%2A>プロパティが返す`null`。  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     取得する、<xref:System.Type.FullName%2A>でない`null`、使用することができます、<xref:System.Type.GetGenericTypeDefinition%2A>例に示すように、ジェネリック型定義を取得するメソッド。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、指定した型の完全名が表示されます。  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 次の例によって返される文字列の比較、<xref:System.Type.ToString%2A>メソッドと`Name`、 <xref:System.Type.FullName%2A>、および<xref:System.Type.AssemblyQualifiedName%2A>プロパティ。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">完全修飾型名の指定</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のジェネリック型パラメーターの共変性および特殊な制約を説明する <see cref="T:System.Reflection.GenericParameterAttributes" /> フラグの組み合わせを取得します。</summary>
        <value>現在のジェネリック型パラメーターの共変性と特殊な制約を表す <see cref="T:System.Reflection.GenericParameterAttributes" /> 値のビットごとの組み合わせ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値には、現在のジェネリック型パラメーターが共変かどうかを示すフラグと特殊な制約を記述するフラグが含まれています。 使用して、<xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType>値を共変性フラグをオンにし、使用、<xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType>制約フラグを選択する値。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次のコード例は、ジェネリック型を定義します。`Test`をさまざまな制約を持つ 2 つの型パラメーターを使用します。 使用して、制約をチェックするプログラムを実行するとき、<xref:System.Type.GenericParameterAttributes%2A>プロパティおよび<xref:System.Type.GetGenericParameterConstraints%2A>メソッド。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の <see cref="T:System.Type" /> オブジェクトは、ジェネリック型パラメーターではありません。 つまり、<see cref="P:System.Type.IsGenericParameter" /> プロパティが <see langword="false" /> を返します。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> オブジェクトがジェネリック型またはジェネリック メソッドの型パラメーターを表す場合に、パラメーターを宣言したジェネリック型またはジェネリック メソッドの型パラメーター リスト内の型パラメーターの位置を取得します。</summary>
        <value>パラメーターを定義するジェネリック型またはジェネリック メソッドの型パラメーター リスト内の型パラメーターの位置。 位置の番号は 0 で始まります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GenericParameterPosition%2A>プロパティは、型パラメーターが最初に定義されているのジェネリック型定義またはジェネリック メソッド定義のパラメーター リストの型パラメーターの位置を返します。 <xref:System.Type.DeclaringType%2A>と<xref:System.Type.DeclaringMethod%2A>プロパティは、ジェネリック型またはジェネリック メソッド定義を識別します。  
  
-   場合、<xref:System.Type.DeclaringMethod%2A>プロパティが返す、 <xref:System.Reflection.MethodInfo>、その<xref:System.Reflection.MethodInfo>ジェネリック メソッド定義を表し、現在<xref:System.Type>オブジェクトのジェネリック メソッド定義の型パラメーターを表します。  
  
-   場合、<xref:System.Type.DeclaringMethod%2A>プロパティが返す`null`、<xref:System.Type.DeclaringType%2A>プロパティは常に返します、 <xref:System.Type> 、ジェネリック型定義と、現在を表すオブジェクト<xref:System.Type>オブジェクトは、そのジェネリック型の型パラメーターを表します。定義。  
  
 値を正しいコンテキストを提供する、<xref:System.Type.GenericParameterPosition%2A>プロパティは、ジェネリック型または型パラメーターが属するメソッドを識別するために必要です。 たとえば、ジェネリック メソッドの戻り値`GetSomething`次のコード。  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 によって返される型`GetSomething`クラスに指定された型引数に依存`A`と`GetSomething`自体。 取得することができます、<xref:System.Reflection.MethodInfo>の`GetSomething`から戻り値の型を取得したりできます。 戻り値の型の型パラメーターを調べる場合<xref:System.Type.GenericParameterPosition%2A>両方に対して 0 を返します。 位置`V`0 は、ため`V`クラスの型パラメーター リストの最初の型パラメーターは、`A`します。 位置`X`0 は、ため`X`の型パラメーター リストの最初の型パラメーターは、`GetSomething`します。  
  
> [!NOTE]
>  呼び出す、<xref:System.Type.GenericParameterPosition%2A>プロパティ例外が発生した場合、現在<xref:System.Type>型パラメーターを表していません。 使用して、オープン構築型の型引数を調べると、<xref:System.Type.IsGenericParameter%2A>型パラメーターであるし、型であるかを知らせるプロパティ。 <xref:System.Type.IsGenericParameter%2A>プロパティが返す`true`;、型パラメーターを使用できます、<xref:System.Type.GenericParameterPosition%2A>の位置を取得して使用するメソッド、<xref:System.Type.DeclaringMethod%2A>と<xref:System.Type.DeclaringType%2A>をジェネリック メソッドを確認したり、入力の定義を定義しているプロパティ.  
  
   
  
## Examples  
 次の例では、2 つの型パラメーターを持つジェネリック クラスを定義し、最初のクラスから派生した 2 つ目のジェネリック クラスを定義します。 派生クラスの基本クラスは、2 つの型引数を持つ: 1 つは<xref:System.Int32>、2 つ目は、派生型の型パラメーター。 によって報告される位置を含む、例では、これらのジェネリック クラスの概要情報を表示、<xref:System.Type.GenericParameterPosition%2A>プロパティ。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の型は型パラメーターを表していません。 つまり、<see cref="P:System.Type.IsGenericParameter" /> は <see langword="false" /> を返します。</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型のジェネリック型引数の配列を取得します。</summary>
        <value>この型のジェネリック型引数の配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、ジェネリック型引数のみを取得します。つまり、現在の型のジェネリック型パラメーターに指定されている型。 現在の型がジェネリック型定義の場合は、このプロパティは空の配列を返します。  
  
> [!NOTE]
>  ジェネリック型を別のジェネリック型またはジェネリック メソッドで使用する場合は、外側のメソッドまたは型のジェネリック型パラメーター、ジェネリック型引数の一部があります。  
  
 ジェネリック型定義を表す型のジェネリック型パラメーターを取得する、<xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType>プロパティ。 取得する、 <xref:System.Reflection.TypeInfo> 、現在のオブジェクト<xref:System.Type>オブジェクトを使用して、<xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType>拡張メソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>配列の次元数を取得します。</summary>
        <returns>現在の型の次元数である整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、配列の次元数が表示されます。  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドの機能は、基底クラスではサポートされていないため、代わりに派生クラスで実装する必要があります。</exception>
        <exception cref="T:System.ArgumentException">現在の型は配列ではありません。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされた場合、<see cref="P:System.Type.Attributes" /> プロパティを実装し、<see cref="T:System.Type" /> に関連付けられている属性を示すビットマスクを取得します。</summary>
        <returns><see cref="T:System.Reflection.TypeAttributes" /> の属性のセットを表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の特定のコンストラクターを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">目的のコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列。 このような空の配列は、<see langword="static" /> フィールド <see cref="F:System.Type.EmptyTypes" /> によって提供されます。</param>
        <summary>指定した配列の型に一致するパラメーターが設定されているパブリック インスタンス コンストラクターを検索します。</summary>
        <returns>パラメーター型配列の型と一致するパラメーターが設定されているパブリック インスタンス コンストラクターが存在する場合は、そのコンストラクターを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのオーバー ロードは、パブリック インスタンス コンス トラクターを検索し、クラス初期化子 (.cctor) を取得するのには使用できません。 クラス初期化子を取得するを受け取るオーバー ロードを使用して、 <xref:System.Reflection.BindingFlags>、し、指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic で)。 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティ。  
  
 このメソッドが戻るかどうか、要求されたコンス トラクターはパブリックでないは、`null`します。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.ConstructorInfo>適切な型引数に置き換え、型パラメーター。 場合、現在<xref:System.Type>、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す、このメソッドは常に返します`null`します。  
  
   
  
## Examples  
 次の例の種類を取得する`MyClass`、取得、<xref:System.Reflection.ConstructorInfo>オブジェクト、およびコンス トラクターのシグネチャが表示されます。  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> は <see langword="null" />です。  
  
または 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
または 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="types">取得するコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。  
  
または 
 <see cref="F:System.Type.EmptyTypes" />。</param>
        <param name="modifiers">パラメーター型配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</summary>
        <returns>指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表す <see cref="T:System.Reflection.ConstructorInfo" /> オブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完全一致が存在しない場合、`binder`で指定されたパラメーターの型を強制的に試行されます、`types`一致するものを選択するには配列です。 場合、`binder`が一致するを選択し、できない`null`が返されます。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるにどのコンス トラクターを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック コンス トラクターを検索します。  
  
-   指定`BindingFlags.NonPublic`検索条件に非パブリック コンス トラクター (つまり、プライベート、内部、および保護されたコンス トラクター) を含める。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドのオーバー ロードを使用してクラス初期化子 (.cctor) を取得することを指定する必要があります<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic で)。 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティ。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.ConstructorInfo>適切な型引数に置き換え、型パラメーター。 場合、現在<xref:System.Type>、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す、このメソッドは常に返します`null`します。  
  
   
  
## Examples  
 次のプログラムの種類を取得します`MyClass1`クラス、取得、<xref:System.Reflection.ConstructorInfo>オブジェクト、指定したバインディング フラグに一致して、コンス トラクターのシグネチャが表示されます。  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> は <see langword="null" />です。  
  
または 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
または 
 <paramref name="modifiers" /> が多次元です。  
  
または 
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
または 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップに関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したバインディング制約および指定した呼び出し規則を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</summary>
        <returns>指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーでは処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、抽象を使用する<xref:System.Reflection.Binder?displayProperty=nameWithType>カスタム バインダーでは処理を書き込むクラス`modifiers`します。 `ParameterModifier` COM 相互運用機能経由で呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみを処理します。  
  
 完全一致が存在しない場合、`binder`で指定されたパラメーターの型を強制的に試行されます、`types`一致するものを選択するには配列です。 場合、`binder`が一致するを選択し、できない`null`が返されます。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるにどのコンス トラクターを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック コンス トラクターを検索します。  
  
-   指定`BindingFlags.NonPublic`検索条件に非パブリック コンス トラクター (つまり、プライベート、内部、および保護されたコンス トラクター) を含める。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドを使用してクラス初期化子 (.cctor) を取得することを指定する必要があります<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic で)。 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティ。  
  
 次の表は、基底クラスのメンバーがによって返される、`Get`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.ConstructorInfo>適切な型引数に置き換え、型パラメーター。 場合、現在<xref:System.Type>、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す、このメソッドは常に返します`null`します。  
  
   
  
## Examples  
 次の例の種類を取得する`MyClass1`、取得、<xref:System.Reflection.ConstructorInfo>オブジェクトを指定したバインディング フラグに一致し、コンス トラクターのシグネチャを表示します。  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> は <see langword="null" />です。  
  
または 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
または 
 <paramref name="modifiers" /> が多次元です。  
  
または 
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
または 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップに関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約および指定した呼び出し規則を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</summary>
        <returns>指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表す <see cref="T:System.Reflection.ConstructorInfo" /> オブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーでは処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、抽象を使用する<xref:System.Reflection.Binder?displayProperty=nameWithType>カスタム バインダーでは処理を書き込むクラス`modifiers`します。 `ParameterModifier` COM 相互運用機能経由で呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみを処理します。  
  
 完全一致が存在しない場合、`binder`で指定されたパラメーターの型を強制的に試行されます、`types`一致するものを選択するには配列です。 場合、`binder`が一致するを選択し、できない`null`が返されます。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるにどのコンス トラクターを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック コンス トラクターを検索します。  
  
-   指定`BindingFlags.NonPublic`検索条件に非パブリック コンス トラクター (つまり、プライベート、内部、および保護されたコンス トラクター) を含める。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドは、<xref:System.Type.GetConstructor%2A> を実装します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> は <see langword="null" />です。  
  
または 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
または 
 <paramref name="modifiers" /> が多次元です。  
  
または 
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <exception cref="T:System.NotSupportedException">現在の型は <see cref="T:System.Reflection.Emit.TypeBuilder" /> または <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> です。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のコンストラクターを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> に対して定義されているパブリック コンストラクターをすべて返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.ConstructorInfo" /> に対して定義されたすべてのパブリック インスタンス コンストラクター (ただし、型初期化子 (静的コンストラクター) を除く) を表している <see cref="T:System.Type" /> オブジェクトの配列。 パブリック インスタンス コンストラクターが現在の <see cref="T:System.Type" /> に対して定義されている場合、または現在の <see cref="T:System.Type" /> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、型 <see cref="T:System.Reflection.ConstructorInfo" /> の空の配列が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A>メソッドでは、宣言の順序などの特定の順序では、コンス トラクターは返しません。 コードする必要があります依存、コンス トラクターが返される順序にする順序が異なります。  
  
 次の表は、基底クラスのメンバーがによって返される、`Get`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 このメソッドのオーバー ロードを呼び出す、<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>メソッド オーバー ロードで<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> Visual Basic で)。 クラスの初期化子 (.cctor) が見つかりません。 クラスの初期化子を検索するを受け取るオーバー ロードを使用して、 <xref:System.Reflection.BindingFlags>、し、指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic で)。 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティ。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.ConstructorInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。 たとえば場合、クラス`C<T>`コンス トラクターを持つ`C(T t1)`(`Sub New(ByVal t1 As T)` Visual Basic で) を呼び出すと、<xref:System.Type.GetConstructors%2A>で`C<int>`を返します、<xref:System.Reflection.ConstructorInfo>を表す`C(int t1)`(C#) (`Sub New(ByVal t1 As Integer)` Visual Basic で)。  
  
 場合、現在<xref:System.Type>がジェネリック型パラメーターを表す、<xref:System.Type.GetConstructors%2A>メソッドは空の配列を返します。  
  
   
  
## Examples  
 この例の出力を示しています、 <xref:System.Type.GetConstructors%2A> 2 つのインスタンス コンス トラクターと 1 つの静的コンス トラクターを持つクラスからをオーバー ロードします。  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 このコードの出力は次のとおりです。  
  
 2  
  
 False  
  
 False  
  
 <xref:System.Type.GetConstructors>のみに使用するオーバー ロード<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>と<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>、静的コンス トラクターはカウントも、`for`式によって評価も`IsStatic`します。  
  
 静的コンス トラクターを検索するには、使用、 <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> 、オーバー ロードし、組み合わせを渡す (論理`OR`) の<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>、 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>次のコード例のように。  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 出力は、ようになりました。  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定した <see langword="BindingFlags" /> を使用して、現在の <see cref="T:System.Type" /> に対して定義されているコンストラクターを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.ConstructorInfo" /> にコンストラクターが定義されている場合は、型初期化子を含め、定義されているコンストラクターのうち指定したバインディング制約に一致するすべてのコンストラクターを表す <see cref="T:System.Type" /> オブジェクトの配列。 現在の <see cref="T:System.Type" /> に対してコンストラクターが定義されていない場合、または現在の <see cref="T:System.Type" /> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、型 <see cref="T:System.Reflection.ConstructorInfo" /> の空の配列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A>メソッドでは、宣言の順序などの特定の順序では、コンス トラクターは返しません。 コードする必要があります依存、コンス トラクターが返される順序にする順序が異なります。  
  
 `bindingAttr` パブリック コンス トラクターまたはパブリックと非パブリック コンス トラクターのみを返すかどうかを指定するために使用します。  
  
 完全一致が存在しない場合、`binder`で指定されたパラメーターの型を強制的に試行されます、`types`一致するものを選択するには配列です。 場合、`binder`が一致するを選択し、できない`null`が返されます。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるにどのコンス トラクターを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック コンス トラクターを検索します。  
  
-   指定`BindingFlags.NonPublic`検索条件に非パブリック コンス トラクター (つまり、プライベート、内部、および保護されたコンス トラクター) を含める。 基本クラスのコンス トラクターは返されません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドのオーバー ロードを使用してクラス初期化子 (.cctor) を取得することを指定する必要があります<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic で)。 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティ。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.ConstructorInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。 たとえば場合、クラス`C<T>`コンス トラクターを持つ`C(T t1)`(`Sub New(ByVal t1 As T)` Visual Basic で) を呼び出すと、<xref:System.Type.GetConstructors%2A>で`C<int>`を返します、<xref:System.Reflection.ConstructorInfo>を表す`C(int t1)`(C#) (`Sub New(ByVal t1 As Integer)` Visual Basic で)。  
  
 場合、現在<xref:System.Type>がジェネリック型パラメーターを表す、<xref:System.Type.GetConstructors%2A>メソッドは空の配列を返します。  
  
   
  
## Examples  
 この例の出力を示しています、 <xref:System.Type.GetConstructors> 2 つのインスタンス コンス トラクターと 1 つの静的コンス トラクターを持つクラスからをオーバー ロードします。  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 このコードの出力は次のとおりです。  
  
 2  
  
 False  
  
 False  
  
 <xref:System.Type.GetConstructors%2A>のみに使用するオーバー ロード<xref:System.Reflection.BindingFlags.Public>と<xref:System.Reflection.BindingFlags.Instance>、静的コンス トラクターはカウントも、`for`式によって評価も`IsStatic`します。  
  
 静的コンス トラクターを検索するには、使用、 <xref:System.Type.GetConstructors%2A> 、オーバー ロードし、の組み合わせ (論理 OR) を渡す<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>、 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>次のコード例のように。  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 出力は、ようになりました。  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Type" /> が設定されている現在の <see cref="T:System.Reflection.DefaultMemberAttribute" /> に定義されているメンバーを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.MemberInfo" /> のすべての既定メンバーを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
現在の <see cref="T:System.Reflection.MemberInfo" /> に既定のメンバーがない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetDefaultMembers%2A>メソッドが返さないメンバーを特定の順序でなど、アルファベット順または宣言の順序。 コードする必要があります依存、メンバーが返される順序にする順序が異なります。  
  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 次の表は、基底クラスのメンバーがによって返される、`Get`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.MemberInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。 たとえば場合、クラス`C<T>`プロパティがあります`P`を返す`T`を呼び出すと、<xref:System.Type.GetDefaultMembers%2A>で`C<int>`返します`int P`(C#) (`Property P As Integer` Visual Basic で)。  
  
 場合、現在<xref:System.Type>クラスの制約のメンバー、またはのメンバーを表すジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーター検索<xref:System.Object>クラスの制約がない場合。  
  
   
  
## Examples  
 次の例の既定のメンバー情報を取得する`MyClass`し、既定のメンバーを表示します。  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされた場合、現在の配列、ポインター、または参照型によって包含または参照されるオブジェクトの <see cref="T:System.Type" /> を返します。</summary>
        <returns>現在の配列、ポインター、または参照型によって包含または参照されるオブジェクトの <see cref="T:System.Type" />。現在の <see langword="null" /> が配列またはポインターではない場合、参照によって渡されない場合、ジェネリック型やジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、<see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る`null`の<xref:System.Array>クラス。  
  
   
  
## Examples  
 次の例を使用して、`GetElementType`メソッド。  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">名前を取得する対象の値。</param>
        <summary>現在の列挙型の指定された値を持つ定数の名前を返します。</summary>
        <returns>指定された値を持つ現在の列挙型のメンバーの名前。そのような定数が見つからない場合は、<see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。  
  
または 
 <paramref name="value" /> は、現在の型ではなく、基になる型が現在の型と同じでもありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の列挙型のメンバーの名前を返します。</summary>
        <returns>列挙型のメンバーの名前が含まれている配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 戻り値の配列の要素は、列挙定数のバイナリ値 (つまり、符号なしの値) に基づいて並べ替えられます。 配列に同じ値を持つ列挙型の定数が含まれている場合は、対応する名前の順序は指定されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の列挙型の基になる型を返します。</summary>
        <returns>現在の列挙型の基になる型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C# および Visual Basic での列挙の基になる型は、既定では、<xref:System.Int32>します。 その他の整数型を指定することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。  
  
または 
列挙型に複数のインスタンス フィールドが含まれているため、無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の列挙型の定数の値の配列を返します。</summary>
        <returns>値を格納する配列。 配列の要素は列挙定数のバイナリ値 (符号なしの値) に基づいて並べ替えられます。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> で宣言または継承されている特定のイベントを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">現在の <see cref="T:System.Type" /> で宣言または継承されているイベントの名前を格納する文字列。</param>
        <summary>指定したパブリック イベントを表す <see cref="T:System.Reflection.EventInfo" /> オブジェクトを返します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で宣言または継承されている指定パブリック イベントが存在する場合は、そのイベントを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 少なくとも 1 つのメソッドまたはパブリック アクセサーがある場合、このイベントはリフレクションには、パブリックと見なされます。 それ以外の場合、イベントは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) を取得します。  
  
 検索`name`小文字が区別されます。 検索には、static および public インスタンスのパブリック イベントが含まれています。  
  
 次の表は、基底クラスのメンバーがによって返される、`Get`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.EventInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のイベントを検索します。  
  
   
  
## Examples  
 次の例では、作成、<xref:System.Reflection.EventInfo>オブジェクトし、指定したイベントの button クラスのイベントを取得します。  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">現在の <see cref="T:System.Type" /> で宣言または継承されているイベントの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定されたバイディング制約を使用して、指定されたイベントを表わす <see cref="T:System.Reflection.EventInfo" /> オブジェクトを返します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で宣言または継承されている指定イベントが存在する場合は、そのイベントを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるイベントを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック イベントを検索します。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないイベント (たとえば、プライベート、内部、および保護されたイベントなど) を含める。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase` 大文字と小文字を無視する`name`します。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたイベントのみを検索、 <xref:System.Type>、継承されたイベントされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 少なくとも 1 つのメソッドまたはパブリック アクセサーがある場合、このイベントはリフレクションには、パブリックと見なされます。 それ以外の場合、イベントは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) を取得します。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.EventInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のイベントを検索します。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29>パブリックまたはパブリックでないイベントの「クリックして」という名前のない型を検索するメソッド`static`(`Shared` Visual Basic で)。  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> で宣言または継承されているイベントを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> で宣言または継承されているすべてのパブリック イベントを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.EventInfo" /> で宣言または継承されているすべてのパブリック イベントを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
現在の <see cref="T:System.Reflection.EventInfo" /> にパブリック イベントがない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 少なくとも 1 つのメソッドまたはパブリック アクセサーがある場合、このイベントはリフレクションには、パブリックと見なされます。 それ以外の場合、イベントは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) を取得します。  
  
 <xref:System.Type.GetEvents%2A>メソッドが返さないイベントでは、特定の順序など、アルファベット順または宣言の順序。 コードする必要があります依存、イベントが返される順序にする順序が異なります。  
  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 次の表は、基底クラスのメンバーがによって返される、`Get`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.EventInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のイベントを検索します。  
  
   
  
## Examples  
 次の例の配列を取得する<xref:System.Reflection.EventInfo>オブジェクトをすべてのイベントを取得、`Button`クラス、およびイベント名が表示されます。 Visual Basic の例をコンパイルするには、次のコマンドラインを使用します。  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> で宣言または継承されているイベントを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.EventInfo" /> で宣言または継承されているイベントのうち、指定したバインディング制約に一致するすべてのイベントを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
現在の <see cref="T:System.Reflection.EventInfo" /> にイベントが存在しないか、またはイベントの中にバインディング制約に一致するものがない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetEvents%2A>メソッドが返さないイベントでは、特定の順序など、アルファベット順または宣言の順序。 コードする必要があります依存、イベントが返される順序にする順序が異なります。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるイベントを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック イベントを検索します。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないイベント (たとえば、プライベート、内部、および保護されたイベントなど) を含める。 保護のみ、基底クラスの内部のイベントが返されます。基底クラスにプライベート イベントは返されません。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたイベントのみを検索、 <xref:System.Type>、継承されたイベントされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 少なくとも 1 つのメソッドまたはパブリック アクセサーがある場合、このイベントはリフレクションには、パブリックと見なされます。 それ以外の場合、イベントは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) を取得します。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.EventInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のイベントを検索します。  
  
   
  
## Examples  
 次の例の配列を取得する<xref:System.Reflection.EventInfo>、指定したバインディング フラグに一致するオブジェクトのすべてのイベントの取得、`Button`クラス、およびイベント名が表示されます。 Visual Basic の例をコンパイルするには、次のコマンドラインを使用します。  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の特定のフィールドを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するデータ フィールドの名前を格納している文字列。</param>
        <summary>指定した名前のパブリック フィールドを検索します。</summary>
        <returns>指定した名前のパブリック フィールドが存在する場合は、そのフィールドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス フィールドが含まれています。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.FieldInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のフィールドを検索します。  
  
   
  
## Examples  
 次の例では、取得、`Type`指定したクラスのオブジェクトを取得、<xref:System.Reflection.FieldInfo>フィールドに、オブジェクト フィールドの値を表示します。  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">この <see cref="T:System.Type" /> オブジェクトは、<see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> メソッドがまだ呼び出されていない <see cref="T:System.Reflection.Emit.TypeBuilder" /> です。</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得するデータ フィールドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <summary>指定したバインディング制約を使用して、指定したフィールドを検索します。</summary>
        <returns>指定した要件と一致するフィールドが存在する場合は、そのフィールドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、基底クラスのメンバーがによって返される、`Get`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるフィールドを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック フィールドを検索します。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないフィールド (つまり、プライベート、内部、および保護されているフィールド) を含める。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase` 大文字と小文字を無視する`name`します。  
  
-   `BindingFlags.DeclaredOnly` 宣言されているフィールドのみを検索する、<xref:System.Type>は継承されたフィールド。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.FieldInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のフィールドを検索します。  
  
   
  
## Examples  
 次の例では、取得、`Type`指定したクラスのオブジェクトを取得、<xref:System.Reflection.FieldInfo>オブジェクト フィールドの指定したバインディング フラグと一致して、フィールドの値を表示します。  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のフィールドを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のすべてのパブリック フィールドを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.FieldInfo" /> に対して定義されているすべてのパブリック フィールドを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
現在の <see cref="T:System.Reflection.FieldInfo" /> に対してパブリック フィールドが定義されていない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A>メソッドが返さないフィールドで特定の順序など、アルファベット順または宣言の順序。 コードする必要があります依存、フィールドが返される順序にする順序が異なります。  
  
 次の表は、基底クラスのメンバーがによって返される、`Get`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.FieldInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のパブリック フィールドを検索します。  
  
   
  
## Examples  
 次の例を使用して、`GetFields()`メソッド。  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> に対して定義されているフィールドを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.FieldInfo" /> に対して定義されているフィールドのうち、指定したバインディング制約に一致するすべてのフィールドを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
現在の <see cref="T:System.Reflection.FieldInfo" /> に対してフィールドが定義されていないか、または定義されているフィールドの中にバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A>メソッドが返さないフィールドで特定の順序など、アルファベット順または宣言の順序。 コードする必要があります依存、フィールドが返される順序にする順序が異なります。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるフィールドを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック フィールドを検索します。  
  
-   指定`BindingFlags.NonPublic`検索にパブリックでないフィールド (つまり、プライベート、内部、および保護されているフィールド) を含める。 保護のみ、基底クラスの内部フィールドが返されます。基底クラスにプライベート フィールドは返されません。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly` 宣言されているフィールドのみを検索する、<xref:System.Type>は継承されたフィールド。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.FieldInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のパブリック フィールドを検索します。  
  
   
  
## Examples  
 次の例を使用して、`GetFields(BindingFlags)`メソッド。  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>クローズ ジェネリック型の型引数またはジェネリック型定義の型パラメーターを表す <see cref="T:System.Type" /> オブジェクトの配列を返します。</summary>
        <returns>ジェネリック型の型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。 現在の型がジェネリック型でない場合は空の配列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ジェネリック型の型引数の一覧に表示される順序では、配列の要素が返されます。  
  
-   現在の型が構築されたクローズ型の場合 (つまり、<xref:System.Type.ContainsGenericParameters%2A>プロパティから返さ`false`)、によって返される配列、<xref:System.Type.GetGenericArguments%2A>メソッドには、ジェネリック型定義のジェネリック型パラメーターに割り当てられている型が含まれています。  
  
-   現在の型がジェネリック型定義の場合は、配列には、型パラメーターが含まれています。  
  
-   現在の型がオープン構築型の場合 (つまり、<xref:System.Type.ContainsGenericParameters%2A>プロパティが返す`true`) ですべての型パラメーターと外側のジェネリック型またはメソッドの型パラメーターにどのような種類が割り当てられていない、配列が含まれます型と型パラメーターの両方。 使用して、<xref:System.Type.IsGenericParameter%2A>見分けるプロパティ。 このシナリオの例については、コード例を参照してください、<xref:System.Type.ContainsGenericParameters%2A>プロパティ。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Type.GetGenericArguments%2A>構築された型の型引数およびジェネリック型定義の型パラメーターを表示するメソッド。  
  
 このコード例が示されている例の一部、<xref:System.Type.IsGenericTypeDefinition%2A>プロパティ。 サンプル出力の例を参照してください。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のジェネリック型パラメーターの制約を表す <see cref="T:System.Type" /> オブジェクトの配列を返します。</summary>
        <returns>現在のジェネリック型パラメーターの制約を表す <see cref="T:System.Type" /> の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ジェネリック型パラメーターの各制約を表した、<xref:System.Type>オブジェクト。 使用して、<xref:System.Type.IsClass%2A>プロパティの制約は、基底クラスの制約であるかどうかはかどうか、プロパティを返します`false`制約、インターフェイスの制約。 型パラメーターは、クラス制約のない、インターフェイス制約はありませんがある、空の配列が返されます。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次のコード例は、ジェネリック型を定義します。`Test`をさまざまな制約を持つ 2 つの型パラメーターを使用します。 使用して、制約をチェックするプログラムを実行するとき、<xref:System.Type.GenericParameterAttributes%2A>プロパティおよび<xref:System.Type.GetGenericParameterConstraints%2A>メソッド。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の <see cref="T:System.Type" /> オブジェクトは、ジェネリック型パラメーターではありません。 つまり、<see cref="P:System.Type.IsGenericParameter" /> プロパティが <see langword="false" /> を返します。</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のジェネリック型を構築する元になるジェネリック型定義を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>現在の型を構築する元になるジェネリック型を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ジェネリック型定義は、他の型を構築するためのテンプレートです。 たとえば、ジェネリック型定義から`G<T>`(c# の構文で表現します。`G(Of T)` Visual basic または`generic <typename T> ref class G`C++ で) 作成して、型をインスタンス化`G<int>`(`G(Of Integer)` Visual Basic で)。 指定された、<xref:System.Type>これを表すオブジェクトの構築型を<xref:System.Type.GetGenericTypeDefinition%2A>メソッドがジェネリック型定義を返します。  
  
 構築された 2 つの型が同じジェネリック型定義から作成する場合は、同じの型引数を使用して、<xref:System.Type.GetGenericTypeDefinition%2A>メソッドは、同じを返します<xref:System.Type>両方の種類のオブジェクト。  
  
 呼び出す場合、<xref:System.Type.GetGenericTypeDefinition%2A>メソッドを<xref:System.Type>既に、ジェネリック型定義を表すオブジェクトを現在を返して、<xref:System.Type>します。  
  
> [!IMPORTANT]
>  ジェネリック型の配列はジェネリックではありません。 C# コードで`A<int>[] v;`または Visual Basic コード`Dim v() As A(Of Integer)`、変数の型`v`ジェネリックではありません。 使用<xref:System.Type.IsGenericType%2A>型が呼び出しの前にジェネリックかどうかを判断する<xref:System.Type.GetGenericTypeDefinition%2A>します。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次のコード例が通常のインスタンスの作成を使用して構築された型のインスタンスを作成し、を使用して、<xref:System.Type.GetType%2A>と<xref:System.Type.GetGenericTypeDefinition%2A>構築型とジェネリック型定義を取得するメソッド。 この例は、ジェネリックを使用して<xref:System.Collections.Generic.Dictionary%602>型は、構築型を表す、<xref:System.Collections.Generic.Dictionary%602>の`Test`文字列キーを持つオブジェクト。  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の型はジェネリック型ではありません。  つまり、<see cref="P:System.Type.IsGenericType" /> は <see langword="false" /> を返します。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスのハッシュ コードを返します。</summary>
        <returns>対象のインスタンスのハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> をオーバーライドします。  
  
   
  
## Examples  
 次の例のハッシュ コードを表示する、`System.Windows.Forms.Button`クラス。  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> で実装または継承されている特定のインターフェイスを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するインターフェイスの名前を格納している文字列。 ジェネリック インターフェイスの場合、これは完全修飾名です。</param>
        <summary>指定した名前のインターフェイスを検索します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で実装または継承されているインターフェイスのうち、指定した名前のインターフェイスが存在する場合は、そのインターフェイスを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索`name`小文字が区別されます。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Type>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>表しますジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーターは、インターフェイスの制約と制約のクラスまたはインターフェイスから継承されたすべてのインターフェイスを検索します。  
  
> [!NOTE]
>  ジェネリック インターフェイスの場合、`name`パラメーターは、アクサン グラーブで終わる、完全修飾名 (\`) と、型パラメーターの数。 これは、ジェネリック インターフェイスの定義と構築されたジェネリック インターフェイスの両方に当てはまります。 たとえば、検索する`IExample<T>`(`IExample(Of T)` Visual basic) または`IExample<string>`(`IExample(Of String)` Visual Basic で)、検索``"IExample`1"``。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Type.GetInterface%28System.String%29>を検索するメソッド、<xref:System.Collections.Hashtable>クラス、<xref:System.Runtime.Serialization.IDeserializationCallback>インターフェイス、およびインターフェイスのメソッドのリスト。  
  
 コード例も示しています、<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>メソッドのオーバー ロードと<xref:System.Type.GetInterfaceMap%2A>メソッド。  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">現在の <see cref="T:System.Type" /> は、別の型の引数と同じジェネリック インターフェイスを実装する型を表します。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">取得するインターフェイスの名前を格納している文字列。 ジェネリック インターフェイスの場合、これは完全修飾名です。</param>
        <param name="ignoreCase">単純なインターフェイス名を指定する <see langword="true" /> の部分 (名前空間が大文字と小文字を厳密に区別することを指定されている部分) で大文字と小文字の区別を無視する場合は、<paramref name="name" />。  
  
または 
 <see langword="false" /> のすべての部分の検索時に大文字と小文字を区別する場合は、<paramref name="name" />。</param>
        <summary>派生クラスでオーバーライドされた場合、インターフェイス名の大文字と小文字を区別するかどうかを指定して、指定したインターフェイスを検索します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で実装または継承されているインターフェイスのうち、指定した名前のインターフェイスが存在する場合は、そのインターフェイスを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ignoreCase`パラメーターの名前空間にない、単純なインターフェイス名にのみ適用されます。 部分`name`名前空間が正しい場合は、必要またはインターフェイスは検出されませんを指定します。 たとえば、文字列"System.icomparable"を検索、<xref:System.IComparable>インターフェイスが、文字列"system.icomparable"しません。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Type>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>表しますジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーターは、インターフェイスの制約と制約のクラスまたはインターフェイスから継承されたすべてのインターフェイスを検索します。  
  
> [!NOTE]
>  ジェネリック インターフェイスの場合、`name`パラメーターは、アクサン グラーブで終わる、完全修飾名 (\`) と、型パラメーターの数。 これは、ジェネリック インターフェイスの定義と構築されたジェネリック インターフェイスの両方に当てはまります。 たとえば、検索する`IExample<T>`(`IExample(Of T)` Visual basic) または`IExample<string>`(`IExample(Of String)` Visual Basic で)、検索`"IExample`1"'。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>の検索を実行するメソッド、<xref:System.Collections.Hashtable>クラス、<xref:System.Collections.IEnumerable>インターフェイス。  
  
 コード例も示しています、<xref:System.Type.GetInterface%28System.String%29>メソッドのオーバー ロードと<xref:System.Type.GetInterfaceMap%2A>メソッド。  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">現在の <see cref="T:System.Type" /> は、別の型の引数と同じジェネリック インターフェイスを実装する型を表します。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">割り当ての取得対象であるインターフェイス型。</param>
        <summary>指定したインターフェイス型に対するインターフェイスの割り当てを返します。</summary>
        <returns><paramref name="interfaceType" /> に対するインターフェイスの割り当てを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インターフェイス マップは、そのインターフェイスを実装するクラスの実際のメンバーにインターフェイスをマップする方法を示します。  
  
 場合、現在<xref:System.Type>構築されたジェネリック型パラメーターは、要素の適切な型引数に置き換えの種類を表す、<xref:System.Reflection.InterfaceMapping>このメソッドによって返されます。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.GetInterfaceMap%2A>メソッドを判断する方法、<xref:System.IFormatProvider>インターフェイスにマップ<xref:System.Globalization.CultureInfo>メソッド、する方法と、<xref:System.IAppDomainSetup>インターフェイスにマップ<xref:System.AppDomainSetup>プロパティ。 に、注意してください、<xref:System.IAppDomainSetup>インターフェイスは、返されたプロパティのセットを定義<xref:System.Reflection.InterfaceMapping>オブジェクトは個別に<xref:System.Reflection.MethodInfo>プロパティの get および set アクセサーのオブジェクト。  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="interfaceType" /> は、現在の型では実装されていません。  
  
または 
<paramref name="interfaceType" /> 引数は、インターフェイスを参照しません。  
  
または

現在のインスタンスまたは <paramref name="interfaceType" /> 引数はオープン ジェネリック型です。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> プロパティは <see langword="true" /> を返します。

または


 <paramref name="interfaceType" /> ジェネリック インターフェイスで、現在の型は配列型です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">現在の <see cref="T:System.Type" /> はジェネリック型パラメーターを表しています。つまり、<see cref="P:System.Type.IsGenericParameter" /> は <see langword="true" /> です。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラス内でオーバーライドされた場合、現在の <see cref="T:System.Type" /> で実装または継承されているすべてのインターフェイスを取得します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で実装または継承されているすべてのインターフェイスを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
現在の <see cref="T:System.Type" /> で実装または継承されているインターフェイスが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetInterfaces%2A>メソッドが返さないインターフェイスでは、特定の順序など、アルファベット順または宣言の順序。 コードする必要があります依存、インターフェイスが返される順序にする順序が異なります。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Type>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>表しますジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーターは、インターフェイスの制約と制約のクラスまたはインターフェイスから継承されたすべてのインターフェイスを検索します。  
  
   
  
## Examples  
 次の例では、指定したクラスの型を取得し、すべてのインターフェイスを実装または継承する型を表示します。 Visual Basic の例をコンパイルするには、次のコンパイラ コマンドを使用します。  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">静的初期化子が呼び出され、例外をスローします。</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のメンバーのうち、指定したメンバーを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メンバーの名前を格納している文字列。</param>
        <summary>指定した名前のパブリック メンバーを検索します。</summary>
        <returns>指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列。それ以外の場合は空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索`name`小文字が区別されます。 検索には、static および public インスタンスのパブリック メンバーが含まれています。  
  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 <xref:System.Type.GetMember%2A>メソッドが返さないメンバーを特定の順序でなど、アルファベット順または宣言の順序。 コードする必要があります依存、メンバーが返される順序にする順序が異なります。  
  
 このメソッドのオーバー ロードがクラスの初期化子 (.cctor) が見つかりません。 クラスの初期化子を検索するを受け取るオーバー ロードを使用して、 <xref:System.Reflection.BindingFlags>、し、指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic で)。 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティ。  
  
 次の表は、基底クラスのメンバーがによって返される、`Get`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.MemberInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>クラスの制約のメンバー、またはのメンバーを表すジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーター検索<xref:System.Object>クラスの制約がない場合。  
  
> [!NOTE]
>  ジェネリック メソッドを含めないでくださいで型引数`name`します。 たとえば、c# のコード`GetMember("MyMethod<int>")`テキスト名を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つの汎用引数を持つ`int`します。  
  
   
  
## Examples  
 次の例のすべてのメンバーの表示、`String`文字 C で始まるクラス  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得するメンバーの名前を含む文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
空の配列を返す場合は 0。</param>
        <summary>指定したバインディング制約を使用して、指定したメンバーを検索します。</summary>
        <returns>指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列。それ以外の場合は空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 <xref:System.Type.GetMember%2A>メソッドが返さないメンバーを特定の順序でなど、アルファベット順または宣言の順序。 コードする必要があります依存、メンバーが返される順序にする順序が異なります。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック メンバーを含める。  
  
-   指定`BindingFlags.NonPublic`検索条件に非パブリック メンバー (つまり、プライベート、内部、および保護されたメンバー) を含める。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase` 大文字と小文字を無視する`name`します。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたメンバーのみを検索する、 <xref:System.Type>、継承されたメンバーされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドのオーバー ロードを使用してクラス初期化子 (.cctor) を取得するには、".cctor"を指定する必要があります`name`、および<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic) の`bindingAttr`します。 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティ。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.MemberInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>クラスの制約のメンバー、またはのメンバーを表すジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーター検索<xref:System.Object>クラスの制約がない場合。  
  
> [!NOTE]
>  ジェネリック メソッドを含めないでくださいで型引数`name`します。 たとえば、c# のコード`GetMember("MyMethod<int>")`テキスト名を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つの汎用引数を持つ`int`します。  
  
   
  
## Examples  
 次の例のすべてのパブリック静的メンバーの表示、`myString`文字 C で始まるクラス  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得するメンバーの名前を含む文字列。</param>
        <param name="type">検索する値。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
空の配列を返す場合は 0。</param>
        <summary>指定されたバインディング制約を使用して、指定されたメンバー型の指定されたメンバーを検索します。</summary>
        <returns>指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列。それ以外の場合は空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 <xref:System.Type.GetMember%2A>メソッドが返さないメンバーを特定の順序でなど、アルファベット順または宣言の順序。 コードする必要があります依存、メンバーが返される順序にする順序が異なります。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック メンバーを含める。  
  
-   指定`BindingFlags.NonPublic`検索条件に非パブリック メンバー (つまり、プライベート、内部、および保護されたメンバー) を含める。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase` 大文字と小文字を無視する`name`します。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたメンバーのみを検索する、 <xref:System.Type>、継承されたメンバーされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドのオーバー ロードを使用してクラス初期化子 (.cctor) を取得するには、".cctor"を指定する必要があります`name`、<xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType>の`type`、および<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>でVisual Basic) の`bindingAttr`します。 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティ。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.MemberInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>クラスの制約のメンバー、またはのメンバーを表すジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーター検索<xref:System.Object>クラスの制約がない場合。  
  
> [!NOTE]
>  ジェネリック メソッドを含めないでくださいで型引数`name`します。 たとえば、c# のコード`GetMember("MyMethod<int>")`テキスト名を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つの汎用引数を持つ`int`します。  
  
   
  
## Examples  
 次の例のすべてのメソッドの表示、`myString`文字 C で始まるクラス  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">派生クラスにより実装が提供される必要があります。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のメンバー (プロパティ、メソッド、フィールド、イベントなど) を取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のすべてのパブリック メンバーを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.MemberInfo" /> のすべてのパブリック メンバーを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
現在の <see cref="T:System.Reflection.MemberInfo" /> にパブリック メンバーが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 <xref:System.Type.GetMembers%2A>メソッドが返さないメンバーを特定の順序でなど、アルファベット順または宣言の順序。 コードする必要があります依存、メンバーが返される順序にする順序が異なります。  
  
 このメソッドのオーバー ロードを呼び出す、<xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>メソッド オーバー ロードで<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> Visual Basic で)。 クラスの初期化子 (.cctor) が見つかりません。 クラスの初期化子を検索するを受け取るオーバー ロードを使用して、 <xref:System.Reflection.BindingFlags>、し、指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic で)。 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティ。  
  
 次の表は、基底クラスのメンバーがによって返される、`Get`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.MemberInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>クラスの制約のメンバー、またはのメンバーを表すジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーター検索<xref:System.Object>クラスの制約がない場合。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します、<xref:System.Type.GetMembers>メソッドのオーバー ロードを指定したクラスのすべてのパブリック メンバーに関する情報を収集します。  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
空の配列を返す場合は 0 (<see cref="F:System.Reflection.BindingFlags.Default" />)。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> に対して定義されているメンバーを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.MemberInfo" /> に対して定義されているメンバーのうち、指定したバインディング制約に一致するすべてのメンバーを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
現在の <see cref="T:System.Reflection.MemberInfo" /> に対してメンバーが定義されていないか、または定義されているメンバーの中にバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メンバーには、プロパティ、メソッド、フィールド、イベント、およびなどが含まれます。  
  
 <xref:System.Type.GetMembers%2A>メソッドが返さないメンバーを特定の順序でなど、アルファベット順または宣言の順序。 コードする必要があります依存、メンバーが返される順序にする順序が異なります。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック メンバーを含める。  
  
-   指定`BindingFlags.NonPublic`検索条件に非パブリック メンバー (つまり、プライベート、内部、および保護されたメンバー) を含める。 保護のみ、基底クラスに内部メンバーが返されます。基底クラスにプライベート メンバーは返されません。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたメンバーのみを検索する、 <xref:System.Type>、継承されたメンバーされません。  
  
 だけを持つには、このメソッドを呼び出す、`Public`フラグまたはのみ、`NonPublic`フラグが指定されたメンバーを返すし、他のフラグは必要ありません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドのオーバー ロードを使用してクラス初期化子 (.cctor) を取得することを指定する必要があります<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic で)。 使用して、クラス初期化子を取得することも、<xref:System.Type.TypeInitializer%2A>プロパティ。  
  
 このメソッドが戻るかどうか、現在は、構築されたジェネリック型を表す、<xref:System.Reflection.MemberInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>クラスの制約のメンバー、またはのメンバーを表すジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーター検索<xref:System.Object>クラスの制約がない場合。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します、<xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>メソッドのオーバー ロードを指定したクラスのすべてのパブリック インスタンス メンバーに関する情報を収集します。  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の特定のメソッドを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メソッドの名前を格納している文字列。</param>
        <summary>指定した名前のパブリック メソッドを検索します。</summary>
        <returns>指定した名前のパブリック メソッドが存在する場合は、そのパブリック メソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス メソッドが含まれています。  
  
 メソッドはオーバー ロードし、は、複数のパブリック メソッドを持つ場合、<xref:System.Type.GetMethod%28System.String%29>メソッドがスローされます、<xref:System.Reflection.AmbiguousMatchException>例外。 1 つ以上のパブリック オーバー ロードがあるため、次の例では、例外がスローされます、<xref:System.Int32.ToString%2A?displayProperty=nameWithType>メソッド。  その一方で、ため、`Person.ToString`メソッドのオーバーライド<xref:System.Object.ToString%2A?displayProperty=nameWithType>したがってがオーバー ロードされないと、<xref:System.Type.GetMethod%28System.String%29>メソッドが取得できる、<xref:System.Reflection.MethodInfo>オブジェクト。  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 特定の方法を取得するのには、次のいずれかの操作を行うことができます。  
  
-   呼び出す、<xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29>メソッドを指定し、`bindingAttr`メソッドを一意に識別する引数。 たとえば、型は、静的およびインスタンスのオーバー ロードを持つため、例外がスローされた場合を指定できます、`bindingAttr`の引数<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>します。  
  
-   オーバー ロードを呼び出して、<xref:System.Type.GetMethod%2A>メソッドを含む、`types`メソッドのパラメーターの型を定義するパラメーター。  
  
-   呼び出す、<xref:System.Type.GetMethods>のすべての型に属しているパブリック メソッドを含む配列を取得します。 という名前の重複するメソッドを識別するために反復することができますし、`name`します。  
  
 このメソッドが戻るかどうか、現在は、構築されたジェネリック型を表す、<xref:System.Reflection.MethodInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>表しますジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーターは、クラスの制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約がない場合。  
  
> [!NOTE]
>  ジェネリック メソッドを含めないでくださいで型引数`name`します。 たとえば、c# のコード`GetMember("MyMethod<int>")`テキスト名を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つの汎用引数を持つ`int`します。  
  
   
  
## Examples  
 次の例では、という名前のメソッドを取得します。`MethodA`します。  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前のメソッドが複数個見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得するメソッドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <summary>指定したバインディング制約を使用して、指定したメソッドを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。  
  
-   いずれかを指定する必要があります<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>または<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>戻り値を取得するためにします。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>パブリック メソッドを検索します。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>検索条件に非パブリック メソッド (つまり、プライベート、内部、および保護されているメソッド) を含める。  
  
-   指定<xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType>に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> 大文字と小文字を無視する`name`します。  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> 宣言されたメソッドのみを検索する、 <xref:System.Type>、継承されたメソッドされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 メソッドはオーバー ロードは、複数のオーバー ロードがで指定された制約を満たしている場合、`bindingAttr`引数、メソッドはスロー、<xref:System.Reflection.AmbiguousMatchException>例外。 次の例では、ために、例外がスローされます。  
  
-   `TestClass`型の 2 つのパブリック インスタンス オーバー ロードには、`DisplayValue`メソッド、`DisplayValue(String)`と`DisplayValue(String, Object[])`します。  
  
-   `TestClass`型の 2 つのパブリック インスタンス オーバー ロードには、`Equals`メソッドのうちの 1 つが継承<xref:System.Object>:`Equals(TestClass)`と`Equals(Object)`します。  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 特定の方法を取得するのには、次のいずれかの操作を行うことができます。  
  
-   バインディング制約を変更します。 前の例では、パブリック インスタンスの取得を試みた`Equals`メソッドが型によって宣言され、正常に継承されないを取得`Equals(TestClass)`します。  
  
-   オーバー ロードを呼び出して、<xref:System.Type.GetMethod%2A>メソッドを含む、`types`メソッドのパラメーターの型を定義するパラメーター。  
  
-   呼び出す、<xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29>メソッドを指定したバインディング属性を持つ型に属するメソッドのすべてを含む配列を取得します。 という名前の重複するメソッドを識別するために反復することができますし、`name`します。 このアプローチは、前の例のイベントのハンドラーで説明されて、<xref:System.Reflection.AmbiguousMatchException>例外。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.MethodInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>表しますジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーターは、クラスの制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約がない場合。  
  
> [!NOTE]
>  ジェネリック メソッドを含めないでくださいで型引数`name`します。 たとえば、c# のコード`GetMember("MyMethod<int>")`テキスト名を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つの汎用引数を持つ`int`します。  
  
   
  
## Examples  
 次の例では、指定したバインディング フラグに一致するメソッドを取得します。  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メソッドの名前を格納している文字列。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</param>
        <summary>指定したパブリック メソッドのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した引数型と一致するパラメーターが設定されたパブリック メソッドが存在する場合は、そのパブリック メソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス メソッドが含まれています。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.MethodInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>表しますジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーターは、クラスの制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約がない場合。  
  
> [!NOTE]
>  `name`パラメーターは、型引数を含めることはできません。 たとえば、c# のコード`GetMethod("MyGenericMethod<int>")`テキスト名を持つメソッドを検索"`MyGenericMethod<int>`"、という名前のメソッドではなく`MyGenericMethod`型の 1 つの汎用引数を持つ`int`します。 代わりに、`GetMethod("MyGenericMethod")`で適切なパラメーターを使用して、`types`配列。  
  
   
  
## Examples  
 次の例の特定のオーバー ロードを検索する`MethodA`さまざまな引数の型を指定します。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]例が必要です、`/unsafe`コンパイラ オプション。  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 次の例では、取得<xref:System.Reflection.MethodInfo>オブジェクトを表す、`Add`非ジェネリック型のメソッド (、<xref:System.Collections.ArrayList>クラス)、オープン ジェネリック型 (、<xref:System.Collections.Generic.List%601>クラス)、およびクローズ ジェネリック型 (、`List(Of String)`型。  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 例では、定義、 `GetAddMethod` 、適切なを取得するメソッド<xref:System.Reflection.MethodInfo>オブジェクト。 提供する、`types`オープン ジェネリック型の引数を呼び出し、<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>メソッド。 提供する、`types`クローズ ジェネリック型の引数の値を取得、<xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType>プロパティ。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前および指定されたパラメーターを持つメソッドが複数見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="types" /> は <see langword="null" />です。  
  
または 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メソッドの名前を格納している文字列。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したパブリック メソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーでは処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、抽象を使用する<xref:System.Reflection.Binder?displayProperty=nameWithType>カスタム バインダーでは処理を書き込むクラス`modifiers`します。 `ParameterModifier` COM 相互運用機能経由で呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみを処理します。  
  
 検索`name`小文字が区別されます。 検索には、static および public のパブリック インスタンス メソッドが含まれています。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 このメソッドが戻るかどうか、現在は、構築されたジェネリック型を表す、<xref:System.Reflection.MethodInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>表しますジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーターは、クラスの制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約がない場合。  
  
> [!NOTE]
>  ジェネリック メソッドを含めないでくださいで型引数`name`します。 たとえば、c# のコード`GetMethod("MyMethod<int>")`テキスト名を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つの汎用引数を持つ`int`します。 代わりに、`GetMethod("MyMethod")`で適切なパラメーターを使用して、`types`配列。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前および指定されたパラメーターを持つメソッドが複数見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="types" /> は <see langword="null" />です。  
  
または 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
または 
 <paramref name="modifiers" /> が多次元です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するメソッドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
または 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したバインディング制約を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーでは処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、抽象を使用する<xref:System.Reflection.Binder?displayProperty=nameWithType>カスタム バインダーでは処理を書き込むクラス`modifiers`します。 `ParameterModifier` COM 相互運用機能経由で呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみを処理します。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック メソッドを検索します。  
  
-   指定`BindingFlags.NonPublic`検索条件に非パブリック メソッド (つまり、プライベート、内部、および保護されているメソッド) を含める。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase` 大文字と小文字を無視する`name`します。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたメソッドのみを検索する、 <xref:System.Type>、継承されたメソッドされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 このメソッドが戻るかどうか、現在は、構築されたジェネリック型を表す、<xref:System.Reflection.MethodInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>表しますジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーターは、クラスの制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約がない場合。  
  
> [!NOTE]
>  ジェネリック メソッドを含めないでくださいで型引数`name`します。 たとえば、c# のコード`GetMember("MyMethod<int>")`テキスト名を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つの汎用引数を持つ`int`します。  
  
   
  
## Examples  
 次の例の特定のオーバー ロードを検索する`MethodA`、バインディング制約とさまざまな引数の型を指定します。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]例が必要です、`/unsafe`コンパイラ オプション。  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="types" /> は <see langword="null" />です。  
  
または 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
または 
 <paramref name="modifiers" /> が多次元です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するメソッドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
または 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップの方法に関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したバインディング制約および指定した呼び出し規則を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーでは処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、抽象を使用する<xref:System.Reflection.Binder?displayProperty=nameWithType>カスタム バインダーでは処理を書き込むクラス`modifiers`します。 `ParameterModifier` COM 相互運用機能経由で呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみを処理します。  
  
 次の表は、基底クラスのメンバーがによって返される、`GetXXX`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック メソッドを検索します。  
  
-   指定`BindingFlags.NonPublic`検索条件に非パブリック メソッド (つまり、プライベート、内部、および保護されているメソッド) を含める。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase` 大文字と小文字を無視する`name`します。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたメソッドのみを検索する、 <xref:System.Type>、継承されたメソッドされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 このメソッドが戻るかどうか、現在は、構築されたジェネリック型を表す、<xref:System.Reflection.MethodInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>表しますジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーターは、クラスの制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約がない場合。  
  
> [!NOTE]
>  ジェネリック メソッドを含めないでくださいで型引数`name`します。 たとえば、c# のコード`GetMember("MyMethod<int>")`テキスト名を持つメンバーを検索"`MyMethod<int>`"、という名前のメソッドではなく`MyMethod`型の 1 つの汎用引数を持つ`int`します。  
  
   
  
## Examples  
 次の例の特定のオーバー ロードを検索する`MethodA`、バインディング制約を指定する、呼び出し規約、およびさまざまな引数の型。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]例が必要です、`/unsafe`コンパイラ オプション。  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="types" /> は <see langword="null" />です。  
  
または 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
または 
 <paramref name="modifiers" /> が多次元です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するメソッドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
または 
<see cref="P:System.Type.DefaultBinder" /> を使用する場合は、null 参照 (Visual Basic の場合は <see langword="Nothing" />)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックをクリーンアップするプロセスに関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
パラメーターをとらないメソッドを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。  
  
または 
 <see langword="null" />。 <paramref name="types" /> が<see langword="null" /> の場合、引数は一致していません。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定したバインディング制約および指定した呼び出し規則を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーでは処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、抽象を使用する<xref:System.Reflection.Binder?displayProperty=nameWithType>カスタム バインダーでは処理を書き込むクラス`modifiers`します。 `ParameterModifier` COM 相互運用機能経由で呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみを処理します。  
  
 `types` が`null` の場合、引数は一致していません。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック メソッドを検索します。  
  
-   指定`BindingFlags.NonPublic`検索条件に非パブリック メソッド (つまり、プライベート、内部、および保護されているメソッド) を含める。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase` 大文字と小文字を無視する`name`します。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたメソッドのみを検索する、 <xref:System.Type>、継承されたメソッドされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
または 
 <paramref name="modifiers" /> が多次元です。  
  
または 
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <exception cref="T:System.NotSupportedException">現在の型は <see cref="T:System.Reflection.Emit.TypeBuilder" /> または <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のメソッドを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のすべてのパブリック メソッドを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.MethodInfo" /> に対して定義されているすべてのパブリック メソッドを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
現在の <see cref="T:System.Reflection.MethodInfo" /> に対してパブリック メソッドが定義されていない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A>メソッドが返さないメソッドを特定の順序でなど、アルファベット順または宣言の順序。 コードする必要があります依存、メソッドが返される順序にする順序が異なります。  
  
 コンス トラクターは、この呼び出しによって返されるメソッドの配列には含まれません。 個別に呼び出して`GetConstructors()`コンス トラクター メソッドを取得します。  
  
 次の表は、基底クラスのメンバーがによって返される、`Get`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 このメソッドが戻るかどうか、現在は、構築されたジェネリック型を表す、<xref:System.Reflection.MethodInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>表しますジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーターは、クラスの制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約がない場合。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> に対して定義されているメソッドを検索します。</summary>
        <returns>現在の <see cref="T:System.Type" /> に対して定義されているメソッドのうち、指定したバインディング制約に一致するすべてのメソッドを表す <see cref="T:System.Reflection.MethodInfo" /> オブジェクトの配列。  
  
または 
現在の <see cref="T:System.Reflection.MethodInfo" /> に対してメソッドが定義されていないか、または定義されているメソッドの中にバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A>メソッドが返さないメソッドを特定の順序でなど、アルファベット順または宣言の順序。 コードする必要があります依存、メソッドが返される順序にする順序が異なります。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるには、どのメソッドを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`パブリック メソッドを検索します。  
  
-   指定`BindingFlags.NonPublic`検索条件に非パブリック メソッド (つまり、プライベート、内部、および保護されているメソッド) を含める。 保護のみ、基本クラスの内部メソッドが返されます。基底クラスにプライベート メソッドは返されません。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたメソッドのみを検索する、 <xref:System.Type>、継承されたメソッドされません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
> [!NOTE]
>  コンス トラクターとメソッドを検索する場合は、パラメーターを省略することはできません。 呼び出すときにのみ、パラメーターを省略できます。  
  
 このメソッドが戻るかどうか、現在は、構築されたジェネリック型を表す、<xref:System.Reflection.MethodInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>表しますジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーターは、クラスの制約のメソッドまたはのメソッドを検索<xref:System.Object>クラスの制約がない場合。  
  
   
  
## Examples  
 次の例では、2 つのパブリック メソッドと 1 つの保護されているメソッドを持つクラスを作成、作成、`Type`オブジェクトに対応する`MyTypeClass`をすべてのパブリックと非パブリック メソッドを取得し、名前を表示します。  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> 内で入れ子になっている特定の型を取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得対象の入れ子にされた型の名前を格納している文字列。</param>
        <summary>指定した名前を持つ入れ子にされたパブリックな型を検索します。</summary>
        <returns>存在する場合は、指定された名前を持つ入れ子にされたパブリックな型を表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索`name`小文字が区別されます。  
  
 入れ子になったクラスの簡易名を使用して、`name`します。 外側のクラスの名前では、修飾しません。 ジェネリックの入れ子になったクラスは、完全修飾名を使用して、アクサン グラーブとジェネリック引数の数を追加します。 たとえば、文字列を使用して、"内部\`1"入れ子になったクラスをジェネリック`Inner<T>`(`Inner(Of T)` Visual Basic で)。 型パラメーターの言語固有の構文を含めないでください。  
  
 次の表は、基底クラスのメンバーがによって返される、`Get`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約の入れ子にされた型を検索します。  
  
 入れ子にされた型がジェネリックの場合、このメソッドは、そのジェネリック型定義を返します。 これは、外側のジェネリック型が構築されたクローズ型である場合でも当てはまります。  
  
> [!NOTE]
>  場合、現在<xref:System.Type>c#、Visual Basic、または C++ で定義されているジェネリック型を表す独自のジェネリック パラメーターがない場合でも、その入れ子にされた型はすべてジェネリック。 これは必ずしも真実での動的アセンブリで定義されているかでコンパイルされた入れ子にされた型ではありません、 [Ilasm.exe (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)します。  
  
 については、ジェネリック型定義の入れ子になったジェネリック型を構築して、入れ子になったジェネリック型で、次を参照してください。<xref:System.Type.MakeGenericType%2A>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得対象の入れ子にされた型の名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、指定されている入れ子にされた型を検索します。</summary>
        <returns>指定した要件と一致し、入れ子にされた型が存在する場合は、その型を表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 入れ子になったクラスの簡易名を使用して、`name`します。 外側のクラスの名前では、修飾しません。 ジェネリックの入れ子になったクラスは、完全修飾名を使用して、アクサン グラーブとジェネリック パラメーターの数を追加します。 たとえば、文字列を使用して、"内部\`1"入れ子になったクラスをジェネリック`Inner<T>`(`Inner(Of T)` Visual Basic で)。 型パラメーターの言語固有の構文を含めないでください。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグを使用して定義する入れ子にすることができますが、検索に含める型します。  
  
-   いずれかを指定する必要があります<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>または<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>戻り値を取得します。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>検索にパブリックな入れ子になった型を含める。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>検索条件に非パブリックの入れ子にされた型 (つまり、プライベート、内部、および保護されている入れ子になった型) を含める。  
  
 このメソッドは、現在の型の入れ子にされた型のみを返します。 現在の型の基底クラスは検索されません。 基底クラスで入れ子にされた型を呼び出し、継承階層を見つける必要があります<xref:System.Type.GetNestedType%2A>各レベル。  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>は無視されます。  
  
 だけを持つには、このメソッドを呼び出す、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>フラグまたはのみ、<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>フラグは、指定した入れ子になった型し、他のフラグが必要としないを返します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約の入れ子にされた型を検索します。  
  
 入れ子にされた型がジェネリックの場合、このメソッドは、そのジェネリック型定義を返します。 これは、外側のジェネリック型が構築されたクローズ型である場合でも当てはまります。  
  
> [!NOTE]
>  場合、現在<xref:System.Type>c#、Visual Basic、または C++ で定義されているジェネリック型を表す独自のジェネリック パラメーターがない場合でも、その入れ子にされた型はすべてジェネリック。 これは必ずしも真実での動的アセンブリで定義されているかでコンパイルされた入れ子にされた型ではありません、 [Ilasm.exe (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)します。  
  
 については、ジェネリック型定義の入れ子になったジェネリック型を構築して、入れ子になったジェネリック型で、次を参照してください。<xref:System.Type.MakeGenericType%2A>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> 内で入れ子になっている型を取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> 内で入れ子になっているすべてのパブリック型を返します。</summary>
        <returns>現在の <see cref="T:System.Type" /> 内で入れ子になっているパブリック型を表す <see cref="T:System.Type" /> オブジェクトの配列 (検索は非再帰的)。または、現在の <see cref="T:System.Type" /> で入れ子になっているパブリック型がない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetNestedTypes%2A>メソッドが返さない種類特定の順序でなど、アルファベット順または宣言の順序。 コードする必要があります依存、型が返される順序にする順序が異なります。  
  
 現在の型ですぐに入れ子になったパブリック型のみが返されます。検索は、再帰ではありません。  
  
 次の表は、基底クラスのメンバーがによって返される、`Get`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約の入れ子にされた型を検索します。  
  
 入れ子にされた型がジェネリックの場合、このメソッドは、そのジェネリック型定義を返します。 これは、外側のジェネリック型が構築されたクローズ型である場合でも当てはまります。  
  
> [!NOTE]
>  場合、現在<xref:System.Type>c#、Visual Basic、または C++ で定義されているジェネリック型を表す独自のジェネリック パラメーターがない場合でも、その入れ子にされた型はすべてジェネリック。 これは必ずしも真実での動的アセンブリで定義されているかでコンパイルされた入れ子にされた型ではありません、 [Ilasm.exe (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)します。  
  
 については、ジェネリック型定義の入れ子になったジェネリック型を構築して、入れ子になったジェネリック型で、次を参照してください。<xref:System.Type.MakeGenericType%2A>します。  
  
   
  
## Examples  
 次の例は、入れ子になったクラスを定義し、`struct`で`MyClass`の型を使用して入れ子にされた型のオブジェクトを取得し、`MyClass`します。  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> 内で入れ子になっている型を検索します。</summary>
        <returns>指定したバインディング制約と一致する現在の <see cref="T:System.Type" /> で入れ子にされたすべての型を表す <see cref="T:System.Type" /> オブジェクトの配列 (検索は非再帰的)。または、バインディング制約と一致する入れ子にされた型が見つからない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 入れ子にされた型の検索は、再帰ではありません。  
  
 <xref:System.Type.GetNestedTypes%2A>メソッドが返さない種類特定の順序でなど、アルファベット順または宣言の順序。 コードする必要があります依存、型が返される順序にする順序が異なります。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグを使用して定義する入れ子にすることができますが、検索に含める型します。  
  
-   いずれかを指定する必要があります<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>または<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>戻り値を取得します。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>検索にパブリックな入れ子になった型を含める。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>検索条件に非パブリックの入れ子にされた型 (つまり、プライベート、内部、および保護されている入れ子になった型) を含める。  
  
 このメソッドは、現在の型の入れ子にされた型のみを返します。 現在の型の基底クラスは検索されません。 基底クラスで入れ子にされた型を呼び出し、継承階層を見つける必要があります<xref:System.Type.GetNestedTypes%2A>各レベル。  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>は無視されます。  
  
 だけを持つには、このメソッドを呼び出す、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>フラグまたはのみ、<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>フラグは、指定した入れ子になった型し、他のフラグが必要としないを返します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約の入れ子にされた型を検索します。  
  
 入れ子にされた型がジェネリックの場合、このメソッドは、そのジェネリック型定義を返します。 これは、外側のジェネリック型が構築されたクローズ型である場合でも当てはまります。  
  
> [!NOTE]
>  場合、現在<xref:System.Type>c#、Visual Basic、または C++ で定義されているジェネリック型を表す独自のジェネリック パラメーターがない場合でも、その入れ子にされた型はすべてジェネリック。 これは必ずしも真実での動的アセンブリで定義されているかでコンパイルされた入れ子にされた型ではありません、 [Ilasm.exe (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)します。  
  
 については、ジェネリック型定義の入れ子になったジェネリック型を構築して、入れ子になったジェネリック型で、次を参照してください。<xref:System.Type.MakeGenericType%2A>します。  
  
   
  
## Examples  
 次の例では、2 つの入れ子になったパブリック クラスと 2 つの入れ子になったプロテクト クラスを作成し、指定したバインディング制約に一致するクラスの情報が表示されます。  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のプロパティを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のすべてのパブリック プロパティを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.PropertyInfo" /> のすべてのパブリック プロパティを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
現在の <see cref="T:System.Reflection.PropertyInfo" /> にパブリック プロパティが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出しと同じですがこのオーバー ロードを呼び出し、<xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29>オーバー ロードを`bindingAttr`引数と等しい`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`(C#) と`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`Visual Basic でします。 すべてのパブリック インスタンスと現在によって表される型で定義されている両方の静的プロパティを返します<xref:System.Type>オブジェクトにも、その基本型から継承されます。  
  
 プロパティは公開されている少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) を取得します。  
  
 <xref:System.Type.GetProperties%2A>メソッドが返さないプロパティで、特定の順序など、アルファベット順または宣言の順序。 コードする必要があります依存、プロパティが返される順序にする順序が異なります。  
  
 次の表は、基底クラスのメンバーがによって返される、`Get`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 このメソッドが戻るかどうか、現在は、構築されたジェネリック型を表す、<xref:System.Reflection.PropertyInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
   
  
## Examples  
 `GetProperties` メソッドの使用例を次に示します。  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> のプロパティを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.PropertyInfo" /> のプロパティのうち、指定したバインディング制約に一致するすべてのプロパティを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
現在の <see cref="T:System.Reflection.PropertyInfo" /> にプロパティが設定されていないか、またはプロパティの中でバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは公開されている少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) を取得します。  
  
 <xref:System.Type.GetProperties%2A>メソッドが返さないプロパティで、特定の順序など、アルファベット順または宣言の順序。 コードする必要があります依存、プロパティが返される順序にする順序が異なります。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグを使用して定義する入れ子にすることができますが、検索に含める型します。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック プロパティを含めます。  
  
-   指定`BindingFlags.NonPublic`検索に非パブリック プロパティ (つまり、プライベート、内部、および保護されているプロパティ) を含めます。 保護のみ、基底クラスの内部プロパティが返されます。基底クラスにプライベート プロパティは返されません。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたプロパティのみを検索する、 <xref:System.Type>、単に継承されたプロパティではなく。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 プロパティは公開されている少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) を取得します。  
  
 このメソッドが戻るかどうか、現在は、構築されたジェネリック型を表す、<xref:System.Reflection.PropertyInfo>適切な型引数に置き換え、型パラメーターを持つオブジェクト。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
   
  
## Examples  
 次の例は、という名前のクラスを定義`PropertyClass`を含む 6 つのプロパティ: 2 つはパブリック、1 つはプライベート、保護された 1 つは、1 つは、内部 (`Friend` Visual Basic で) と内部の保護がいずれか (`Protected Friend` Visual Basic で)。 いくつかの基本的なプロパティの情報を表示します (プロパティの名前と型、読み取り/書き込み、およびの可視性には、かどうか、`get`と`set`アクセサー) の指定したバインディング制約に一致するプロパティ。  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の特定のプロパティを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <summary>指定した名前のパブリック プロパティを検索します。</summary>
        <returns>指定した名前のパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索`name`小文字が区別されます。 検索には、パブリック static および public インスタンスのプロパティが含まれています。  
  
 プロパティは公開されている少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) を取得します。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.PropertyInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
 状況は<xref:System.Reflection.AmbiguousMatchException>が発生した、次が含まれます。  
  
-   2 つが格納される型が同じであるインデックス付きプロパティが異なる数のパラメーターの名前します。 あいまいさを解決するには、オーバー ロードを使用して、<xref:System.Type.GetProperty%2A>パラメーターの型を指定するメソッド。  
  
-   派生型を使用して、同じ名前の継承されたプロパティを非表示にするプロパティを宣言する、`new`修飾子 (`Shadows` Visual Basic で)。 あいまいさを解決するには、使用、<xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29>メソッドのオーバー ロードを追加、<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>は継承されないメンバーに、検索を制限するフラグ。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文が簡素化され、その型の既定値にする 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]`(`myList(3)` Visual Basic で) 3 のインデックスを持つ要素を取得します。 プロパティをオーバー ロードすることができます。  
  
 C# では、この機能は、インデクサーが呼び出されます、名前によって参照されることはできません。 既定では、c# インデクサーが"Item"という名前のインデックス付きプロパティとしてメタデータに表示されます。 ただし、クラス ライブラリの開発者が使用できます、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータでインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>します。 C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もことができます。  
  
 型が既定のプロパティを持つかどうかを調べるには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>メソッドをテストするため、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
   
  
## Examples  
 次の例では、取得、`Type`ユーザー定義のクラスのオブジェクトは、そのクラスのプロパティを取得し、プロパティ名が表示されます。  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 内部的には、このプロパティは、メタデータで名前によって参照する、"Item"にします。 取得しようと`PropertyInfo`リフレクションを使用して正しくを返すためにこの内部名を指定する必要があります、`PropertyInfo`プロパティ。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前のプロパティが複数個見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">取得するプロパティの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <summary>指定されたバインディング制約を使用して、指定されたプロパティを検索します。</summary>
        <returns>指定した要件と一致するプロパティが存在する場合は、そのプロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは公開されている少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) を取得します。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるプロパティを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック プロパティを含めます。  
  
-   指定`BindingFlags.NonPublic`検索に非パブリック プロパティ (つまり、プライベート、内部、および保護されているプロパティ) を含めます。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase` 大文字と小文字を無視する`name`します。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたプロパティのみを検索する、 <xref:System.Type>、単に継承されたプロパティではなく。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.PropertyInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
 状況は<xref:System.Reflection.AmbiguousMatchException>が発生した、次が含まれます。  
  
-   2 つが格納される型が同じであるインデックス付きプロパティが異なる数のパラメーターの名前します。 あいまいさを解決するには、オーバー ロードを使用して、<xref:System.Type.GetProperty%2A>パラメーターの型を指定するメソッド。  
  
-   派生型が継承されたプロパティを同じ名前を非表示にするプロパティを宣言を使用して、`new`修飾子 (`Shadows` Visual Basic で)。 あいまいさを解決するには、含める<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>継承されていないメンバーへの検索を制限します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文が簡素化され、その型の既定値にする 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]`(`myList(3)` Visual Basic で) 3 のインデックスを持つ要素を取得します。 プロパティをオーバー ロードすることができます。  
  
 C# では、この機能は、インデクサーが呼び出されます、名前によって参照されることはできません。 既定では、c# インデクサーが"Item"という名前のインデックス付きプロパティとしてメタデータに表示されます。 ただし、クラス ライブラリの開発者が使用できます、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータでインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>します。 C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もことができます。  
  
 型が既定のプロパティを持つかどうかを調べるには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>メソッドをテストするため、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
   
  
## Examples  
 次の例では、ユーザー定義のクラスの型を取得、そのクラスのプロパティを取得し、指定したバインディング制約に一致するプロパティ名が表示されます。  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前を持ち、指定されたバインディング制約に一致する 2 つ以上のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <summary>指定した名前および戻り値の型を持つパブリック プロパティを検索します。</summary>
        <returns>指定した名前のパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは公開されている少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) を取得します。  
  
 検索`name`小文字が区別されます。 検索には、パブリック static および public インスタンスのプロパティが含まれています。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.PropertyInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文が簡素化され、その型の既定値にする 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]`(`myList(3)` Visual Basic で) 3 のインデックスを持つ要素を取得します。 プロパティをオーバー ロードすることができます。  
  
 C# では、この機能は、インデクサーが呼び出されます、名前によって参照されることはできません。 既定では、c# インデクサーが"Item"という名前のインデックス付きプロパティとしてメタデータに表示されます。 ただし、クラス ライブラリの開発者が使用できます、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータでインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>します。 C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もことができます。  
  
 型が既定のプロパティを持つかどうかを調べるには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>メソッドをテストするため、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
   
  
## Examples  
 次の例では、1 つのプロパティを持つクラスを定義し、プロパティの型と名前を取得します。  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前のプロパティが複数個見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> であるか、または <paramref name="returnType" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <summary>指定したパブリック プロパティのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した引数型と一致するパラメーターが設定されているパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは公開されている少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) を取得します。  
  
 検索`name`小文字が区別されます。 検索には、パブリック static および public インスタンスのプロパティが含まれています。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.PropertyInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文が簡素化され、その型の既定値にする 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]`(`myList(3)` Visual Basic で) 3 のインデックスを持つ要素を取得します。 プロパティをオーバー ロードすることができます。  
  
 C# では、この機能は、インデクサーが呼び出されます、名前によって参照されることはできません。 既定では、c# インデクサーが"Item"という名前のインデックス付きプロパティとしてメタデータに表示されます。 ただし、クラス ライブラリの開発者が使用できます、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータでインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>します。 C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もことができます。  
  
 型が既定のプロパティを持つかどうかを調べるには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>メソッドをテストするため、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
   
  
## Examples  
 次の例では、取得、`Type`ユーザー定義のクラスのオブジェクトは、そのクラスのプロパティを取得しに渡される引数で指定されたプロパティ名とプロパティの型を表示します`GetProperty`します。  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち引数の型が一致する複数のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="types" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> の要素は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <summary>指定したパブリック プロパティのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した引数型と一致するパラメーターが設定されているパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは公開されている少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) を取得します。  
  
 検索`name`小文字が区別されます。 検索には、パブリック static および public インスタンスのプロパティが含まれています。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.PropertyInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文が簡素化され、その型の既定値にする 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]`(`myList(3)` Visual Basic で) 3 のインデックスを持つ要素を取得します。 プロパティをオーバー ロードすることができます。  
  
 C# では、この機能は、インデクサーが呼び出されます、名前によって参照されることはできません。 既定では、c# インデクサーが"Item"という名前のインデックス付きプロパティとしてメタデータに表示されます。 ただし、クラス ライブラリの開発者が使用できます、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータでインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>します。 C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もことができます。  
  
 型が既定のプロパティを持つかどうかを調べるには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>メソッドをテストするため、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち引数の型が一致する複数のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="types" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> の要素は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したパブリック プロパティのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは公開されている少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) を取得します。  
  
 既定のバインダーでは処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、抽象を使用する<xref:System.Reflection.Binder?displayProperty=nameWithType>カスタム バインダーでは処理を書き込むクラス`modifiers`します。 `ParameterModifier` COM 相互運用機能経由で呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみを処理します。  
  
 検索`name`小文字が区別されます。 検索には、パブリック static および public インスタンスのプロパティが含まれています。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.PropertyInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文が簡素化され、その型の既定値にする 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]`(`myList(3)` Visual Basic で) 3 のインデックスを持つ要素を取得します。 プロパティをオーバー ロードすることができます。  
  
 C# では、この機能は、インデクサーが呼び出されます、名前によって参照されることはできません。 既定では、c# インデクサーが"Item"という名前のインデックス付きプロパティとしてメタデータに表示されます。 ただし、クラス ライブラリの開発者が使用できます、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータでインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>します。 C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もことができます。  
  
 型が既定のプロパティを持つかどうかを調べるには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>メソッドをテストするため、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
   
  
## Examples  
 次の例では、取得、`Type`オブジェクトに対応する`MyPropertyClass`に渡される引数を使用して、このクラスのインデックス付きプロパティを取得し、`GetProperty`メソッド。  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前を持ち、指定された引数の型および修飾子に一致する 2 つ以上のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="types" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
または 
 <paramref name="modifiers" /> が多次元です。  
  
または 
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> の要素は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するプロパティの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
または 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定された指定のプロパティを検索します。</summary>
        <returns>指定した要件と一致するプロパティが存在する場合は、そのプロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは公開されている少なくとも 1 つのアクセサーがある場合、リフレクションには、パブリックと見なされます。 それ以外の場合、プロパティは、プライベートと見なされ、使用する必要があります<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic での結合を使用して値`Or`) を取得します。  
  
 既定のバインダーでは処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、抽象を使用する<xref:System.Reflection.Binder?displayProperty=nameWithType>カスタム バインダーでは処理を書き込むクラス`modifiers`します。 `ParameterModifier` COM 相互運用機能経由で呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみを処理します。  
  
 次の表は、基底クラスのメンバーがによって返される、`Get`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるプロパティを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック プロパティを含めます。  
  
-   指定`BindingFlags.NonPublic`検索に非パブリック プロパティ (つまり、プライベート、内部、および保護されているプロパティ) を含めます。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase` 大文字と小文字を無視する`name`します。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたプロパティのみを検索する、 <xref:System.Type>、単に継承されたプロパティではなく。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 場合、現在<xref:System.Type>このメソッドが戻る構築されたジェネリック型を表す、<xref:System.Reflection.PropertyInfo>適切な型引数に置き換え、型パラメーター。  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義では、このメソッドは、クラス制約のプロパティを検索します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]インデックス付きプロパティにアクセスするための構文が簡素化され、その型の既定値にする 1 つのインデックス付きプロパティを許可します。 たとえば場合、変数`myList`を指す、 <xref:System.Collections.ArrayList>、構文`myList[3]`(`myList(3)` Visual Basic で) 3 のインデックスを持つ要素を取得します。 プロパティをオーバー ロードすることができます。  
  
 C# では、この機能は、インデクサーが呼び出されます、名前によって参照されることはできません。 既定では、c# インデクサーが"Item"という名前のインデックス付きプロパティとしてメタデータに表示されます。 ただし、クラス ライブラリの開発者が使用できます、<xref:System.Runtime.CompilerServices.IndexerNameAttribute>メタデータでインデクサーの名前を変更する属性。 たとえば、<xref:System.String>クラスという名前のインデクサーには、<xref:System.String.Chars%2A>します。 C# 以外の言語を使用して作成されたインデックス付きプロパティには、項目、以外の名前もことができます。  
  
 型が既定のプロパティを持つかどうかを調べるには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>メソッドをテストするため、<xref:System.Reflection.DefaultMemberAttribute>属性。 型が<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>プロパティが既定のプロパティの名前を返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前を持ち、指定されたバインディング制約に一致する 2 つ以上のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="types" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
または 
 <paramref name="modifiers" /> が多次元です。  
  
または 
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> の要素は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">取得するプロパティの名前を格納している文字列。</param>
        <param name="bindingAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。  
  
または 
<see langword="null" /> を返す 0。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメンバーの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
または 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
または 
インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>派生クラス内でオーバーライドされるときに、指定のバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されたプロパティを検索します。</summary>
        <returns>指定した要件と一致するプロパティが存在する場合は、そのプロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーでは処理されませんが<xref:System.Reflection.ParameterModifier>(、`modifiers`パラメーター)、抽象を使用する<xref:System.Reflection.Binder?displayProperty=nameWithType>カスタム バインダーでは処理を書き込むクラス`modifiers`します。 `ParameterModifier` COM 相互運用機能経由で呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみを処理します。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるプロパティを定義するために使用できます。  
  
-   いずれかを指定する必要があります`BindingFlags.Instance`または`BindingFlags.Static`戻り値を取得するためにします。  
  
-   指定`BindingFlags.Public`検索にパブリック プロパティを含めます。  
  
-   指定`BindingFlags.NonPublic`検索に非パブリック プロパティ (つまり、プライベート、内部、および保護されているプロパティ) を含めます。  
  
-   指定`BindingFlags.FlattenHierarchy`に含める`public`と`protected`階層; の静的メンバー`private`継承クラスの静的メンバーは含まれません。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase` 大文字と小文字を無視する`name`します。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたプロパティのみを検索する、 <xref:System.Type>、単に継承されたプロパティではなく。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前を持ち、指定されたバインディング制約に一致する 2 つ以上のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="types" /> は <see langword="null" />です。  
  
または 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
または 
 <paramref name="modifiers" /> が多次元です。  
  
または 
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <exception cref="T:System.NotSupportedException">現在の型は <see cref="T:System.Reflection.Emit.TypeBuilder" />、<see cref="T:System.Reflection.Emit.EnumBuilder" />、または <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された型を表す <see cref="T:System.Type" /> オブジェクトを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> を取得します。</summary>
        <returns>現在の <see cref="T:System.Type" /> です。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">完全修飾型名の指定</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型のアセンブリ修飾名。 以下を参照してください。<see cref="P:System.Type.AssemblyQualifiedName" /> 型が現在実行中のアセンブリまたは Mscorlib.dll 内にある場合は、名前空間で修飾された型名を指定するだけで十分です。</param>
        <summary>大文字小文字を区別する検索を実行して、指定された名前の <see cref="T:System.Type" /> を取得します。</summary>
        <returns>存在する場合は、指定した名前を持つ型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用することができます、<xref:System.Type.GetType%2A>メソッドを取得する、<xref:System.Type>から取得できるアセンブリ修飾名がわかっている場合、別のアセンブリ内の型のオブジェクト<xref:System.Type.AssemblyQualifiedName>します。 <xref:System.Type.GetType%2A> 指定されたアセンブリの読み込みと`typeName`します。 使用してアセンブリを読み込むこともできます、<xref:System.Reflection.Assembly.Load%2A>メソッドでは、次を使用して、<xref:System.Type.GetType%2A>または<xref:System.Reflection.Assembly.GetTypes%2A>のメソッド、<xref:System.Reflection.Assembly>クラスを取得する<xref:System.Type>オブジェクト。 C# で使用する方が効率的では型がコンパイル時に既知のプログラムにアセンブリ内にある場合は、 <xref:System.Type.GetType%2A> Visual Basic、または C++ です。  
  
> [!NOTE]
>  場合`typeName`が見つからないことを呼び出し、<xref:System.Type.GetType%28System.String%29>メソッドを返します。`null`します。 例外はスローされません。 制御するかどうか、例外がスローされますのオーバー ロードを呼び出して、<xref:System.Type.GetType%2A>メソッドを持つ、`throwOnError`パラメーター。  
  
 <xref:System.Type.GetType%2A> ディスクから読み込まれるアセンブリでのみ機能します。 呼び出す場合<xref:System.Type.GetType%2A>を使用して定義されている動的アセンブリで定義された型を検索する、<xref:System.Reflection.Emit>サービス、一貫性のない動作を取得する可能性があります。 動作かどうか、動的アセンブリがあるで永続的で異なります。、を使用して作成、`RunAndSave`または`Save`アクセスのモード、<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>列挙体。 動的アセンブリは永続的と、前にディスクに書き込まれたかどうか`GetType`が呼び出される、ローダー ディスクに保存されているアセンブリを検索、そのアセンブリを読み込み、そのアセンブリから型を取得します。 アセンブリがディスクに保存されていない場合`GetType`メソッドを返しますという`null`します。 `GetType` 一時動的アセンブリを理解しませんそのため、`GetType`動的アセンブリを返しますでは一時的な型を取得する`null`します。  
  
 使用する`GetType`で動的モジュールでは、サブスクライブ、<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>イベントと呼び出し`GetType`保存する前にします。 それ以外の場合、メモリ内アセンブリの 2 つのコピーが表示されます。  
  
 次の表は、基底クラスのメンバーがによって返される、`Get`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 配列または COM 型は検索されませんの使用可能なクラスのテーブルに読み込まれていない場合を除き、します。  
  
 `typeName` 型名で修飾できます、名前空間またはアセンブリ名の指定を含むアセンブリ修飾名。 以下を参照してください。<xref:System.Type.AssemblyQualifiedName%2A>  
  
 場合`typeName`に名前空間がアセンブリ名ではなく、このメソッドを呼び出し元のオブジェクトのアセンブリと、Mscorlib.dll だけをこの順序で検索します。 TypeName は、部分的または完全なアセンブリ名を持つ完全修飾されている場合、このメソッドは、指定したアセンブリで検索します。 アセンブリに厳密な名前がある場合は、アセンブリの完全名が必要です。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>プロパティは入れ子にされた型、アセンブリ名、およびジェネリック型引数を含む完全修飾型名を返します。 共通言語ランタイムをサポートするすべてのコンパイラが入れ子になったクラスの簡易名を生成し、リフレクションは、次の規則に従って、照会されたときに、完全修飾名を構築します。  
  
> [!NOTE]
>  .NET Framework version 2.0 では、プロセッサ アーキテクチャは、アセンブリの id に追加され、アセンブリ名の文字列の一部として指定できます。 たとえば、"ProcessorArchitecture = msil"です。 ただし、これが含まれていませんによって返される文字列で、<xref:System.Type.AssemblyQualifiedName%2A>互換性のためのプロパティ。 作成して型を読み込むことも、<xref:System.Reflection.AssemblyName>オブジェクトとの適切なオーバー ロードに渡す、<xref:System.Reflection.Assembly.Load%2A>メソッド。 使用してできます、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>アセンブリから型を読み込みます。 「 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>」も参照してください。  
  
|区切り記号|説明|  
|---------------|-------------|  
|円記号 (\\)|文字をエスケープします。|  
|アクサン グラーブ文字 (') |ジェネリック型の名前の末尾にある、型パラメーターの数を表す 1 つ以上の数字の前にします。|  
|角かっこ ()|構築されたジェネリック型のジェネリック型引数リストを囲む型引数リスト内で、アセンブリ修飾型を囲みます。|  
|コンマ (,)|アセンブリ名の前にします。|  
|ピリオド (.)|名前空間の識別子を表します。|  
|プラス記号 (+)|入れ子になったクラスの前にします。|  
  
 たとえば、クラスの完全修飾名は次のようになります。  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 かどうかには、名前空間が TopNamespace.Sub+Namespace、し、プラス記号 (+)、エスケープ文字の前に、文字列になります (\\) 入れ子の区切り記号として解釈されないようにします。 リフレクションは、次のように、この文字列を生成します。  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A"では"が"\\+\\+"、および"\\「が」\\\\"。  
  
 この修飾名を保存し、後で読み込みに使用される、<xref:System.Type>します。 検索して読み込む、<xref:System.Type>を使用して、<xref:System.Type.GetType%2A>のみ、またはアセンブリ修飾型名を持つ型のいずれかの名前します。 <xref:System.Type.GetType%2A> 型と名前のみが検索、<xref:System.Type>呼び出し元のアセンブリで、システム アセンブリでし。 <xref:System.Type.GetType%2A> アセンブリ修飾型名が探して、<xref:System.Type>で任意のアセンブリ。  
  
 型名には、参照型、ポインター型または配列型、型であるかどうかなど、型に関する追加情報を示す後続の文字を含めることができます。 このような末尾の文字型の名前を取得する`t.GetElementType().ToString()`ここで、`t`型です。  
  
 スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。 アセンブリ名では、',' 区切り記号の前にスペースは、関連するが、',' 区切り記号の後のスペースは無視されます。  
  
 ジェネリック型の名前は、アクサン グラーブ文字で終わる (\`) ジェネリック型引数の数を表す数字が続きます。 この名前のマングルの目的は、ジェネリック型と同じ名前が、型パラメーターの数が異なる同じスコープ内で発生しているをサポートするためにコンパイラを許可すること。 たとえば、リフレクションが完全修飾名を返します`Tuple`1` and `タプル`2`ジェネリック メソッドから`Tuple(Of T)`と`Tuple(Of T0, T1)`Visual basic でまたは`Tuple<T>`、およびタプル`\<T0, T1>`Visual c# でします。  
  
 、ジェネリック型の型引数リストが角かっこで囲まれているし、型引数がコンマで区切られます。 たとえば、ジェネリック<xref:System.Collections.Generic.Dictionary%602>は 2 つの型パラメーターがあります。 A<xref:System.Collections.Generic.Dictionary%602>の`MyType`型のキーを持つ<xref:System.String>次のように表される可能性があります。  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 型引数リスト内のアセンブリ修飾の型を指定するには、角かっこ内のアセンブリ修飾型を囲みます。 それ以外の場合、アセンブリ修飾名の部分を区切るコンマは、追加の型引数を区切り記号として解釈されます。 たとえば、<xref:System.Collections.Generic.Dictionary%602>の`MyType`型のキーを持つ、fromMyAssembly.dll <xref:System.String>、次のように指定する場合があります。  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  アセンブリ修飾の型は、型パラメーター リスト内に表示されるときにのみ、角かっこで囲むことができます。 型パラメーター リストで修飾し、非修飾の型のアセンブリを検索するための規則は、非ジェネリックの型を修飾し、修飾されていない場合の規則と同じです。  
  
 Null 許容型は、ジェネリック型の特殊なケースです。 たとえば、null 許容<xref:System.Int32>"System.Nullable'1[System.Int32]"の文字列として表されます。  
  
> [!NOTE]
>  C#、C++、および Visual Basic で、型の演算子を使用して、null 許容型を取得することもできます。 たとえば、null 許容<xref:System.Boolean>によって型が返される`typeof(Nullable<bool>)`c# によって`Nullable<Boolean>::typeid`C++ では、および`GetType(Nullable(Of Boolean))`Visual Basic で。  
  
 次の表で使用する構文`GetType`さまざまな種類。  
  
|取得するには|使用|  
|------------|---------|  
|Null 許容型 <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|アンマネージ ポインター `MyType`|`Type.GetType("MyType*")`|  
|ポインターへのアンマネージ ポインター `MyType`|`Type.GetType("MyType**")`|  
|マネージ ポインターまたはへの参照 `MyType`|`Type.GetType("MyType&")`。 ポインターとは異なり、参照は 1 つのレベルに制限されます。|  
|親クラスと入れ子になったクラス|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限を 0 と 1 次元配列|`Type.GetType("MyType[]")`|  
|不明な下限を持つ 1 次元配列|`Type.GetType("MyType[*]")`|  
|N 次元の配列|合計 n-1 回角かっこ内のコンマ (,) です。 たとえば、`System.Object[,,]`を 3 次元を表す`Object`配列。|  
|1 次元配列の配列|`Type.GetType("MyType[][]")`|  
|不明な下限の四角形の 2 次元配列|`Type.GetType("MyType[,]")`|  
|1 つの型引数を持つジェネリック型|``Type.GetType("MyGenericType`1[MyType]")``|  
|2 つの型引数を持つジェネリック型|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|2 つのアセンブリ修飾型引数を持つジェネリック型|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|アセンブリ修飾型引数を持つアセンブリ修飾のジェネリック型|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|型引数が 2 つの型引数を持つジェネリック型のジェネリック型|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 次の例の種類を取得する`System.Int32`し、その型のオブジェクトを使用して、表示、<xref:System.Type.FullName%2A>プロパティの`System.Int32`します。  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
または 
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
または 
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.IO.IOException" /> を代わりにキャッチします。  
  
</para>
          </block>  
  
 アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
または 
共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">完全修飾型名の指定</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型のアセンブリ修飾名。 以下を参照してください。<see cref="P:System.Type.AssemblyQualifiedName" /> 型が現在実行中のアセンブリまたは Mscorlib.dll 内にある場合は、名前空間で修飾された型名を指定するだけで十分です。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。 また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」を参照してください。</param>
        <summary>大文字と小文字を区別する検索を実行し、型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の <see cref="T:System.Type" /> を取得します。</summary>
        <returns>指定した名前を持つ型。 型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用することができます、<xref:System.Type.GetType%2A>メソッドを取得する、<xref:System.Type>から取得できるアセンブリ修飾名がわかっている場合、別のアセンブリ内の型のオブジェクト<xref:System.Type.AssemblyQualifiedName>します。 <xref:System.Type.GetType%2A> 指定されたアセンブリの読み込みと`typeName`します。 使用してアセンブリを読み込むこともできます、<xref:System.Reflection.Assembly.Load%2A>メソッドでは、次を使用して、<xref:System.Type.GetType%2A>または<xref:System.Reflection.Assembly.GetTypes%2A>のメソッド、<xref:System.Reflection.Assembly>クラスを取得する<xref:System.Type>オブジェクト。 使用する方が効率的では、型がコンパイル時に既知のプログラムにアセンブリ内にある場合は、 `typeof` c# で<xref:System.Type.GetType%2A>Visual basic、または`typeid`C++ では。  
  
 `GetType` ディスクから読み込まれるアセンブリでのみ機能します。 呼び出す場合`GetType`を使用して定義されている動的アセンブリで定義された型を検索する、<xref:System.Reflection.Emit>サービス、一貫性のない動作を取得する可能性があります。 動作かどうか、動的アセンブリがあるで永続的で異なります。、を使用して作成、`RunAndSave`または`Save`アクセスのモード、<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>列挙体。 動的アセンブリは永続的と、前にディスクに書き込まれたかどうか`GetType`が呼び出される、ローダー ディスクに保存されているアセンブリを検索、そのアセンブリを読み込み、そのアセンブリから型を取得します。 アセンブリがディスクに保存されていない場合`GetType`メソッドを返しますという`null`します。 `GetType` 一時動的アセンブリを理解しませんそのため、`GetType`動的アセンブリを返しますでは一時的な型を取得する`null`します。  
  
 使用する`GetType`で動的モジュールでは、サブスクライブ、<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>イベントと呼び出し`GetType`保存する前にします。 それ以外の場合、メモリ内アセンブリの 2 つのコピーが表示されます。  
  
 `throwOnError`パラメーターは、例外のセクションで説明した、型が見つからないし、もその他の特定の例外条件を抑制ときの動作を指定します。 値に関係なくいくつかの例外がスローされる`throwOnError`します。 たとえば、種類が見つかりましたが、アンロードすることはできません、<xref:System.TypeLoadException>がスローされた場合でも`throwOnError`は`false`します。  
  
 次の表は、基底クラスのメンバーがによって返される、`Get`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 配列または COM 型は検索されませんの使用可能なクラスのテーブルに読み込まれていない場合を除き、します。  
  
 `typeName` 型名で修飾できます、名前空間またはアセンブリ名の指定を含むアセンブリ修飾名。 以下を参照してください。<xref:System.Type.AssemblyQualifiedName%2A>  
  
 場合`typeName`に名前空間がアセンブリ名ではなく、このメソッドを呼び出し元のオブジェクトのアセンブリと、Mscorlib.dll だけをこの順序で検索します。 TypeName は、部分的または完全なアセンブリ名を持つ完全修飾されている場合、このメソッドは、指定したアセンブリで検索します。 アセンブリに厳密な名前がある場合は、アセンブリの完全名が必要です。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>プロパティは入れ子にされた型、アセンブリ名、およびジェネリック型引数を含む完全修飾型名を返します。 共通言語ランタイムをサポートするすべてのコンパイラが入れ子になったクラスの簡易名を生成し、リフレクションは、次の規則に従って、照会されたときに、完全修飾名を構築します。  
  
> [!NOTE]
>  .NET Framework version 2.0 では、プロセッサ アーキテクチャは、アセンブリの id に追加され、アセンブリ名の文字列の一部として指定できます。 たとえば、"ProcessorArchitecture = msil"です。 ただし、これが含まれていませんによって返される文字列で、<xref:System.Type.AssemblyQualifiedName%2A>互換性のためのプロパティ。 作成して型を読み込むことも、<xref:System.Reflection.AssemblyName>オブジェクトとの適切なオーバー ロードに渡す、<xref:System.Reflection.Assembly.Load%2A>メソッド。 使用してできます、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>アセンブリから型を読み込みます。 「 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>」も参照してください。  
  
|区切り記号|説明|  
|---------------|-------------|  
|円記号 (\\)|文字をエスケープします。|  
|アクサン グラーブ文字 (') |ジェネリック型の名前の末尾にある、型パラメーターの数を表す 1 つ以上の数字の前にします。|  
|角かっこ ()|構築されたジェネリック型のジェネリック型引数リストを囲む型引数リスト内で、アセンブリ修飾型を囲みます。|  
|コンマ (,)|アセンブリ名の前にします。|  
|ピリオド (.)|名前空間の識別子を表します。|  
|プラス記号 (+)|入れ子になったクラスの前にします。|  
  
 たとえば、クラスの完全修飾名は次のようになります。  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 かどうかには、名前空間が TopNamespace.Sub+Namespace、し、プラス記号 (+)、エスケープ文字の前に、文字列になります (\\) 入れ子の区切り記号として解釈されないようにします。 リフレクションは、次のように、この文字列を生成します。  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A"では"が"\\+\\+"、および"\\「が」\\\\"。  
  
 この修飾名を保存し、後で読み込みに使用される、<xref:System.Type>します。 検索して読み込む、<xref:System.Type>を使用して、<xref:System.Type.GetType%2A>のみ、またはアセンブリ修飾型名を持つ型のいずれかの名前します。 <xref:System.Type.GetType%2A> 型と名前のみが検索、<xref:System.Type>呼び出し元のアセンブリで、システム アセンブリでし。 <xref:System.Type.GetType%2A> アセンブリ修飾型名が探して、<xref:System.Type>で任意のアセンブリ。  
  
 型名には、参照型、ポインター型または配列型、型であるかどうかなど、型に関する追加情報を示す後続の文字を含めることができます。 このような末尾の文字型の名前を取得する`t.GetElementType().ToString()`ここで、`t`型です。  
  
 スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。 アセンブリ名では、',' 区切り記号の前にスペースは、関連するが、',' 区切り記号の後のスペースは無視されます。  
  
 ジェネリック型の名前は、アクサン グラーブ文字で終わる (\`) ジェネリック型引数の数を表す数字が続きます。 この名前のマングルの目的は、ジェネリック型と同じ名前が、型パラメーターの数が異なる同じスコープ内で発生しているをサポートするためにコンパイラを許可すること。 たとえば、リフレクションが完全修飾名を返します`Tuple`1` and `タプル`2`ジェネリック メソッドから`Tuple(Of T)`と`Tuple(Of T0, T1)`Visual basic でまたは`Tuple<T>`、およびタプル`\<T0, T1>`Visual c# でします。  
  
 、ジェネリック型の型引数リストが角かっこで囲まれているし、型引数がコンマで区切られます。 たとえば、ジェネリック<xref:System.Collections.Generic.Dictionary%602>は 2 つの型パラメーターがあります。 A<xref:System.Collections.Generic.Dictionary%602>の`MyType`型のキーを持つ<xref:System.String>次のように表される可能性があります。  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 型引数リスト内のアセンブリ修飾の型を指定するには、角かっこ内のアセンブリ修飾型を囲みます。 それ以外の場合、アセンブリ修飾名の部分を区切るコンマは、追加の型引数を区切り記号として解釈されます。 たとえば、<xref:System.Collections.Generic.Dictionary%602>の`MyType`型のキーを持つ、MyAssembly.dll から<xref:System.String>、次のように指定する場合があります。  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  アセンブリ修飾の型は、型パラメーター リスト内に表示されるときにのみ、角かっこで囲むことができます。 型パラメーター リストで修飾し、非修飾の型のアセンブリを検索するための規則は、非ジェネリックの型を修飾し、修飾されていない場合の規則と同じです。  
  
 Null 許容型は、ジェネリック型の特殊なケースです。 たとえば、null 許容<xref:System.Int32>"System.Nullable'1[System.Int32]"の文字列として表されます。  
  
> [!NOTE]
>  C#、C++、および Visual Basic で、型の演算子を使用して、null 許容型を取得することもできます。 たとえば、null 許容<xref:System.Boolean>によって型が返される`typeof(Nullable<bool>)`c# によって`Nullable<Boolean>::typeid`C++ では、および`GetType(Nullable(Of Boolean))`Visual Basic で。  
  
 次の表で使用する構文`GetType`さまざまな種類。  
  
|取得するには|使用|  
|------------|---------|  
|Null 許容型 <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|アンマネージ ポインター `MyType`|`Type.GetType("MyType*")`|  
|ポインターへのアンマネージ ポインター `MyType`|`Type.GetType("MyType**")`|  
|マネージ ポインターまたはへの参照 `MyType`|`Type.GetType("MyType&")`。 ポインターとは異なり、参照は 1 つのレベルに制限されます。|  
|親クラスと入れ子になったクラス|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限を 0 と 1 次元配列|`Type.GetType("MyArray[]")`|  
|不明な下限を持つ 1 次元配列|`Type.GetType("MyArray[*]")`|  
|N 次元の配列|合計 n-1 回角かっこ内のコンマ (,) です。 たとえば、`System.Object[,,]`を 3 次元を表す`Object`配列。|  
|2 次元配列の配列|`Type.GetType("MyArray[][]")`|  
|不明な下限の四角形の 2 次元配列|`Type.GetType("MyArray[,]")`|  
|1 つの型引数を持つジェネリック型|``Type.GetType("MyGenericType`1[MyType]")``|  
|2 つの型引数を持つジェネリック型|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|2 つのアセンブリ修飾型引数を持つジェネリック型|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|アセンブリ修飾型引数を持つアセンブリ修飾のジェネリック型|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|型引数が 2 つの型引数を持つジェネリック型のジェネリック型|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 次の例の種類を取得する`System.Int32`し、その型のオブジェクトを使用して、表示、<xref:System.Type.FullName%2A>プロパティの`System.Int32`します。 型のオブジェクトは、存在しないアセンブリを参照して、この例は例外をスローします。  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> が <see langword="true" /> です。型が見つかりません。  
  
または 
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> に埋め込まれたタブなどの正しくない文字が含まれています。 
または 
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は空の文字列です。  
  
または 
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は無効なサイズの配列型を表します。  
  
または 
 <paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> が <see langword="true" /> で、<paramref name="typeName" /> に正しくない構文が含まれています。 例: "MyType[,*,]"。  
  
または 
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
または 
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
または 
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.IO.IOException" /> を代わりにキャッチします。  
  
</para>
          </block>  
  
 アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
または 
共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">完全修飾型名の指定</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型のアセンブリ修飾名。 以下を参照してください。<see cref="P:System.Type.AssemblyQualifiedName" /> 型が現在実行中のアセンブリまたは Mscorlib.dll 内にある場合は、名前空間で修飾された型名を指定するだけで十分です。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。 また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」を参照してください。</param>
        <param name="ignoreCase">大文字と小文字を区別せずに <see langword="true" /> の検索を実行するには <paramref name="typeName" />。大文字と小文字を区別して <see langword="false" /> の検索を実行するには <paramref name="typeName" />。</param>
        <summary>指定した名前を持つ <see cref="T:System.Type" /> を取得します。型が見つからない場合に例外をスローするかどうかと、大文字と小文字を区別する検索を実行するかどうかも指定します。</summary>
        <returns>指定した名前を持つ型。 型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用することができます、<xref:System.Type.GetType%2A>メソッドを取得する、<xref:System.Type>から取得できるアセンブリ修飾名がわかっている場合、別のアセンブリ内の型のオブジェクト<xref:System.Type.AssemblyQualifiedName>します。 <xref:System.Type.GetType%2A> 指定されたアセンブリの読み込みと`typeName`します。 使用してアセンブリを読み込むこともできます、<xref:System.Reflection.Assembly.Load%2A>メソッドでは、次を使用して、<xref:System.Type.GetType%2A>または<xref:System.Reflection.Assembly.GetTypes%2A>のメソッド、<xref:System.Reflection.Assembly>クラスを取得する<xref:System.Type>オブジェクト。 使用する方が効率的では、型がコンパイル時に既知のプログラムにアセンブリ内にある場合は、 `typeof` c# で<xref:System.Type.GetType%2A>Visual basic、または`typeid`C++ では。  
  
 `GetType` ディスクから読み込まれるアセンブリでのみ機能します。 呼び出す場合`GetType`を使用して定義されている動的アセンブリで定義された型を検索する、<xref:System.Reflection.Emit>サービス、一貫性のない動作を取得する可能性があります。 動作かどうか、動的アセンブリがあるで永続的で異なります。、を使用して作成、`RunAndSave`または`Save`アクセスのモード、<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>列挙体。 動的アセンブリは永続的と、前にディスクに書き込まれたかどうか`GetType`が呼び出される、ローダー ディスクに保存されているアセンブリを検索、そのアセンブリを読み込み、そのアセンブリから型を取得します。 アセンブリがディスクに保存されていない場合`GetType`メソッドを返しますという`null`します。 `GetType` 一時動的アセンブリを理解しませんそのため、`GetType`動的アセンブリを返しますでは一時的な型を取得する`null`します。  
  
 使用する`GetType`で動的モジュールでは、サブスクライブ、<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>イベントと呼び出し`GetType`保存する前にします。 それ以外の場合、メモリ内アセンブリの 2 つのコピーが表示されます。  
  
 `throwOnError`パラメーターは、例外のセクションで説明した、型が見つからないし、もその他の特定の例外条件を抑制ときの動作を指定します。 値に関係なくいくつかの例外がスローされる`throwOnError`します。 たとえば、種類が見つかりましたが、アンロードすることはできません、<xref:System.TypeLoadException>がスローされた場合でも`throwOnError`は`false`します。  
  
 次の表は、基底クラスのメンバーがによって返される、`Get`メソッドの型でリフレクション時にします。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|×|×|  
|フィールド|×|はい。 フィールドは、常に、名前とシグネチャによる非表示です。|  
|event|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
|メソッド|×|はい。 (仮想および非仮想) メソッドには、名前によって隠ぺいまたは名前とシグネチャによる非表示を指定できます。|  
|入れ子にされた型|×|×|  
|プロパティ|利用不可|共通型システムの規則は、継承は、メソッド、プロパティを実装するのと同じです。 プロパティは、リフレクションは、名前とシグネチャで隠ぺいとして扱います。 下記のメモ 2 を参照してください。|  
  
1.  名前とシグネチャによる非表示にするは、すべてのパーツのカスタム修飾子を含む、シグネチャの戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約と見なします。 これは、バイナリ比較です。  
  
2.  リフレクション プロパティおよびイベントは、名前とシグネチャによる非表示にするは。 派生クラスには get アクセサーのみ、基本クラスに、get と set アクセサーの両方を持つプロパティがある場合は、派生クラスのプロパティには、基底クラスのプロパティが非表示にし、基本クラスの set アクセス操作子にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 配列または COM 型は検索されませんの使用可能なクラスのテーブルに読み込まれていない場合を除き、します。  
  
 `typeName` 型名で修飾できます、名前空間またはアセンブリ名の指定を含むアセンブリ修飾名。 以下を参照してください。<xref:System.Type.AssemblyQualifiedName%2A>  
  
 場合`typeName`に名前空間がアセンブリ名ではなく、このメソッドを呼び出し元のオブジェクトのアセンブリと、Mscorlib.dll だけをこの順序で検索します。 TypeName は、部分的または完全なアセンブリ名を持つ完全修飾されている場合、このメソッドは、指定したアセンブリで検索します。 アセンブリに厳密な名前がある場合は、アセンブリの完全名が必要です。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>プロパティは入れ子にされた型、アセンブリ名、および型引数を含む完全修飾型名を返します。 共通言語ランタイムをサポートするすべてのコンパイラが入れ子になったクラスの簡易名を生成し、リフレクションは、次の規則に従って、照会されたときに、完全修飾名を構築します。  
  
> [!NOTE]
>  .NET Framework version 2.0 では、プロセッサ アーキテクチャは、アセンブリの id に追加され、アセンブリ名の文字列の一部として指定できます。 たとえば、"ProcessorArchitecture = msil"です。 ただし、これが含まれていませんによって返される文字列で、<xref:System.Type.AssemblyQualifiedName%2A>互換性のためのプロパティ。 作成して型を読み込むことも、<xref:System.Reflection.AssemblyName>オブジェクトとの適切なオーバー ロードに渡す、<xref:System.Reflection.Assembly.Load%2A>メソッド。 使用してできます、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>アセンブリから型を読み込みます。 「 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>」も参照してください。  
  
|区切り記号|説明|  
|---------------|-------------|  
|円記号 (\\)|文字をエスケープします。|  
|アクサン グラーブ文字 (') |ジェネリック型の名前の末尾にある、型パラメーターの数を表す 1 つ以上の数字の前にします。|  
|角かっこ ()|構築されたジェネリック型のジェネリック型引数リストを囲む型引数リスト内で、アセンブリ修飾型を囲みます。|  
|コンマ (,)|アセンブリ名の前にします。|  
|ピリオド (.)|名前空間の識別子を表します。|  
|プラス記号 (+)|入れ子になったクラスの前にします。|  
  
 たとえば、クラスの完全修飾名は次のようになります。  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 かどうかには、名前空間が TopNamespace.Sub+Namespace、し、プラス記号 (+)、エスケープ文字の前に、文字列になります (\\) 入れ子の区切り記号として解釈されないようにします。 リフレクションは、次のように、この文字列を生成します。  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A"では"が"\\+\\+"、および"\\「が」\\\\"。  
  
 この修飾名を保存し、後で読み込みに使用される、<xref:System.Type>します。 検索して読み込む、<xref:System.Type>を使用して、<xref:System.Type.GetType%2A>のみ、またはアセンブリ修飾型名を持つ型のいずれかの名前します。 <xref:System.Type.GetType%2A> 型と名前のみが検索、<xref:System.Type>呼び出し元のアセンブリで、システム アセンブリでし。 <xref:System.Type.GetType%2A> アセンブリ修飾型名が探して、<xref:System.Type>で任意のアセンブリ。  
  
 型名には、参照型、ポインター型または配列型、型であるかどうかなど、型に関する追加情報を示す後続の文字を含めることができます。 このような末尾の文字型の名前を取得する`t.GetElementType().ToString()`ここで、`t`型です。  
  
 スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。 アセンブリ名では、',' 区切り記号の前にスペースは、関連するが、',' 区切り記号の後のスペースは無視されます。  
  
 ジェネリック型の名前は、アクサン グラーブ文字で終わる (\`) ジェネリック型引数の数を表す数字が続きます。 この名前のマングルの目的は、ジェネリック型と同じ名前が、型パラメーターの数が異なる同じスコープ内で発生しているをサポートするためにコンパイラを許可すること。 たとえば、リフレクションが完全修飾名を返します`Tuple`1` and `タプル`2`ジェネリック メソッドから`Tuple(Of T)`と`Tuple(Of T0, T1)`Visual basic でまたは`Tuple<T>`、およびタプル`\<T0, T1>`Visual c# でします。  
  
 、ジェネリック型の型引数リストが角かっこで囲まれているし、型引数がコンマで区切られます。 たとえば、ジェネリック<xref:System.Collections.Generic.Dictionary%602>は 2 つの型パラメーターがあります。 A<xref:System.Collections.Generic.Dictionary%602>の`MyType`型のキーを持つ<xref:System.String>次のように表される可能性があります。  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 型引数リスト内のアセンブリ修飾の型を指定するには、角かっこ内のアセンブリ修飾型を囲みます。 それ以外の場合、アセンブリ修飾名の部分を区切るコンマは、追加の型引数を区切り記号として解釈されます。 たとえば、<xref:System.Collections.Generic.Dictionary%602>の`MyType`型のキーを持つ、MyAssembly.dll から<xref:System.String>、次のように指定する場合があります。  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  アセンブリ修飾の型は、型パラメーター リスト内に表示されるときにのみ、角かっこで囲むことができます。 型パラメーター リストで修飾し、非修飾の型のアセンブリを検索するための規則は、非ジェネリックの型を修飾し、修飾されていない場合の規則と同じです。  
  
 Null 許容型は、ジェネリック型の特殊なケースです。 たとえば、null 許容<xref:System.Int32>"System.Nullable'1[System.Int32]"の文字列として表されます。  
  
> [!NOTE]
>  C#、C++、および Visual Basic で、型の演算子を使用して、null 許容型を取得することもできます。 たとえば、null 許容<xref:System.Boolean>によって型が返される`typeof(Nullable<bool>)`c# によって`Nullable<Boolean>::typeid`C++ では、および`GetType(Nullable(Of Boolean))`Visual Basic で。  
  
 次の表で使用する構文`GetType`さまざまな種類。  
  
|取得するには|使用|  
|------------|---------|  
|Null 許容型 <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|アンマネージ ポインター `MyType`|`Type.GetType("MyType*")`|  
|ポインターへのアンマネージ ポインター `MyType`|`Type.GetType("MyType**")`|  
|マネージ ポインターまたはへの参照 `MyType`|`Type.GetType("MyType&")`。 ポインターとは異なり、参照は 1 つのレベルに制限されます。|  
|親クラスと入れ子になったクラス|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限を 0 と 1 次元配列|`Type.GetType("MyArray[]")`|  
|不明な下限を持つ 1 次元配列|`Type.GetType("MyArray[*]")`|  
|N 次元の配列|合計 n-1 回角かっこ内のコンマ (,) です。 たとえば、`System.Object[,,]`を 3 次元を表す`Object`配列。|  
|2 次元配列の配列|`Type.GetType("MyArray[][]")`|  
|不明な下限の四角形の 2 次元配列|`Type.GetType("MyArray[,]")`|  
|1 つの型引数を持つジェネリック型|``Type.GetType("MyGenericType`1[MyType]")``|  
|2 つの型引数を持つジェネリック型|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|2 つのアセンブリ修飾型引数を持つジェネリック型|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|アセンブリ修飾型引数を持つアセンブリ修飾のジェネリック型|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|型引数が 2 つの型引数を持つジェネリック型のジェネリック型|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> が <see langword="true" /> です。型が見つかりません。  
  
または 
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> に埋め込まれたタブなどの正しくない文字が含まれています。 
または 
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は空の文字列です。  
  
または 
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は無効なサイズの配列型を表します。  
  
または 
 <paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> が <see langword="true" /> で、<paramref name="typeName" /> に正しくない構文が含まれています。 例: "MyType[,*,]"。  
  
または 
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
または 
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
または 
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
または 
共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">完全修飾型名の指定</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型の名前。 <paramref name="typeResolver" /> パラメーターを指定する場合は、<paramref name="typeResolver" /> が解決できる任意の文字列を型名として使用できます。 <paramref name="assemblyResolver" /> パラメーターを指定する場合、または標準の型解決を使用する場合は、<paramref name="typeName" /> をアセンブリ修飾名にする必要があります (<see cref="P:System.Type.AssemblyQualifiedName" />を参照)。ただし、現在実行されているアセンブリ内または Mscorlib.dll に型がある場合は、名前空間で修飾された型名を指定するだけで十分です。</param>
        <param name="assemblyResolver">で指定されたアセンブリを特定して返すメソッド<paramref name="typeName" />. <paramref name="assemblyResolver" /> には、アセンブリ名が <see cref="T:System.Reflection.AssemblyName" /> オブジェクトとして渡されます。 <paramref name="typeName" /> にアセンブリの名前が含まれていない場合、<paramref name="assemblyResolver" /> は呼び出されません。 <paramref name="assemblyResolver" /> を指定しない場合は、標準のアセンブリ解決が実行されます。  
  
注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。 渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。 指定したメソッドまたは使い慣れているメソッドだけを使用してください。</param>
        <param name="typeResolver"><paramref name="typeName" /> で指定された型を、<paramref name="assemblyResolver" /> または標準のアセンブリ解決によって返されたアセンブリから特定して返すメソッド。 アセンブリが指定されていない場合は、<paramref name="typeResolver" /> メソッドで指定できます。 このメソッドは、大文字と小文字を区別せずに検索を実行するかどうかを指定するパラメーターも受け取ります。そのパラメーターには <see langword="false" /> が渡されます。  
  
注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</param>
        <summary>指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</summary>
        <returns>指定された名前の型。型が見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの詳細な使用シナリオ、`assemblyResolver`と`typeResolver`でパラメーターが見つかりません、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードします。  
  
> [!NOTE]
>  場合`typeName`が見つからないことを呼び出し、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>メソッドを返します。`null`します。 例外はスローされません。 制御するかどうか、例外がスローされますのオーバー ロードを呼び出して、<xref:System.Type.GetType%2A>メソッドを持つ、`throwOnError`パラメーター。  
  
 呼び出しと同じには、このメソッドのオーバー ロードを呼び出し、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードを指定して`false`の`throwOnError`と`ignoreCase`パラメーター。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> が型名とアセンブリ名に解析された際にエラーが発生します (たとえば、単純な型名にエスケープされていない特殊文字が含まれている場合など)。  
  
または 
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
または 
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
または 
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。  
  
または 
 <paramref name="typeName" /> に無効なアセンブリ名が含まれています。  
  
または 
 <paramref name="typeName" /> が、型名のない有効なアセンブリ名です。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリ、またはその依存関係のうちの 1 つが無効です。  
  
または 
現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型の名前。 <paramref name="typeResolver" /> パラメーターを指定する場合は、<paramref name="typeResolver" /> が解決できる任意の文字列を型名として使用できます。 <paramref name="assemblyResolver" /> パラメーターを指定する場合、または標準の型解決を使用する場合は、<paramref name="typeName" /> をアセンブリ修飾名にする必要があります (<see cref="P:System.Type.AssemblyQualifiedName" />を参照)。ただし、現在実行されているアセンブリ内または Mscorlib.dll に型がある場合は、名前空間で修飾された型名を指定するだけで十分です。</param>
        <param name="assemblyResolver">で指定されたアセンブリを特定して返すメソッド<paramref name="typeName" />. <paramref name="assemblyResolver" /> には、アセンブリ名が <see cref="T:System.Reflection.AssemblyName" /> オブジェクトとして渡されます。 <paramref name="typeName" /> にアセンブリの名前が含まれていない場合、<paramref name="assemblyResolver" /> は呼び出されません。 <paramref name="assemblyResolver" /> を指定しない場合は、標準のアセンブリ解決が実行されます。  
  
注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。 渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。 指定したメソッドまたは使い慣れているメソッドだけを使用してください。</param>
        <param name="typeResolver"><paramref name="typeName" /> で指定された型を、<paramref name="assemblyResolver" /> または標準のアセンブリ解決によって返されたアセンブリから特定して返すメソッド。 アセンブリが指定されていない場合は、このメソッドで指定できます。 このメソッドは、大文字と小文字を区別せずに検索を実行するかどうかを指定するパラメーターも受け取ります。そのパラメーターには <see langword="false" /> が渡されます。  
  
注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。 また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」を参照してください。</param>
        <summary>型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</summary>
        <returns>指定した名前を持つ型。 型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの詳細な使用シナリオ、`assemblyResolver`と`typeResolver`でパラメーターが見つかりません、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードします。  
  
 呼び出しと同じには、このメソッドのオーバー ロードを呼び出し、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードを指定して`false`の`ignoreCase`パラメーター。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> が <see langword="true" /> です。型が見つかりません。  
  
または 
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> に埋め込まれたタブなどの正しくない文字が含まれています。 
または 
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は空の文字列です。  
  
または 
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は無効なサイズの配列型を表します。  
  
または 
 <paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> が型名とアセンブリ名に解析される際にエラーが発生します (たとえば、単純な型名にエスケープされていない特殊文字が含まれている場合など)。  
  
または 
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> に無効な構文 ("MyType[,*,]" など) が含まれています。  
  
または 
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
または 
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
または 
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。  
  
または 
 <paramref name="typeName" /> に無効なアセンブリ名が含まれています。  
  
または 
 <paramref name="typeName" /> が、型名のない有効なアセンブリ名です。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
または 
現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型の名前。 <paramref name="typeResolver" /> パラメーターを指定する場合は、<paramref name="typeResolver" /> が解決できる任意の文字列を型名として使用できます。 <paramref name="assemblyResolver" /> パラメーターを指定する場合、または標準の型解決を使用する場合は、<paramref name="typeName" /> をアセンブリ修飾名にする必要があります (<see cref="P:System.Type.AssemblyQualifiedName" />を参照)。ただし、現在実行されているアセンブリ内または Mscorlib.dll に型がある場合は、名前空間で修飾された型名を指定するだけで十分です。</param>
        <param name="assemblyResolver">で指定されたアセンブリを特定して返すメソッド<paramref name="typeName" />. <paramref name="assemblyResolver" /> には、アセンブリ名が <see cref="T:System.Reflection.AssemblyName" /> オブジェクトとして渡されます。 <paramref name="typeName" /> にアセンブリの名前が含まれていない場合、<paramref name="assemblyResolver" /> は呼び出されません。 <paramref name="assemblyResolver" /> を指定しない場合は、標準のアセンブリ解決が実行されます。  
  
注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。 渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。 指定したメソッドまたは使い慣れているメソッドだけを使用してください。</param>
        <param name="typeResolver"><paramref name="typeName" /> で指定された型を、<paramref name="assemblyResolver" /> または標準のアセンブリ解決によって返されたアセンブリから特定して返すメソッド。 アセンブリが指定されていない場合は、このメソッドで指定できます。 このメソッドは、大文字小文字を区別せずに検索を実行するかどうかを指定するパラメーターも受け取ります。そのパラメーターには、<paramref name="ignoreCase" /> の値が渡されます。  
  
注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。 また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」を参照してください。</param>
        <param name="ignoreCase">大文字と小文字を区別せずに <see langword="true" /> の検索を実行するには <paramref name="typeName" />。大文字と小文字を区別して <see langword="false" /> の検索を実行するには <paramref name="typeName" />。</param>
        <summary>大文字と小文字を区別せずに検索を実行するかどうか、および型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</summary>
        <returns>指定した名前を持つ型。 型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのオーバー ロードとその関連のオーバー ロードを使用して (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>と<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) の既定の実装を置き換える、<xref:System.Type.GetType%2A>より柔軟な実装を持つメソッド。 型名とこれらを含むアセンブリの名前を解決する独自のメソッドを用意するには、次の操作を行うことができます。  
  
-   型が読み込まれたアセンブリのバージョンを制御します。  
  
-   アセンブリ名を含まない型名を検索する別の場所を指定します。  
  
-   部分的なアセンブリ名を使用してアセンブリを読み込みます。  
  
-   サブクラスを返す<xref:System.Type?displayProperty=nameWithType>を共通言語ランタイム (CLR) では作成されません。  
  
 たとえば、バージョン トレラントなシリアル化でこのメソッド使用する部分的な名前を使用して"best fit"のアセンブリを検索できます。 他のオーバー ロード、<xref:System.Type.GetType%2A>メソッドに必要なアセンブリ修飾型名を持ち、バージョン番号が含まれます。  
  
 サブクラスを返す必要があります、型システムの代替実装を<xref:System.Type?displayProperty=nameWithType>は、CLR では作成されません。 すべての型の他のオーバー ロードによって返される、<xref:System.Type.GetType%2A>メソッドはランタイム型。  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>使用法  
 このメソッドのオーバー ロードとその関連のオーバー ロードが解析`typeName`型と、アセンブリの名前の名前にし、名前を解決します。 アセンブリ名の解決は、アセンブリのコンテキストで型名を解決する必要がありますので、型名の解決の前に発生します。  
  
> [!NOTE]
>  アセンブリ修飾型名の概念に慣れていない場合は、次を参照してください。、<xref:System.Type.AssemblyQualifiedName%2A>プロパティ。  
  
 場合`typeName`アセンブリ修飾名ではないアセンブリの解決はスキップされます。 Mscorlib.dll または現在実行中のアセンブリのコンテキストで非修飾型名を解決することも、内のアセンブリを行うことができます必要に応じて、`typeResolver`パラメーター。 などのさまざまな種類の名前解決が内のテーブルとして表示されているは、アセンブリ名を省略すると効果、[混合名前解決](#mixed_name_resolution)セクション。  
  
 一般的な使用法:  
  
-   メソッドは渡さない`assemblyResolver`または`typeResolver`不明または信頼されていない呼び出し元から来た場合。 指定したメソッドまたは使い慣れているメソッドだけを使用してください。  
  
    > [!CAUTION]
    >  不明または信頼されていない呼び出し元からメソッドを使用すると、悪意のあるコードの特権が昇格される可能性があります。  
  
-   省略した場合、`assemblyResolver`や`typeResolver`の値は、パラメーター、`throwOnError`パラメーターは、既定の解決を実行するメソッドに渡されます。  
  
-   場合`throwOnError`は`true`、このメソッドがスローされます、<xref:System.TypeLoadException>とき`typeResolver`を返します`null`と<xref:System.IO.FileNotFoundException>とき`assemblyResolver`を返します`null`。  
  
-   このメソッドによってスローされた例外をキャッチしません`assemblyResolver`と`typeResolver`します。 したが、競合回避モジュールのメソッドによってスローされる例外を担当します。  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>アセンブリを解決します。  
 `assemblyResolver`メソッドは受信、<xref:System.Reflection.AssemblyName>オブジェクトに含まれている文字列のアセンブリ名の解析によって生成される`typeName`します。 場合`typeName`アセンブリ名を含まない`assemblyResolver`が呼び出されないと`null`に渡される`typeResolver`します。  
  
 場合`assemblyResolver`が指定された、標準のアセンブリのプローブを使用してアセンブリを見つけます。 場合`assemblyResolver`が指定されて、<xref:System.Type.GetType%2A>メソッドでは、標準のプローブは実行しません。 そうすることが必要、`assemblyResolver`に渡すすべてのアセンブリを処理することができます。  
  
 `assemblyResolver`メソッドが返す`null`場合は、アセンブリを解決することはできません。 場合`assemblyResolver`返します`null`、`typeResolver`は呼び出されませんとそれ以上の処理が発生します。 さらに、場合`throwOnError`は`true`、<xref:System.IO.FileNotFoundException>がスローされます。  
  
 場合、<xref:System.Reflection.AssemblyName>に渡される`assemblyResolver`部分は、名前、1 つ以上の一部が`null`します。 たとえば、バージョン、設定されていない場合、<xref:System.Reflection.AssemblyName.Version%2A>プロパティは`null`します。 場合、<xref:System.Reflection.AssemblyName.Version%2A>プロパティ、<xref:System.Reflection.AssemblyName.CultureInfo%2A>プロパティ、および<xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A>メソッドの戻り値のすべて`null`、アセンブリの簡易名のみが指定されました。 `assemblyResolver`メソッドを使用したり、アセンブリ名のすべての部分を無視します。  
  
 別のアセンブリ解決のオプションの効果は内のテーブルとして表示されます、[混合名前解決](#mixed_name_resolution)のシンプルかつアセンブリ修飾型名のセクション。  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>型の解決  
 場合`typeName`アセンブリ名を指定しない`typeResolver`常に呼び出されます。 場合`typeName`、アセンブリ名を指定します`typeResolver`アセンブリ名が正常に解決されるときにのみ呼び出されます。 場合`assemblyResolver`または標準のアセンブリをプローブ返します`null`、`typeResolver`は呼び出されません。  
  
 `typeResolver`メソッドは 3 つの引数を受け取ります。  
  
-   検索するアセンブリまたは`null`場合`typeName`にアセンブリ名が含まれていません。  
  
-   型の簡易名。 入れ子になった型の場合、最も外側にある含んでいる型になります。 ジェネリック型の場合、これは、ジェネリック型の簡易名です。  
  
-   ブール値`true`型名の大文字と小文字の無視する場合。  
  
 実装は、これらの引数の使用方法を決定します。 `typeResolver`メソッドが返す`null`型を解決できない場合。 場合`typeResolver`返します`null`と`throwOnError`は`true`のこのオーバー ロード<xref:System.Type.GetType%2A>スロー、 <xref:System.TypeLoadException>。  
  
 別の型解決オプションの効果は内のテーブルとして表示されます、[混合名前解決](#mixed_name_resolution)のシンプルかつアセンブリ修飾型名のセクション。  
  
#### <a name="resolving-nested-types"></a>入れ子にされた型を解決します。  
 場合`typeName`は入れ子にされた型、最も外側の名前だけに渡される型を含む`typeResolver`します。 ときに`typeResolver`この型を返します、<xref:System.Type.GetNestedType%2A>メソッドが最も内側の入れ子にされた型が解決されるまでに再帰的には呼び出されます。  
  
#### <a name="resolving-generic-types"></a>ジェネリック型の解決  
 <xref:System.Type.GetType%2A>ジェネリック型を解決するには、再帰的と呼びます。自体は、ジェネリック型を解決するのには、最初にし、型引数を解決します。 型引数が、ジェネリックの場合<xref:System.Type.GetType%2A>型引数を解決するには、再帰的と呼びます。  
  
 組み合わせた`assemblyResolver`と`typeResolver`この再帰のすべてのレベルを解決できるようにする必要がありますを指定することです。 たとえば、指定した、`assemblyResolver`の読み込みを制御する`MyAssembly`します。 ジェネリック型を解決したいとします`Dictionary<string, MyType>`(`Dictionary(Of String, MyType)` Visual Basic で)。 次のジェネリック型の名前を渡す場合があります。  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 注意`MyType`のみのアセンブリ修飾の型引数です。 名前、<xref:System.Collections.Generic.Dictionary%602>と<xref:System.String>クラスはアセンブリ修飾できません。 `typeResolver`できるハンドルである必要がありますか、アセンブリまたは`null`を受信するため、`null`の<xref:System.Collections.Generic.Dictionary%602>と<xref:System.String>します。 その場合のオーバー ロードを呼び出すことによって処理できる、 <xref:System.Type.GetType%2A> Mscorlib.dll が非修飾型名の両方があるため、文字列を受け取るメソッド。  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 `assemblyResolver`これらの型名はアセンブリ修飾ではないために、辞書の型と文字列型のメソッドが呼び出されません。  
  
 たとえばの代わりに`System.String`、最初のジェネリック引数の型が`YourType`から`YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 解決できないため、このアセンブリには、Mscorlib.dll でも、現在実行中のアセンブリが、`YourType`せず、アセンブリ修飾名。 `assemblyResolve`は再帰的に呼び出されると、できる必要がある場合に対処します。 返す代わりに`null`以外のアセンブリの`MyAssembly`、指定されたを使用してアセンブリの読み込みを実行するようになりました<xref:System.Reflection.AssemblyName>オブジェクト。  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 戻る[の使用法](#usage_notes)します。  
  
#### <a name="resolving-type-names-with-special-characters"></a>特殊文字を含む型名を解決します。  
 特定の文字は、アセンブリ修飾名で特別な意味を持ちます。 単純型の名前にこれらの文字が含まれている場合、文字では、簡易名は、アセンブリ修飾名の一部で、解析エラーが発生します。 解析エラーを避けるためをアセンブリ修飾名を渡す前に、円記号と特殊文字をエスケープする必要があります、<xref:System.Type.GetType%2A>メソッド。 たとえば、型が名前付き`Strange]Type`、エスケープ文字を角かっこの前に、次のように追加する必要があります:`Strange\]Type`します。  
  
> [!NOTE]
>  このような特殊文字名では、Visual Basic または c# で作成することはできませんが、Microsoft intermediate language (MSIL) を使用するか、動的アセンブリを出力に作成できます。  
  
 次の表では、型名に特殊文字を示します。  
  
|文字|説明|  
|---------------|-------------|  
|`,` (コンマ)|アセンブリ修飾名の区切り記号。|  
|`[]` (角かっこ)|サフィックスのペアとして、配列の型を示します区切り記号のペアとして、汎用引数リストとアセンブリ修飾名を囲みます。|  
|`&` (アンパサンド)|サフィックスとして、型が参照型であることを示します。|  
|`*` (アスタリスク)|サフィックスとして、型がポインター型であることを示します。|  
|`+` (プラス)|入れ子にされた型の区切り記号。|  
|`\` (円記号)|文字をエスケープします。|  
  
 などのプロパティ<xref:System.Type.AssemblyQualifiedName%2A>正しくエスケープされた文字列を返します。 正しくエスケープされた文字列を渡す必要があります、<xref:System.Type.GetType%2A>メソッド。 さらに、<xref:System.Type.GetType%2A>メソッドは、正しくエスケープされた名前を渡します`typeResolver`と既定の型の解決方法。 かどうかは、エスケープされていない名に名前を比較する必要があります。 `typeResolver`、エスケープ文字を削除する必要があります。  
  
 戻る[の使用法](#usage_notes)します。  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>Mixed 名前解決  
 次の表は、間の相互作用をまとめたものです`assemblyResolver`、 `typeResolver`、型名とアセンブリ名のすべての組み合わせに対して、既定の名前解決と`typeName`:。  
  
|型名の内容|アセンブリ リゾルバー メソッド|型競合回避モジュールのメソッド|結果|  
|---------------------------|------------------------------|--------------------------|------------|  
|アセンブリの種類|null|null|呼び出しに相当、<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>メソッドのオーバー ロードします。|  
|アセンブリの種類|提供されます。|null|`assemblyResolver` アセンブリを返すかを返します`null`アセンブリを解決できない場合。 アセンブリが解決される場合、<xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>は、アセンブリから型を読み込むメソッドのオーバー ロードが使用されます。 それ以外の場合、型の解決を試行はありません。|  
|アセンブリの種類|null|提供されます。|アセンブリ名を変換と同じ、<xref:System.Reflection.AssemblyName>オブジェクトと呼び出し、<xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType>アセンブリを取得するメソッドのオーバー ロードします。 渡されるアセンブリが解決した場合は、 `typeResolver`、それ以外の`typeResolver`は呼び出されません型を解決しようがありません。|  
|アセンブリの種類|提供されます。|提供されます。|`assemblyResolver` アセンブリを返すかを返します`null`アセンブリを解決できない場合。 渡されるアセンブリが解決した場合は、 `typeResolver`、それ以外の`typeResolver`は呼び出されません型を解決しようがありません。|  
|型|null に用意されています。|null|呼び出しに相当、<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>メソッドのオーバー ロードします。 アセンブリ名が指定されていないために、Mscorlib.dll と現在実行中のアセンブリのみが検索されます。 場合`assemblyResolver`が指定されて、無視されます。|  
|型|null に用意されています。|提供されます。|`typeResolver` 呼び出されると`null`のアセンブリが渡されます。 `typeResolver` 目的のため読み込むアセンブリを含む、任意のアセンブリから型を提供できます。 場合`assemblyResolver`が指定されて、無視されます。|  
|アセンブリ|null に用意されています。|null に用意されています。|A<xref:System.IO.FileLoadException>アセンブリ修飾型名の場合と同様に、アセンブリ名は解析されるので、スローされます。 これは、結果、無効なアセンブリ名。|  
  
 をバックアップします。[使用法](#usage_notes)、[アセンブリを解決する](#resolving_assemblies)、[型の解決](#resolving_types)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> が <see langword="true" /> です。型が見つかりません。  
  
または 
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> に埋め込まれたタブなどの正しくない文字が含まれています。 
または 
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は空の文字列です。  
  
または 
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> は無効なサイズの配列型を表します。  
  
または 
 <paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> が型名とアセンブリ名に解析される際にエラーが発生します (たとえば、単純な型名にエスケープされていない特殊文字が含まれている場合など)。  
  
または 
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> に無効な構文 ("MyType[,*,]" など) が含まれています。  
  
または 
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
または 
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
または 
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。  
  
または 
 <paramref name="typeName" /> に無効なアセンブリ名が含まれています。  
  
または 
 <paramref name="typeName" /> が、型名のない有効なアセンブリ名です。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリ、またはその依存関係のうちの 1 つが無効です。  
  
または 
現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">型を確認する対象のオブジェクトの配列。</param>
        <summary>指定した配列内のオブジェクトの型を取得します。</summary>
        <returns><paramref name="args" /> 内の対応する要素の型を表す <see cref="T:System.Type" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、使用する方法を示します、<xref:System.Type.GetTypeArray%2A>メソッドを配列の要素の種類を一覧表示します。  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> は <see langword="null" />です。  
  
または 
<paramref name="args" /> の要素の 1 つ以上が <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラスの初期化子が呼び出され、少なくとも 1 つは例外をスローします。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">基になる型コードを取得する対象となる型。</param>
        <summary>指定した <see cref="T:System.Type" /> の基になる型コードを取得します。</summary>
        <returns><paramref name="type" /> が <see langword="null" /> の場合、基になる型または <see cref="F:System.TypeCode.Empty" /> のコード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 継承する場合<xref:System.Type>、オーバーライドすることでこのメソッドの動作を変更することができます、<xref:System.Type.GetTypeCodeImpl%2A>メソッド。  
  
   
  
## Examples  
 コード例を次に示しますが、どのように<xref:System.TypeCode>列挙体を使用できます。 意思決定ブロック内で、`WriteObjectInfo`メソッド、<xref:System.TypeCode>の<xref:System.Object>パラメーターが調べられるし、適切なメッセージがコンソールに書き込まれます。  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Type" /> インスタンスの基になる型コードを返します。</summary>
        <returns>基になる型の型コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの実装を提供する、 `static` (で C# の場合) または`Shared`(Visual Basic) で<xref:System.Type.GetTypeCode%28System.Type%29>メソッド。 継承する場合<xref:System.Type>、独自の実装を提供するには、このメソッドをオーバーライドできます<xref:System.Type.GetTypeCode%2A>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したクラス識別子 (CLSID) に関連付けられている型を取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">取得する型の CLSID。</param>
        <summary>指定したクラス識別子 (CLSID) に関連付けられている型を取得します。</summary>
        <returns>CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>メソッドをサポートしています遅延バインディング アクセス アンマネージ COM オブジェクトを .NET Framework アプリから COM オブジェクトのクラス id (CLSID) がわかっている場合。  COM クラスのクラス識別子は、レジストリの hkey_classes_root \clsid キーで定義されます。 値を取得することができます、<xref:System.Type.IsCOMObject%2A>プロパティをこのメソッドによって返される型が COM オブジェクトかどうかを確認します。  
  
> [!TIP]
>  呼び出すことができます、 <xref:System.Type.GetTypeFromProgID%2A> COM に遅延バインディング アクセスの方法がわかっているプログラム id (ProgID) のオブジェクトします。  
  
 2 段階のプロセスには、CLSID からアンマネージ COM オブジェクトをインスタンス化します。  
  
1.  取得、<xref:System.Type>を表すオブジェクトを`__ComObject`CLSID を呼び出すことによって対応する、<xref:System.Type.GetTypeFromCLSID%2A>メソッド。  
  
2.  呼び出す、 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> COM オブジェクトをインスタンス化するメソッド。  
  
 図の例を参照してください。  
  
 <xref:System.Type.GetTypeFromCLSID%28System.Guid%29>オーバー ロードがインスタンス化するときに発生する可能性のある例外を無視する<xref:System.Type>オブジェクトに基づいて、`clsid`引数。 場合に例外がスローされないので注意`clsid`がレジストリに見つかりません。  
  
   
  
## Examples  
 次のコードの例では、Microsoft Word の CLSID[アプリケーション オブジェクト](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)Microsoft Word のアプリケーションを表す COM 型を取得します。 呼び出すことによって、型をインスタンス化、<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>メソッドを呼び出すことで閉じると、 [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)メソッド。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>.NET Framework オブジェクトではなく、COM オブジェクトを使用する場合、このメソッドは使用するもの。 管理対象オブジェクト、COM から参照できるものも含めすべて (つまり、その<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性が<see langword="true" />) によって返される GUID を持つ、<see cref="P:System.Type.GUID" />プロパティ。 メソッドを返しますが、<see cref="T:System.Type" />オブジェクト GUID に対応する .NET Framework 用のオブジェクトを使用することはできません<see cref="T:System.Type" />呼び出すことによって、型のインスタンスを作成するオブジェクト、<see cref="M:System.Activator.CreateInstance(System.Type)" />メソッドを次の例を示します。  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
代わりに、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />アンマネージ COM オブジェクト、および結果の GUID の取得にのみ使用する必要があります<see cref="T:System.Type" />オブジェクトに渡される、<see cref="M:System.Activator.CreateInstance(System.Type)" />メソッドはアンマネージ COM オブジェクトを表す必要があります。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">取得する型の CLSID。</param>
        <param name="throwOnError">発生した例外をすべてスローする場合は <see langword="true" />。  
  
または 
 発生した例外をすべて無視する場合は <see langword="false" />。</param>
        <summary>型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したクラス ID (CLSID) に関連付けられた型を取得します。</summary>
        <returns>CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>メソッドをサポートしています遅延バインディング アクセス アンマネージ COM オブジェクトを .NET Framework アプリから COM オブジェクトのクラス id (CLSID) がわかっている場合。  COM クラスのクラス識別子は、レジストリの hkey_classes_root \clsid キーで定義されます。 値を取得することができます、<xref:System.Type.IsCOMObject%2A>プロパティをこのメソッドによって返される型が COM オブジェクトかどうかを確認します。  
  
> [!TIP]
>  呼び出すことができます、 <xref:System.Type.GetTypeFromProgID%2A> COM に遅延バインディング アクセスの方法がわかっているプログラム id (ProgID) のオブジェクトします。  
  
 2 段階のプロセスには、CLSID からアンマネージ COM オブジェクトをインスタンス化します。  
  
1.  取得、<xref:System.Type>を表すオブジェクトを`__ComObject`CLSID を呼び出すことによって対応する、<xref:System.Type.GetTypeFromCLSID%2A>メソッド。  
  
2.  呼び出す、 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> COM オブジェクトをインスタンス化するメソッド。  
  
 図の例を参照してください。  
  
 ような例外<xref:System.OutOfMemoryException>を指定する場合にスローされる`true`の`throwOnError`、未登録の Clsid に対しては失敗しませんが、します。  
  
   
  
## Examples  
 次のコードの例では、Microsoft Word の CLSID[アプリケーション オブジェクト](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)Microsoft Word のアプリケーションを表す COM 型を取得します。 呼び出すことによって、型をインスタンス化、<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>メソッドを呼び出すことで閉じると、 [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)メソッド。 型の読み込み中にエラーが発生した場合、例外がスローされます。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>.NET Framework オブジェクトではなく、COM オブジェクトを使用する場合、このメソッドは使用するもの。 管理対象オブジェクト、COM から参照できるものも含めすべて (つまり、その<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性が<see langword="true" />) によって返される GUID を持つ、<see cref="P:System.Type.GUID" />プロパティ。 メソッドを返しますが、<see cref="T:System.Type" />オブジェクト GUID に対応する .NET Framework 用のオブジェクトを使用することはできません<see cref="T:System.Type" />呼び出すことによって、型のインスタンスを作成するオブジェクト、<see cref="M:System.Activator.CreateInstance(System.Type)" />メソッドを次の例を示します。  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
代わりに、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />アンマネージ COM オブジェクト、および結果の GUID の取得にのみ使用する必要があります<see cref="T:System.Type" />オブジェクトに渡される、<see cref="M:System.Activator.CreateInstance(System.Type)" />メソッドはアンマネージ COM オブジェクトを表す必要があります。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">取得する型の CLSID。</param>
        <param name="server">型の読み込み元のサーバー。 サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</param>
        <summary>指定したサーバーから、指定したクラス ID (CLSID) に関連付けられている型を取得します。</summary>
        <returns>CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>メソッドをサポートしています遅延バインディング アクセス アンマネージ COM オブジェクトを .NET Framework アプリから COM オブジェクトのクラス id (CLSID) がわかっている場合。  COM クラスのクラス識別子は、レジストリの hkey_classes_root \clsid キーで定義されます。 値を取得することができます、<xref:System.Type.IsCOMObject%2A>プロパティをこのメソッドによって返される型が COM オブジェクトかどうかを確認します。  
  
> [!TIP]
>  呼び出すことができます、 <xref:System.Type.GetTypeFromProgID%2A> COM に遅延バインディング アクセスの方法がわかっているプログラム id (ProgID) のオブジェクトします。  
  
 2 段階のプロセスには、CLSID からアンマネージ COM オブジェクトをインスタンス化します。  
  
1.  取得、<xref:System.Type>を表すオブジェクトを`__ComObject`CLSID を呼び出すことによって対応する、<xref:System.Type.GetTypeFromCLSID%2A>メソッド。  
  
2.  呼び出す、 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> COM オブジェクトをインスタンス化するメソッド。  
  
   
  
## Examples  
 次のコードの例では、Microsoft Word の CLSID[アプリケーション オブジェクト](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)computer17.central.contoso.com という名前のサーバーから Microsoft Word のアプリケーションを表す COM 型を取得します。 呼び出すことによって、型をインスタンス化、<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>メソッドを呼び出すことで閉じると、 [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)メソッド。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>.NET Framework オブジェクトではなく、COM オブジェクトを使用する場合、このメソッドは使用するもの。 管理対象オブジェクト、COM から参照できるものも含めすべて (つまり、その<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性が<see langword="true" />) によって返される GUID を持つ、<see cref="P:System.Type.GUID" />プロパティ。 メソッドを返しますが、<see cref="T:System.Type" />オブジェクト GUID に対応する .NET Framework 用のオブジェクトを使用することはできません<see cref="T:System.Type" />呼び出すことによって、型のインスタンスを作成するオブジェクト、<see cref="M:System.Activator.CreateInstance(System.Type)" />メソッドを次の例を示します。  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
代わりに、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />アンマネージ COM オブジェクト、および結果の GUID の取得にのみ使用する必要があります<see cref="T:System.Type" />オブジェクトに渡される、<see cref="M:System.Activator.CreateInstance(System.Type)" />メソッドはアンマネージ COM オブジェクトを表す必要があります。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">取得する型の CLSID。</param>
        <param name="server">型の読み込み元のサーバー。 サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</param>
        <param name="throwOnError">発生した例外をすべてスローする場合は <see langword="true" />。  
  
または 
 発生した例外をすべて無視する場合は <see langword="false" />。</param>
        <summary>型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したサーバーの指定したクラス ID (CLSID) に関連付けられた型を取得します。</summary>
        <returns>CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>メソッドをサポートしています遅延バインディング アクセス アンマネージ COM オブジェクトを .NET Framework アプリから COM オブジェクトのクラス id (CLSID) がわかっている場合。  COM クラスのクラス識別子は、レジストリの hkey_classes_root \clsid キーで定義されます。 値を取得することができます、<xref:System.Type.IsCOMObject%2A>プロパティをこのメソッドによって返される型が COM オブジェクトかどうかを確認します。  
  
> [!TIP]
>  呼び出すことができます、 <xref:System.Type.GetTypeFromProgID%2A> COM に遅延バインディング アクセスの方法がわかっているプログラム id (ProgID) のオブジェクトします。  
  
 2 段階のプロセスには、CLSID からアンマネージ COM オブジェクトをインスタンス化します。  
  
1.  取得、<xref:System.Type>を表すオブジェクトを`__ComObject`CLSID を呼び出すことによって対応する、<xref:System.Type.GetTypeFromCLSID%2A>メソッド。  
  
2.  呼び出す、 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> COM オブジェクトをインスタンス化するメソッド。  
  
 ような例外<xref:System.OutOfMemoryException>を指定する場合にスローされる`true`の`throwOnError`、未登録の Clsid に対しては失敗しませんが、します。  
  
   
  
## Examples  
 次のコードの例では、Microsoft Word の CLSID[アプリケーション オブジェクト](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)computer17.central.contoso.com という名前のサーバーから Microsoft Word のアプリケーションを表す COM 型を取得します。 呼び出すことによって、型をインスタンス化、<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>メソッドを呼び出すことで閉じると、 [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)メソッド。 型の読み込み中にエラーが発生した場合、例外がスローされます。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>.NET Framework オブジェクトではなく、COM オブジェクトを使用する場合、このメソッドは使用するもの。 管理対象オブジェクト、COM から参照できるものも含めすべて (つまり、その<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性が<see langword="true" />) によって返される GUID を持つ、<see cref="P:System.Type.GUID" />プロパティ。 ですが、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />メソッドを返しますを<see cref="T:System.Type" />、特定の管理対象オブジェクトの GUID に対応するオブジェクトを使用することはできません<see cref="T:System.Type" />呼び出すことによって、型のインスタンスを作成するオブジェクト、<see cref="M:System.Activator.CreateInstance(System.Type)" />メソッドの次の例として、。示しています。  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
代わりに、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />アンマネージ COM オブジェクト、および結果の GUID の取得にのみ使用する必要があります<see cref="T:System.Type" />オブジェクトに渡される、<see cref="M:System.Activator.CreateInstance(System.Type)" />メソッドはアンマネージ COM オブジェクトを表す必要があります。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">型を参照するオブジェクト。</param>
        <summary>指定した型ハンドルによって参照される型を取得します。</summary>
        <returns>指定した <see cref="T:System.RuntimeTypeHandle" /> によって参照される型。または <paramref name="handle" /> の <see cref="P:System.RuntimeTypeHandle.Value" /> プロパティが <see langword="null" /> の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドルは、取得されたアプリケーション ドメインでのみ有効です。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.GetTypeFromHandle%2A>を取得するメソッド、<xref:System.Type>オブジェクトから、<xref:System.RuntimeTypeHandle>によって提供される、<xref:System.Type.GetTypeHandle%2A>メソッド。  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したプログラム ID (ProgID) に関連付けられている型を取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">取得する型の ProgID。</param>
        <summary>指定されたプログラム ID (ProgID) に関連付けられている型を取得し、<see cref="T:System.Type" /> の読み込み中にエラーが発生した場合は null を返します。</summary>
        <returns><paramref name="progID" /> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したクラス ProgID に関連付けられている型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが提供される COM サポートをします。 Progid は、名前空間の概念によって置き換えられたため、Microsoft .NET Framework では使用されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> は <see langword="null" />です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">取得する型の ProgID。</param>
        <param name="throwOnError">発生した例外をすべてスローする場合は <see langword="true" />。  
  
または 
 発生した例外をすべて無視する場合は <see langword="false" />。</param>
        <summary>型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定されたプログラム ID (ProgID) に関連付けられた型を取得します。</summary>
        <returns><paramref name="progID" /> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したプログラム ID (ProgID) に関連付けられている型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが提供される COM サポートをします。 プログラム Id は、名前空間の概念によって置き換えられたため、Microsoft .NET Framework では使用されません。  
  
   
  
## Examples  
 次の例では、ProgID が有効でない場合は、例外をスローするかどうかを指定する、ProgID を渡すことによって、型を取得します。 関連するすべての該当する例外メッセージと共に、ProgID ClassID を表示します。  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">指定された ProgID が登録されていません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">取得する型の progID。</param>
        <param name="server">型の読み込み元のサーバー。 サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</param>
        <summary>指定したサーバーから、指定したプログラム ID (progID) に関連付けられている型を取得し、型の読み込み中にエラーが発生した場合は null を返します。</summary>
        <returns><paramref name="progID" /> がレジストリの正しいエントリで、型がそれに関連付けられている場合は、指定したプログラム ID (progID) に関連付けられている型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが提供される COM サポートをします。 プログラム Id は、名前空間の概念によって置き換えられたため、Microsoft .NET Framework では使用されません。  
  
   
  
## Examples  
 次の例では、ProgID とサーバー名を渡すことによって、型を取得します。 次に、例では、ProgID に関連する ClassID を表示しますか、ProgID またはサーバー名が有効でない場合は、例外をスローします。  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="prodID" /> は <see langword="null" />です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">取得する <see cref="T:System.Type" /> の progID。</param>
        <param name="server">型の読み込み元のサーバー。 サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</param>
        <param name="throwOnError">発生した例外をすべてスローする場合は <see langword="true" />。  
  
または 
 発生した例外をすべて無視する場合は <see langword="false" />。</param>
        <summary>型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したサーバーの指定したプログラム ID (progID) に関連付けられた型を取得します。</summary>
        <returns><paramref name="progID" /> がレジストリの正しいエントリで、型がそれに関連付けられている場合は、指定したプログラム ID (progID) に関連付けられている型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが提供される COM サポートをします。 プログラム Id は、名前空間の概念によって置き換えられたため、Microsoft .NET Framework では使用されません。  
  
   
  
## Examples  
 次の例では、ProgID とサーバー名を渡すことによって、型を取得します。 例では、ProgID、ProgID またはサーバー名が有効でない場合は、例外をスローするかどうかを指定することに関連する ClassID が表示されます。  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">指定された progID が登録されていません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">型ハンドルの取得対象となるオブジェクト。</param>
        <summary>指定したオブジェクトの <see cref="T:System.Type" /> のハンドルを取得します。</summary>
        <returns>指定した <see cref="T:System.Type" /> の <see cref="T:System.Object" /> のハンドル。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドルは、取得されたアプリケーション ドメインでのみ有効です。  
  
   
  
## Examples  
 次の例では、クラスを定義する`MyClass1`のインスタンスを取得およびオブジェクトのランタイム ハンドルを取得します。  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> に関連付けられている GUID を取得します。</summary>
        <value><see cref="T:System.Type" /> に関連付けられている GUID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GUID は、型を使用して、関連付け、<xref:System.Runtime.InteropServices.GuidAttribute>属性。  
  
   
  
## Examples  
 次の例は、クラスを作成`MyClass1`のパブリック メソッドを作成します、`Type`オブジェクトに対応する`MyClass1`を取得し、<xref:System.Guid>を使用して構造体、`GUID`のプロパティ、`Type`クラス。  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が別の型を包含または参照しているかどうか、つまり現在の <see cref="T:System.Type" /> が配列、ポインター、または参照渡しかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が配列やポインターであるか、参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For example, Type.GetType("Int32[]").HasElementType returns `true`, but Type.GetType("Int32").HasElementType returns `false`. HasElementType も返します`true`の「Int32 *」と"Int32 (& a)"。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型またはジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`false`します。  
  
   
  
## Examples  
 次の例を返します`true`または`false`オブジェクトは、配列、参照型またはポインターかどうかによって異なります。  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされた場合、<see cref="P:System.Type.HasElementType" /> プロパティを実装し、現在の <see cref="T:System.Type" /> が別の型を包含または参照しているかどうか、つまり現在の <see cref="T:System.Type" /> が配列やポインターであるか、参照渡しかどうかを判断します。</summary>
        <returns><see langword="true" /> が配列やポインターであるか、参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For example, Type.GetType("Int32[]").HasElementTypeImpl returns `true`, but Type.GetType("Int32").HasElementTypeImpl returns `false`. HasElementTypeImpl も返します`true`の「Int32 *」と"Int32 (& a)"。  
  
   
  
## Examples  
 次の例では、クラスを定義する`MyTypeDelegator`が優先されます、`HasElementTypeImpl`メソッド。 メイン クラスをチェック、`HasElementType`型の要素のプロパティを表示します。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の特定のメンバーを呼び出します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。  
  
または 
既定メンバーを呼び出すための空の文字列 ("")。  
  
または 
<see langword="IDispatch" /> メンバーの場合は、"[DispID=3]" のように DispID を表す文字列。</param>
        <param name="invokeAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。 アクセスは、<see langword="BindingFlags" />、<see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> など、<see langword="GetField" /> のうちの 1 つになります。 検索の種類を指定する必要はありません。 検索の種類が省略されている場合は、<see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> を使用します。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
または 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。 可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<see cref="T:System.Reflection.Binder" /> オブジェクトを明示的に定義することが必要な場合があるのでご注意ください。</param>
        <param name="target">指定したメンバーを呼び出す対象となるオブジェクト。</param>
        <param name="args">呼び出すメンバーに渡される引数を格納する配列。</param>
        <summary>指定したバインディング制約を使用し、指定した引数リストと照合して、指定したメンバーを呼び出します。</summary>
        <returns>呼び出されるメンバーの戻り値を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  使用することはできません<xref:System.Type.InvokeMember%2A>ジェネリック メソッドを呼び出します。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。  
  
-   指定`BindingFlags.Public`検索にパブリック メンバーを含める。  
  
-   指定`BindingFlags.NonPublic`検索条件に非パブリック メンバー (つまり、private と protected のメンバー) を含める。  
  
-   指定`BindingFlags.FlattenHierarchy`階層の静的メンバーを含めます。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase` 大文字と小文字を無視する`name`します。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたメンバーのみを検索する、 <xref:System.Type>、継承されたメンバーされません。  
  
 次<xref:System.Reflection.BindingFlags>呼び出しフラグは、メンバーを取得するには、どのような操作を示すために使用できます。  
  
-   `CreateInstance` コンス トラクターを呼び出す。 `name` 無視されます。 他の呼び出しフラグが無効です。  
  
-   `InvokeMethod` コンス トラクターまたは型の初期化子ではされませんが、メソッドを呼び出す。 無効`SetField`または`SetProperty`します。 場合`InvokeMethod`自体で指定された`BindingFlags.Public`、 `BindingFlags.Instance`、および`BindingFlags.Static`が自動的に含まれています。  
  
-   `GetField` フィールドの値を取得します。 無効`SetField`します。  
  
-   `SetField` フィールドの値を設定します。 無効`GetField`します。  
  
-   `GetProperty` プロパティを取得します。 無効`SetProperty`します。  
  
-   `SetProperty` プロパティを設定します。 無効`GetProperty`します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 次の条件の両方に該当する場合、メソッドが呼び出されます。  
  
-   メソッド宣言パラメーターの数の引数の数に等しい、`args`配列 (既定の引数がメンバーに定義されていない場合と`BindingFlags.OptionalParamBinding`を指定)。  
  
-   各引数の型は、バインダーによってパラメーターの型に変換できます。  
  
 バインダーは、すべての一致するメソッドに紹介します。 要求されたバインドの種類に基づいてこれらのメソッドが検出された (<xref:System.Reflection.BindingFlags>値`InvokeMethod`、`GetProperty`など)。 メソッドのセットは、名前、引数の数とバインダーで定義されている検索修飾子のセットによってフィルター処理されます。  
  
 メソッドを選択した後に呼び出されます。 ユーザー補助機能は、その時点でチェックされます。 検索では、メソッドに関連付けられているユーザー補助属性に基づいて、メソッドのセットを検索するかを制御できます。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>のメソッド、<xref:System.Reflection.Binder>クラスが呼び出されるメソッドを選択する責任を負います。 既定のバインダーでは、最も具体的な一致を選択します。  
  
 完全に信頼されたコードのアクセス制限は無視されます。つまり、プライベート コンス トラクター、メソッド、フィールド、およびプロパティにアクセスできを通じて呼び出される<xref:System.Reflection>たびに、コードが完全に信頼されました。  
  
 使用することができます`Type.InvokeMember`を指定して、特定の値にフィールドを設定する<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>します。 たとえば、クラス C、および F と F をという名前のパブリック インスタンス フィールドを設定する場合は、`String`などのコードを使用することができます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 F がある場合、`String[]`などのコードを使用することができます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 この新しい配列にフィールド F が初期化されます。 使用することも`Type.InvokeMember`など、次のコードを使用して、値と、次の値のインデックスを指定することによって、配列内の位置を設定します。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 これにより、文字列"b"に F を保持する配列内の文字列"z"が変更されます。  
  
 呼び出した場合、`IDispatch`メンバー、文字列形式を使用して、メンバー名の代わりに DispID を指定する"[DispID = ##]"。 たとえば、MyComMethod の DispID が 3 の場合は、文字列を指定できます"[DispID = 3]""MyComMethod"の代わりにします。 メンバーの DispID を呼び出すことは、名前で、メンバーを調べるよりも高速です。 複雑な集計のシナリオで、DispID は必要なメンバーを呼び出すための唯一の方法でがあります。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、呼び出し元が許可されている場合は、非パブリック メンバーへのアクセスに使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグを設定し、許可セットまたはサブセットに非パブリック メンバーの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 次の例では`InvokeMember`型のメンバーにアクセスします。  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> に <see langword="CreateInstance" /> が含まれず、<paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> が有効な <see cref="T:System.Reflection.BindingFlags" /> 属性ではありません。  
  
または 
 <paramref name="invokeAttr" /> にバインド フラグ <see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> のいずれかが含まれていません。  
  
または 
 <paramref name="invokeAttr" /> に、<see langword="CreateInstance" /> と <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> との組み合わせが含まれています。  
  
または 
 <paramref name="invokeAttr" /> に <see langword="GetField" /> と <see langword="SetField" /> の両方が含まれています。  
  
または 
 <paramref name="invokeAttr" /> に <see langword="GetProperty" /> と <see langword="SetProperty" /> の両方が含まれています。  
  
または 
 <paramref name="invokeAttr" /> に、<see langword="InvokeMethod" /> と <see langword="SetField" /> または <see langword="SetProperty" /> との組み合わせが含まれています。  
  
または 
 <paramref name="invokeAttr" /> に <see langword="SetField" /> が含まれており、<paramref name="args" /> に複数の要素があります。  
  
または 
COM オブジェクトでこのメソッドが呼び出され、バインド フラグ <see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" />、<see langword="BindingFlags.PutRefDispProperty" /> のいずれかが渡されませんでした。  
  
または 
名前付きパラメーター配列の 1 つに、<see langword="null" /> である文字列が含まれています。</exception>
        <exception cref="T:System.MethodAccessException">指定されたメンバーは、クラス初期化子です。</exception>
        <exception cref="T:System.MissingFieldException">フィールドまたはプロパティが見つかりません。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="args" /> 内の引数と一致するメソッドが見つかりません。  
  
または 
現在の <see cref="T:System.Type" /> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返します。</exception>
        <exception cref="T:System.Reflection.TargetException">指定されたメンバーを <paramref name="target" /> で呼び出すことができません。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">複数のメソッドがバインディングの基準と一致します。</exception>
        <exception cref="T:System.NotSupportedException">現在、.NET Compact Framework は、このメソッドをサポートしていません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="name" /> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。 つまり、このメソッドの <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> プロパティが <see langword="true" /> を返します。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">アクセス許可に関係なく、非パブリック メンバーの次のように設定します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。  
  
または 
既定メンバーを呼び出すための空の文字列 ("")。  
  
または 
<see langword="IDispatch" /> メンバーの場合は、"[DispID=3]" のように DispID を表す文字列。</param>
        <param name="invokeAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。 アクセスは、<see langword="BindingFlags" />、<see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> など、<see langword="GetField" /> のうちの 1 つになります。 検索の種類を指定する必要はありません。 検索の種類が省略されている場合は、<see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> を使用します。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
または 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。 可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<see cref="T:System.Reflection.Binder" /> オブジェクトを明示的に定義することが必要な場合があるのでご注意ください。</param>
        <param name="target">指定したメンバーを呼び出す対象となるオブジェクト。</param>
        <param name="args">呼び出すメンバーに渡される引数を格納する配列。</param>
        <param name="culture">使用するグローバリゼーション ロケールを表すオブジェクト。これは、<see cref="T:System.String" /> 型の数値を <see cref="T:System.Double" /> に変換するなど、ロケール固有の変換を実行するために必要となる場合があります。  
  
または 
現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> を使用する場合は、null 参照 (Visual Basic の場合は <see langword="Nothing" />)。</param>
        <summary>指定したバインディング制約を使用し、指定したメンバーのうち、指定した引数リストおよびカルチャと一致するメンバーを呼び出します。</summary>
        <returns>呼び出されるメンバーの戻り値を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーでは処理されませんが<xref:System.Globalization.CultureInfo>(、`culture`パラメーター)、抽象を使用する<xref:System.Reflection.Binder?displayProperty=nameWithType>カスタム バインダーでは処理を書き込むクラス`culture`します。  
  
> [!NOTE]
>  使用することはできません<xref:System.Type.InvokeMember%2A>ジェネリック メソッドを呼び出します。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。  
  
-   指定`BindingFlags.Public`検索にパブリック メンバーを含める。  
  
-   指定`BindingFlags.NonPublic`検索条件に非パブリック メンバー (つまり、プライベート、内部、および保護されたメンバー) を含める。  
  
-   指定`BindingFlags.FlattenHierarchy`階層の静的メンバーを含めます。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase` 大文字と小文字を無視する`name`します。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたメンバーのみを検索する、 <xref:System.Type>、継承されたメンバーされません。  
  
 次<xref:System.Reflection.BindingFlags>呼び出しフラグは、メンバーを取得するには、どのような操作を示すために使用できます。  
  
-   `CreateInstance` コンス トラクターを呼び出す。 `name` 無視されます。 他の呼び出しフラグが無効です。  
  
-   `InvokeMethod` コンス トラクターまたは型の初期化子ではされませんが、メソッドを呼び出す。 無効`SetField`または`SetProperty`します。 場合`InvokeMethod`自体で指定された`BindingFlags.Public`、 `BindingFlags.Instance`、および`BindingFlags.Static`が自動的に含まれています。  
  
-   `GetField` フィールドの値を取得します。 無効`SetField`します。  
  
-   `SetField` フィールドの値を設定します。 無効`GetField`します。  
  
-   `GetProperty` プロパティを取得します。 無効`SetProperty`します。  
  
-   `SetProperty` プロパティを設定します。 無効`GetProperty`します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 次の条件の両方に該当する場合、メソッドが呼び出されます。  
  
-   メソッド宣言パラメーターの数の引数の数に等しい、`args`配列 (既定の引数がメンバーに定義されていない場合と`BindingFlags.OptionalParamBinding`を指定)。  
  
-   各引数の型は、バインダーによってパラメーターの型に変換できます。  
  
 バインダーは、すべての一致するメソッドに紹介します。 要求されたバインドの種類に基づいてこれらのメソッドが検出された (<xref:System.Reflection.BindingFlags>値`InvokeMethod`、`GetProperty`など)。 メソッドのセットは、名前、引数の数とバインダーで定義されている検索修飾子のセットによってフィルター処理されます。  
  
 メソッドを選択した後に呼び出されます。 ユーザー補助機能は、その時点でチェックされます。 検索では、メソッドに関連付けられているユーザー補助属性に基づいて、メソッドのセットを検索するかを制御できます。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>のメソッド、<xref:System.Reflection.Binder>クラスが呼び出されるメソッドを選択する責任を負います。 既定のバインダーでは、最も具体的な一致を選択します。  
  
 完全に信頼されたコードのアクセス制限は無視されます。つまり、プライベート コンス トラクター、メソッド、フィールド、およびプロパティにアクセスでき、コードが完全に信頼されたリフレクションを通じて起動します。  
  
 使用することができます`Type.InvokeMember`を指定して、特定の値にフィールドを設定する<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>します。 たとえば、クラス C、および F と F をという名前のパブリック インスタンス フィールドを設定する場合は、`String`などのコードを使用することができます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 F がある場合、`String[]`などのコードを使用することができます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 この新しい配列にフィールド F が初期化されます。 使用することも`Type.InvokeMember`など、次のコードを使用して、値と、次の値のインデックスを指定することによって、配列内の位置を設定します。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 これにより、文字列"b"に F を保持する配列内の文字列"z"が変更されます。  
  
 呼び出した場合、`IDispatch`メンバーの文字列形式を使用して、メンバー名の代わりに DispID を指定する"[DispID = ##]"。 たとえば、MyComMethod の DispID が 3 の場合は、文字列を指定できます"[DispID = 3]""MyComMethod"の代わりにします。 メンバーの DispID を呼び出すことは、名前で、メンバーを調べるよりも高速です。 複雑な集計のシナリオで、DispID は必要なメンバーを呼び出すための唯一の方法でがあります。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、呼び出し元が許可されている場合は、非パブリック メンバーへのアクセスに使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグを設定し、許可セットまたはサブセットに非パブリック メンバーの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> に <see langword="CreateInstance" /> が含まれず、<paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> が有効な <see cref="T:System.Reflection.BindingFlags" /> 属性ではありません。  
  
または 
 <paramref name="invokeAttr" /> にバインド フラグ <see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> のいずれかが含まれていません。  
  
または 
 <paramref name="invokeAttr" /> に、<see langword="CreateInstance" /> と <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> との組み合わせが含まれています。  
  
または 
 <paramref name="invokeAttr" /> に <see langword="GetField" /> と <see langword="SetField" /> の両方が含まれています。  
  
または 
 <paramref name="invokeAttr" /> に <see langword="GetProperty" /> と <see langword="SetProperty" /> の両方が含まれています。  
  
または 
 <paramref name="invokeAttr" /> に、<see langword="InvokeMethod" /> と <see langword="SetField" /> または <see langword="SetProperty" /> との組み合わせが含まれています。  
  
または 
 <paramref name="invokeAttr" /> に <see langword="SetField" /> が含まれており、<paramref name="args" /> に複数の要素があります。  
  
または 
COM オブジェクトでこのメソッドが呼び出され、バインド フラグ <see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" />、<see langword="BindingFlags.PutRefDispProperty" /> のいずれかが渡されませんでした。  
  
または 
名前付きパラメーター配列の 1 つに、<see langword="null" /> である文字列が含まれています。</exception>
        <exception cref="T:System.MethodAccessException">指定されたメンバーは、クラス初期化子です。</exception>
        <exception cref="T:System.MissingFieldException">フィールドまたはプロパティが見つかりません。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="args" /> 内の引数と一致するメソッドが見つかりません。  
  
または 
現在の <see cref="T:System.Type" /> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返します。</exception>
        <exception cref="T:System.Reflection.TargetException">指定されたメンバーを <paramref name="target" /> で呼び出すことができません。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">複数のメソッドがバインディングの基準と一致します。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="name" /> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。 つまり、このメソッドの <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> プロパティが <see langword="true" /> を返します。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">アクセス許可に関係なく、非パブリック メンバーの次のように設定します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。  
  
または 
既定メンバーを呼び出すための空の文字列 ("")。  
  
または 
<see langword="IDispatch" /> メンバーの場合は、"[DispID=3]" のように DispID を表す文字列。</param>
        <param name="invokeAttr">検索の実行方法を指定する 1 つ以上の <see cref="T:System.Reflection.BindingFlags" /> から成るビットマスク。 アクセスは、<see langword="BindingFlags" />、<see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> など、<see langword="GetField" /> のうちの 1 つになります。 検索の種類を指定する必要はありません。 検索の種類が省略されている場合は、<see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> を使用します。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
または 
<see cref="P:System.Type.DefaultBinder" /> を使用する場合は、null 参照 (Visual Basic の場合は Nothing)。 可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<see cref="T:System.Reflection.Binder" /> オブジェクトを明示的に定義することが必要な場合があるのでご注意ください。</param>
        <param name="target">指定したメンバーを呼び出す対象となるオブジェクト。</param>
        <param name="args">呼び出すメンバーに渡される引数を格納する配列。</param>
        <param name="modifiers"><paramref name="args" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 パラメーターに関連付けられた属性は、メンバーのシグネチャに格納されます。  
  
既定のバインダーは、COM コンポーネントを呼び出す場合のみ、このパラメーターを処理します。</param>
        <param name="culture">使用するロケールを表す <see cref="T:System.Globalization.CultureInfo" /> オブジェクト。これは、String 型の数値を Double に変換するなど、ロケール固有の変換を実行するために必要となる場合があります。  
  
または 
現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> を使用する場合は、null 参照 (Visual Basic の場合は <see langword="Nothing" />)。</param>
        <param name="namedParameters"><paramref name="args" /> 配列内の値が渡されるパラメーターの名前を格納する配列。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用し、指定した引数リスト、修飾子、カルチャと照合して、指定されたメンバーを呼び出します。</summary>
        <returns>呼び出されるメンバーの戻り値を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` コンス トラクター メンバー、またはメソッド メンバーの呼び出し、取得またはプロパティ メンバーを設定、取得またはデータ フィールドのメンバーを設定または取得または設定配列メンバーの要素。  
  
> [!NOTE]
>  使用することはできません<xref:System.Type.InvokeMember%2A>ジェネリック メソッドを呼び出します。  
  
 呼び出した場合、`IDispatch`メンバーの文字列形式を使用して、メンバー名の代わりに DispID を指定する"[DispID = ##]"。 たとえば、MyComMethod の DispID が 3 の場合は、文字列を指定できます"[DispID = 3]""MyComMethod"の代わりにします。 メンバーの DispID を呼び出すことは、名前で、メンバーを調べるよりも高速です。 複雑な集計のシナリオで、DispID は必要なメンバーを呼び出すための唯一の方法でがあります。  
  
 既定のバインダーでは処理されませんが<xref:System.Reflection.ParameterModifier>または<xref:System.Globalization.CultureInfo>(、`modifiers`と`culture`パラメーター)、抽象を使用する<xref:System.Reflection.Binder?displayProperty=nameWithType>カスタム バインダーでは処理を書き込むクラス`modifiers`と`culture`. `ParameterModifier` COM 相互運用機能経由で呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみを処理します。  
  
 `namedParameters` 配列の各パラメーターは、`args` 配列内の対応する要素の値を取得します。 `args` の長さが `namedParameters` の長さより大きい場合、残りの引数の値は順番に渡されます。  
  
 `namedParameters`配列は、入力配列内の引数の順序を変更するために使用できます。 たとえば、メソッドを指定`M(string a, int b)`(`M(ByVal a As String, ByVal b As Integer)` Visual Basic で) と、入力配列`{ 42, "x" }`、入力配列にそのまま渡すことができます`args`場合、配列`{ "b", "a" }`が指定されて`namedParameters`。  
  
 次<xref:System.Reflection.BindingFlags>フィルター フラグは、検索に含めるメンバーを定義するために使用できます。  
  
-   指定`BindingFlags.Public`検索にパブリック メンバーを含める。  
  
-   指定`BindingFlags.NonPublic`検索条件に非パブリック メンバー (つまり、プライベート、内部、および保護されたメンバー) を含める。  
  
-   指定`BindingFlags.FlattenHierarchy`階層の静的メンバーを含めます。  
  
 次<xref:System.Reflection.BindingFlags>修飾フラグは、検索の動作を変更するために使用できます。  
  
-   `BindingFlags.IgnoreCase` 大文字と小文字を無視する`name`します。  
  
-   `BindingFlags.DeclaredOnly` 宣言されたメンバーのみを検索する、 <xref:System.Type>、継承されたメンバーされません。  
  
 次<xref:System.Reflection.BindingFlags>呼び出しフラグは、メンバーを取得するには、どのような操作を示すために使用できます。  
  
-   `CreateInstance` コンス トラクターを呼び出す。 `name` 無視されます。 他の呼び出しフラグが無効です。  
  
-   `InvokeMethod` コンス トラクターまたは型の初期化子ではされませんが、メソッドを呼び出す。 無効`SetField`または`SetProperty`します。 場合`InvokeMethod`自体で指定された`BindingFlags.Public`、 `BindingFlags.Instance`、および`BindingFlags.Static`が自動的に含まれています。  
  
-   `GetField` フィールドの値を取得します。 無効`SetField`します。  
  
-   `SetField` フィールドの値を設定します。 無効`GetField`します。  
  
-   `GetProperty` プロパティを取得します。 無効`SetProperty`します。  
  
-   `SetProperty` プロパティを設定します。 無効`GetProperty`します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 次の条件の両方に該当する場合、メソッドが呼び出されます。  
  
-   メソッド宣言パラメーターの数の引数の数に等しい、`args`配列 (既定の引数がメンバーに定義されていない場合と`BindingFlags.OptionalParamBinding`を指定)。  
  
-   各引数の型は、バインダーによってパラメーターの型に変換できます。  
  
 バインダーは、すべての一致するメソッドに紹介します。 要求されたバインドの種類に基づいてこれらのメソッドが検出された (<xref:System.Reflection.BindingFlags>値`InvokeMethod`、`GetProperty`など)。 メソッドのセットは、名前、引数の数とバインダーで定義されている検索修飾子のセットによってフィルター処理されます。  
  
 メソッドを選択した後に呼び出されます。 ユーザー補助機能は、その時点でチェックされます。 検索では、メソッドに関連付けられているユーザー補助属性に基づいて、メソッドのセットを検索するかを制御できます。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>のメソッド、<xref:System.Reflection.Binder>クラスが呼び出されるメソッドを選択する責任を負います。 既定のバインダーでは、最も具体的な一致を選択します。  
  
 `InvokeMember` 既定値を持つパラメーターを持つメソッドを呼び出すために使用できます。 リフレクションではこれらのメソッドにバインドする、<xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType>を指定します。 既定値を持つパラメーターの場合、別の値を指定するかを指定<xref:System.Reflection.Missing.Value?displayProperty=nameWithType>既定値を使用します。  
  
 たとえば、MyMethod などのメソッド (x, y の float int 2.0 以上)。 Mymethod (4) として最初の引数だけを持つには、このメソッドを呼び出すには、上記のバインディング フラグのいずれかを渡すし、最初の引数は 4、2 つの引数を渡すと`Missing.Value`の 2 番目の引数。 使用しない限り`Missing.Value`と省略可能なパラメーターを省略することがない、`Invoke`メソッド。 これを行う必要があります場合を使用して、`InvokeMember`代わりにします。  
  
 完全に信頼されたコードのアクセス制限は無視されます。つまり、プライベート コンス トラクター、メソッド、フィールド、およびプロパティにアクセスできを通じて呼び出される<xref:System.Reflection>たびに、コードが完全に信頼されました。  
  
 使用することができます`Type.InvokeMember`を指定して、特定の値にフィールドを設定する<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>します。 たとえば、クラス C、および F と F をという名前のパブリック インスタンス フィールドを設定する場合は、`String`などのコードを使用することができます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 F がある場合、`String[]`などのコードを使用することができます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 この新しい配列にフィールド F が初期化されます。 使用することも`Type.InvokeMember`など、次のコードを使用して、値と、次の値のインデックスを指定することによって、配列内の位置を設定します。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 これにより、文字列"b"に F を保持する配列内の文字列"z"が変更されます。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメソッドは、呼び出し元が許可されている場合は、非パブリック メンバーへのアクセスに使用できます<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>フラグを設定し、許可セットまたはサブセットに非パブリック メンバーの許可セットが、呼び出し元に制限されている場合そのします。 (を参照してください[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md))。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> に <see langword="CreateInstance" /> が含まれず、<paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="args" /> と <paramref name="modifiers" /> の長さが同じではありません。  
  
または 
 <paramref name="invokeAttr" /> が有効な <see cref="T:System.Reflection.BindingFlags" /> 属性ではありません。  
  
または 
 <paramref name="invokeAttr" /> にバインド フラグ <see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> のいずれかが含まれていません。  
  
または 
 <paramref name="invokeAttr" /> に、<see langword="CreateInstance" /> と <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" />、<see langword="SetProperty" /> との組み合わせが含まれています。  
  
または 
 <paramref name="invokeAttr" /> に <see langword="GetField" /> と <see langword="SetField" /> の両方が含まれています。  
  
または 
 <paramref name="invokeAttr" /> に <see langword="GetProperty" /> と <see langword="SetProperty" /> の両方が含まれています。  
  
または 
 <paramref name="invokeAttr" /> に、<see langword="InvokeMethod" /> と <see langword="SetField" /> または <see langword="SetProperty" /> との組み合わせが含まれています。  
  
または 
 <paramref name="invokeAttr" /> に <see langword="SetField" /> が含まれており、<paramref name="args" /> に複数の要素があります。  
  
または 
名前付きパラメーター配列が、引数配列よりも長くなっています。  
  
または 
COM オブジェクトでこのメソッドが呼び出され、バインド フラグ <see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" />、<see langword="BindingFlags.PutRefDispProperty" /> のいずれかが渡されませんでした。  
  
または 
名前付きパラメーター配列の 1 つに、<see langword="null" /> である文字列が含まれています。</exception>
        <exception cref="T:System.MethodAccessException">指定されたメンバーは、クラス初期化子です。</exception>
        <exception cref="T:System.MissingFieldException">フィールドまたはプロパティが見つかりません。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="args" /> 内の引数と一致するメソッドが見つかりません。  
  
または 
<paramref name="namedParameters" /> の中で引数名が指定されているメンバーが見つかりません。  
  
または 
現在の <see cref="T:System.Type" /> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返します。</exception>
        <exception cref="T:System.Reflection.TargetException">指定されたメンバーを <paramref name="target" /> で呼び出すことができません。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">複数のメソッドがバインディングの基準と一致します。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="name" /> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。 つまり、このメソッドの <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> プロパティが <see langword="true" /> を返します。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">アクセス許可に関係なく、非パブリック メンバーの次のように設定します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が抽象型で、オーバーライドする必要があるかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が抽象である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAbstract%2A>プロパティが返す`true`次の場合。  
  
-   現在の型が抽象です。これは、インスタンス化することはできませんが、派生クラスの基本クラスとしてのみ使用できます。 C# の場合は、抽象クラスが付いて、[抽象](~/docs/csharp/language-reference/keywords/abstract.md); キーワードでマークされている Visual basic で、 [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)キーワード。  
  
-   現在の型は、インターフェイスです。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す`false`します。  
  
   
  
## Examples  
 次の例の配列を作成する<xref:System.Type>、次の種類を表すオブジェクト: 型の戻り値が含まれています`true`場合、指定したオブジェクトが`abstract`。 それ以外を返します`false`。  
  
-   `AbstractClass`、抽象クラス (クラスがマーク`abstract`(C#) と`MustInherit`Visual Basic で)。  
  
-   `DerivedClass`を継承するクラス`AbstractClass`します。  
  
-   `SingleClass`、クラスを継承不可になります。 として定義されて`sealed`(C#) と`NotInheritable`Visual Basic でします。  
  
-   `ITypeInfo`、、のインターフェイス。  
  
-   `ImplementingClass`を実装するクラス、`ITypeInfo`インターフェイス。  
  
 メソッドを返します`true`のみ`AbstractClass`、抽象クラス、および`ITypeInfo`、インターフェイスです。  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="AnsiClass" /> に、文字列書式属性として <see cref="T:System.Type" /> が選択されているかどうかを示す値を取得します。</summary>
        <value><see langword="true" />に、文字列書式属性として<see langword="AnsiClass" /> が選択されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>文字列形式の属性を選択します。 文字列形式の属性は、文字列を解釈する方法を定義することで、相互運用性を強化します。  
  
 場合、現在<xref:System.Type>ジェネリック型をこのプロパティに関連する型が構築されたジェネリック型定義を表します。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型の型パラメーターを表す`false`します。  
  
   
  
## Examples  
 次の例では、フィールドの情報を取得して確認、`AnsiClass`属性。  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型が配列かどうかを示す値を返します。</summary>
        <value>現在の型が配列である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsArray%2A>プロパティが返す`false`の<xref:System.Array>クラス。 返します`false`、現在のインスタンスがある場合、<xref:System.Type>コレクション型やインターフェイスなど、コレクションと連携するように設計を表すオブジェクトを<xref:System.Collections.IEnumerable>または<xref:System.Collections.Generic.IEnumerable%601>します。  
  
 配列を確認するには、ようコードを使用します。  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 現在の型がジェネリック型またはジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合、このプロパティは常に返します`false`します。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例を使用して、<xref:System.Type.IsArray%2A>プロパティ。  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsArray" /> プロパティを実装し、<see cref="T:System.Type" /> が配列かどうかを判断します。</summary>
        <returns><see langword="true" /> が配列である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンス、<xref:System.Array>クラスを返す必要があります`false`オブジェクト、配列ではないためです。  
  
   
  
## Examples  
 次の例では、上書き、`IsArrayImpl`メソッドで、`MyTypeDelegator`クラス、変数、配列には、結果を表示する場合にチェックします。  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">現在の型と比較する型。</param>
        <summary>指定された型のインスタンスを現在の型インスタンスに割り当てることができるかどうかを判定します。</summary>
        <returns><see langword="true" /> が返されるのは、以下のいずれかの条件が満たされる場合です。 
-   <paramref name="c" /> と現在のインスタンスが同じ型を表す。  
  
-   <paramref name="c" /> が、現在のインスタンスから直接または間接に派生している。 <paramref name="c" /> が現在のインスタンスから継承している場合は、現在のインスタンスから直接派生し、<paramref name="c" /> が現在のインスタンスから継承している 1 つ以上のクラスの連続から継承している場合は、現在のインスタンスから間接的に派生します。  
  
-   現在のインスタンスが、<paramref name="c" /> が実装するインターフェイスである。  
  
-   <paramref name="c" /> がジェネリック型パラメーターであり、現在のインスタンスが <paramref name="c" /> の定数の 1 つを表している。  
  
次の例では、現在のインスタンスは、<see cref="T:System.IO.Stream" /> クラスを表す <see cref="T:System.Type" /> オブジェクトです。 <c>GenericWithConstraint</c> は、ジェネリック型パラメーターを <see cref="T:System.IO.Stream" /> 型にする必要があるジェネリック型です。 ジェネリック型パラメーターを <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> に渡すことで、ジェネリック型パラメーターのインスタンスを <see cref="T:System.IO.Stream" /> オブジェクトに割り当てられることを示します。  
  
[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)] 
-   <paramref name="c" /> が値型を表し、現在のインスタンスが <c>Nullable&lt;c&gt;</c> (Visual Basic では <c>Nullable(Of c)</c>) を表している。  
  
 <see langword="false" /> が返されるのは、これらの条件がいずれも満たされない場合、または <paramref name="c" /> が <see langword="null" /> である場合です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAssignableFrom%2A>のインスタンスかどうかを判断するメソッドを使用できる`c`割り当てることができるメソッド、現在の型のインスタンスには、デザイン時の型が不明のオブジェクトを処理するときに最も役に立つと条件付きでは、次の例として、割り当てを示しています。  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 このメソッドしたがってによりスローされることがなく実行時、次のようなコードの行を<xref:System.InvalidCastException>例外または同様の例外。  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 このメソッドは、派生クラスでオーバーライドできます。  
  
> [!NOTE]
>  ジェネリック型定義が構築されたクローズ型から割り当てることではできません。 つまり、構築されたクローズ型を割り当てることはできません`MyGenericList<int>`(`MyGenericList(Of Integer)` Visual Basic で) 型の変数に`MyGenericList<T>`します。  
  
 場合、`c`型のパラメーターが<xref:System.Reflection.Emit.TypeBuilder>結果が構築される型に基づきます。 次のコード例を示しますこのという名前の組み込み型を使用して`B`します。  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 次の例で、`IsAssignableFrom`クラス、整数の配列、およびジェネリック メソッドを使用して定義します。  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="AutoClass" /> に、文字列書式属性として <see cref="T:System.Type" /> が選択されているかどうかを示す値を取得します。</summary>
        <value><see langword="true" />に、文字列書式属性として<see langword="AutoClass" /> が選択されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>文字列形式の属性を選択します。 文字列形式の属性は、文字列を解釈する方法を定義することで、相互運用性を強化します。  
  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、元の型が構築されたジェネリック型定義に適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型の型パラメーターを表す`false`します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型のフィールドが、共通言語ランタイムによって自動的に配置されているかどうかを示す値を取得します。</summary>
        <value>現在の型の<see langword="true" /> プロパティに <see cref="P:System.Type.Attributes" /> が含まれる場合は <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、便利なように提供されます。 また、使用することができます、<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>レイアウト属性の型、およびテストをかどうかを選択する列挙値<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>設定されます。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>、および<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>列挙値は、型のフィールドがメモリにレイアウトする方法を示します。  
  
 動的な型の場合を指定できます<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>型を作成する場合。 コードでは、適用、<xref:System.Runtime.InteropServices.StructLayoutAttribute>属性、<xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType>型にランタイム クラスをレイアウトする適切な方法を決定する列挙値。  
  
> [!NOTE]
>  使用することはできません、<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>メソッドを決定するかどうか、<xref:System.Runtime.InteropServices.StructLayoutAttribute>型に適用されています。  
  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、元の型が構築されたジェネリック型定義に適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります `MyGenericType<T>.`  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す`false`します。  
  
   
  
## Examples  
 次の例では、型のインスタンスを作成し、表示、<xref:System.Type.IsAutoLayout%2A>プロパティ。  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">メタデータと自己言及的なコンポーネント</related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が参照渡しかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 を実際の型を取得するには、参照によって渡された型を逆参照を呼び出して<xref:System.Type.GetElementType%2A>型にします。  
  
   
  
## Examples  
 次の例を使用して、`IsByRef`プロパティを指定した型が参照によって渡されるかどうかを確認します。 例では、クラスを定義する`MyTypeDelegator`が優先されます、`HasElementTypeImpl`メソッド。 メイン クラスをチェック、`HasElementType`型の要素のプロパティを表示します。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsByRef" /> プロパティを実装し、<see cref="T:System.Type" /> が参照渡しかどうかを判断します。</summary>
        <returns><see langword="true" /> が参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がクラスまたはデリゲートである (つまり値型やインターフェイスではない) かどうかを示す値を取得します。</summary>
        <value><see langword="true" /> がクラスである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返します`true`クラスとデリゲート。 返します`false`値の型 (構造と列挙型) をボックス化されている場合でもです。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す`true`します。場合、現在<xref:System.Type>このプロパティを返しますに構築されたジェネリック型を表す`true`ジェネリック型定義がクラス定義; である場合は、定義しませんインターフェイスまたは値型。  
  
> [!NOTE]
>  このプロパティを返します`true`の`Type`インスタンスを表す、<xref:System.Enum>と<xref:System.ValueType>クラス。 これら 2 つのクラスは列挙型の基本型と値型の場合は、それぞれが列挙型または値の型自体ではありません。 詳細については、次を参照してください。、<xref:System.Type.IsValueType%2A>と<xref:System.Type.IsEnum%2A>プロパティ。  
  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType>としてクラスまたはインターフェイスの型宣言を識別する列挙値。ただし、クラスおよび値型の両方が付いて、<xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType>属性。 型の属性のプロパティと使用の値を取得する場合、<xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType>も呼び出す必要がある型が値型ではなくクラスかどうかを決定する値、<xref:System.Type.IsValueType%2A>プロパティ。 例を<xref:System.Reflection.TypeAttributes>列挙型には、追加情報と例が含まれています。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、型のインスタンスを作成しの型がクラスであるかどうかを示します。  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が COM オブジェクトかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が COM オブジェクトである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る`false`の COM インターフェイスのオブジェクトではないためです。 Microsoft .NET Framework オブジェクトによっては、COM インターフェイスを実装することができます。  
  
 また、COM クラスの読み込みし、取得、`Type`を使用してその COM クラスのオブジェクト、 [Tlbimp.exe (タイプ ライブラリ インポーター)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)ツール。  
  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、元の型が構築されたジェネリック型定義に適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int`> (`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す`false`します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsCOMObject" /> プロパティを実装し、<see cref="T:System.Type" /> が COM オブジェクトかどうかを判断します。</summary>
        <returns><see langword="true" /> が COM オブジェクトである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る`false`の COM インターフェイスのオブジェクトではないためです。 Microsoft .NET Framework オブジェクトによっては、COM インターフェイスを実装することができます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このオブジェクトが構築ジェネリック型かどうかを示す値を取得します。 構築ジェネリック型のインスタンスを作成できます。</summary>
        <value>このオブジェクトが構築ジェネリック型を表している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 構築されたジェネリック型は、すべてのジェネリック型パラメーターに指定された明示的な型にしました。 クローズ ジェネリック型とも呼ばれます。  
  
 このプロパティが`true`、現在の型のインスタンスを作成できます。 場合`false`、することはできません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> をコンテキスト内で管理できるかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> をコンテキスト内でホストできる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンテキストは、クラス メンバーへの呼び出しをインターセプトし、同期などのクラスに適用されるポリシーを適用します。 リモート処理コンテキストについて詳細を参照してください。<xref:System.Runtime.Remoting.Contexts.Context>します。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す`false`します。  
  
   
  
## Examples  
 次の例で、 `IsContextful`、 <xref:System.Type.IsMarshalByRef%2A>、および<xref:System.Type.IsPrimitive%2A>のプロパティ、<xref:System.Type>クラス。 コンテキストでは、指定された型をホストすることができるかどうか、参照によってマーシャ リングして、型がプリミティブ データ型かどうかを確認します。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Type.IsContextful" /> プロパティを実装し、<see cref="T:System.Type" /> をコンテキスト内で管理できるかどうかを判断します。</summary>
        <returns><see langword="true" /> をコンテキスト内でホストできる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、派生クラスでオーバーライドできます。  
  
 コンテキストは、クラス メンバーへの呼び出しをインターセプトし、同期などのクラスに適用されるポリシーを適用します。  
  
   
  
## Examples  
 次の例を使用して、`IsContextfulImpl`メソッド。  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が列挙体であるどうかを示す値を取得します。</summary>
        <value>現在の <see langword="true" /> が列挙体を表している場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返します`true`列挙体ではなく、<xref:System.Enum>自体を入力します。  
  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、元の型が構築されたジェネリック型定義に適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す`false`します。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、使用する方法、`IsEnum`プロパティ。  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">テスト対象の値。</param>
        <summary>指定された値が現在の列挙型に存在するかどうかを示す値を返します。</summary>
        <returns>指定された値が現在の列挙型のメンバーである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> は、列挙体の基になる型にできない型です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">現在の型と等しいかどうかをテストする COM 型。</param>
        <summary>2 つの COM 型が同じ ID を持ち、型の同値の対象になるかどうかを判断します。</summary>
        <returns>両方の COM 型が等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドは、一方の型が実行のために読み込まれたアセンブリに存在し、もう一方の型がリフレクションのみのコンテキストに読み込まれたアセンブリに存在する場合にも <see langword="false" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、共通言語ランタイムは、マネージ アセンブリ相互運用機能からの COM 型の型情報を取得する必要はなく、マネージ アセンブリに直接 COM 型の型情報の埋め込みをサポートしていますアセンブリ。 埋め込まれる型情報にはマネージド アセンブリに実際に使用される型とメンバーのみが含まれるため、2 つのマネージド アセンブリで同じ COM 型の表示が非常に異なることが考えられます。 マネージド アセンブリごとに、COM 型の表示を表す異なる <xref:System.Type> オブジェクトが与えられます。 共通言語ランタイムでは、インターフェイス、構造、列挙、委任といった異なる表示間で型の等価性が与えられます。  
  
 型の等価性とは、マネージド アセンブリ間で渡される COM オブジェクトを受け取り側のアセンブリで適切なマネージド型に変換できることを意味します。 <xref:System.Type.IsEquivalentTo%2A>メソッドにより、別のアセンブリから取得した COM オブジェクトが、最初のアセンブリの独自埋め込まれた相互運用機能型の 1 つとして同じ COM id であると判断するために、アセンブリとそのため、その型にキャストできます。  
  
 詳細については、次を参照してください。[型の等価性と埋め込まれた相互運用機能型](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型のフィールドが、明示的に指定したオフセット位置に配置されているかどうかを示す値を取得します。</summary>
        <value>現在の型の<see langword="true" /> プロパティに <see cref="P:System.Type.Attributes" /> が含まれる場合は <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、便利なように提供されます。 また、使用することができます、<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>レイアウト属性の型、およびテストをかどうかを選択する列挙値<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>設定されます。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、 <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>、および<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>列挙値は、型のフィールドがメモリにレイアウトする方法を示します。  
  
 動的な型の場合を指定できます<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>型を作成する場合。 コードでは、適用、<xref:System.Runtime.InteropServices.StructLayoutAttribute>属性、<xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>型にフィールドを開始するオフセットが明示的に指定されているかを指定する列挙値。  
  
> [!NOTE]
>  使用することはできません、<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>メソッドを決定するかどうか、<xref:System.Runtime.InteropServices.StructLayoutAttribute>型に適用されています。  
  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、元の型が構築されたジェネリック型定義に適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す`false`します。  
  
   
  
## Examples  
 次の例では、型のインスタンスを作成しの値を表示します。 その<xref:System.Type.IsExplicitLayout%2A>プロパティ。 使用して、`MySystemTime`クラスのコード例でもは<xref:System.Runtime.InteropServices.StructLayoutAttribute>します。  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">メタデータと自己言及的なコンポーネント</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表しているかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> オブジェクトがジェネリック型定義またはジェネリック メソッド定義の型パラメーターを表している場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> ジェネリック型パラメーターを表すオブジェクトを呼び出すことによって取得できます、<xref:System.Type.GetGenericArguments%2A>のメソッド、 <xref:System.Type> 、ジェネリック型定義を表しているオブジェクトまたは<xref:System.Reflection.MethodInfo.GetGenericArguments%2A>のメソッド、<xref:System.Reflection.MethodInfo>ジェネリック メソッドを表すオブジェクトを定義。  
  
-   ジェネリック型またはメソッドの定義、<xref:System.Type.IsGenericParameter%2A>プロパティが返す`true`結果の配列の各要素に対して。  
  
-   構築されたクローズ型またはメソッドの<xref:System.Type.IsGenericParameter%2A>プロパティが返す`false`によって返される配列の各要素に対して、<xref:System.Type.GetGenericArguments%2A>メソッド。  
  
-   構築されたオープン型またはメソッドは、特定の種類を配列の一部の要素があり、型パラメーターがあります。 <xref:System.Type.IsGenericParameter%2A> 返します`false`の種類と`true`の型パラメーター。 コード例を<xref:System.Type.ContainsGenericParameters%2A>プロパティ型と型パラメーターの組み合わせを持つジェネリック クラスを示します。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.IsGenericParameter%2A>ジェネリック型のジェネリック型パラメーターをテストするプロパティ。  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型がジェネリック型かどうかを示す値を取得します。</summary>
        <value><see langword="true" /> 現在の型がジェネリック型である場合それ以外の場合、<see langword="false" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用、<xref:System.Type.IsGenericType%2A>プロパティを確認するかどうかを<xref:System.Type>オブジェクトがジェネリック型を表します。 使用して、<xref:System.Type.ContainsGenericParameters%2A>プロパティを決定するかどうか、<xref:System.Type>オブジェクトは、オープン構築型またはクローズ構築型を表します。  
  
> [!NOTE]
>  <xref:System.Type.IsGenericType%2A>プロパティが返す`false`の直接の型がジェネリックでない場合。 たとえば、要素が配列型の`A<int>`(`A(Of Integer)` Visual Basic で) 自体ではないジェネリック型。  
  
 ジェネリック リフレクションで使用される一般的な用語に対するインバリアント条件を次の表に示します。  
  
|用語|インバリアント|  
|----------|---------------|  
|ジェネリック型定義|<xref:System.Type.IsGenericTypeDefinition%2A> プロパティが `true` です。<br /><br /> ジェネリック型を定義します。 呼び出して構築された型を作成、<xref:System.Type.MakeGenericType%2A>メソッドを<xref:System.Type>ジェネリック型定義を表すオブジェクトを型引数の配列を指定します。<br /><br /> <xref:System.Type.MakeGenericType%2A> ジェネリック型定義でのみ呼び出すことができます。<br /><br /> 任意のジェネリック型定義はジェネリック型 (、<xref:System.Type.IsGenericType%2A>プロパティは`true`) が、その逆は true ではありません。|  
|ジェネリック型|<xref:System.Type.IsGenericType%2A> プロパティが `true` です。<br /><br /> ジェネリック型定義、構築されたオープン型またはクローズ構築型を指定できます。<br /><br /> タイプの配列要素型がジェネリック自体ではないジェネリック型。 場合も、同様、<xref:System.Type>ジェネリック型へのポインターを表すオブジェクト。|  
|オープン構築型|<xref:System.Type.ContainsGenericParameters%2A> プロパティが `true` です。<br /><br /> 例としては、型パラメーターが割り当てられていないジェネリック型、ジェネリック型定義または構築されたオープン型に入れ子になっている型またはジェネリック型を型引数を持つ、<xref:System.Type.ContainsGenericParameters%2A>プロパティは`true`します。<br /><br /> 場合によっては、オープン構築型のインスタンスを作成することはできません。<br /><br /> 開いているすべての構築された型が汎用的なことに注意してください。 たとえば、配列要素型がジェネリック型定義はジェネリックではありませんし、オープン構築型へのポインターがジェネリックでないです。|  
|構築されたクローズ型|<xref:System.Type.ContainsGenericParameters%2A> プロパティが `false` です。<br /><br /> ときに検証の再帰、型では、未割り当てのジェネリック パラメーターはありません。|  
|ジェネリック型パラメーター|<xref:System.Type.IsGenericParameter%2A> プロパティが `true` です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> プロパティが `true` です。<br /><br /> ジェネリック型定義では、後で割り当てられる型のプレース ホルダー。|  
|ジェネリック型引数|ジェネリック型パラメーターを含む、任意の型を指定できます。<br /><br /> 型引数の配列として指定されます<xref:System.Type>にオブジェクトが渡される、<xref:System.Type.MakeGenericType%2A>メソッドが構築ジェネリック型を作成するときにします。 結果の型のインスタンスを作成する場合、<xref:System.Type.ContainsGenericParameters%2A>プロパティである必要があります`false`のすべての型引数。|  
  
 次のコード例とテーブルは、これらの用語と不変条件の一部を示しています。 `Derived`クラスは、その基本型が構築された型をその型引数リスト内の型と型パラメーターの組み合わせを持つため、興味深い部分です。  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 次の表に、クラスの作成および使用する例を示します`Base`、 `Derived`、および`G`します。 C++ および c# のコードが同じ場合は、1 つのエントリが表示されます。  
  
|例|インバリアント|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|このタイプの場合。<br /><br /> <xref:System.Type.IsGenericType%2A> は `true`です。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `true`です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> は `true`です。|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|このタイプの場合。<br /><br /> <xref:System.Type.IsGenericType%2A> は `true`です。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `false`です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> は `true`です。|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|変数の型の`d`:<br /><br /> <xref:System.Type.IsGenericType%2A> `false`ため`d`は配列です。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `false`です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> は `false`です。|  
|`T`、 `U`、および`V`(すべての場所で表示)|<xref:System.Type.IsGenericParameter%2A> は `true`です。<br /><br /> <xref:System.Type.IsGenericType%2A> `false`ジェネリック型に型パラメーターを制約する方法がないためです。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `false`です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> `true`ため`T`、 `U`、および`V`それ自体がジェネリック型パラメーター。 後でそれらに割り当てられている型の引数について何もこの意味しません。|  
|フィールドの型 `F`|<xref:System.Type.IsGenericType%2A> は `true`です。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> `false`型の型パラメーターに割り当てられているため`G`します。 これと呼ばれることに相当、<xref:System.Type.MakeGenericType%2A>メソッド。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> `true`ため、フィールドの型`F`オープン構築型を型引数を持ちます。 構築された型がオープンための型引数 (つまり、 `Base`) はジェネリック型定義です。 これは再帰的な性質を示しています、<xref:System.Type.IsGenericType%2A>プロパティ。|  
|入れ子になったクラス `Nested`|<xref:System.Type.IsGenericType%2A> `true`場合でも、`Nested`クラスには、独自のジェネリック型パラメーターがないジェネリック型に入れ子になっているためです。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `true`です。 つまり、呼び出すことができます、<xref:System.Type.MakeGenericType%2A>メソッドと外側の型の型パラメーターの供給`Derived`します。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> `true`型であるため、 `Derived`、ジェネリック型パラメーターがあります。 これは再帰的な性質を示しています、<xref:System.Type.ContainsGenericParameters%2A>プロパティ。|  
  
   
  
## Examples  
 次のコード例の値を表示する、 <xref:System.Type.IsGenericType%2A>、 <xref:System.Type.IsGenericTypeDefinition%2A>、 <xref:System.Type.IsGenericParameter%2A>、および<xref:System.Type.ContainsGenericParameters%2A>「解説」セクションで説明されている型のプロパティ。 プロパティの値の説明については、「解説」表を参照してください。  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が、他のジェネリック型を構築できるジェネリック型の定義を表しているかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> オブジェクトがジェネリック型定義を表している場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ジェネリック型定義は、他の型を構築するためのテンプレートです。 たとえば、ジェネリック型定義から`G<T>`(c# の構文で表現します。`G(Of T)` Visual basic または`generic <typename T> ref class G`C++ で) 作成して、型をインスタンス化`G<int>`(`G(Of Integer)` Visual Basic で)、呼び出すことによって、<xref:System.Type.MakeGenericType%2A>メソッドを含む汎用引数リスト、<xref:System.Int32>型。 指定された、<xref:System.Type>これを表すオブジェクトの構築型を<xref:System.Type.GetGenericTypeDefinition%2A>メソッド失意ジェネリック型定義もう一度です。  
  
 使用して、<xref:System.Type.IsGenericTypeDefinition%2A>プロパティを現在の型から新しい型を作成できるかどうかを判断します。 場合、<xref:System.Type.IsGenericTypeDefinition%2A>プロパティが返す`true`、呼び出すことができます、<xref:System.Type.MakeGenericType%2A>新しいジェネリック型を作成します。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次の例では、それがジェネリック型定義かどうかを含む、型に関する情報が表示されます。 構築された型、ジェネリック型定義、および通常の型は、情報が表示されます。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> に <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> 属性が適用されているかどうかを示す (つまり、COM タイプ ライブラリからインポートされたかどうかを示す) 値を取得します。</summary>
        <value><see langword="true" /> が <see cref="T:System.Type" /> を持っている場合は <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、元の型が構築されたジェネリック型定義に適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります `MyGenericType<T>.`  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す`false`します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">現在の型と比較するオブジェクト。</param>
        <summary>指定したオブジェクトが現在の <see cref="T:System.Type" /> のインスタンスかどうかを判断します。</summary>
        <returns><see langword="true" /> が返されるのは、現在の <see langword="Type" /> が <paramref name="o" /> によって表されるオブジェクトの継承可能な階層内にある場合、または現在の <see langword="Type" /> が <paramref name="o" /> によって実装されているインターフェイスである場合です。 <see langword="false" /> が返されるのは、これらの条件のいずれも満たされない場合、または <paramref name="o" /> が <see langword="null" /> であるか、現在の <see langword="Type" /> がオープン ジェネリック型である (つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返す) 場合です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、派生クラスでオーバーライドできます。  
  
> [!NOTE]
>  構築された型は、そのジェネリック型定義のインスタンスではありません。 つまり、 `MyGenericList<int>` (`MyGenericList(Of Integer)` Visual basic) のインスタンスではない`MyGenericList<T>`(`MyGenericList(Of T)` Visual Basic で)。  
  
   
  
## Examples  
 `IsInstanceOfType` メソッドの使用例を次に示します。  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がインターフェイスである (つまり値型やクラスではない) ことを示す値を取得します。</summary>
        <value><see langword="true" /> がインターフェイスである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask>クラス、インターフェイス、または値の型として型宣言を識別します。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す`false`します。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例は、インターフェイスを作成し、インターフェイスの種類を確認しますクラスがあるかどうかを示します、`IsInterface`プロパティ セット。  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型のフィールドが、定義済みまたはメタデータに対して出力された順序で、連続して配置されているかどうかを示す値を取得します。</summary>
        <value>現在の型の<see langword="true" /> プロパティに <see cref="P:System.Type.Attributes" /> が含まれる場合は <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、便利なように提供されます。 また、使用することができます、<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>レイアウト属性の型、およびテストをかどうかを選択する列挙値<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>設定されます。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、 <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>、および<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>列挙値は、型のフィールドがメモリにレイアウトする方法を示します。  
  
 動的な型の場合を指定できます<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>型を作成する場合。 コードでは、適用、<xref:System.Runtime.InteropServices.StructLayoutAttribute>属性、<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>型にそのレイアウトがシーケンシャルを指定する列挙値。  
  
> [!NOTE]
>  使用することはできません、<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>メソッドを決定するかどうか、<xref:System.Runtime.InteropServices.StructLayoutAttribute>型に適用されています。  
  
 詳細については、ドキュメントについては、共通言語基盤 (CLI) 仕様の 9.1.2」セクションを参照してください。"第 2 部。メタデータの定義およびセマンティクス"。 ドキュメントはオンラインで入手できます。MSDN の「[ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212)」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「[Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)」を参照してください。  
  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、元の型が構築されたジェネリック型定義に適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す`false`します。  
  
   
  
## Examples  
 次の例では、クラスのインスタンスを作成する、<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>列挙値、<xref:System.Runtime.InteropServices.StructLayoutAttribute>クラスが設定されているを確認、<xref:System.Type.IsLayoutSequential%2A>プロパティ、結果を表示します。  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">メタデータと自己言及的なコンポーネント</related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が参照渡しでマーシャリングされるかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が参照渡しでマーシャリングされる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例で、 `IsContextful`、 <xref:System.Type.IsMarshalByRef%2A>、および<xref:System.Type.IsPrimitive%2A>のプロパティ、<xref:System.Type>クラス。 コンテキストでは、指定された型をホストすることができるかどうか、参照によってマーシャ リングして、型がプリミティブ データ型かどうかを確認します。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Type.IsMarshalByRef" /> プロパティを実装し、<see cref="T:System.Type" /> が参照渡しでマーシャリングされるかどうかを判断します。</summary>
        <returns><see langword="true" /> が参照渡しでマーシャリングされる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、派生クラスでオーバーライドできます。  
  
   
  
## Examples  
 次の例では、指定された型が参照によってマーシャ リングされ、結果を表示するかどうかを判断します。  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> オブジェクトが、別の型の定義内に入れ子になっている定義で定義された型を表しているかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が別の型に入れ子になっている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsNested%2A>プロパティが返す`true`すべての可視性に関係なく、型を入れ子になった。 同時にネストして可視性をテストするに関連するプロパティを使用して、 <xref:System.Type.IsNestedAssembly%2A>、 <xref:System.Type.IsNestedFamily%2A>、 <xref:System.Type.IsNestedFamANDAssem%2A>、 <xref:System.Type.IsNestedFamORAssem%2A>、 <xref:System.Type.IsNestedPrivate%2A>、または<xref:System.Type.IsNestedPublic%2A>します。  
  
> [!NOTE]
>  <xref:System.Reflection.TypeAttributes.VisibilityMask>列挙型のメンバーが型の可視性属性を選択します。  
  
   
  
## Examples  
 次の例では、さまざまな種類の可視性のある入れ子になったクラスの数が外側のクラスを作成します。 可視性に関連する多数の値を取得し、<xref:System.Type>親の型とその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するアセンブリ内でだけ参照可能かどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が入れ子になっていて、それ自体が属するアセンブリ内でだけ参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型の型パラメーターを表す`false`します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 可視属性を選択します。  
  
   
  
## Examples  
 次の例では、さまざまな種類の可視性のある入れ子になったクラスの数が外側のクラスを作成します。 可視性に関連する多数の値を取得し、<xref:System.Type>親の型とその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するファミリとアセンブリの両方に属しているクラスだけから参照可能かどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が入れ子になっていて、それ自体が属するファミリとアセンブリの両方に属しているクラスだけから参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型の型パラメーターを表す`false`します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 可視属性を選択します。  
  
> [!NOTE]
>  C# および Visual Basic の言語では、独自のアセンブリで保護されている型にのみ表示されている入れ子にされた型を定義するためのセマンティクスは含まれません。 `protected internal` c# での可視性と`Protected Friend`Visual Basic での可視性が保護されている型と同じアセンブリ内の型の両方に表示されている入れ子にされた型を定義します。  
  
 A<xref:System.Type>オブジェクトのファミリが同じすべてのオブジェクトとして定義されている<xref:System.Type>とそのサブタイプの。  
  
   
  
## Examples  
 次の例では、さまざまな種類の可視性のある入れ子になったクラスの数が外側のクラスを作成します。 可視性に関連する多数の値を取得し、<xref:System.Type>親の型とその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するファミリ内でだけ参照可能かどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が入れ子になっていて、それ自体が属するファミリ内でだけ参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型の型パラメーターを表す`false`します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 可視属性を選択します。  
  
 A<xref:System.Type>オブジェクトのファミリがの正確なすべてのオブジェクトとして定義されている同じ<xref:System.Type>とそのサブタイプの。  
  
   
  
## Examples  
 次の例では、さまざまな種類の可視性のある入れ子になったクラスの数が外側のクラスを作成します。 可視性に関連する多数の値を取得し、<xref:System.Type>親の型とその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するファミリまたはアセンブリのいずれかに属しているクラスだけから参照可能かどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が入れ子になっていて、それ自体が属するファミリまたはアセンブリのいずれかに属しているクラスだけから参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型の可視性がある場合`protected internal`(C#) または`Protected Friend`Visual basic で、<xref:System.Type.IsNestedFamORAssem%2A>プロパティが返す`true`します。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型の型パラメーターを表す`false`します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 可視属性を選択します。  
  
 A<xref:System.Type>オブジェクトのファミリがの正確なすべてのオブジェクトとして定義されている同じ<xref:System.Type>とそのサブタイプの。  
  
   
  
## Examples  
 次の例では、さまざまな種類の可視性のある入れ子になったクラスの数が外側のクラスを作成します。 可視性に関連する多数の値を取得し、<xref:System.Type>親の型とその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が入れ子になっていて、プライベートとして宣言されているかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が入れ子になっていて、プライベートとして宣言されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型の型パラメーターを表す`false`します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 可視属性を選択します。  
  
   
  
## Examples  
 次の例では、さまざまな種類の可視性のある入れ子になったクラスの数が外側のクラスを作成します。 可視性に関連する多数の値を取得し、<xref:System.Type>親の型とその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クラスが入れ子になっていて、パブリックとして宣言されているかどうかを示す値を取得します。</summary>
        <value>クラスが入れ子になっていて、パブリックとして宣言されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型の型パラメーターを表す`false`します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 可視属性を選択します。  
  
   
  
## Examples  
 次の例では、さまざまな種類の可視性のある入れ子になったクラスの数が外側のクラスを作成します。 可視性に関連する多数の値を取得し、<xref:System.Type>親の型とその入れ子にされた型の各プロパティ。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がパブリックとして宣言されていないかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> がパブリックとして宣言されていなくて、入れ子にされた型でない場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 入れ子にされた型; でこのプロパティは使用しないで使用して、<xref:System.Type.IsNestedPublic%2A>プロパティ代わりにします。  
  
 場合、現在<xref:System.Type>このプロパティを返します、ジェネリック型の型パラメーターを表す`false`します。  
  
   
  
## Examples  
 この例のポイント`IsNotPublic`型の可視性を取得するプロパティ。  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 次のコード例では、使用できない理由を示します`IsPublic`と`IsNotPublic`の入れ子になったクラスです。  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 入れ子になったクラスは、結果を無視する`IsPublic`と`IsNotPublic`の結果にのみ注意を払うと`IsNestedPublic`と`IsNestedPrivate`します。 次のコードのリフレクション出力に次のようになります。  
  
|クラス|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|A|false|true|false|false|  
|B|false|false|true|false|  
|C|false|false|false|true|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がポインターかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> がポインターである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型またはジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`false`します。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例を使用して、`IsPointer`プロパティ。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsPointer" /> プロパティを実装し、<see cref="T:System.Type" /> がポインターかどうかを判断します。</summary>
        <returns><see langword="true" /> がポインターである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がプリミティブ型の 1 つかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> がプリミティブ型の 1 つである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プリミティブ型は<xref:System.Boolean>、 <xref:System.Byte>、 <xref:System.SByte>、 <xref:System.Int16>、 <xref:System.UInt16>、 <xref:System.Int32>、 <xref:System.UInt32>、 <xref:System.Int64>、 <xref:System.UInt64>、 <xref:System.IntPtr>、 <xref:System.UIntPtr>、 <xref:System.Char>、<xref:System.Double>、および<xref:System.Single>します。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型またはジェネリック型またはジェネリック メソッドの定義の型パラメーターを表す`false`します。  
  
   
  
## Examples  
 次の例で、 `IsContextful`、 <xref:System.Type.IsMarshalByRef%2A>、および<xref:System.Type.IsPrimitive%2A>のプロパティ、<xref:System.Type>クラス。 コンテキストでは、指定された型をホストすることができるかどうか、参照によってマーシャ リングして、型がプリミティブ データ型かどうかを確認します。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsPrimitive" /> プロパティを実装し、<see cref="T:System.Type" /> がプリミティブ型の 1 つかどうかを判断します。</summary>
        <returns><see langword="true" /> がプリミティブ型の 1 つである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プリミティブ型は<xref:System.Boolean>、 <xref:System.Byte>、 <xref:System.SByte>、 <xref:System.Int16>、 <xref:System.UInt16>、 <xref:System.Int32>、 <xref:System.UInt32>、 <xref:System.Int64>、 <xref:System.UInt64>、 <xref:System.Char>、 <xref:System.Double>、および<xref:System.Single>します。  
  
   
  
## Examples  
 次の例では、指定された型はプリミティブ型であり、結果が表示されるかどうかを判断します。  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がパブリックとして宣言されているかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> がパブリックとして宣言されていて、入れ子にされた型でない場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 入れ子にされた型は; を使用しないでください。使用して、<xref:System.Type.IsNestedPublic%2A>代わりにします。  
  
 場合、現在<xref:System.Type>このプロパティを返します、ジェネリック型の型パラメーターを表す`true`します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 可視属性を選択します。  
  
   
  
## Examples  
 次の例のインスタンスを作成する`MyTestClass`、チェック、`IsPublic`プロパティ、結果を表示します。  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 入れ子になったクラスは、結果を無視する`IsPublic`と`IsNotPublic`の結果にのみ注意を払うと<xref:System.Type.IsNestedPublic%2A>と<xref:System.Type.IsNestedPrivate%2A>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が sealed として宣言されているかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が sealed として宣言されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型の型パラメーターを表す`true`します。  
  
   
  
## Examples  
 次の例のインスタンスを作成する、`sealed`クラスのチェック、`IsSealed`プロパティ、結果を表示します。  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型が現在の信頼レベルでセキュリティ クリティカルまたはセキュリティ セーフ クリティカルであり、重要な操作を実行できるかどうかを示す値を取得します。</summary>
        <value>現在の型が現在の信頼レベルでセキュリティ クリティカルまたはセキュリティ セーフ クリティカルである場合は <see langword="true" />。現在の型が透過的な場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>、 <xref:System.Type.IsSecuritySafeCritical%2A>、および<xref:System.Type.IsSecurityTransparent%2A>プロパティが共通言語ランタイム (CLR) によって決定される、現在の信頼レベルの種類の透明度を報告します。 これらのプロパティの組み合わせは、次の表に示します。  
  
|セキュリティ レベル|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|重大|`true`|`false`|`false`|  
|セーフ クリティカル|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
> [!IMPORTANT]
>  部分的に信頼されたアセンブリでは、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。 アセンブリが (たとえば、サンド ボックス アプリケーション ドメイン) に部分的に信頼されたアプリケーション ドメインに読み込まれる場合は、ランタイム アセンブリのセキュリティの注釈は無視します。 アセンブリとそのすべての型を透過的に処理されます。 ランタイムは、そのアセンブリが (たとえば、デスクトップ アプリケーションの既定のアプリケーション ドメイン) に完全に信頼されたアプリケーション ドメインに読み込まれた場合にのみ、部分信頼アセンブリのセキュリティの注釈に注意を支払います。 これに対し、信頼されたアセンブリ (つまり、厳密な名前付きアセンブリをグローバル アセンブリ キャッシュにインストールされている) は、ため、現在の信頼レベルは常に完全に信頼されたに常に、アプリケーション ドメインの信頼レベルに関係なく、完全な信頼で読み込まれます。 使用して、アセンブリとアプリケーション ドメインの現在の信頼レベルを決定できます、<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>と<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>プロパティ。  
  
 リフレクションと透過性の詳細については、次を参照してください。[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)します。 透過性の詳細については、次を参照してください。[セキュリティ変更](~/docs/framework/security/security-changes.md)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">リフレクションに関するセキュリティ上の考慮事項</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework におけるセキュリティの変更点</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型が現在の信頼レベルでセキュリティ セーフ クリティカルであり、重要な操作を実行でき、透過的なコードからアクセスできるかどうかを示す値を取得します。</summary>
        <value>現在の型が現在の信頼レベルでセキュリティ セーフ クリティカルである場合は <see langword="true" />。現在の型がセキュリティ クリティカルまたは透過的な場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>、 <xref:System.Type.IsSecuritySafeCritical%2A>、および<xref:System.Type.IsSecurityTransparent%2A>プロパティが共通言語ランタイム (CLR) によって決定される、現在の信頼レベルの種類の透明度を報告します。 これらのプロパティの組み合わせは、次の表に示します。  
  
|セキュリティ レベル|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|重大|`true`|`false`|`false`|  
|セーフ クリティカル|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
> [!IMPORTANT]
>  部分的に信頼されたアセンブリでは、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。 アセンブリが (たとえば、サンド ボックス アプリケーション ドメイン) に部分的に信頼されたアプリケーション ドメインに読み込まれる場合は、ランタイム アセンブリのセキュリティの注釈は無視します。 アセンブリとそのすべての型を透過的に処理されます。 ランタイムは、そのアセンブリが (たとえば、デスクトップ アプリケーションの既定のアプリケーション ドメイン) に完全に信頼されたアプリケーション ドメインに読み込まれた場合にのみ、部分信頼アセンブリのセキュリティの注釈に注意を支払います。 これに対し、信頼されたアセンブリ (つまり、厳密な名前付きアセンブリをグローバル アセンブリ キャッシュにインストールされている) は、ため、現在の信頼レベルは常に完全に信頼されたに常に、アプリケーション ドメインの信頼レベルに関係なく、完全な信頼で読み込まれます。 使用して、アセンブリとアプリケーション ドメインの現在の信頼レベルを決定できます、<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>と<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>プロパティ。  
  
 リフレクションと透過性の詳細については、次を参照してください。[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)します。 透過性の詳細については、次を参照してください。[セキュリティ変更](~/docs/framework/security/security-changes.md)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">リフレクションに関するセキュリティ上の考慮事項</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework におけるセキュリティの変更点</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型が現在の信頼レベルで透過的であり、重要な操作を実行できないかどうかを示す値を取得します。</summary>
        <value>現在の型が現在の信頼レベルで透過的セキュリティである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返す場合`true`、<xref:System.Type.IsSecurityCritical%2A>と<xref:System.Type.IsSecuritySafeCritical%2A>プロパティの戻り値`false`します。  
  
 <xref:System.Type.IsSecurityCritical%2A>、 <xref:System.Type.IsSecuritySafeCritical%2A>、および<xref:System.Type.IsSecurityTransparent%2A>プロパティが共通言語ランタイム (CLR) によって決定される、現在の信頼レベルの種類の透明度を報告します。 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
> [!IMPORTANT]
>  部分的に信頼されたアセンブリでは、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。 アセンブリが (たとえば、サンド ボックス アプリケーション ドメイン) に部分的に信頼されたアプリケーション ドメインに読み込まれる場合は、ランタイム アセンブリのセキュリティの注釈は無視します。 アセンブリとそのすべての型を透過的に処理されます。 ランタイムは、そのアセンブリが (たとえば、デスクトップ アプリケーションの既定のアプリケーション ドメイン) に完全に信頼されたアプリケーション ドメインに読み込まれた場合にのみ、部分信頼アセンブリのセキュリティの注釈に注意を支払います。 これに対し、信頼されたアセンブリ (つまり、厳密な名前付きアセンブリをグローバル アセンブリ キャッシュにインストールされている) は、ため、現在の信頼レベルは常に完全に信頼されたに常に、アプリケーション ドメインの信頼レベルに関係なく、完全な信頼で読み込まれます。 使用して、アセンブリとアプリケーション ドメインの現在の信頼レベルを決定できます、<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>と<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>プロパティ。  
  
 リフレクションと透過性の詳細については、次を参照してください。[リフレクションに関するセキュリティの考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)します。 透過性の詳細については、次を参照してください。[セキュリティ変更](~/docs/framework/security/security-changes.md)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">リフレクションに関するセキュリティ上の考慮事項</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework におけるセキュリティの変更点</related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> をシリアル化できるかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> をシリアル化できる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
.NET Standard で定義されている型がでマークされていない<xref:System.SerializableAttribute>します。 代わりに、各 .NET 実装では、型がシリアル化できるかどうかを判断します。 実行時に使用することができます、<xref:System.Type.IsSerializable%2A>プロパティを実装するが、型のインスタンスのシリアル化をサポートするかどうかを確認します。 詳細と例では、次を参照してください。 [.NET 標準オブジェクトがシリアル化可能な場合を判断する方法](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)します。
  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、元の型が構築されたジェネリック型定義に適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す`false`します。  
  
   
  
## Examples  
 次の例のインスタンスを作成する`MyTestClass`クラスは、[Serializable] 属性を設定し、チェック、`IsSerializable`プロパティ`true`または`false`します。  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型が特別な処理を必要とする名前を持っているかどうかを示す値を取得します。</summary>
        <value>型の名前が特別な処理を必要とする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 始まるか、アンダー スコア文字 (_)、プロパティ アクセサー、および演算子のメソッドをオーバー ロードが含まれている名前は、一部のコンパイラで特別な処理が必要となる型の例を示します。  
  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、元の型が構築されたジェネリック型定義に適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す`false`します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">現在の型と比較する型。</param>
        <summary>現在の <see cref="T:System.Type" /> が、指定した <see cref="T:System.Type" /> から派生しているかどうかを判断します。</summary>
        <returns>現在の <see langword="Type" /> が <paramref name="c" /> から派生している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 <see langword="false" /> と現在の <paramref name="c" /> とが等価の場合も、このメソッドは <see langword="Type" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことができます、<xref:System.Type.IsSubclassOf%2A>次のいずれかを判断するメソッド。  
  
-   かどうか別の 1 つのクラスが派生します。  
  
-   型がから派生するかどうか<xref:System.ValueType>します。 ただし、<xref:System.Type.IsValueType%2A>は型が値型かどうかをより効率的な方法です。  
  
-   型がから派生するかどうか<xref:System.Enum>します。 ただし、<xref:System.Type.IsEnum%2A>メソッドは、型が列挙体かどうかをより効率的な方法です。  
  
-   かどうか、型がデリゲート、つまり、いずれかから派生したかどうか<xref:System.Delegate>または<xref:System.MulticastDelegate>します。  
  
 <xref:System.Type.IsSubclassOf%2A>インターフェイスが別のインターフェイスから派生するかどうか、またはクラスがインターフェイスを実装するかどうかを判断するメソッドを使用できません。 使用して、<xref:System.Type.IsAssignableFrom%2A>として次の例は、使用するメソッド。  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 場合、現在<xref:System.Type>型パラメーターを表すジェネリック型またはジェネリック メソッドの定義でから、またはそのクラスの制約から派生して<xref:System.Object?displayProperty=nameWithType>クラスの制約が存在しない場合。  
  
> [!NOTE]
>  インターフェイスで使用する場合を除く<xref:System.Type.IsSubclassOf%2A>反対の<xref:System.Type.IsAssignableFrom%2A>します。 つまり場合、`t1.IsSubclassOf(t2)`は`true`、し`t2.IsAssignableFrom(t1)`も`true`します。  
  
 このメソッドは、派生クラスでオーバーライドできます。  
  
   
  
## Examples  
 次の例では、という名前のクラスを作成する`Class1`という名前の派生クラスと`DerivedC1`します。 呼び出す、<xref:System.Type.IsSubclassOf%2A>を表示するメソッド`DerivedC1`のサブクラスは`Class1`します。  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> は <see langword="null" />です。</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="UnicodeClass" /> に、文字列書式属性として <see cref="T:System.Type" /> が選択されているかどうかを示す値を取得します。</summary>
        <value><see langword="true" />に、文字列書式属性として<see langword="UnicodeClass" /> が選択されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>文字列書式属性を選択するために使用します。 文字列形式の属性は、文字列を解釈する方法を定義することで、相互運用性を強化します。  
  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、元の型が構築されたジェネリック型定義に適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す`false`します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が値型かどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が値型である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値の型は、bits; のシーケンスとして表現されている型値の型は、クラスまたはインターフェイスではありません。 値の型は、一部のプログラミング言語でに「構造体」と呼ばれます。 列挙型は、値型の特殊なケースです。  
  
 このプロパティを返します`false`の<xref:System.ValueType>クラス<xref:System.ValueType>値型そのものではありません。 これは、すべての値の型の基本クラスとする任意の値型を割り当てることがそのためです。 これができない場合<xref:System.ValueType>自体が、値の型。 型のフィールドに割り当てられているときに、値の型がボックス化は<xref:System.ValueType>します。  
  
 このプロパティを返します`true`列挙型のではなく、<xref:System.Enum>自体を入力します。 この動作を示す例を参照してください。<xref:System.Type.IsEnum%2A>します。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、型の変数を作成する`MyEnum`、チェック、`IsValueType`プロパティ、結果を表示します。  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Type.IsValueType" /> プロパティを実装するとともに、<see cref="T:System.Type" /> が値型である (つまり、クラスやインターフェイスでない) かどうかを判断します。</summary>
        <returns><see langword="true" /> が値型である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、代替の型システムの実装を有効にするのに提供されます。 これはアプリケーション コードでは一般的に使用されません。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> にアセンブリの外側のコードからアクセスできるかどうかを示す値を取得します。</summary>
        <value>現在の<see langword="true" /> がパブリック型である場合、またはすべての包含する型がパブリックであるような入れ子にされたパブリック型である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用して、型がコンポーネント アセンブリのパブリック インターフェイスの一部であるかどうかを判断します。  
  
   
  
## Examples  
 次のコード例では、一方のみが、アセンブリ外部から参照できる、2 つのクラスをテストします。  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の型の配列を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>下限を 0 に設定して現在の型の 1 次元配列を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>下限を 0 に設定して現在の型の 1 次元配列を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A>メソッドは、配列型の型を持つ要素は、実行時に計算を生成する方法を提供します。  
  
 **注**共通言語ランタイム (つまり、1 次元配列は常に 0 から始まる) のベクトル間の違いは、および多次元の配列。 ベクターは、常に 1 つだけディメンションを持つは、1 つだけディメンションを多次元配列と同じではされません。 このメソッドのオーバー ロードは、ベクター型を作成する場合にのみ使用でき、ベクター型を作成する唯一の方法はします。 使用して、<xref:System.Type.MakeArrayType%28System.Int32%29>多次元配列の型を作成するメソッドのオーバー ロードします。  
  
   
  
## Examples  
 次のコード例は、配列を作成します。 `ref` (`ByRef` Visual basic)、およびポインターの型の、`Test`クラス。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
        <exception cref="T:System.TypeLoadException">現在の型は <see cref="T:System.TypedReference" /> です。  
  
または 
現在の型は <see langword="ByRef" /> 型です。 つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">配列の次元数。 この数値は 32 以下である必要があります。</param>
        <summary>次元数を指定して現在の型の配列を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>次元数を指定して現在の型の配列を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A>メソッドは、配列型の型を持つ要素は、実行時に計算を生成する方法を提供します。  
  
> [!NOTE]
>  共通言語ランタイム (つまり、1 次元配列は常に 0 から始まる) のベクトル間の違いは、および多次元の配列。 ベクターは、常に 1 つだけディメンションを持つは、1 つだけディメンションを多次元配列と同じではされません。 このメソッドのオーバー ロードを使用して、ベクター型を作成することはできません。場合`rank`は 1 です。 このメソッドのオーバー ロードが 1 つのディメンションを多次元配列の型を返します。 使用して、<xref:System.Type.MakeArrayType>ベクター型を作成するメソッドのオーバー ロードします。  
  
   
  
## Examples  
 次のコード例は、配列を作成します。 `ref` (`ByRef` Visual basic)、およびポインターの型の、`Test`クラス。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="rank" /> が無効です。 たとえば、0 または負の値です。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。</exception>
        <exception cref="T:System.TypeLoadException">現在の型は <see cref="T:System.TypedReference" /> です。  
  
または 
現在の型は <see langword="ByRef" /> 型です。 つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。  
  
または 
 <paramref name="rank" /> が 32 を超えています。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see langword="ref" /> パラメーター (Visual Basic の場合は <see langword="ByRef" /> パラメーター) として渡されるときに現在の型を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns><see langword="ref" /> パラメーター (Visual Basic の場合は <see langword="ByRef" /> パラメーター) として渡されるときに現在の型を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeByRefType%2A>メソッドを生成する方法を提供する`ref`型 (`ByRef` Visual Basic で) パラメーターを一覧表示します。  
  
 Microsoft intermediate language (MSIL) の構文を使用する場合、現在<xref:System.Type>オブジェクトが表す<xref:System.Int32>、このメソッドが戻る、<xref:System.Type>オブジェクトを表す`Int32&`します。  
  
   
  
## Examples  
 次のコード例は、配列を作成します。 `ref` (`ByRef` Visual basic)、およびポインターの型の、`Test`クラス。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。</exception>
        <exception cref="T:System.TypeLoadException">現在の型は <see cref="T:System.TypedReference" /> です。  
  
または 
現在の型は <see langword="ByRef" /> 型です。 つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">現在のジェネリック型の型パラメーターに置き換えられる型の配列。</param>
        <summary>型の配列の要素を現在のジェネリック型定義の型パラメーターで置き換え、結果の構築型を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns><see cref="T:System.Type" /> の要素を現在のジェネリック型の型パラメーターで置き換えることによって作られる構築型を表す <paramref name="typeArguments" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeGenericType%2A>メソッドでは、特定の種類を作成するため、ジェネリック型定義の型パラメーターに代入するコードを記述できます。、<xref:System.Type>構築された特定の型を表すオブジェクト。 これを使用することができます<xref:System.Type>構築された型の実行時のインスタンスを作成するオブジェクト。  
  
 型を使用して構築<xref:System.Type.MakeGenericType%2A>開くことができる、一部の型引数は、外側のジェネリック メソッドまたは型の型パラメーターを指定できます。 動的アセンブリを生成するときに、このようなオープン構築型を使用する場合があります。 たとえば、クラス`Base`と`Derived`次のコード。  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 生成する`Derived`、動的アセンブリではその基本型を構築するために必要です。 これを行うには、呼び出し、<xref:System.Type.MakeGenericType%2A>メソッドを<xref:System.Type>オブジェクト クラスを表す`Base`、ジェネリック型引数を使用して<xref:System.Int32>、型パラメーター`V`から`Derived`します。 型およびジェネリック型パラメーターの両方がによって表されるため、<xref:System.Type>オブジェクトに、両方を含む配列を渡すことができます、<xref:System.Type.MakeGenericType%2A>メソッド。  
  
> [!NOTE]
>  などの構築型`Base<int, V>`便利な場合に、コードの出力が呼び出すことはできません、<xref:System.Type.MakeGenericType%2A>この型のメソッドでジェネリック型定義ではないためです。 最初に呼び出しをインスタンス化できる構築されたクローズ型を作成する、<xref:System.Type.GetGenericTypeDefinition%2A>を取得するメソッド、<xref:System.Type>をジェネリック型定義を表すオブジェクトを呼び出して<xref:System.Type.MakeGenericType%2A>目的の型引数を使用します。  
  
 <xref:System.Type>によって返されるオブジェクト<xref:System.Type.MakeGenericType%2A>と同じ、<xref:System.Type>呼び出すことによって取得、<xref:System.Object.GetType%2A>メソッド結果の構築型、または<xref:System.Object.GetType%2A>構築されたジェネリック同じから作成された型のいずれかのメソッド同じ型の引数を使用して定義を入力します。  
  
> [!NOTE]
>  ジェネリック型の配列は自体はジェネリック型です。 呼び出すことはできません<xref:System.Type.MakeGenericType%2A>など、配列で入力`C<T>[]`(`Dim ac() As C(Of T)` Visual Basic で)。 クローズ ジェネリック型を構築する`C<T>[]`、呼び出す<xref:System.Type.GetElementType%2A>ジェネリック型定義を取得する`C<T>`; 呼び出す<xref:System.Type.MakeGenericType%2A>上に構築された型; を作成し、最後に呼び出すジェネリック型定義、<xref:System.Type.MakeArrayType%2A>メソッド配列型の作成に構築された型。 ポインター型の場合も同様と`ref`型 (`ByRef` Visual Basic で)。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
## <a name="nested-types"></a>入れ子にされた型  
 C#、C++、または Visual Basic を使用してジェネリック型が定義されている場合、入れ子にされた型はすべてジェネリックです。 これは、入れ子にされた型には、独自の型パラメーターがあるないため、3 つすべての言語は、入れ子にされた型の型パラメーター リストの包含する型の型パラメーターを含む場合でも当てはまります。 次のクラスを検討してください。  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 入れ子になったクラスの型パラメーター リスト`Inner`2 つの型パラメーターを持つ`T`と`U`、うち 1 つ目は、その外側のクラスの型パラメーター。 入れ子になったクラスの型パラメーター リスト同様に、 `Innermost1` 3 つの型パラメーターを持つ`T`、 `U`、および`V`で`T`と`U`外側のクラスから。 入れ子になったクラス`Innermost2`2 つの型パラメーターを持つ`T`と`U`、その外側のクラスから取得します。  
  
 それを囲む型のパラメーター リストは、1 つ以上の型パラメーターを持つ、入れ子にされた型の型パラメーター リスト内の順序ですべての型パラメーターが含まれます。  
  
 入れ子にされた型のジェネリック型定義からジェネリック型を構築するには、呼び出し、<xref:System.Type.MakeGenericType%2A>配列を持つメソッドがすべて包含する型、最も外側のジェネリック型の先頭と末尾の型引数の配列を連結して形成される、独自の型パラメーターを持つ場合は、それ自体には、入れ子にされた型の引数の配列を入力します。 インスタンスを作成する`Innermost1`を呼び出し、 <xref:System.Type.MakeGenericType%2A> T、U、および V に割り当てられる次の 3 つの型を含む配列を持つメソッド。インスタンスを作成する`Innermost2`を呼び出し、 <xref:System.Type.MakeGenericType%2A> T と U に割り当てられる 2 つの型を含む配列を持つメソッド  
  
 言語は、入れ子にされた型のフィールドを定義する、それを囲む型の型パラメーターを使用できるように、この方法で型を囲む型のパラメーターを伝達します。 それ以外の場合、型パラメーターは、入れ子にされた型の本文内のスコープにはできません。 動的アセンブリ内のコードを出力するかを使用して、型を外側の型パラメーターを伝達することがなく、入れ子にされた型を定義することは、 [Ilasm.exe (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)します。 MSIL アセンブラーの次のコードを検討してください。  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 この例では型のフィールドを定義する`T`または`U`クラスで`Innermost`スコープにこれらの型パラメーターがないためです。 次のアセンブラー コードでは、C、Visual Basic、および c# で定義されている場合と同じように動作する入れ子になったクラスを定義します。  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 使用することができます、 [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を高度な言語で定義されている入れ子になったクラスを調べて、この名前付けスキームを確認します。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.MakeGenericType%2A>メソッドのジェネリック型定義から構築された型を作成する、<xref:System.Collections.Generic.Dictionary%602>型。 構築された型を表す、<xref:System.Collections.Generic.Dictionary%602>の`Test`文字列キーを持つオブジェクト。  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の型はジェネリック型の定義を表していません。 つまり、<see cref="P:System.Type.IsGenericTypeDefinition" /> は <see langword="false" /> を返します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArguments" /> は <see langword="null" />です。  
  
または 
<paramref name="typeArguments" /> のどの要素も <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeArguments" /> 内の要素数は現在のジェネリック型定義の型パラメーター数と同じではありません。  
  
または 
<paramref name="typeArguments" /> のいずれかの要素が、現在のジェネリック型の対応する型パラメーターに指定された制約を満たしていません。  
  
または 
 <paramref name="typeArguments" /> には、ポインター型 (<see cref="P:System.Type.IsPointer" /> は <see langword="true" /> を返します)、参照渡し型 (<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します)、または <see cref="T:System.Void" /> である要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の型へのポインターを表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>現在の型へのポインターを表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakePointerType%2A>メソッドは、ポインター型のパラメーター リストを生成する方法を提供します。  
  
 Microsoft intermediate language (MSIL) の構文を使用する場合、現在<xref:System.Type>オブジェクトが表す<xref:System.Int32>、このメソッドが戻る、<xref:System.Type>オブジェクトを表す`Int32*`します。  
  
   
  
## Examples  
 次のコード例は、配列を作成します。 `ref` (`ByRef` Visual basic)、およびポインターの型の、`Test`クラス。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。</exception>
        <exception cref="T:System.TypeLoadException">現在の型は <see cref="T:System.TypedReference" /> です。  
  
または 
現在の型は <see langword="ByRef" /> 型です。 つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーが型であるか、または入れ子にされた型であるかを示す <see cref="T:System.Reflection.MemberTypes" /> 値を取得します。</summary>
        <value>このメンバーが型であるか、または入れ子にされた型であるかを示す <see cref="T:System.Reflection.MemberTypes" /> 値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティのオーバーライド<xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>します。 セットを確認すると、そのため、<xref:System.Reflection.MemberInfo>オブジェクトによって返される配列など<xref:System.Type.GetMembers%2A>-<xref:System.Reflection.MemberInfo.MemberType%2A>プロパティが返す<xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType>指定されたメンバーが入れ子にされた型の場合。  
  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、元の型が構築されたジェネリック型定義に適用されます。 たとえば場合、現在<xref:System.Type>を表します`MyGenericType<int>`(`MyGenericType(Of Integer)` Visual Basic で)、このプロパティの値はによって決まります`MyGenericType<T>`。  
  
 場合、現在<xref:System.Type>常にこのプロパティを返します、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す<xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>します。  
  
   
  
## Examples  
 次のコード例は、`MemberType`フィールドへのパラメーターとして、`GetMember`メソッド。  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> 情報に不足している値を表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、`Missing`パラメーターの既定値を取得するためにリフレクションによる呼び出しのためのフィールド。 場合、`Missing`フィールド、パラメーター値が渡され、そのパラメーターの既定値はありません、<xref:System.ArgumentException>がスローされます。  
  
   
  
## Examples  
 次のコード例の使用を示しています、`Missing`フィールドを既定の引数を持つメソッドを呼び出します。  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 このコードを実行すると、次の出力が生成されます。  
  
 10 = b 55.3 c = 12 を =  
  
 10 = b 1.3 c = 1 を =  
  
 10 = b 1.2 c = 1 を =  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が定義されているモジュール (DLL) を取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> が定義されているモジュールです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、現在<xref:System.Type>表します構築されたジェネリック型、このプロパティは、ジェネリック型定義が定義されているモジュールを返します。 インスタンスを作成する場合など`MyGenericStack<int>`、<xref:System.Type.Module%2A>構築された型のプロパティでは、モジュールを返しますを`MyGenericStack<T>`が定義されています。  
  
 同様に場合、現在<xref:System.Type>ジェネリック パラメーターを表す`T`、このプロパティを定義するジェネリック型を含むアセンブリを返します`T`します。  
  
   
  
## Examples  
 次の例に示しますを使用して、<xref:System.Type.Namespace%2A>と`Module`プロパティと<xref:System.Type.ToString%2A>メソッドの<xref:System.Type>します。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされると、現在の型の名前を取得します。</summary>
        <value>現在の型の名前。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> の名前空間を取得します。</summary>
        <value><see cref="T:System.Type" /> の名前空間。現在のインスタンスに名前空間がない場合、または現在のインスタンスがジェネリック パラメーターを表す場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名前空間は、論理デザイン時名前付け便利、主にアプリケーションでスコープを定義し、クラスとその他の種類を 1 つの階層構造で整理するために使用です。 ランタイムの観点からは、名前空間はありません。  
  
 場合、現在<xref:System.Type>構築ジェネリック型を表し、このプロパティは、ジェネリック型定義を含む名前空間を返します。 同様に場合、現在<xref:System.Type>ジェネリック パラメーターを表す`T`、このプロパティを定義するジェネリック型定義を含む名前空間を返します`T`します。  
  
 場合、現在<xref:System.Type>オブジェクトは、ジェネリック パラメーターを表す、このプロパティを返します`null`します。  
  
   
  
## Examples  
 次の例に示しますを使用して、`Namespace`と<xref:System.Type.Module%2A>プロパティと<xref:System.Type.ToString%2A>メソッドの<xref:System.Type>します。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">完全修飾型名の指定</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初のオブジェクト。</param>
        <param name="right">比較する 2 番目のオブジェクト。</param>
        <summary>2 つの <see cref="T:System.Type" /> オブジェクトが等しいかどうかを示します。</summary>
        <returns><see langword="true" /> が <paramref name="left" /> に等しい場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初のオブジェクト。</param>
        <param name="right">比較する 2 番目のオブジェクト。</param>
        <summary>2 つの <see cref="T:System.Type" /> オブジェクトが等しくないかどうかを示します。</summary>
        <returns><see langword="true" /> が <paramref name="left" /> と等しくない場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーを取得するために使用したクラス オブジェクトを取得します。</summary>
        <value>この <see langword="Type" /> オブジェクトを取得するために使用した <see cref="T:System.Type" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type>オブジェクトの場合、このプロパティの値は、の値と同じでは常に、<xref:System.Type.DeclaringType%2A>プロパティ。  
  
   
  
## Examples  
 この例では、入れ子になったクラスのリフレクションされた型が表示されます。  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する <see cref="T:System.Type" /> のアセンブリ修飾名。</param>
        <param name="throwIfNotFound">型が見つからない場合に <see cref="T:System.TypeLoadException" /> をスローするには <see langword="true" />。型が見つからない場合に <see langword="null" /> を返すには <see langword="false" />。 また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」セクションを参照してください。</param>
        <param name="ignoreCase">大文字と小文字を区別せずに <paramref name="typeName" /> の検索を実行するには <see langword="true" />。大文字と小文字を区別して <paramref name="typeName" /> の検索を実行するには <see langword="false" />。</param>
        <summary>大文字と小文字を区別する検索を実行し、型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の <see cref="T:System.Type" /> を取得します。 型は実行ではなくリフレクションのためだけに読み込まれます。</summary>
        <returns>存在する場合は、指定した名前を持つ型。それ以外の場合は <see langword="null" />。 型が見つからない場合、<paramref name="throwIfNotFound" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwIfNotFound" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して型を含むアセンブリがリフレクションのみのコンテキスト読み込まれない場合、<xref:System.Type.ReflectionOnlyGetType%2A>メソッドは、最初に相当にアセンブリを読み込むだけでは、リフレクションを使用して、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>メソッド、および呼び出すことによって、型を読み込み、アセンブリの<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>メソッド。 アセンブリ修飾名については、次を参照してください。、<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>プロパティ。 型名の指定の詳細については、次を参照してください。、<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>メソッドのオーバー ロードします。  
  
 アセンブリが既に実行に対して読み込まれている場合は、リフレクション専用コンテキストに別のコピーが読み込まれます。  
  
 `throwIfNotFound`パラメーターは、例外のセクションで説明した、型が見つからないし、もその他の特定の例外条件を抑制ときの動作を指定します。 値に関係なくいくつかの例外がスローされる`throwIfNotFound`します。 アセンブリが有効でない場合など、<xref:System.BadImageFormatException>がスローされた場合でも`throwIfNotFound`は`false`します。  
  
 詳細については、リフレクションのみのコンテキストを使用して、次を参照してください。[方法。リフレクションのみのコンテキストにアセンブリを読み込む](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwIfNotFound" /> が <see langword="true" /> です。型が見つかりません。  
  
または 
 <paramref name="throwIfNotFound" /> が <see langword="true" /> です。<paramref name="typeName" /> に埋め込まれたタブなどの正しくない文字が含まれています。 
または 
 <paramref name="throwIfNotFound" /> が <see langword="true" /> です。<paramref name="typeName" /> は空の文字列です。  
  
または 
 <paramref name="throwIfNotFound" /> が <see langword="true" /> です。<paramref name="typeName" /> は無効なサイズの配列型を表します。  
  
または 
 <paramref name="typeName" /> が <see cref="T:System.TypedReference" /> オブジェクトの配列を表しています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> にはアセンブリ名は含まれません。  
  
または 
 <paramref name="throwIfNotFound" /> は <see langword="true" /> であり、<paramref name="typeName" /> には無効な構文 (たとえば、"MyType[,*,]") が含まれています。  
  
または 
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
または 
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
または 
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwIfNotFound" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
または 
現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">完全修飾型名の指定</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md">方法 : リフレクションのみのコンテキストにアセンブリを読み込む</related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型のレイアウトを説明する <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> を取得します。</summary>
        <value>現在の型のレイアウト機能全体を説明する <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> を取得します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> によって返されない、<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>メソッド。 代わりに、このプロパティを使用して、それを取得します。  
  
   
  
## Examples  
 まず、次のコード例は、クラス、構造体、および (構造体は、クラス内で入れ子になった) 特殊なレイアウト属性を持つ構造体を定義します。 使用して、<xref:System.Type.StructLayoutAttribute%2A>を取得するプロパティを<xref:System.Runtime.InteropServices.StructLayoutAttribute>の各型、および属性のプロパティが表示されます。  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">将来使用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</param>
        <summary>一連の名前を対応する一連のディスパッチ識別子に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出さないでいます。 詳細については`IDispatch::GetIDsOfNames`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインター。</param>
        <summary>オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出さないでいます。 詳細については`IDispatch::GetTypeInfo`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</param>
        <summary>オブジェクトが提供する型情報インターフェイスの数 (0 または 1) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出さないでいます。 詳細については`IDispatch::GetTypeInfoCount`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバーを識別します。</param>
        <param name="riid">将来使用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出さないでいます。 詳細については`IDispatch::Invoke`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see langword="String" /> の名前を表す <see langword="Type" /> を返します。</summary>
        <returns>現在の <see cref="T:System.String" /> の名前を表す <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、共通言語ランタイムの完全修飾名前空間とすべてのプリミティブ型の名前を返します。 たとえば、c# の命令`(long)0.Type().ToString()`"Int64"だけではなく"System.Int64"を返します。  
  
 場合、現在<xref:System.Type>名前空間と入れ子にされた型がアセンブリではなく、ジェネリック型、型と型引数が修飾名を表します。 場合、現在<xref:System.Type>表しますジェネリック型またはジェネリック メソッド、このメソッドの定義の型パラメーターは、型パラメーターの非修飾名を返します。  
  
   
  
## Examples  
 次の例に示しますを使用して、<xref:System.Type.Namespace%2A>と<xref:System.Type.Module%2A>プロパティと`ToString`メソッドの<xref:System.Type>します。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 次の例によって返される文字列の比較、<xref:System.Type.ToString%2A>メソッドと`Name`、 <xref:System.Type.FullName%2A>、および<xref:System.Type.AssemblyQualifiedName%2A>プロパティ。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のハンドルを取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> のハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` 型を表す内部データ構造体へのポインターをカプセル化します。 このハンドルは、プロセスの有効期間中に一意です。 ハンドルは、取得されているアプリケーション ドメインでのみ有効です。  
  
   
  
## Examples  
 次の例では、対応する型のハンドルを返し、ハンドルから型を取得し、表示をメソッドへのハンドルを渡します。  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">現在、.NET Compact Framework は、このプロパティをサポートしていません。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の初期化子を取得します。</summary>
        <value><see cref="T:System.Type" /> のクラス コンストラクターの名前を格納するオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 クラスの初期化子は、使用、<xref:System.Type.FindMembers%2A>メソッド、またはのオーバー ロードによって、 <xref:System.Type.GetMember%2A>、 <xref:System.Type.GetMembers%2A>、 <xref:System.Type.GetConstructor%2A>、および<xref:System.Type.GetConstructors%2A>取るメソッド<xref:System.Reflection.BindingFlags>をパラメーターとして。  
  
 場合、現在<xref:System.Type>このプロパティを返します、ジェネリック型またはジェネリック メソッドの定義で型パラメーターを表す`null`します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型を表す共通言語ランタイムによって提供された型を示します。</summary>
        <value><see cref="T:System.Type" /> の基になるシステム型。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>