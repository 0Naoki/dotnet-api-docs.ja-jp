<Type Name="Exception" FullName="System.Exception">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b6aa85862050a9a84c2c2d8e4a9054a8b03377d8" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51872225" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Exception = class&#xA;    interface ISerializable&#xA;    interface _Exception" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>アプリケーションの実行中に発生したエラーを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスは、すべての例外の基本クラスです。 エラーが発生したときに、システムまたは現在実行中のアプリケーションのいずれかがによって報告、エラーに関する情報を含む例外をスローします。 例外がスローされた後、アプリケーションまたは既定の例外ハンドラーによって処理されます。  
  
 このセクションの内容:  
  
 [エラーと例外](#Errors)   
 [Try/catch ブロック](#TryCatch)   
 [例外の種類の機能](#Features)   
 [例外クラスのプロパティ](#Properties)   
 [パフォーマンスに関する考慮事項](#Performance)   
 [例外の再スロー](#Rethrow)   
 [標準の例外を選択します。](#Standard)   
 [カスタム例外を実装します。](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a>エラーと例外  
 実行時エラーは、さまざまな理由で発生します。 ただし、すべてのエラーは、コードの例外として処理する必要があります。 ここでは、実行時とそれらに応答する適切な方法で発生する可能性があるエラーのいくつかのカテゴリです。  
  
-   **使用状況のエラー。** 使用法のエラーは、例外が発生するプログラム ロジックでエラーを表します。 ただし、エラーは、例外処理ではなく、問題のあるコードを変更することでアドレス指定する必要があります。 オーバーライドなど、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッドは、次の例を前提としている`obj`引数は null 以外に常にあります。  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     <xref:System.NullReferenceException>の例外をとき`obj`は`null`明示的に呼び出す前に null をテストするソース コードを修正して取り除くことができます、 <xref:System.Object.Equals%2A?displayProperty=nameWithType> override キーワードと再コンパイルします。 次の例には処理する修正されたソース コードが含まれています、`null`引数。  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     使用状況のエラーの例外処理を使用して、代わりに使用することができます、<xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType>デバッグ ビルドでの使用状況のエラーを識別するメソッドと<xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType>デバッグとリリースの両方で使用エラーを識別するためにメソッドが構築されます。 詳細については、次を参照してください。[マネージ コードでアサーション](/visualstudio/debugger/assertions-in-managed-code)します。  
  
-   **プログラムのエラー。** プログラム エラーは、必ずしもバグのないコードを記述することで回避することはできませんが、ランタイム エラーです。  
  
     場合によっては、プログラム エラーは、想定または日常的なエラー状態を反映可能性があります。 ここでは、プログラム エラーを処理し、代わりに、操作を再試行する例外処理の使用を回避する可能性があります。 たとえば場合は、ユーザーが特定の形式で日付を入力必要ですが、解析できます日付文字列を呼び出して、<xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType>を返すメソッドを<xref:System.Boolean>を使用する代わりに、解析操作が成功したかどうかを示す値<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>メソッドがスローされます、<xref:System.FormatException>日付文字列に変換できない場合は例外を<xref:System.DateTime>値。 同様に、ユーザーは、存在しないファイルを開くしようとすると、最初に呼び出せる、<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>ファイルが存在し、その場合は、作成するかどうか、ユーザーを要求するかどうかを確認する方法。  
  
     それ以外の場合は、プログラム エラーは、コードで処理できる、予期しないエラー状態を反映します。 たとえば、場合でも、ファイルが存在することを確認したら、それが削除できます前に、それを開くか、または、壊れている可能性があります。 その場合は、インスタンス化してファイルを開こうとした、<xref:System.IO.StreamReader>オブジェクトまたは呼び出し元、<xref:System.IO.File.Open%2A>メソッドがスローする可能性が、<xref:System.IO.FileNotFoundException>例外。 このような場合は、例外、エラーから回復する処理を使用する必要があります。  
  
-   **システム障害。** システム障害は、プログラムでは意味のある方法で処理できない実行時エラーです。 たとえば、任意のメソッドをスローできます、<xref:System.OutOfMemoryException>例外の場合は、共通言語ランタイムが追加のメモリを割り当てることができません。 通常、システム障害は例外処理を使用して、処理されません。 代わりに、できる場合がありますなど、イベントを使用する<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>を呼び出すと、<xref:System.Environment.FailFast%2A?displayProperty=nameWithType>例外情報を記録し、アプリケーションが終了する前に、エラーをユーザーに通知するメソッド。  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a>Try/catch ブロック  
 共通言語ランタイムは、例外として、オブジェクトの表現とプログラム コードと例外処理にコードの分離に基づく例外処理モデルを提供します。`try`ブロックと`catch`ブロックします。 1 つまたは複数があることができます`catch`ブロックする場合に、それぞれ特定の種類の例外、または別のブロックよりも具体的な例外をキャッチする 1 つのブロックを処理するために設計されています。  
  
 コードがある必要があります内に配置するアプリケーションでは、アプリケーション コードのブロックの実行中に発生する例外を処理する場合、`try`ステートメントと呼びます、`try`ブロックします。 によってスローされた例外を処理するアプリケーション コード、`try`ブロックが内に配置される、`catch`ステートメントと呼びます、`catch`ブロックします。 0 個以上`catch`ブロックに関連付けられ、`try`ブロック、および各`catch`ブロックに処理する例外の種類を決定する種類のフィルターが含まれています。  
  
 例外が発生したときに、`try`ブロック、システムに関連付けられている検索`catch`ことによって検出されるまでに、アプリケーション コードに表示される順序でブロックを`catch`例外を処理するブロック。 A`catch`ブロック型の例外を処理`T`catch ブロックの種類のフィルターが指定されている場合`T`任意の型または`T`から派生します。 システムが 1 つ目のインスタンスを検出した後に検索を停止した`catch`例外を処理するブロック。 このため、アプリケーション コードで、`catch`前に、型を処理するブロックを指定する必要があります、`catch`このセクションの次の例に示すように、基本型を処理するブロック。 処理する catch ブロック`System.Exception`最後に指定します。  
  
 None の場合、`catch`に現在関連付けられているブロック`try`ブロック処理、例外と現在`try`内でその他のブロックが入れ子になった`try`、現在の呼び出しでブロック、`catch`ブロックに次の関連付けそれを囲む`try`ブロックが検索されます。 ない場合は`catch`例外のブロックが見つかると、システムは、現在の呼び出しの前の入れ子レベルを検索します。 ない場合は`catch`ブロック、例外が、現在の呼び出しで見つかった、コール スタックに渡された例外および以前のスタック フレームが検索、`catch`例外を処理するブロック。 呼び出し履歴にフレームがなくなるまで、または、例外が処理されるまで、呼び出し履歴の検索が続行されます。 検索せず、呼び出しスタックの一番上に達した場合、`catch`既定の例外ハンドラー、例外処理ブロックを処理し、アプリケーションが終了します。  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a>例外の種類の機能  
 例外の種類は、次の機能をサポートします。  
  
-   エラーを説明する人間が判読できるテキスト。 例外が発生したときに、ランタイムは、問題を解決するのには、エラーの性質をユーザーに通知し、アクションを提案する使用可能なテキスト メッセージにします。 このテキスト メッセージが保持されている、<xref:System.Exception.Message%2A>例外オブジェクトのプロパティ。 例外オブジェクトを作成する際は、コンス トラクターに、その特定の例外の詳細を説明テキスト文字列を渡すことができます。 コンス トラクターにエラー メッセージの引数が指定されていない場合は、既定のエラー メッセージが使用されます。 詳細については、<xref:System.Exception.Message%2A> プロパティを参照してください。  
  
-   例外がスローされたときに、呼び出し履歴の状態。 <xref:System.Exception.StackTrace%2A>プロパティは、コードでエラーが発生するかを判断するのに使用できるスタック トレースを保持します。 スタック トレースは、呼び出されたすべてのメソッドと、呼び出しが行われる場所のソース ファイル内の行番号を示します。  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a>例外クラスのプロパティ  
 <xref:System.Exception>クラスには、さまざまなコードの場所、種類、ヘルプ ファイル、および例外の原因の特定に役立つプロパティが含まれています: <xref:System.Exception.StackTrace%2A>、 <xref:System.Exception.InnerException%2A>、 <xref:System.Exception.Message%2A>、 <xref:System.Exception.HelpLink%2A>、 <xref:System.Exception.HResult%2A>、 <xref:System.Exception.Source%2A>、<xref:System.Exception.TargetSite%2A>、および<xref:System.Exception.Data%2A>します。  
  
 2 つ以上の例外と因果関係が存在する場合に、<xref:System.Exception.InnerException%2A>プロパティは、この情報を保持します。 この内部例外への応答では、外側の例外がスローされます。 外側の例外を処理するコードは、前の内部例外からの情報を使用して、エラーをより適切に処理できます。 内のキー/値ペアのコレクションとして、例外に関する補足情報を格納できる、<xref:System.Exception.Data%2A>プロパティ。  
  
 例外オブジェクトの作成時に、コンス トラクターに渡されるエラー メッセージ文字列はローカライズする必要があるし、を使用してリソース ファイルから指定することができます、<xref:System.Resources.ResourceManager>クラス。 ローカライズされたリソースの詳細については、次を参照してください。、[サテライト アセンブリの作成](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)と[Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)トピック。  
  
 例外が発生した理由に関する詳細情報をユーザーに提供する、<xref:System.Exception.HelpLink%2A>プロパティがヘルプ ファイルへの URL (または URN) を保持できます。  
  
 <xref:System.Exception>クラスは、値が 0x80131500 HRESULT COR_E_EXCEPTION を使用します。  
  
 インスタンスの初期プロパティ値の一覧については、<xref:System.Exception>クラスを参照してください、<xref:System.Exception.%23ctor%2A>コンス トラクター。  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 スローすることや、例外の処理は、大量のシステム リソースと実行時間を消費します。 予測可能なイベントを処理したり、フロー制御が、真に異常な状態の処理にのみ例外をスローします。 たとえば、場合によっては、クラス ライブラリを開発しているときなど、メソッドの引数は、有効なパラメーターで呼び出されるメソッドを想定しているため有効でない場合は、例外をスローする妥当なは。 無効なメソッド引数では、使用状況、エラーの結果でない場合に、何か異常が発生したことを意味します。 逆は例外はスローされません、場合によっては無効なデータを入力するユーザーを想定できるため、ユーザー入力が有効でない場合。 代わりに、ユーザーは、有効な入力を入力できるように再試行メカニズムを提供します。 また、使用状況のエラーを処理する例外を使用する必要があります。 代わりに、[アサーション](/visualstudio/debugger/assertions-in-managed-code)を特定し、使用状況のエラーを修正します。  
  
 リターン コードで十分です。 ときに例外をスローしないでくださいさらに、リターン コードを例外に変換できません。および例外定期的に catch は、無視するか、および処理を続行します。  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a>例外の再スロー  
 多くの場合、例外ハンドラーは、呼び出し元に例外を渡すだけですが。 このほとんどは、多くの場合に行われます。  
  
-   さらに、.NET Framework クラス ライブラリやその他のクラス ライブラリでメソッドの呼び出しをラップするクラス ライブラリです。  
  
-   アプリケーションまたは致命的な例外が発生するライブラリ。 例外ハンドラーでは、例外をログにでき、例外を再スローすることができます。  
  
 例外を再スローするお勧めの方法は、単に使用する、[スロー](~/docs/csharp/language-reference/keywords/throw.md) (C#) ステートメント、[スロー](~/docs/visual-basic/language-reference/statements/throw-statement.md)式を含めず、Visual Basic でのステートメント。 これにより、呼び出し元に例外が伝達されるすべての呼び出し履歴情報を保持します。 次に例を示します。 文字列の拡張メソッドで`FindOccurrences`、1 つまたは複数の呼び出しをラップします<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>その引数の事前検証なし。  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 呼び出し元を呼び出して`FindOccurrences`2 回クリックします。 2 番目の呼び出しで`FindOccurrences`、呼び出し元のパスを`null`ケースを検索文字列として、<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>をスローするメソッド、<xref:System.ArgumentNullException>例外。 によってこの例外を処理、`FindOccurrences`メソッドを呼び出し元に渡されたバックします。 式のない throw ステートメントを使用しているため、例からの出力は、呼び出し履歴が保持されることを示します。  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 一方を使用して、例外が再スローされた場合、  
  
```csharp  
throw e  
```  
  
```vb  
Throw e  
```  
  
 ステートメントでは、完全な呼び出し履歴は保持されませんし、例は、次の出力を生成します。  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 少し煩雑な代替手段は、新しい例外をスローして、内部例外の元の例外のコール スタック情報を保持するためには。 呼び出し元は、新しい例外を使用できます<xref:System.Exception.InnerException%2A>プロパティがスタック フレームと、元の例外に関する他の情報を取得します。 この場合は、throw ステートメントは次のとおりです。  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 例外を処理するユーザー コードが認識することが、<xref:System.Exception.InnerException%2A>プロパティは、次の例外ハンドラーに示すように、元の例外に関する情報を格納します。  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a>標準の例外を選択します。  
 例外をスローするときに、カスタム例外を実装する代わりに .NET Framework の多くの場合、既存の例外の種類を使用できます。 これら 2 つの条件下で、標準の例外の種類を使用する必要があります。  
  
-   使用法のエラーによって引き起こされる例外をスローしている (つまり、メソッドを呼び出すことが開発者によって行われたプログラム ロジックのエラーによって)。 通常は例外をスローするよう<xref:System.ArgumentException>、 <xref:System.ArgumentNullException>、 <xref:System.InvalidOperationException>、または<xref:System.NotSupportedException>します。 開発者によって修正できるように、エラーを記述する必要があります、例外オブジェクトをインスタンス化するときに、例外オブジェクトのコンス トラクターを指定する文字列。 詳細については、<xref:System.Exception.Message%2A> プロパティを参照してください。  
  
-   既存の .NET Framework の例外で呼び出し元に伝えることがエラーが処理されます。 考えられる最も派生例外をスローする必要があります。 たとえば、メソッドが有効な列挙型のメンバーである引数を必要とする必要がありますをスローする、 <xref:System.ComponentModel.InvalidEnumArgumentException> (最も派生クラス) ではなく、<xref:System.ArgumentException>します。  
  
 次の表は、一般的な例外タイプとをそれらをスローは条件を示します。  
  
|例外|条件|  
|---------------|---------------|  
|<xref:System.ArgumentException>|メソッドに渡される null 以外の引数が無効です。|  
|<xref:System.ArgumentNullException>|メソッドに渡される引数が`null`します。|  
|<xref:System.ArgumentOutOfRangeException>|引数は、有効な値の範囲外です。|  
|<xref:System.IO.DirectoryNotFoundException>|ディレクトリ パスの一部が無効です。|  
|<xref:System.DivideByZeroException>|整数で、分母または<xref:System.Decimal>除算演算が 0 です。|  
|<xref:System.IO.DriveNotFoundException>|ドライブをご利用いただけませんまたは存在しません。|  
|<xref:System.IO.FileNotFoundException>|ファイルが存在しません。|  
|<xref:System.FormatException>|などの変換メソッドによって、文字列から変換する適切な形式で値がない`Parse`します。|  
|<xref:System.IndexOutOfRangeException>|インデックスが配列またはコレクションの範囲外です。|  
|<xref:System.InvalidOperationException>|メソッドの呼び出しがオブジェクトの現在の状態では無効です。|  
|<xref:System.Collections.Generic.KeyNotFoundException>|コレクション内のメンバーにアクセスするための指定したキーが見つかりません。|  
|<xref:System.NotImplementedException>|メソッドまたは操作が実装されていません。|  
|<xref:System.NotSupportedException>|メソッドまたは操作がサポートされていません。|  
|<xref:System.ObjectDisposedException>|操作が破棄されているオブジェクト。|  
|<xref:System.OverflowException>|算術演算、キャストまたは変換操作の結果はオーバーフローが発生します。|  
|<xref:System.IO.PathTooLongException>|パスまたはファイル名は、システム定義の最大長を超えています。|  
|<xref:System.PlatformNotSupportedException>|現在のプラットフォームでは、操作がサポートされていません。|  
|<xref:System.RankException>|問題の次元数を含む配列がメソッドに渡されます。|  
|<xref:System.TimeoutException>|操作に割り当てられた時間間隔が終了しました。|  
|<xref:System.UriFormatException>|無効な Uniform Resource Identifier (URI) が使用されます。|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a>カスタム例外を実装します。  
 次の場合、既存の .NET Framework の例外を使用して、エラー状態を処理するための適切ではありません。  
  
-   ときに、例外には、既存の .NET Framework の例外にマップできない固有のプログラム エラーが反映されます。  
  
-   例外の処理とは異なる既存の .NET Framework の例外または例外を適切な処理が必要な場合は、同様の例外から区別する必要があります。 スローする場合など、<xref:System.ArgumentOutOfRangeException>例外のターゲットの整数型の範囲外である文字列の数値表現の解析中に、しない、同じ例外を指定していない呼び出し元に起因するエラーに使用する、メソッドを呼び出すと、適切なのことに制約されている値。  
  
 <xref:System.Exception>クラスは、.NET Framework のすべての例外の基本クラスです。 多くの派生クラスのメンバーの継承の動作に依存、 <xref:System.Exception> ; クラスのメンバーをオーバーライドしないで<xref:System.Exception>、またも任意の一意のメンバーを定義しないでください。  
  
 独自の例外クラスを定義するには。  
  
1.  継承するクラスを定義<xref:System.Exception>します。 必要に応じて、例外に関する追加情報を提供するクラスに必要な任意の一意のメンバーを定義します。 など、<xref:System.ArgumentException>クラスが含まれています、<xref:System.ArgumentException.ParamName%2A>の引数の例外の原因となったパラメーターの名前を指定するプロパティと<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>プロパティが含まれています、<xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A>タイムアウト間隔を示すプロパティです。  
  
2.  必要に応じて、変更または変更する機能を持つ継承されたメンバーをオーバーライドします。 既存のほとんどを派生クラスの<xref:System.Exception>継承されたメンバーの動作をオーバーライドできません。  
  
3.  カスタム例外オブジェクトがシリアル化できるかどうかを決定します。 シリアル化では、例外に関する情報を保存することができ、例外情報をリモート処理コンテキスト内のサーバーとクライアント プロキシで共有を許可します。 例外オブジェクトをシリアル化可能にするには、マークで、<xref:System.SerializableAttribute>属性。  
  
4.  例外クラスのコンス トラクターを定義します。 通常、例外クラスは、次のコンス トラクターの 1 つ以上あります。  
  
    -   <xref:System.Exception.%23ctor>、既定値を使用する新しい例外オブジェクトのプロパティを初期化します。  
  
    -   <xref:System.Exception.%23ctor%28System.String%29>を指定したエラー メッセージが新しい例外オブジェクトを初期化します。  
  
    -   <xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>を指定したエラー メッセージと内部例外を新しい例外オブジェクトを初期化します。  
  
    -   <xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>、これは、`protected`からの新しい例外オブジェクトを初期化するコンス トラクターにシリアル化されたデータ。 例外オブジェクトをシリアル化できるようにすることを選択した場合は、このコンス トラクターを実装する必要があります。  
  
 次の例では、カスタム例外クラスの使用を示します。 定義、`NotPrimeException`クライアントが素数でない開始番号を指定することによって、素数のシーケンスを取得する場合にスローされる例外。 例外は、新しいプロパティを定義します。 `NonPrime`、、以外の素数、例外の原因となったを返します。 保護されているパラメーターなしのコンス トラクターを持つコンス トラクターを実装するだけでなく<xref:System.Runtime.Serialization.SerializationInfo>と<xref:System.Runtime.Serialization.StreamingContext>パラメーターのシリアル化、`NotPrimeException`クラス定義をサポートする 3 つの追加コンス トラクター、`NonPrime`プロパティ。  各コンス トラクターは、値の非の素数を保持するだけでなく基底クラスのコンス トラクターを呼び出します。 `NotPrimeException`クラスが指定されても、<xref:System.SerializableAttribute>属性。  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 `PrimeNumberGenerator`次の例に示すようにクラスでは、Sieve of Eratosthenes を使用して、クライアントがそのクラス コンス トラクターの呼び出しで指定された制限を 2 から素数のシーケンスを計算します。 `GetPrimesFrom`メソッドは指定した下限以上であるすべての素数を返しますが、スロー、`NotPrimeException`その下限の値が素数ではない場合。  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 次の例では 2 つの呼び出し、`GetPrimesFrom`メソッドと素数以外をアプリケーション ドメインの境界を越えるうちの 1 つ。 どちらの場合も、例外がスローされ、クライアント コードで正常に処理します。  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows ランタイムと [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]の[!INCLUDE[win8](~/includes/win8-md.md)]、非 .NET Framework のスタック フレームで例外が伝達されるいくつかの例外情報が通常は失われます。 以降では、[!INCLUDE[net_v451](~/includes/net-v451-md.md)]と[!INCLUDE[win81](~/includes/win81-md.md)]、共通言語ランタイムは引き続き、元の使用<xref:System.Exception>その例外は、非 .NET Framework のスタック フレームに変更されていない場合にスローされたオブジェクト。  
  
   
  
## Examples  
 次の例で、`catch`処理するために定義されているブロック<xref:System.ArithmeticException>エラー。 これは、`catch`キャッチでブロックも<xref:System.DivideByZeroException>エラー、ため<xref:System.DivideByZeroException>から派生<xref:System.ArithmeticException>はありません`catch`を明示的に定義されているブロック<xref:System.DivideByZeroException>エラー。  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/exceptions/index.md">例外の処理とスロー</related>
    <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">デスクトップ アプリケーションでのリソースのパッケージ化と配置</related>
    <related type="Article" href="https://msdn.microsoft.com/library/70ab2522-6486-4076-a1a9-e0f11cd0f3a1">マネージド コードのアサーション</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Exception" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Exception" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターは、新しいインスタンスの <xref:System.Exception.Message%2A> プロパティを初期化して、その値として、現在のシステムのカルチャを反映した、エラーを説明するシステム提供のメッセージを指定します。  
  
 すべての派生クラスでは、この既定のコンス トラクターを提供する必要があります。 <xref:System.Exception> のインスタンスの初期プロパティ値を次の表に示します。  
  
|プロパティ|[値]|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|null 参照 (Visual Basic の場合は `Nothing`)。|  
|<xref:System.Exception.Message%2A>|システム提供のローカライズされた説明。|  
  
   
  
## Examples  
 次のコード例では、`Exception`定義済みのメッセージを使用します。 コードは、基本と派生クラスのパラメーターなしのコンス トラクターの使用を示します`Exception`クラス。  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new Exception : string -&gt; Exception" Usage="new System.Exception message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">エラーを説明するメッセージ。</param>
        <summary>指定したエラー メッセージを使用して、<see cref="T:System.Exception" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターの初期化、<xref:System.Exception.Message%2A>を使用して、新しいインスタンスのプロパティ、`message`パラメーター。 場合、`message`パラメーターが`null`、これは、呼び出すことと同じ、<xref:System.Exception.%23ctor%2A>コンス トラクター。  
  
 <xref:System.Exception> のインスタンスの初期プロパティ値を次の表に示します。  
  
|プロパティ|[値]|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|null 参照 (Visual Basic の場合は `Nothing`)。|  
|<xref:System.Exception.Message%2A>|エラー メッセージ文字列。|  
  
   
  
## Examples  
 次のコード例では、`Exception`特定の条件。 コードの使い方の基本と派生クラスをパラメーターとして呼び出し元が指定したメッセージを受け取るコンス トラクターの`Exception`クラス。  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new Exception : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Exception" Usage="new System.Exception (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">スローされている例外に関するシリアル化済みオブジェクト データを保持している <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="context">転送元または転送先についてのコンテキスト情報を含む <see cref="T:System.Runtime.Serialization.StreamingContext" /> です。</param>
        <summary>シリアル化したデータを使用して、<see cref="T:System.Exception" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターは、逆シリアル化中に、ストリームで送信された例外オブジェクトを再構築するために呼び出されます。 詳細については、次を参照してください。 [XML および SOAP シリアル化](~/docs/standard/serialization/xml-and-soap-serialization.md)します。  
  
   
  
## Examples  
 次のコード例は、派生定義シリアル化可能な`Exception`クラス。 コードが強制的に 0 による除算のエラーとを使用して、派生した例外のインスタンスを作成し、(<xref:System.Runtime.Serialization.SerializationInfo>、 <xref:System.Runtime.Serialization.StreamingContext>) コンス トラクター。 コードをファイルにインスタンスをシリアル化、新しい例外のスローにファイルを逆シリアル化し、キャッチして、例外のデータが表示されます。  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">クラス名が <see langword="null" /> であるか、<see cref="P:System.Exception.HResult" /> が 0 です。</exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">XML シリアル化および SOAP シリアル化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new Exception : string * Exception -&gt; Exception" Usage="new System.Exception (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">例外の原因を説明するエラー メッセージ。</param>
        <param name="innerException">現在の例外の原因である例外。内部例外が指定されていない場合は null 参照 (Visual Basic では、<see langword="Nothing" />)。</param>
        <summary>指定したエラー メッセージおよびこの例外の原因となった内部例外への参照を使用して、<see cref="T:System.Exception" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 前の例外の直接の結果としてスローされる例外については、<xref:System.Exception.InnerException%2A> プロパティに、前の例外への参照が格納されます。 <xref:System.Exception.InnerException%2A> プロパティは、コンストラクターに渡されたものと同じ値を返します。`Nothing` プロパティによって内部例外値がコンストラクターに渡されなかった場合は、null 参照 (Visual Basic の場合は <xref:System.Exception.InnerException%2A>) を返します。  
  
 <xref:System.Exception> のインスタンスの初期プロパティ値を次の表に示します。  
  
|プロパティ|[値]|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|内部例外の参照。|  
|<xref:System.Exception.Message%2A>|エラー メッセージ文字列。|  
  
   
  
## Examples  
 次のコード例では、`Exception`特定の条件。 コードは、メッセージと内部例外の基本と派生クラスの両方のパラメーターとして受け取るコンス トラクターの使用を示します`Exception`クラス。  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Data : System.Collections.IDictionary" Usage="System.Exception.Data" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>例外に関する追加のユーザー定義情報を提供する、キー/値ペアのコレクションを取得します。</summary>
        <value>
          <see cref="T:System.Collections.IDictionary" /> インターフェイスを実装し、ユーザー定義のキー/値ペアのコレクションを格納するオブジェクト。 既定値は空のコレクションです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Collections.IDictionary?displayProperty=nameWithType>によって返されるオブジェクト、<xref:System.Exception.Data%2A>プロパティを格納および例外に関連する補足情報を取得します。 情報は任意の数のユーザー定義のキー/値ペアの形式です。 各キー/値ペアのキー コンポーネントは、問題を識別する文字列では通常ペアの値のコンポーネントは任意の種類のオブジェクトであることができます。  
  
## <a name="keyvalue-pair-security"></a>キー/値ペアのセキュリティ  
 によって返されるコレクションに格納されているキー/値のペア、<xref:System.Exception.Data%2A>プロパティは、安全ではありません。 アプリケーションを呼び出すと、入れ子になった一連のルーチンの各ルーチンには、例外ハンドラーが含まれている場合は、結果のコール スタックには、これらの例外ハンドラーの階層が含まれています。 低レベル ルーチンでは、例外をスローする場合、呼び出しスタックの階層内のいずれかの上位レベルの例外ハンドラーは読み取りや、他の例外ハンドラーによって、コレクションに格納されているキー/値ペアを変更します。 つまり、キー/値ペア内の情報が機密ではないと、アプリケーションが、キー/値ペア内の情報が破損している場合に、正常に動作が保証する必要があります。  
  
## <a name="key-conflicts"></a>キーの競合  
 キーの競合は、別の例外ハンドラー、キー/値のペアへのアクセスに同じキーを指定する場合に発生します。 キーの競合の結果には、下位レベルの例外ハンドラーより高度な例外ハンドラーと通信できる誤ってをこの通信プログラムの微妙なエラーが発生する可能性がありますので、アプリケーションを開発する際に、注意を使用します。 ただし、注意が必要ですが、アプリケーションを強化するためにキーの競合を使用できます。  
  
## <a name="avoiding-key-conflicts"></a>キーの競合を避ける  
 キー/値ペアの一意のキーを生成する名前付け規則を採用することでキーの競合を回避します。 たとえば、名前付け規則では、アプリケーションのピリオドで区切った名前で構成されるキーのペア、および一意の識別子の補足情報を提供するメソッドを生成可能性があります。  
  
 たとえば、2 つのアプリケーションには、製品と仕入先がという名前をそれぞれ Sales という名前のメソッドがあります。 製品のアプリケーションで Sales メソッドでは、製品の識別番号 (在庫の単位または SKU の管理) を提供します。 Id 番号、または SID、サプライヤーのサプライヤー アプリケーション内の Sales メソッドを提供します。 そのため、この例の名前付け規則は、"Products.Sales.SKU"と"Suppliers.Sales.SID"キーを生成します。  
  
## <a name="exploiting-key-conflicts"></a>キーの競合を悪用します。  
 キーの競合を悪用するには、1 つ以上の特殊な既定のキーの存在を使用して処理を制御します。 たとえば、1 つのシナリオでは、コール スタックの階層で最上位レベルの例外ハンドラーは、下位レベルの例外ハンドラーによってスローされたすべての例外をキャッチします。 高度な例外ハンドラーが内の残りのキー/値ペアを書式設定する特殊なキーとキー/値ペアが存在する場合、<xref:System.Collections.IDictionary>オブジェクトでは、残りのキー/値ペアが通常の方法で書式設定、それ以外の場合。  
  
 これでと、別のシナリオでコール スタックの階層の各レベルでの例外ハンドラーは、[次へ] の下位レベルの例外ハンドラーによってスローされた例外をキャッチします。 さらに、各例外ハンドラーがによって返されるコレクションを知っている、<xref:System.Exception.Data%2A>プロパティに既定の一連のキーでアクセスできるキー/値ペアのセットが含まれています。  
  
 各例外ハンドラーでは、その例外ハンドラーに固有の情報に対応するキー/値ペアの値のコンポーネントを更新するのにキーの既定のセットを使用します。 更新プロセスが完了したら、例外ハンドラーは、次のより高度な例外ハンドラーに例外をスローします。 最後に、最上位レベルの例外ハンドラーは、キー/値ペアにアクセスし、すべての下位レベルの例外ハンドラーから統合の更新プログラムの情報を表示します。  
  
   
  
## Examples  
 次の例では、追加しを使用して情報を取得する方法、<xref:System.Exception.Data%2A>プロパティ。  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseException : unit -&gt; Exception&#xA;override this.GetBaseException : unit -&gt; Exception" Usage="exception.GetBaseException " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、それ以後に発生する 1 つ以上の例外の根本原因である <see cref="T:System.Exception" /> を返します。</summary>
        <returns>例外のチェインでスローされた最初の例外。 現在の例外の <see cref="P:System.Exception.InnerException" /> プロパティが null 参照 (Visual Basic の場合は <see langword="Nothing" />) である場合、このプロパティは現在の例外を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例外のチェーンから成る例外のセットで参照されている例外の直接の結果として、チェーン内の各例外がスローされるように、`InnerException`プロパティ。 チェーンの指定した場合、チェーン内の他のすべての例外の根本原因である 1 つだけ例外があります。 この例外は、基本の例外と呼ばれる、その`InnerException`プロパティには常に null 参照が含まれています。  
  
 例外のチェーン内のすべての例外、`GetBaseException`メソッドは、同じオブジェクト (基本例外) を返す必要があります。  
  
 使用して、`GetBaseException`メソッド例外の根本原因を見つけるには、現在の例外と、最初の例外の発生した可能性がある例外について必要はありません。  
  
   
  
## Examples  
 次のコード例では、2 つの派生を定義します`Exception`クラス。 例外を強制し、各派生クラスで再度スローします。 コードの使用を示しています、`GetBaseException`元の例外を取得します。  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="GetBaseException" />メソッドが例外内容または形式に対する制御を必要とするクラスでオーバーライドします。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="exception.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">スローされている例外に関するシリアル化済みオブジェクト データを保持している <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="context">転送元または転送先についてのコンテキスト情報を含む <see cref="T:System.Runtime.Serialization.StreamingContext" /> です。</param>
        <summary>派生クラスでオーバーライドされた場合は、その例外に関する情報を使用して <see cref="T:System.Runtime.Serialization.SerializationInfo" /> を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetObjectData` は、シリアル化する対象のすべての例外オブジェクト データを使用して、<xref:System.Runtime.Serialization.SerializationInfo> を設定します。 逆シリアル化中に、ストリームで転送された `SerializationInfo` から例外が再構成されます。  
  
   
  
## Examples  
 次のコード例は、派生定義シリアル化可能な`Exception`を実装するクラス`GetObjectData`、2 つのプロパティに軽微な変更は、これとし、呼び出しの基本クラスをシリアル化を実行します。 この例では、強制的に 0 による除算エラーしから派生した例外のインスタンスを作成します。 コードをファイルにインスタンスをシリアル化、新しい例外のスローにファイルを逆シリアル化し、キャッチして、例外のデータが表示されます。  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> パラメーターが null 参照 (Visual Basic の場合は <see langword="Nothing" />) です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="exception.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスのランタイム型を取得します。</summary>
        <returns>現在のインスタンスの正確なランタイム型を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.GetType%2A>メソッドは、.NET Framework インフラストラクチャをサポートするために存在し、内部的には、基本的なメソッドを呼び出します<xref:System.Object.GetType%2A?displayProperty=nameWithType>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HelpLink : string with get, set" Usage="System.Exception.HelpLink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この例外に関連付けられているヘルプ ファイルへのリンクを取得または設定します。</summary>
        <value>URN (Uniform Resource Name) または URL (Uniform Resource Locator)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ヘルプ ファイルを表す戻り値は、URN または URL です。 たとえば、`HelpLink`値可能性があります。  
  
 "file:///C:/Applications/Bazzal/help.html#ErrorNum42"  
  
   
  
## Examples  
 次のコード例がスローされます、`Exception`設定、`HelpLink`プロパティでは、コンス トラクターとし、キャッチされた例外と表示`HelpLink`します。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.HResult : int with get, set" Usage="System.Exception.HResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の例外に割り当てられているコード化数値である HRESULT を取得または設定します。</summary>
        <value>HRESULT 値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HRESULT は 32 ビット値は、3 つのフィールドに分かれています。 重大度コード、機能コード、およびエラー コード。 重大度コードでは、戻り値が、情報、警告、またはエラーを表すかどうかを示します。 機能コードでは、エラーの原因のシステムの領域を識別します。 エラー コードは、例外を表すために割り当てられている一意の番号です。 各例外は、個別の HRESULT にマップされます。 マネージ コードでは、例外をスローするときに、ランタイムは、HRESULT を COM クライアントに渡します。 アンマネージ コードにエラーが返されるときは、HRESULT が、ランタイムによってスローされる例外に変換されます。 HRESULT 値と、対応する .NET Framework の例外については、次を参照してください。[方法: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)します。 参照してください[の共通 HRESULT 値](https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx)が発生する最も高い値の一覧については、Windows ドキュメント。  
  
 以降では、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]、<xref:System.Exception.HResult%2A>プロパティの set アクセス操作子が保護されている、その取得メソッドはパブリックです。  .NET Framework の以前のバージョンでは、getter と setter の両方を保護します。  
  
   
  
## Examples  
 次のコード例を定義する派生`Exception`設定クラス、`HResult`プロパティをそのコンス トラクターでカスタム値にします。  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/610b364b-2761-429d-9c4a-afbc3e66f1b9">方法: HRESULT に例外を割り当てる</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx">共通 HRESULT 値</related>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerException : Exception" Usage="System.Exception.InnerException" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の例外の原因となる <see cref="T:System.Exception" /> インスタンスを取得します。</summary>
        <value>現在の例外を発生させたエラーを説明するオブジェクト。 <see cref="P:System.Exception.InnerException" /> プロパティは、<see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> コンストラクターに渡されたものと同じ値を返します。内部例外の値がコンストラクターに渡されなかった場合は <see langword="null" /> を返します。 このプロパティは読み取り専用です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに例外`X`直前の例外の直接の結果としてスローされる`Y`、<xref:System.Exception.InnerException%2A>プロパティの`X`への参照を含める必要があります`Y`します。  
  
 <xref:System.Exception.InnerException%2A> プロパティを使用して、現在の例外の原因になった例外のセットを取得します。  
  
 以前の例外をキャッチする新しい例外を作成することができます。 2 つ目の例外を処理、エラーをより適切に処理するために以前の例外から追加情報に使用するコードです。  
  
 ファイルを読み取り、そのファイルからデータを書式設定する関数があるとします。 コード ファイルを読み取るしようと、この例では、<xref:System.IO.IOException>がスローされます。 関数をキャッチ、<xref:System.IO.IOException>をスローし、<xref:System.IO.FileNotFoundException>します。 <xref:System.IO.IOException>で保存できませんでした、<xref:System.Exception.InnerException%2A>のプロパティ、 <xref:System.IO.FileNotFoundException>、キャッチするコードを有効にすると、<xref:System.IO.FileNotFoundException>最初のエラーの原因を確認します。  
  
 <xref:System.Exception.InnerException%2A>例外オブジェクトの初期化時に、内部例外への参照を保持するプロパティを設定します。  
  
   
  
## Examples  
 次の例は、スローおよび内部例外を参照する例外をキャッチします。  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Message : string" Usage="System.Exception.Message" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の例外を説明するメッセージを取得します。</summary>
        <value>例外の理由を説明するエラー メッセージ、または空の文字列 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 エラー メッセージは、例外を処理する開発者を対象します。 テキスト、<xref:System.Exception.Message%2A>プロパティは、エラーを完全に記述する必要があり、可能であれば、する必要があります、エラーを修正する方法を説明もします。 最上位の例外ハンドラーが、エンドユーザーのメッセージを表示するには、のでが文法的に正しいことと、メッセージの各文がピリオドで終わることをことを確認する必要があります。 疑問符 (?) または感嘆符は使用しないでください。 アプリケーションでは、ローカライズされた例外メッセージを使用する場合は、正確に変換されていることを確認してください。  
  
> [!IMPORTANT]
>  適切なアクセス許可をチェックすることがなく例外メッセージに機密情報が開示されません。  
  
 値、<xref:System.Exception.Message%2A>によって返される情報のプロパティが含まれている<xref:System.Exception.ToString%2A>します。<xref:System.Exception.Message%2A>プロパティが設定を作成するときにのみ、<xref:System.Exception>します。 現在のインスタンスのコンス トラクターにメッセージが指定されていない場合、システムは現在のシステム カルチャを使用して書式設定されている既定のメッセージを提供します。  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows ランタイムと [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 以降では、[!INCLUDE[net_v451](~/includes/net-v451-md.md)]と[!INCLUDE[win81](~/includes/win81-md.md)]、Windows ランタイム型と .NET Framework の一部ではないメンバーから継承される例外からエラー メッセージの忠実性が向上しています。 具体的には、Visual C コンポーネント拡張からメッセージを例外 (C +/cli CX) .NET Framework のバックアップに反映させるようになりました<xref:System.Exception>オブジェクト。  
  
   
  
## Examples  
 次のコード例をスローおよびキャッチし、<xref:System.Exception>例外、例外のテキストが表示されますを使用してメッセージ、<xref:System.Exception.Message%2A>プロパティ。
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>プロパティから例外をスローしてのテキスト内で参照する必要がある場合<see cref="P:System.Exception.Message" />を設定または取得するプロパティの引数には、プロパティ引数の名前として"value"を使用します。</para>
        </block>
        <block subset="none" type="overrides">
          <para>
            <see cref="P:System.Exception.Message" />プロパティがメッセージの内容または形式の制御を必要とするクラスでオーバーライドします。 アプリケーション コードがキャッチされた例外についての情報を表示する必要があるとき、このプロパティを通常にアクセスします。  
  
エラー メッセージをローカライズする必要があります。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberSignature Language="F#" Value="member this.SerializeObjectState : EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " Usage="member this.SerializeObjectState : System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>例外がシリアル化され、例外に関するシリアル化されたデータを含む例外状態オブジェクトが作成されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例外の状態オブジェクトを実装して、<xref:System.Runtime.Serialization.ISafeSerializationData>インターフェイス。  
  
 ときに、<xref:System.Exception.SerializeObjectState>イベントをサブスクライブすると、例外が逆シリアル化し、空の例外として作成します。 例外のコンス トラクターが実行されないと、例外の状態を逆シリアル化もします。 <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A>例外状態オブジェクトのコールバック メソッドに空の例外を逆シリアル化されたデータをプッシュすることができます、ように通知されます。  
  
 <xref:System.Exception.SerializeObjectState>イベントにより、例外データを逆シリアル化およびシリアル化する透過的な例外の種類。 透過的なコード内で、それが動作しているアクセス許可セットの範囲内のコマンドを実行ことはできません実行を呼び出す、派生元のしたりクリティカルなコードを含めることができます。  
  
 場合、<xref:System.Exception.SerializeObjectState>イベントがサブスクライブしていない、逆シリアル化の発生を使用して通常どおり、<xref:System.Exception.%23ctor%2A>コンス トラクター。  
  
 ハンドラーでは、通常、<xref:System.Exception.SerializeObjectState>そのシリアル化を提供する例外のコンス トラクターでイベントを追加します。 コンス トラクターがないため、ときに実行、<xref:System.Exception.SerializeObjectState>イベント ハンドラーが実行される、スロー、逆シリアル化された例外をシリアル化することができます、<xref:System.Runtime.Serialization.SerializationException>例外、例外を逆シリアル化しようとするとします。 これを回避するにはのハンドラーを追加する必要がありますも、<xref:System.Exception.SerializeObjectState>内のイベント、<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType>メソッド。 説明については、「例」を参照してください。  
  
   
  
## Examples  
 次の例では、定義、`BadDivisionException`を処理する、<xref:System.Exception.SerializeObjectState>イベント。 これは、入れ子になった状態のオブジェクトも含まれています。 という名前の構造`BadDivisionExceptionState`を実装する、<xref:System.Runtime.Serialization.ISafeSerializationData>インターフェイス。  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 `BadDivisionException` 0 による浮動小数点除算が発生したときに例外がスローされます。 例では、インスタンス化中 0 による除算の最初に、`BadDivisionException`オブジェクト、シリアル化、および例外をスローします。 0 による後続の部門が発生すると、例が既にシリアル化されたオブジェクトを逆シリアル化、なって、および例外をスローします。 オブジェクトのシリアル化、逆シリアル化、シリアル、および逆シリアル化のために、例、<xref:System.Exception.SerializeObjectState>両方で、イベント ハンドラー、`BadDivisionException`クラスのコンス トラクターと、<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType>実装します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>このイベントは購読し、使用した場合、以下の継承階層内のすべての派生型は同じシリアル化機構を実装する必要があります。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Exception.Source" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>エラーの原因となるアプリケーションまたはオブジェクトの名前を取得または設定します。</summary>
        <value>エラーの原因となるアプリケーションまたはオブジェクトの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Exception.Source%2A>プロパティが明示的に設定されていない、ランタイムが自動的に設定が、例外が発生したアセンブリの名前にします。  
  
   
  
## Examples  
 次の例がスローされます、`Exception`設定、`Source`プロパティでは、コンス トラクターとし、キャッチされた例外と表示`Source`します。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このオブジェクトはランタイム <see cref="N:System.Reflection" /> オブジェクトでなければなりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Exception.StackTrace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼び出し履歴で直前のフレームの文字列形式を取得します。</summary>
        <value>呼び出し履歴の直前のフレームを説明する文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 実行スタックは、指定された時点で実行されているすべてのメソッドを追跡します。 メソッド呼び出しのトレースは、スタック トレースと呼ばれます。 スタック トレースの一覧は、例外が発生したメソッドの行番号に呼び出し履歴を追跡する方法を提供します。  
  
 <xref:System.Exception.StackTrace%2A>プロパティは、例外がスローされた場所で行われた呼び出し履歴のフレームを返します。 新しいインスタンスを作成して、呼び出し履歴フレームに関する情報を取得できます、<xref:System.Diagnostics.StackTrace?displayProperty=nameWithType>クラスとを使用してその<xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType>メソッド。  
  
 アプリケーション コードで例外がスローされるたびに、共通言語ランタイム (CLR) は、スタック トレースを更新 (を使用して、`throw`キーワード)。 スタック トレースが、例外がスローされた当初、メソッド内の場所と、例外があった場所メソッド内の場所の両方を含む例外がスローされましたが、メソッドと異なるメソッドで再スローされた場合再スローされます。 例外がスローされると後で再度スローされ、同じメソッドの場合、スタック トレースには、場所と、例外が再度スローされますが、例外をスローした場所には含まれませんのみが含まれます。  
  
 <xref:System.Exception.StackTrace%2A>プロパティは多くのメソッド呼び出しなどのためのコード変換、期待どおりに、報告がインライン化、最適化中に発生しました。  
  
   
  
## Examples  
 次のコード例がスローされます、`Exception`し、それをキャッチして使用してスタック トレースが表示されます、、`StackTrace`プロパティ。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="StackTrace" />プロパティがスタック トレースの内容または形式の制御を必要とするクラスでオーバーライドします。  
  
既定では、スタック トレースは、例外オブジェクトがスローされる直前にキャプチャされます。 使用<see cref="P:System.Environment.StackTrace" />例外がスローされていないときに、スタック トレース情報を取得します。</para>
        </block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetSite : System.Reflection.MethodBase" Usage="System.Exception.TargetSite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の例外がスローされたメソッドを取得します。</summary>
        <value>現在の例外をスローした <see cref="T:System.Reflection.MethodBase" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この例外をスローするメソッドがないし、スタック トレースが null 参照ではない場合 (`Nothing` Visual basic)、<xref:System.Exception.TargetSite%2A>スタック トレースからメソッドを取得します。 スタック トレースが null 参照であると、<xref:System.Exception.TargetSite%2A> も null 参照を返します。  
  
> [!NOTE]
>  <xref:System.Exception.TargetSite%2A>プロパティは、例外がスローされた例外ハンドラーがアプリケーション ドメイン境界を越えて例外を処理する場合、メソッドの名前を正確に表示されない場合があります。  
  
   
  
## Examples  
 次のコード例がスローされます、`Exception`し、それをキャッチして、発信元を使用する方法が表示されます、`TargetSite`プロパティ。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="exception.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の例外の文字列形式を作成して返します。</summary>
        <returns>現在の例外の文字列形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.ToString%2A> 人間が理解できるものでは現在の例外の表現を返します。 例外には、カルチャに依存するデータが含まれる、文字列形式にによって返されます`ToString`する現在のシステム カルチャが考慮が必要です。 返される文字列の形式については、正確な要件はありませんは、ユーザー側で認識されるオブジェクトの値を反映するように試行する必要があります。  
  
 既定の実装<xref:System.Exception.ToString%2A>を現在の例外、メッセージ、呼び出しの結果をスローしたクラスの名前を取得します。<xref:System.Exception.ToString%2A>内部例外、および呼び出しの結果で<xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>します。 これらのメンバーのいずれかが場合`null`、その値が返される文字列に含まれません。  
  
 エラー メッセージがない場合、または空の文字列である場合 ("")、エラー メッセージが返されません。 それ以外の場合にのみ、内部例外とスタック トレースの名前が返される`null`します。  
  
 このメソッドは、<xref:System.Object.ToString%2A?displayProperty=nameWithType> をオーバーライドします。  
  
   
  
## Examples  
 次の例は、例外が発生し、呼び出し元の結果が表示されます<xref:System.Exception.ToString%2A>その例外でします。 なお、<xref:System.Exception.ToString%2A?displayProperty=nameWithType>例外クラスのインスタンスが引数の一覧に表示されたら、メソッドが暗黙的に呼び出されます、<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>メソッド。  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>