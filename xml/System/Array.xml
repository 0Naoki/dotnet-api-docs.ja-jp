<Type Name="Array" FullName="System.Array">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8d48d6bb686177694f1cbd85699b8af508b80aa1" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37485539" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>配列の作成、操作、検索、および並べ替えを行うメソッドを提供します。これにより、共通言語ランタイムのすべての配列の基本クラスとして機能します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>クラスの一部、<xref:System.Collections>名前空間。 ただし、まだと見なされます、コレクションに基づいているため、<xref:System.Collections.IList>インターフェイス。  
  
 <xref:System.Array>クラスは配列をサポートする言語の実装の基本クラスです。 ただし、システムとコンパイラから派生できる明示的に、<xref:System.Array>クラス。 ユーザーは、言語によって提供される配列構造を使用する必要があります。  
  
 値の要素が、<xref:System.Array>します。 長さ、<xref:System.Array>は含めることができる要素の合計数です。 下限、<xref:System.Array>は、最初の要素のインデックスです。 <xref:System.Array>の下限を持つことができますが、既定でゼロの下限の境界があります。 インスタンスを作成するときに、別の下限を定義することができます、<xref:System.Array>クラスを使用して<xref:System.Array.CreateInstance%2A>します。多次元<xref:System.Array>各次元のさまざまな境界があることができます。 配列には、最大 32 次元を持つことができます。  
  
 内のクラスとは異なり、<xref:System.Collections>名前空間、<xref:System.Array>容量は固定です。 容量を増やす必要があります新規に作成する<xref:System.Array>オブジェクト、必要な容量を要素のコピー元から<xref:System.Array>を新しいオブジェクトし、古い<xref:System.Array>します。  
  
 既定の最大サイズ、 <xref:System.Array> 2 ギガバイト (GB)。 64 ビット環境では、設定でサイズの制限を回避できます、`enabled`の属性、 [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)構成要素を`true`実行時環境でします。 ただし、配列は 40億要素では、合計して、0X7FEFFFFF の特定のディメンション (0X7FFFFFC7 バイト配列および 1 バイト構造体の配列) で最大のインデックスに制限できます。  
  
 1 次元配列の実装、 <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>、 <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>、 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>、<xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType>と<xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType>ジェネリック インターフェイス。 実装は、実行時に配列に提供され、その結果、ジェネリック インターフェイスに表示されないの宣言の構文、<xref:System.Array>クラス。 さらに、ジェネリック インターフェイスの種類 (明示的なインターフェイスの実装) の配列をキャストすることによってのみアクセスできるインターフェイスのメンバーの参照トピックではありません。 これらのインターフェイスの 1 つの配列をキャストするときの注意すべき重要な点は、追加のメンバーが挿入、または、throw の要素を削除<xref:System.NotSupportedException>します。  
  
 <xref:System.Type> オブジェクトは、配列型の宣言に関する情報を提供します。 <xref:System.Array> 同じ配列の型を持つオブジェクトでは、同じ共有<xref:System.Type>オブジェクト。  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> <xref:System.Type.GetElementType%2A?displayProperty=nameWithType>で期待どおりの結果を返さない可能性があります<xref:System.Array>ため場合、配列は、型にキャスト<xref:System.Array>結果は、オブジェクト、配列ではありません。 つまり、`typeof(System.Array).IsArray`返します`false`と`typeof(System.Array).GetElementType`返します`null`します。  
  
 <xref:System.Array.Copy%2A?displayProperty=nameWithType>メソッドだけでなく、同じ型の配列との間にもさまざまな種類の標準的な配列間の要素のコピーは、型キャストを自動的に処理します。  
  
 いくつかのメソッドなど<xref:System.Array.CreateInstance%2A>、 <xref:System.Array.Copy%2A>、 <xref:System.Array.CopyTo%2A>、<xref:System.Array.GetValue%2A>と<xref:System.Array.SetValue%2A>、大量の処理能力の配列の対応するためにパラメーターとして 64 ビット整数値を受け入れるオーバー ロードを提供します。 <xref:System.Array.LongLength%2A> <xref:System.Array.GetLongLength%2A>配列の長さを示す、64 ビット整数を返します。  
  
 <xref:System.Array>並べ替えの基準とは限りません。  並べ替える必要があります、<xref:System.Array>操作を実行する前に (など<xref:System.Array.BinarySearch%2A>) を必要とする、<xref:System.Array>並べ替えられます。  
  
 使用して、<xref:System.Array>ネイティブ コードでのポインター オブジェクトがサポートされておらずがスローされます、<xref:System.NotSupportedException>のいくつかの方法です。  
  
   
  
## Examples  
 次のコード例に示す方法<xref:System.Array.Copy%2A?displayProperty=nameWithType>整数型の配列と型の配列の要素をコピー<xref:System.Object>します。  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 次のコード例は、作成し、初期化、<xref:System.Array>プロパティとその要素が表示されます。  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>パブリック静的 (<see langword="Shared" /> Visual Basic で) この型のメンバーはスレッド セーフです。 インスタンス メンバーの場合は、スレッド セーフであるとは限りません。  この実装は同期を行わない (スレッド セーフな) ラッパーを<see cref="T:System.Array" />。 ただし、.NET Framework クラスに基づいた<see cref="T:System.Array" />のコレクションを使用して、独自の同期バージョンの提供、<see cref="P:System.Array.SyncRoot" />プロパティ。  コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">読み取り専用の <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> ラッパーでラップする、インデックス番号が 0 から始まる 1 次元配列。</param>
        <summary>指定した配列をラップする読み取り専用のラッパーを作成します。</summary>
        <returns>指定した配列をラップする読み取り専用の <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> ラッパー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 配列への変更を防ぐためには、このラッパーを介してのみの配列を公開します。  
  
 読み取り専用のコレクション、コレクションの変更を防止するラッパー コレクションそのため、基になるコレクションの変更が加えられた、読み取り専用コレクションはそれらの変更を反映します。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次の例では、読み取り専用配列をラップする<xref:System.Collections.ObjectModel.ReadOnlyCollection%601>します。  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バイナリ サーチ アルゴリズムを使用して、並べ替え済みの 1 次元の <see cref="T:System.Array" /> 内で値を検索します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる並べ替え済みの 1 次元 <see cref="T:System.Array" />。</param>
        <param name="value">検索するオブジェクト。</param>
        <summary>配列の各要素および指定したオブジェクトによって実装されている <see cref="T:System.IComparable" /> インターフェイスを使用して、1 次元の並べ替え済み配列全体の中から特定の要素を検索します。</summary>
        <returns>
          <paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含んだ配列の検索をサポートしていません。 `array` このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、<xref:System.Array>に指定した値が含まれていないメソッドは負の整数を返します。 ビットごとの補数演算子を適用することができます (~、c# で`Not`Visual Basic で) にインデックスを生成するためには、負の結果。 このインデックスが 1 つである場合、配列の上限よりも大きい要素がないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`します。  
  
 いずれか`value`のすべての要素または`array`実装する必要があります、<xref:System.IComparable>の比較に使用するインターフェイス。 要素`array`既にによって定義されている並べ替え順序に従って値を増やすことで並べ替える必要があります、<xref:System.IComparable>実装。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`value`実装していない、<xref:System.IComparable>インターフェイスの要素`array`テストされて<xref:System.IComparable>検索を開始する前にします。 検索が実装していない要素が発生した場合に例外がスローされます<xref:System.IComparable>します。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 1 つ以上の要素を含む`value`メソッドは、1 つだけの出現回数、および必ずしも 1 つ目のインデックスを返します。  
  
 `null` 参照型; と常に比較できます。そのため、使用する比較`null`例外は生成されません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable>実装を指定された要素を比較する方法を決定する`null`します。  
  
 このメソッドは O (log `n`) 操作、場所`n`は、<xref:System.Array.Length%2A>の`array`。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示しています。<xref:System.Array.BinarySearch%2A>の特定のオブジェクトを検索する、<xref:System.Array>します。  
  
> [!NOTE]
>  配列は、その要素を昇順に並べ替え順序で作成されます。 <xref:System.Array.BinarySearch%2A>メソッドが、配列を昇順で並べ替える必要があります。  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> の型は、<paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> は <see cref="T:System.IComparable" /> インターフェイスを実装しておらず、<see cref="T:System.IComparable" /> インターフェイスを実装していない要素が検索により検出されました。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる並べ替え済みの 1 次元 <see cref="T:System.Array" />。</param>
        <param name="value">検索するオブジェクト。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  または、各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>指定した <see cref="T:System.Collections.IComparer" /> インターフェイスを使用して、1 次元の並べ替え済み配列全体の中から値を検索します。</summary>
        <returns>
          <paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含んだ配列の検索をサポートしていません。 `array` このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、<xref:System.Array>に指定した値が含まれていないメソッドは負の整数を返します。 ビットごとの補数演算子を適用することができます (~、c# で`Not`Visual Basic で) にインデックスを生成するためには、負の結果。 このインデックスが 1 つである場合、配列の上限よりも大きい要素がないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`します。  
  
 比較演算子は、要素の比較方法をカスタマイズします。 たとえば、使用することができます、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>として大文字の文字列検索を実行する比較子。  
  
 場合`comparer`ない`null`、要素の`array`指定して、指定した値と比較されます<xref:System.Collections.IComparer>実装します。 要素`array`によって定義されている並べ替え順序に従って値を増やすことで並べ替える必要があります既に`comparer`、それ以外の結果が正しくない可能性があります。  
  
 場合`comparer`は`null`、比較を使用して、<xref:System.IComparable>指定した値または要素自体によって提供される実装。 要素`array`既にによって定義されている並べ替え順序に従って値を増やすことで並べ替える必要があります、<xref:System.IComparable>実装。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`comparer`は`null`と`value`実装していない、<xref:System.IComparable>インターフェイスの要素`array`テストされて<xref:System.IComparable>検索を開始する前にします。 検索が実装していない要素が発生した場合に例外がスローされます<xref:System.IComparable>します。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 1 つ以上の要素を含む`value`メソッドは、1 つだけの出現回数、および必ずしも 1 つ目のインデックスを返します。  
  
 `null` 参照型; と常に比較できます。そのため、使用する比較`null`例外は生成されません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable>実装を指定された要素を比較する方法を決定する`null`します。  
  
 このメソッドは O (log `n`) 操作、場所`n`は、<xref:System.Array.Length%2A>の`array`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> は <paramref name="array" /> の要素と互換性がない型です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> は <see cref="T:System.IComparable" /> インターフェイスを実装しておらず、<see cref="T:System.IComparable" /> インターフェイスを実装していない要素が検索により検出されました。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる並べ替え済みの 1 次元 <see cref="T:System.Array" />。</param>
        <param name="index">検索範囲の開始位置を示すインデックス。</param>
        <param name="length">検索する範囲の長さ。</param>
        <param name="value">検索するオブジェクト。</param>
        <summary>配列の各要素および指定した値によって実装されている <see cref="T:System.IComparable" /> インターフェイスを使用して、1 次元の並べ替え済み配列の要素範囲の中から値を検索します。</summary>
        <returns>
          <paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含んだ配列の検索をサポートしていません。 `array` このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、<xref:System.Array>に指定した値が含まれていないメソッドは負の整数を返します。 ビットごとの補数演算子を適用することができます (~、c# で`Not`Visual Basic で) にインデックスを生成するためには、負の結果。 このインデックスが 1 つである場合、配列の上限よりも大きい要素がないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`します。  
  
 いずれか`value`のすべての要素または`array`実装する必要があります、<xref:System.IComparable>の比較に使用するインターフェイス。 要素`array`既にによって定義されている並べ替え順序に従って値を増やすことで並べ替える必要があります、<xref:System.IComparable>実装。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`value`実装していない、<xref:System.IComparable>インターフェイスの要素`array`テストされて<xref:System.IComparable>検索を開始する前にします。 検索が実装していない要素が発生した場合に例外がスローされます<xref:System.IComparable>します。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 1 つ以上の要素を含む`value`メソッドは、1 つだけの出現回数、および必ずしも 1 つ目のインデックスを返します。  
  
 `null` 参照型; と常に比較できます。そのため、使用する比較`null`例外は生成されません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable>実装を指定された要素を比較する方法を決定する`null`します。  
  
 このメソッドは O (log `n`) 操作、場所`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  または、<paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  または、<paramref name="value" /> の型に <paramref name="array" /> の要素との互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> は <see cref="T:System.IComparable" /> インターフェイスを実装しておらず、<see cref="T:System.IComparable" /> インターフェイスを実装していない要素が検索により検出されました。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる並べ替え済みの 1 次元 <see cref="T:System.Array" />。</param>
        <param name="index">検索範囲の開始位置を示すインデックス。</param>
        <param name="length">検索する範囲の長さ。</param>
        <param name="value">検索するオブジェクト。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  または、各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>指定した <see cref="T:System.Collections.IComparer" /> インターフェイスを使用して、1 次元の並べ替え済み配列の要素範囲の中から値を検索します。</summary>
        <returns>
          <paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含んだ配列の検索をサポートしていません。 `array` このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、<xref:System.Array>に指定した値が含まれていないメソッドは負の整数を返します。 ビットごとの補数演算子を適用することができます (~、c# で`Not`Visual Basic で) にインデックスを生成するためには、負の結果。 このインデックスが 1 つである場合、配列の上限よりも大きい要素がないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`します。  
  
 比較演算子は、要素の比較方法をカスタマイズします。 たとえば、使用することができます、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>として大文字の文字列検索を実行する比較子。  
  
 場合`comparer`ない`null`、要素の`array`指定して、指定した値と比較されます<xref:System.Collections.IComparer>実装します。 要素`array`によって定義されている並べ替え順序に従って値を増やすことで並べ替える必要があります既に`comparer`、それ以外の結果が正しくない可能性があります。  
  
 場合`comparer`は`null`、比較を使用して、<xref:System.IComparable>指定した値または要素自体によって提供される実装。 要素`array`既にによって定義されている並べ替え順序に従って値を増やすことで並べ替える必要があります、<xref:System.IComparable>実装。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`comparer`は`null`と`value`実装していない、<xref:System.IComparable>インターフェイスの要素`array`テストされて<xref:System.IComparable>検索を開始する前にします。 検索が実装していない要素が発生した場合に例外がスローされます<xref:System.IComparable>します。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 1 つ以上の要素を含む`value`メソッドは、1 つだけの出現回数、および必ずしも 1 つ目のインデックスを返します。  
  
 `null` 参照型; と常に比較できます。そのため、使用する比較`null`を使用する場合に例外を生成しない<xref:System.IComparable>します。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable>実装を指定された要素を比較する方法を決定する`null`します。  
  
 このメソッドは O (log `n`) 操作、場所`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  または、<paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  または、<paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> は <paramref name="array" /> の要素と互換性がない型です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> は <see cref="T:System.IComparable" /> インターフェイスを実装しておらず、<see cref="T:System.IComparable" /> インターフェイスを実装していない要素が検索により検出されました。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する並べ替え済みの 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value">検索するオブジェクト。</param>
        <summary>
          <see cref="T:System.Array" /> の各要素および指定したオブジェクトによって実装されている <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用して、1 次元の並べ替え済み配列全体の中から特定の要素を検索します。</summary>
        <returns>
          <paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含んだ配列の検索をサポートしていません。 `array` このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合`array`に指定した値が含まれていないメソッドは負の整数を返します。 ビットごとの補数演算子を適用することができます (~、c# で`Not`Visual Basic で) にインデックスを生成するためには、負の結果。 このインデックスが配列のサイズに等しい場合は、要素がないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`します。  
  
 `T` 実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスは、比較のために使用します。 要素`array`既にによって定義されている並べ替え順序に従って値を増やすことで並べ替える必要があります、<xref:System.IComparable%601>実装。 それ以外の場合、結果正しく可能性がありますされません。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 1 つ以上の要素を含む`value`メソッドは、1 つだけの出現回数、および必ずしも 1 つ目のインデックスを返します。  
  
 `null` 参照型; と常に比較できます。そのため、使用する比較`null`例外は生成されません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable%601>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable%601>実装を指定された要素を比較する方法を決定する`null`します。  
  
 このメソッドは O (log `n`) 操作、場所`n`は、<xref:System.Array.Length%2A>の`array`。  
  
   
  
## Examples  
 次のコード例に示します、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>ジェネリック メソッドのオーバー ロードと<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ジェネリック メソッドのオーバー ロードします。 文字列の配列は、任意の順序に作成されます。  
  
 配列が表示され、並べ替え、もう一度表示されます。 使用するには、配列を並べ替える必要があります、<xref:System.Array.BinarySearch%2A>メソッド。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%2A>と<xref:System.Array.BinarySearch%2A>Visual Basic、c#、および C++ は、最初の引数の型とジェネリック型パラメーターの型を推論するため、ジェネリック メソッドの呼び出しを非ジェネリックの対応する間に違い探さないです。 使用する場合、 [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ジェネリック メソッドのオーバー ロードが 2 つの文字列を検索するために使用しではない配列および 1 つを 1 つです。 配列との戻り値、<xref:System.Array.BinarySearch%2A>メソッドに渡される、`ShowWhere`ジェネリック メソッドは、それ以外の場合、要素検索文字列が間に、配列を使用した場合、文字列が見つかった場合は、インデックス値を表示します。 インデックスが負の値、配列内の文字列でない場合ため、`ShowWhere`メソッドは、ビットごとの補数 (、~ 演算子が c# および Visual C は、 `Xor`Visual Basic で-1) 検索よりも大きい一覧の最初の要素のインデックスを取得する string します。  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> は、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する並べ替え済みの 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value">検索するオブジェクト。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> の実装。  または、各要素の <see cref="T:System.IComparable`1" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して、1 次元の並べ替え済み配列全体の中から値を検索します。</summary>
        <returns>
          <paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含んだ配列の検索をサポートしていません。 `array` このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、<xref:System.Array>に指定した値が含まれていないメソッドは負の整数を返します。 ビットごとの補数演算子を適用することができます (~、c# で`Not`Visual Basic で) にインデックスを生成するためには、負の結果。 このインデックスが配列のサイズに等しい場合は、要素がないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`します。  
  
 比較演算子は、要素の比較方法をカスタマイズします。 たとえば、使用することができます、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>として大文字の文字列検索を実行する比較子。  
  
 場合`comparer`ない`null`、要素の`array`指定して、指定した値と比較されます<xref:System.Collections.Generic.IComparer%601>ジェネリック インターフェイスの実装。 要素`array`によって定義されている並べ替え順序に従って値を増やすことで並べ替える必要があります既に`comparer`、それ以外の結果が正しくない可能性があります。  
  
 場合`comparer`は`null`、比較を使用して、<xref:System.IComparable%601>ジェネリック インターフェイスの実装によって提供される`T`します。 要素`array`既にによって定義されている並べ替え順序に従って値を増やすことで並べ替える必要があります、<xref:System.IComparable%601>実装。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`comparer`は`null`と`value`を実装しません、<xref:System.IComparable%601>ジェネリック インターフェイス、要素の`array`テストされて<xref:System.IComparable%601>検索を開始する前にします。 検索が実装していない要素が発生した場合に例外がスローされます<xref:System.IComparable%601>します。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 1 つ以上の要素を含む`value`メソッドは、1 つだけの出現回数、および必ずしも 1 つ目のインデックスを返します。  
  
 `null` 参照型; と常に比較できます。そのため、使用する比較`null`例外は生成されません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable%601>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable%601>実装を指定された要素を比較する方法を決定する`null`します。  
  
 このメソッドは O (log `n`) 操作、場所`n`は、<xref:System.Array.Length%2A>の`array`。  
  
   
  
## Examples  
 次の例で、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードと<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードします。  
  
 コード例では、という名前の文字列の代替の比較子を定義します。 `ReverseCompare`、実装、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual c で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッドは、文字列は、低-高のではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 配列が表示され、並べ替え、もう一度表示されます。 使用するには、配列を並べ替える必要があります、<xref:System.Array.BinarySearch%2A>メソッド。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>と<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>Visual Basic、c#、および C++ は、最初の引数の型とジェネリック型パラメーターの型を推論するため、ジェネリック メソッドの呼び出しを非ジェネリックの対応する間に違い探さないです。 使用する場合、 [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードが 2 つの文字列を検索するために使用しではない配列および 1 つを 1 つです。 配列との戻り値、<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>メソッドに渡される、`ShowWhere`ジェネリック メソッドは、それ以外の場合、要素検索文字列が間に、配列を使用した場合、文字列が見つかった場合は、インデックス値を表示します。 インデックスが負の値、文字列は、n がない場合、配列のため、`ShowWhere`メソッドは、ビットごとの補数 (、~ c# および Visual C は、演算子`Xor`Visual Basic で-1) 検索からよりも大きい一覧の最初の要素のインデックスを取得するにはng です。  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> は <paramref name="array" /> の要素と互換性がない型です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> は <see langword="null" /> であり、<paramref name="T" /> は <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する並べ替え済みの 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="index">検索範囲の開始位置を示すインデックス。</param>
        <param name="length">検索する範囲の長さ。</param>
        <param name="value">検索するオブジェクト。</param>
        <summary>
          <see cref="T:System.Array" /> の各要素および指定した値によって実装されている <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用して、1 次元の並べ替え済み配列の要素範囲の中から値を検索します。</summary>
        <returns>
          <paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含んだ配列の検索をサポートしていません。 `array` このメソッドを呼び出す前に並べ替える必要があります。  
  
 配列に指定した値が含まれていない場合は、負の整数を返します。 ビットごとの補数演算子を適用することができます (~、c# で`Not`Visual Basic で) にインデックスを生成するためには、負の結果。 このインデックスが配列のサイズに等しい場合は、要素がないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`します。  
  
 `T` 実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスは、比較のために使用します。 要素`array`既にによって定義されている並べ替え順序に従って値を増やすことで並べ替える必要があります、<xref:System.IComparable%601>実装。 それ以外の場合、結果正しく可能性がありますされません。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 1 つ以上の要素を含む`value`メソッドは、1 つだけの出現回数、および必ずしも 1 つ目のインデックスを返します。  
  
 `null` 参照型; と常に比較できます。そのため、使用する比較`null`例外は生成されません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable%601>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable%601>実装を指定された要素を比較する方法を決定する`null`します。  
  
 このメソッドは O (log `n`) 操作、場所`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  または、<paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  または、<paramref name="value" /> の型に <paramref name="array" /> の要素との互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> は、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する並べ替え済みの 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="index">検索範囲の開始位置を示すインデックス。</param>
        <param name="length">検索する範囲の長さ。</param>
        <param name="value">検索するオブジェクト。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> の実装。  または、各要素の <see cref="T:System.IComparable`1" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して、1 次元の並べ替え済み配列の要素範囲の中から値を検索します。</summary>
        <returns>
          <paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。 <paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス +1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含んだ配列の検索をサポートしていません。 `array` このメソッドを呼び出す前に並べ替える必要があります。  
  
 配列に指定した値が含まれていない場合は、負の整数を返します。 ビットごとの補数演算子を適用することができます (~、c# で`Not`Visual Basic で) にインデックスを生成するためには、負の結果。 このインデックスが配列のサイズに等しい場合は、要素がないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`します。  
  
 比較演算子は、要素の比較方法をカスタマイズします。 たとえば、使用することができます、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>として大文字の文字列検索を実行する比較子。  
  
 場合`comparer`ない`null`、要素の`array`指定して、指定した値と比較されます<xref:System.Collections.Generic.IComparer%601>ジェネリック インターフェイスの実装。 要素`array`によって定義されている並べ替え順序に従って値を増やすことで並べ替える必要があります既に`comparer`、それ以外の結果が正しくない可能性があります。  
  
 場合`comparer`は`null`、比較を使用して、<xref:System.IComparable%601>ジェネリック インターフェイスの実装の種類に対して指定した`T`します。 要素`array`既にによって定義されている並べ替え順序に従って値を増やすことで並べ替える必要があります、<xref:System.IComparable%601>実装。 それ以外の場合、結果正しく可能性がありますされません。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 1 つ以上の要素を含む`value`メソッドは、1 つだけの出現回数、および必ずしも 1 つ目のインデックスを返します。  
  
 `null` 参照型; と常に比較できます。そのため、使用する比較`null`を使用する場合に例外を生成しない<xref:System.IComparable%601>します。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable%601>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable%601>実装を指定された要素を比較する方法を決定する`null`します。  
  
 このメソッドは O (log `n`) 操作、場所`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  または、<paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  または、<paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> は <paramref name="array" /> の要素と互換性がない型です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> は <see langword="null" /> であり、<paramref name="T" /> は <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要素を削除する必要がある配列。</param>
        <param name="index">削除する要素の範囲の開始インデックス。</param>
        <param name="length">削除する要素の数。</param>
        <summary>配列内にある要素の範囲を、各要素の型の既定値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、配列内の各要素を要素型の既定値にリセットします。 参照型の要素を設定 (を含む<xref:System.String>要素) を`null`、および値型の要素を次の表に示すように既定値に設定します。  
  
|型|[値]|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|すべての整数と浮動小数点数値型|0 (ゼロ)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|他の値型|型のフィールドの既定値|  
  
 範囲では、多次元配列で要素のラップ行から行をクリアします。  
  
 このメソッドはのみ、要素の値をクリアします要素自体は削除されません。 配列が固定サイズです。そのため、要素を追加または削除することはできません。  
  
 このメソッドは O (`n`) 操作、`n`は`length`します。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.Clear%2A>メソッドを 1 次元、2 次元、および 3 次元の配列内の整数値をリセットします。  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 次の例では、定義、`TimeZoneTime`を含む構造を<xref:System.TimeZoneInfo>フィールドと<xref:System.DateTimeOffset>フィールド。 呼び出して、<xref:System.Array.Clear%2A>メソッドの 2 つの要素の配列内の 1 つの要素を消去する`TimeZoneTime`値。 メソッドの既定値に消去された要素の値を設定する、<xref:System.TimeZoneInfo>となるオブジェクト`null`との既定値、<xref:System.DateTimeOffset>となるオブジェクト<xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>します。  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  または、<paramref name="length" /> が 0 未満です。  または、<paramref name="index" /> と <paramref name="length" /> の合計が <paramref name="array" /> のサイズを超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Array" /> の簡易コピーを作成します。</summary>
        <returns>
          <see cref="T:System.Array" /> の簡易コピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 簡易コピーを<xref:System.Array>の要素のみをコピー、<xref:System.Array>参照型または値型ですが、参照先のオブジェクトはコピーしないかどうか。 新しい参照<xref:System.Array>同じオブジェクトを参照元を<xref:System.Array> をポイントします。  
  
 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が参照する直接的または間接的にすべてコピーします。  
  
 クローンは、同じ<xref:System.Type>元として<xref:System.Array>します。  
  
 このメソッドは O (`n`) 操作、`n`は<xref:System.Array.Length%2A>します。  
  
   
  
## Examples  
 次のコード例のクローンを<xref:System.Globalization.CultureInfo?displayProperty=nameWithType>配列し、は簡易コピーの動作を示します。  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">コピー操作の開始位置となる <c>sourceArray</c> 内のインデックスを表す 32 ビット整数。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">格納を開始する <c>destinationArray</c> 内のインデックスを表す 32 ビット整数。</param>
        <param name="length">コピーする要素の数を表す 32 ビット整数。</param>
        <summary>指定したコピー元インデックスを開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、指定したコピー先インデックスを開始位置として他の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。  コピーが完全に成功しない限り、変更は一切適用されません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`と`destinationArray`パラメーターは、同じ次元数をいる必要があります。  `sourceArray`型と同じである必要がありますまたはから派生した、`destinationArray`種類です。 それ以外の場合、<xref:System.ArrayTypeMismatchException>がスローされます。  異なり<xref:System.Array.Copy%2A>、<xref:System.Array.ConstrainedCopy%2A>いずれかの操作を実行する前に、配列型の互換性を確認します。  
  
 多次元配列間でコピーする場合、配列のように動作長い 1 次元配列では、場所の行 (または列) が概念的にレイアウトされるエンド ツー エンドです。 たとえば、配列を持つ 3 つの行 (または列) 4 つの要素の配列の先頭から、各コピーの 6 つの要素の場合は最初の行 (または列) の 4 つすべての要素の最初の 2 つの要素、2 番目の行 (または列) がコピーします。 3 番目の行 (または列) の 2 番目の要素からコピーを開始する`sourceIndex`さらに 2 つの 2 番目の行 (または列) の長さを加算結果の最初の行 (または列) の上限があります。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作はまるでの元の値`sourceArray`する前に一時的な場所に保持された`destinationArray`が上書きされます。  
  
 [C++]  
  
 このメソッドは、標準の C/C++ 関数`memmove`ではなく、`memcpy`します。  
  
 配列には、参照型の配列または値型の配列を指定できます。  場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列である<xref:System.Object>、シャロー コピーを実行します。 簡易コピーを<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を格納している<xref:System.Array>します。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が参照する直接的または間接的にすべてコピーします。  
  
 このメソッドが、コピー中に例外をスローした場合、`destinationArray`変わりません。 そのため、<xref:System.Array.ConstrainedCopy%2A>制約された実行領域内で使用できます (<xref:System.Runtime.ConstrainedExecution.Cer>)。  
  
 このメソッドは O (`n`) 操作、`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> は <see langword="null" />です。  または、<paramref name="destinationArray" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> はどちらも同じでもなく、<paramref name="destinationArray" /> 型から派生したものでもありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> は <paramref name="sourceArray" /> の最初の次元の下限を下回っています。  または、<paramref name="destinationIndex" /> は <paramref name="destinationArray" /> の最初の次元の下限を下回っています。  または、<paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> は <paramref name="sourceIndex" /> から最後の <paramref name="sourceArray" /> までの要素の数を超えています。  または、<paramref name="length" /> は <paramref name="destinationIndex" /> から最後の <paramref name="destinationArray" /> までの要素の数を超えています。</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">元の配列要素の型。</typeparam>
        <typeparam name="TOutput">変換後の配列要素の型。</typeparam>
        <param name="array">変換元となる、インデックス番号が 0 から始まる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="converter">各要素の型を変換するための <see cref="T:System.Converter`2" />。</param>
        <summary>ある型の配列を別の型の配列に変換します。</summary>
        <returns>要素の型を変換した後の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602>オブジェクトを対象の型に変換するメソッドをデリゲートです。  要素`array`に個別に渡される、 <xref:System.Converter%602>、新しい配列に変換された要素が保存されます。  
  
 ソース`array`は変更されません。  
  
 このメソッドは O (`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例は、という名前のメソッドを定義します。`PointFToPoint`に変換する、<xref:System.Drawing.PointF>構造体を、<xref:System.Drawing.Point>構造体。 配列を作成し<xref:System.Drawing.PointF>構造体を作成、`Converter<PointF, Point>`デリゲート (`Converter(Of PointF, Point)` Visual Basic で) を表す、`PointFToPoint`メソッドに、デリゲートを渡します、<xref:System.Array.ConvertAll%2A>メソッド。 <xref:System.Array.ConvertAll%2A>メソッドは、入力リストの各要素に渡します、`PointFToPoint`メソッドは、の新しいリストに変換された要素と<xref:System.Drawing.Point>構造体。 両方の一覧が表示されます。  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。  または、<paramref name="converter" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>一方の <see cref="T:System.Array" /> の要素範囲を他方の <see cref="T:System.Array" /> にコピーし、必要に応じて型キャストとボックス化を実行します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="length">コピーする要素の数を表す 32 ビット整数。</param>
        <summary>最初の要素を開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、最初の要素を開始位置として他の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。 長さは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`と`destinationArray`パラメーターは、同じ次元数をいる必要があります。 さらに、`destinationArray`次元されて既にする必要があり、十分な数の要素がコピーされたデータを格納する必要があります。  
  
 多次元配列間でコピーする場合、配列のように動作長い 1 次元配列では、場所の行 (または列) が概念的にレイアウトされるエンド ツー エンドです。 たとえば、配列を持つ 3 つの行 (または列) 4 つの要素の配列の先頭から、各コピーの 6 つの要素の場合は最初の行 (または列) の 4 つすべての要素の最初の 2 つの要素、2 番目の行 (または列) がコピーします。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作はまるでの元の値`sourceArray`する前に一時的な場所に保持された`destinationArray`が上書きされます。  
  
 [C++]  
  
 このメソッドは、標準の C/C++ 関数`memmove`ではなく、`memcpy`します。  
  
 配列には、参照型の配列または値型の配列を指定できます。 型のダウン キャストを実行すると、必要に応じて。  
  
-   参照型の配列から値型の配列にコピーするときは、各要素がボックス化解除し、コピーします。 参照型の配列に値型の配列からコピーする場合は、各要素がボックス化され、コピーされます。  
  
-   参照型または値型の配列からコピーするとき、 <xref:System.Object> 、配列、<xref:System.Object>がそれぞれの値または参照を保持するために作成され、コピーします。 コピーするとき、<xref:System.Object>可能であれば、参照型または値型の配列と、割り当て先の配列は、<xref:System.InvalidCastException>がスローされます。  
  
-   場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列である<xref:System.Object>、シャロー コピーを実行します。 簡易コピーを<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を格納している<xref:System.Array>します。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が参照する直接的または間接的にすべてコピーします。  
  
 <xref:System.ArrayTypeMismatchException>が、互換性のない型が配列である場合にスローされます。 型の互換性の定義は次のとおりです。  
  
-   型がそれ自体との互換性です。  
  
-   値型と互換性が<xref:System.Object>とその値の型によって実装されたインターフェイス型を使用します。 値型では、直接そのインターフェイスを実装している場合にのみ、インターフェイスに接続されていると見なされます。 接続されていない型に互換性がありません。  
  
-   2 つの組み込みの (定義済みの) 値の型は互換性のある拡大変換を元の型から変換先の型へのコピーがある場合です。 拡大変換では縮小変換情報が失われることができますが、については、失われます。 たとえばは拡大変換は、32 ビット符号付き整数を 64 ビット符号付き整数に変換して、縮小変換は、64 ビット符号付き整数に変換する 32 ビット符号付き整数。 変換の詳細については、次を参照してください。<xref:System.Convert>します。  
  
-   非組み込みの (ユーザー定義) の値型は、自分自身とのみ互換性。  
  
-   列挙型への暗黙的な変換がある<xref:System.Enum>とその基になる型。  
  
 場合のすべての要素`sourceArray`キャスト (たとえば、派生クラスを基底クラスまたはオブジェクトへのインターフェイスから) が必要ですし、1 つまたは複数の要素に対応する型にキャストできない`destinationArray`、<xref:System.InvalidCastException>がスローされます。  
  
 このメソッドの状態のコピー中に例外をスローする場合`destinationArray`が定義されていません。  
  
 このメソッドは O (`n`) 操作、`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> は <see langword="null" />です。  または、<paramref name="destinationArray" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> の型は互換性がありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> は <paramref name="sourceArray" /> にある要素の数を超えています。  または、<paramref name="length" /> は <paramref name="destinationArray" /> にある要素の数を超えています。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="length">コピーする要素の数を表す 64 ビット整数。 この整数は 0 から <see cref="F:System.Int32.MaxValue" /> (この値を含む) の間である必要があります。</param>
        <summary>最初の要素を開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、最初の要素を開始位置として他の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。 長さは 64 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`と`destinationArray`パラメーターは、同じ次元数をいる必要があります。 さらに、`destinationArray`次元されて既にする必要があり、十分な数の要素がコピーされたデータを格納する必要があります。  
  
 多次元配列間でコピーする場合、配列のように動作長い 1 次元配列では、場所の行 (または列) が概念的にレイアウトされるエンド ツー エンドです。 たとえば、配列を持つ 3 つの行 (または列) 4 つの要素の配列の先頭から、各コピーの 6 つの要素の場合は最初の行 (または列) の 4 つすべての要素の最初の 2 つの要素、2 番目の行 (または列) がコピーします。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作はまるでの元の値`sourceArray`する前に一時的な場所に保持された`destinationArray`が上書きされます。  
  
 [C++]  
  
 このメソッドは、標準の C/C++ 関数`memmove`ではなく、`memcpy`します。  
  
 配列には、参照型の配列または値型の配列を指定できます。 型のダウン キャストを実行すると、必要に応じて。  
  
-   参照型の配列から値型の配列にコピーするときは、各要素がボックス化解除し、コピーします。 参照型の配列に値型の配列からコピーする場合は、各要素がボックス化され、コピーされます。  
  
-   参照型または値型の配列からコピーするとき、 <xref:System.Object> 、配列、<xref:System.Object>がそれぞれの値または参照を保持するために作成され、コピーします。 コピーするとき、<xref:System.Object>可能であれば、参照型または値型の配列と、割り当て先の配列は、<xref:System.InvalidCastException>がスローされます。  
  
-   場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列である<xref:System.Object>、シャロー コピーを実行します。 簡易コピーを<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を格納している<xref:System.Array>します。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が参照する直接的または間接的にすべてコピーします。  
  
 <xref:System.ArrayTypeMismatchException>が、互換性のない型が配列である場合にスローされます。 型の互換性の定義は次のとおりです。  
  
-   型がそれ自体との互換性です。  
  
-   値型と互換性が<xref:System.Object>とその値の型によって実装されたインターフェイス型を使用します。 値型では、直接そのインターフェイスを実装している場合にのみ、インターフェイスに接続されていると見なされます。 接続されていない型に互換性がありません。  
  
-   2 つの組み込みの (定義済みの) 値の型は互換性のある拡大変換を元の型から変換先の型へのコピーがある場合です。 拡大変換では縮小変換情報が失われることができますが、については、失われます。 たとえばは拡大変換は、32 ビット符号付き整数を 64 ビット符号付き整数に変換して、縮小変換は、64 ビット符号付き整数に変換する 32 ビット符号付き整数。 変換の詳細については、次を参照してください。<xref:System.Convert>します。  
  
-   非組み込みの (ユーザー定義) の値型は、自分自身とのみ互換性。  
  
-   列挙型への暗黙的な変換がある<xref:System.Enum>とその基になる型。  
  
 場合のすべての要素`sourceArray`キャスト (たとえば、派生クラスを基底クラスまたはオブジェクトへのインターフェイスから) が必要ですし、1 つまたは複数の要素に対応する型にキャストできない`destinationArray`、<xref:System.InvalidCastException>がスローされます。  
  
 このメソッドの状態のコピー中に例外をスローする場合`destinationArray`が定義されていません。  
  
 このメソッドは O (`n`) 操作、`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> は <see langword="null" />です。  または、<paramref name="destinationArray" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> の型は互換性がありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> が 0 未満であるか、または <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> は <paramref name="sourceArray" /> にある要素の数を超えています。  または、<paramref name="length" /> は <paramref name="destinationArray" /> にある要素の数を超えています。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">コピー操作の開始位置となる <c>sourceArray</c> 内のインデックスを表す 32 ビット整数。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">格納を開始する <c>destinationArray</c> 内のインデックスを表す 32 ビット整数。</param>
        <param name="length">コピーする要素の数を表す 32 ビット整数。</param>
        <summary>指定したコピー元インデックスを開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、指定したコピー先インデックスを開始位置として他の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。 長さとインデックスは、32 ビット整数として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`と`destinationArray`パラメーターは、同じ次元数をいる必要があります。 さらに、`destinationArray`次元されて既にする必要があり、十分な数の要素から開始する必要があります、`destinationIndex`コピーされたデータに対応する位置。  
  
 多次元配列間でコピーする場合、配列のように動作長い 1 次元配列では、場所の行 (または列) が概念的にレイアウトされるエンド ツー エンドです。 たとえば、配列を持つ 3 つの行 (または列) 4 つの要素の配列の先頭から、各コピーの 6 つの要素の場合は最初の行 (または列) の 4 つすべての要素の最初の 2 つの要素、2 番目の行 (または列) がコピーします。 3 番目の行 (または列) の 2 番目の要素からコピーを開始する`sourceIndex`さらに 2 つの 2 番目の行 (または列) の長さを加算結果の最初の行 (または列) の上限があります。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作はまるでの元の値`sourceArray`する前に一時的な場所に保持された`destinationArray`が上書きされます。  
  
 [C++]  
  
 このメソッドは、標準の C/C++ 関数`memmove`ではなく、`memcpy`します。  
  
 配列には、参照型の配列または値型の配列を指定できます。 型のダウン キャストを実行すると、必要に応じて。  
  
-   参照型の配列から値型の配列にコピーするときは、各要素がボックス化解除し、コピーします。 参照型の配列に値型の配列からコピーする場合は、各要素がボックス化され、コピーされます。  
  
-   参照型または値型の配列からコピーするとき、 <xref:System.Object> 、配列、<xref:System.Object>がそれぞれの値または参照を保持するために作成され、コピーします。 コピーするとき、<xref:System.Object>可能であれば、参照型または値型の配列と、割り当て先の配列は、<xref:System.InvalidCastException>がスローされます。  
  
-   場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列である<xref:System.Object>、シャロー コピーを実行します。 簡易コピーを<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を格納している<xref:System.Array>します。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が参照する直接的または間接的にすべてコピーします。  
  
 <xref:System.ArrayTypeMismatchException>が、互換性のない型が配列である場合にスローされます。 型の互換性の定義は次のとおりです。  
  
-   型がそれ自体との互換性です。  
  
-   値型と互換性が<xref:System.Object>とその値の型によって実装されたインターフェイス型を使用します。 値型では、直接そのインターフェイスを実装している場合にのみ、インターフェイスに接続されていると見なされます。 接続されていない型に互換性がありません。  
  
-   2 つの組み込みの (定義済みの) 値の型は互換性のある拡大変換を元の型から変換先の型へのコピーがある場合です。 拡大変換では縮小変換情報が失われることができますが、については、失われます。 たとえばは拡大変換は、32 ビット符号付き整数を 64 ビット符号付き整数に変換して、縮小変換は、64 ビット符号付き整数に変換する 32 ビット符号付き整数。 変換の詳細については、次を参照してください。<xref:System.Convert>します。  
  
-   非組み込みの (ユーザー定義) の値型は、自分自身とのみ互換性。  
  
-   列挙型への暗黙的な変換がある<xref:System.Enum>とその基になる型。  
  
 場合のすべての要素`sourceArray`キャスト (たとえば、派生クラスを基底クラスまたはオブジェクトへのインターフェイスから) が必要ですし、1 つまたは複数の要素に対応する型にキャストできない`destinationArray`、<xref:System.InvalidCastException>がスローされます。  
  
 このメソッドの状態のコピー中に例外をスローする場合`destinationArray`が定義されていません。  
  
 このメソッドは O (`n`) 操作、`n`は`length`します。  
  
   
  
## Examples  
 次のコード例は、いずれかからコピーする方法を示しています。<xref:System.Array>型の<xref:System.Object>間<xref:System.Array>整数型。  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> は <see langword="null" />です。  または、<paramref name="destinationArray" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> の型は互換性がありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> は <paramref name="sourceArray" /> の最初の次元の下限を下回っています。  または、<paramref name="destinationIndex" /> は <paramref name="destinationArray" /> の最初の次元の下限を下回っています。  または、<paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> は <paramref name="sourceIndex" /> から最後の <paramref name="sourceArray" /> までの要素の数を超えています。  または、<paramref name="length" /> は <paramref name="destinationIndex" /> から最後の <paramref name="destinationArray" /> までの要素の数を超えています。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">コピー操作の開始位置となる <c>sourceArray</c> 内のインデックスを表す 64 ビット整数。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">格納を開始する <c>destinationArray</c> 内のインデックスを表す 64 ビット整数。</param>
        <param name="length">コピーする要素の数を表す 64 ビット整数。 この整数は 0 から <see cref="F:System.Int32.MaxValue" /> (この値を含む) の間である必要があります。</param>
        <summary>指定したコピー元インデックスを開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、指定したコピー先インデックスを開始位置として他の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。 長さとインデックスは、64 ビット整数として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`と`destinationArray`パラメーターは、同じ次元数をいる必要があります。 さらに、`destinationArray`次元されて既にする必要があり、十分な数の要素から開始する必要があります、`destinationIndex`コピーされたデータに対応する位置。  
  
 多次元配列間でコピーする場合、配列のように動作長い 1 次元配列では、場所の行 (または列) が概念的にレイアウトされるエンド ツー エンドです。 たとえば、配列を持つ 3 つの行 (または列) 4 つの要素の配列の先頭から、各コピーの 6 つの要素の場合は最初の行 (または列) の 4 つすべての要素の最初の 2 つの要素、2 番目の行 (または列) がコピーします。 3 番目の行 (または列) の 2 番目の要素からコピーを開始する`sourceIndex`さらに 2 つの 2 番目の行 (または列) の長さを加算結果の最初の行 (または列) の上限があります。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作はまるでの元の値`sourceArray`する前に一時的な場所に保持された`destinationArray`が上書きされます。  
  
 [C++]  
  
 このメソッドは、標準の C/C++ 関数`memmove`ではなく、`memcpy`します。  
  
 配列には、参照型の配列または値型の配列を指定できます。 型のダウン キャストを実行すると、必要に応じて。  
  
-   参照型の配列から値型の配列にコピーするときは、各要素がボックス化解除し、コピーします。 参照型の配列に値型の配列からコピーする場合は、各要素がボックス化され、コピーされます。  
  
-   参照型または値型の配列からコピーするとき、 <xref:System.Object> 、配列、<xref:System.Object>がそれぞれの値または参照を保持するために作成され、コピーします。 コピーするとき、<xref:System.Object>可能であれば、参照型または値型の配列と、割り当て先の配列は、<xref:System.InvalidCastException>がスローされます。  
  
-   場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列である<xref:System.Object>、シャロー コピーを実行します。 簡易コピーを<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を格納している<xref:System.Array>します。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が参照する直接的または間接的にすべてコピーします。  
  
 <xref:System.ArrayTypeMismatchException>が、互換性のない型が配列である場合にスローされます。 型の互換性の定義は次のとおりです。  
  
-   型がそれ自体との互換性です。  
  
-   値型と互換性が<xref:System.Object>とその値の型によって実装されたインターフェイス型を使用します。 値型では、直接そのインターフェイスを実装している場合にのみ、インターフェイスに接続されていると見なされます。 接続されていない型に互換性がありません。  
  
-   2 つの組み込みの (定義済みの) 値の型は互換性のある拡大変換を元の型から変換先の型へのコピーがある場合です。 拡大変換では縮小変換情報が失われることができますが、については、失われます。 たとえばは拡大変換は、32 ビット符号付き整数を 64 ビット符号付き整数に変換して、縮小変換は、64 ビット符号付き整数に変換する 32 ビット符号付き整数。 変換の詳細については、次を参照してください。<xref:System.Convert>します。  
  
-   非組み込みの (ユーザー定義) の値型は、自分自身とのみ互換性。  
  
-   列挙型への暗黙的な変換がある<xref:System.Enum>とその基になる型。  
  
 場合のすべての要素`sourceArray`キャスト (たとえば、派生クラスを基底クラスまたはオブジェクトへのインターフェイスから) が必要ですし、1 つまたは複数の要素に対応する型にキャストできない`destinationArray`、<xref:System.InvalidCastException>がスローされます。  
  
 このメソッドの状態のコピー中に例外をスローする場合`destinationArray`が定義されていません。  
  
 このメソッドは O (`n`) 操作、`n`は`length`します。  
  
   
  
## Examples  
 次のコード例は、いずれかからコピーする方法を示しています。<xref:System.Array>型の<xref:System.Object>間<xref:System.Array>整数型。  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> は <see langword="null" />です。  または、<paramref name="destinationArray" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> の型は互換性がありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> が、<paramref name="sourceArray" /> の有効なインデックスの範囲外です。  または、<paramref name="destinationIndex" /> が <paramref name="destinationArray" /> の有効なインデックスの範囲外です。  または、<paramref name="length" /> が 0 未満であるか、または <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> は <paramref name="sourceIndex" /> から最後の <paramref name="sourceArray" /> までの要素の数を超えています。  または、<paramref name="length" /> は <paramref name="destinationIndex" /> から最後の <paramref name="destinationArray" /> までの要素の数を超えています。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の 1 次元配列のすべての要素を、指定した 1 次元配列にコピーします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">現在の配列からコピーされる要素のコピー先である 1 次元配列。</param>
        <param name="index">コピーを開始する <c>array</c> のインデックスを表す 32 ビット整数。</param>
        <summary>現在の 1 次元配列のすべての要素を、指定したコピー先配列インデックスで開始する指定の 1 次元配列にコピーします。 インデックスは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在の配列インスタンスのすべての要素をコピー、`array`コピー先の配列、インデックスから始まります`index`します。 `array`コピー先の配列の寸法されて既にする必要がありますや十分な数の要素をコピーした要素に対応する必要があります。 そうしないと、例外がスローされます。  
  
 このメソッドは、サポート、<xref:System.Collections.ICollection?displayProperty=nameWithType>インターフェイス。 実装する場合<xref:System.Collections.ICollection?displayProperty=nameWithType>を使用して、明示的に必要な<xref:System.Array.Copy%2A>余分な間接参照を回避するためにします。  
  
 このメソッドの状態のコピー中に例外をスローする場合`array`が定義されていません。  
  
 このメソッドは O (`n`) 操作、`n`は<xref:System.Array.Length%2A>します。簡易コピーのみを実行します。  
  
   
  
## Examples  
 次のコード例をコピーする方法を示しています、<xref:System.Array>間<xref:System.Array>します。  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 次のコード例をコピーする方法を示しています、<xref:System.Array>間<xref:System.Array>で下限が 0 以外の値。 なおソース全体<xref:System.Array>コピーすると、ターゲットの既存の要素を上書きする空の要素を含む<xref:System.Array>します。  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> が多次元です。  または、コピー元配列の要素数が、コピー先 <paramref name="array" /> の <paramref name="index" /> から末尾までの使用可能な要素数を超えています。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">コピー元の <see cref="T:System.Array" /> の型をコピー先の <paramref name="array" /> の型に自動的にキャストすることはできません。</exception>
        <exception cref="T:System.RankException">ソース配列が多次元配列です。</exception>
        <exception cref="T:System.InvalidCastException">コピー元 <see cref="T:System.Array" /> の中の少なくとも 1 つの要素を、コピー先 <paramref name="array" /> の型にキャストすることができません。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array">現在の配列からコピーされる要素のコピー先である 1 次元配列。</param>
        <param name="index">コピーを開始する <c>array</c> のインデックスを表す 64 ビット整数。</param>
        <summary>現在の 1 次元配列のすべての要素を、指定したコピー先配列インデックスで開始する指定の 1 次元配列にコピーします。 このインデックスは 64 ビット整数値として指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在の配列インスタンスのすべての要素をコピー、`array`コピー先の配列、インデックスから始まります`index`します。 `array`コピー先の配列の寸法されて既にする必要がありますや十分な数の要素をコピーした要素に対応する必要があります。 そうしないと、例外がスローされます。  
  
 このメソッドは、サポート、<xref:System.Collections.ICollection?displayProperty=nameWithType>インターフェイス。 実装する場合<xref:System.Collections.ICollection?displayProperty=nameWithType>を使用して、明示的に必要な<xref:System.Array.Copy%2A>余分な間接参照を回避するためにします。  
  
 このメソッドの状態のコピー中に例外をスローする場合`array`が定義されていません。  
  
 このメソッドは O (`n`) 操作、`n`は<xref:System.Array.Length%2A>します。簡易コピーのみを実行します。  
  
   
  
## Examples  
 次のコード例をコピーする方法を示しています、<xref:System.Array>間<xref:System.Array>します。  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 次のコード例をコピーする方法を示しています、<xref:System.Array>間<xref:System.Array>で下限が 0 以外の値。 なおソース全体<xref:System.Array>コピーすると、ターゲットの既存の要素を上書きする空の要素を含む<xref:System.Array>します。  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> が多次元です。  または、コピー元配列の要素数が、コピー先 <paramref name="array" /> の <paramref name="index" /> から末尾までの使用可能な要素数を超えています。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">コピー元の <see cref="T:System.Array" /> の型をコピー先の <paramref name="array" /> の型に自動的にキャストすることはできません。</exception>
        <exception cref="T:System.RankException">コピー元の <see cref="T:System.Array" /> が多次元です。</exception>
        <exception cref="T:System.InvalidCastException">コピー元 <see cref="T:System.Array" /> の中の少なくとも 1 つの要素を、コピー先 <paramref name="array" /> の型にキャストすることができません。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="length">作成する <see cref="T:System.Array" /> のサイズ。</param>
        <summary>
          <see cref="T:System.Type" /> と長さを指定して、0 から始まるインデックス番号を持つ 1 次元の <see cref="T:System.Array" /> を作成します。</summary>
        <returns>長さを指定した、0 から始まるインデックス番号を使用する指定した <see cref="T:System.Type" /> の新しい 1 次元の <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>の遅延バインディング アクセスを許可するように、パブリック コンス トラクターではなく、メソッド。  
  
 参照型の要素に初期化されます`null`します。 値型の要素がゼロに初期化されます。  
  
 このメソッドは O (`n`) 操作、`n`は`length`します。  
  
   
  
## Examples  
 次のコード例は、作成し、1 次元を初期化する方法を示しています。<xref:System.Array>します。  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  または、<paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="lengths">作成する <see cref="T:System.Array" /> の各次元のサイズを表す 32 ビット整数の配列。</param>
        <summary>
          <see cref="T:System.Array" /> と次元の長さを指定して、0 から始まるインデックス番号を持つ多次元の <see cref="T:System.Type" /> を作成します。 次元の長さは、32 ビット整数の配列で指定します。</summary>
        <returns>各次元が指定した長さで、インデックス番号が 0 から始まる、指定した <see cref="T:System.Array" /> の新しい多次元 <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>の遅延バインディング アクセスを許可するように、パブリック コンス トラクターではなく、メソッド。  
  
 要素の数、`lengths`配列は、新しいディメンションの数に一致する必要があります<xref:System.Array>します。 各要素、`lengths`配列は、新しい対応する次元の長さを指定する必要があります<xref:System.Array>します。  
  
 参照型の要素に初期化されます`null`します。 値型の要素がゼロに初期化されます。  
  
 このメソッドは O (`n`) 操作、場所`n`のすべての値の積である`lengths`します。  
  
   
  
## Examples  
 次のコード例は、作成して、多次元を初期化する方法を示しています。<xref:System.Array>します。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" />です。  または、<paramref name="lengths" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。  または、<paramref name="lengths" /> 配列に含まれる要素が 1 つ未満です。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  または、<paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lengths" /> 内の値が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="lengths">作成する <see cref="T:System.Array" /> の各次元のサイズを表す 64 ビット整数の配列。 配列内の各整数はゼロから <see cref="F:System.Int32.MaxValue" /> までの値であることが必要です。</param>
        <summary>
          <see cref="T:System.Array" /> と次元の長さを指定して、0 から始まるインデックス番号を持つ多次元の <see cref="T:System.Type" /> を作成します。 次元の長さは、64 ビット整数の配列で指定します。</summary>
        <returns>各次元が指定した長さで、インデックス番号が 0 から始まる、指定した <see cref="T:System.Array" /> の新しい多次元 <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>の遅延バインディング アクセスを許可するように、パブリック コンス トラクターではなく、メソッド。  
  
 要素の数、`lengths`配列は、新しいディメンションの数に一致する必要があります<xref:System.Array>します。 各要素、`lengths`配列は、新しい対応する次元の長さを指定する必要があります<xref:System.Array>します。  
  
 参照型の要素に初期化されます`null`します。 値型の要素がゼロに初期化されます。  
  
 このメソッドは O (`n`) 操作、場所`n`のすべての値の積である`lengths`します。  
  
   
  
## Examples  
 次のコード例は、作成して、多次元を初期化する方法を示しています。<xref:System.Array>します。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" />です。  または、<paramref name="lengths" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。  または、<paramref name="lengths" /> 配列に含まれる要素が 1 つ未満です。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  または、<paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lengths" /> 内のいずれかの値が 0 未満の値か、<see cref="F:System.Int32.MaxValue" /> より大きい値です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="length1">作成する <see cref="T:System.Array" /> の最初の次元のサイズ。</param>
        <param name="length2">作成する <see cref="T:System.Array" /> の 2 番目の次元のサイズ。</param>
        <summary>
          <see cref="T:System.Type" /> と次元の長さを指定して、0 から始まるインデックス番号を持つ 2 次元の <see cref="T:System.Array" /> を作成します。</summary>
        <returns>指定した <see cref="T:System.Type" /> の、次元ごとに指定した長さの、0 から始まるインデックス番号を持つ新しい 2 次元の <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>の遅延バインディング アクセスを許可するように、パブリック コンス トラクターではなく、メソッド。  
  
 参照型の要素に初期化されます`null`します。 値型の要素がゼロに初期化されます。  
  
 このメソッドは O (`n`) 操作、`n`の製品は、`length1`と`length2`します。  
  
   
  
## Examples  
 次のコード例は、作成し、2 次元を初期化する方法を示しています。<xref:System.Array>します。  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  または、<paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> が 0 未満です。  または、<paramref name="length2" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="lengths">作成する <see cref="T:System.Array" /> の各次元のサイズを格納する 1 次元配列。</param>
        <param name="lowerBounds">作成する <see cref="T:System.Array" /> の各次元の下限 (開始インデックス) を格納する 1 次元配列。</param>
        <summary>指定した <see cref="T:System.Type" /> と次元の長さの、指定した下限を持つ多次元の <see cref="T:System.Array" /> を作成します。</summary>
        <returns>次元ごとに指定した長さと下限を持つ、指定した <see cref="T:System.Type" /> の新しい多次元の <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>の遅延バインディング アクセスを許可するように、パブリック コンス トラクターではなく、メソッド。  
  
 `lengths`と`lowerBounds`配列は同じ数の要素をいる必要があります。 要素の数、`lengths`配列は、新しいディメンションの数に一致する必要があります<xref:System.Array>します。  
  
 各要素、`lengths`配列は、新しい対応する次元の長さを指定する必要があります<xref:System.Array>します。  
  
 各要素、`lowerBounds`配列は、新しい対応する次元の下限の境界を指定する必要があります<xref:System.Array>します。 一般に、.NET Framework クラス ライブラリと多くのプログラミング言語は、0 以外の下限を処理しません。  
  
 参照型の要素に初期化されます`null`します。 値型の要素がゼロに初期化されます。  
  
 このメソッドは O (`n`) 操作、場所`n`のすべての値の積である`lengths`します。  
  
   
  
## Examples  
 次のコード例は、作成して、多次元を初期化する方法を示しています。<xref:System.Array>下限を指定します。  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" />です。  または、<paramref name="lengths" /> が <see langword="null" /> です。  または、<paramref name="lowerBounds" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。  または、<paramref name="lengths" /> 配列に含まれる要素が 1 つ未満です。  または、<paramref name="lengths" /> と <paramref name="lowerBounds" /> の配列に含まれている要素の数が異なります。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  または、<paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lengths" /> 内の値が 0 未満です。  または、<paramref name="lowerBounds" /> 内に非常に大きな値があり、ディメンションの下限の境界と長さの合計が <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="length1">作成する <see cref="T:System.Array" /> の最初の次元のサイズ。</param>
        <param name="length2">作成する <see cref="T:System.Array" /> の 2 番目の次元のサイズ。</param>
        <param name="length3">作成する <see cref="T:System.Array" /> の 3 番目の次元のサイズ。</param>
        <summary>
          <see cref="T:System.Array" /> と次元の長さを指定して、0 から始まるインデックス番号を持つ 3 次元の <see cref="T:System.Type" /> を作成します。</summary>
        <returns>指定した <see cref="T:System.Array" /> の、次元ごとに指定した長さの、0 から始まるインデックス番号を持つ新しい 3 次元の <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>の遅延バインディング アクセスを許可するように、パブリック コンス トラクターではなく、メソッド。  
  
 参照型の要素に初期化されます`null`します。 値型の要素がゼロに初期化されます。  
  
 このメソッドは O (`n`) 操作、場所`n`の製品は、 `length1`、 `length2`、および`length3`します。  
  
   
  
## Examples  
 次のコード例は、作成し、3 次元を初期化する方法を示しています。<xref:System.Array>します。  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  または、<paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> が 0 未満です。  または、<paramref name="length2" /> が 0 未満です。  または、<paramref name="length3" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <summary>空の配列を返します。</summary>
        <returns>空の <see cref="T:System.Array" /> を返します。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>指定された配列に、指定された述語によって定義された条件と一致する要素が含まれているかどうかを判断します。</summary>
        <returns>指定された述語によって定義された条件と一致する要素が少なくとも 1 つ、<paramref name="array" /> に存在する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>を返すメソッドにデリゲート`true`デリゲートで定義されている条件に一致するオブジェクトが渡された場合。  要素`array`に個別に渡される、<xref:System.Predicate%601>との一致が見つかったときに、処理は停止されます。  
  
> [!NOTE]
>  C# および Visual Basic の場合でない作成に必要な<xref:System.Predicate%601>明示的に委任します。 これらの言語では、コンテキストから適切なデリゲート推測し、自動的に作成します。  
  
 このメソッドは O (`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例についての一致条件を指定する、<xref:System.Array.Exists%2A>惑星が特定の文字で始まるかどうか、または指定された配列で、地球が見つかったかどうかを確認するメソッド usinglambda 式。  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 次の例では、<xref:System.Array.Exists%2A>メソッドを文字列配列に任意の名前が指定した文字で始まるかどうかを示します。 例では、インスタンス化、`StringSearcher`そのクラス コンス トラクターを検索する文字列を渡すことによってオブジェクト。 `StringSearcher.StartsWith`メソッドと同じシグネチャを持つ、<xref:System.Predicate%601>を委任します。 ときに、<xref:System.Array.Exists%2A>メソッドが呼び出されると、返されるまで、配列の各メンバーがデリゲートに渡される`true`または配列内のすべての要素を反復処理します。  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 ことができますもラムダ式を使用ではなく、デリゲートのシグネチャを持つ対応するメソッドを明示的に定義します。 次の例は、`StringSearcher`クラスとその`StartsWith`メソッド、ラムダ式を使用します。  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。  または、<paramref name="match" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の配列。インデックス番号が 0 から始まる必要があります。</param>
        <param name="match">検索する要素の条件を定義する述語。</param>
        <summary>指定された述語によって定義された条件と一致する要素を検索し、<see cref="T:System.Array" /> 全体の中で最もインデックス番号の小さい要素を返します。</summary>
        <returns>見つかった場合は、指定された述語によって定義された条件と一致する最初の要素。それ以外の場合は、型 <paramref name="T" /> の既定値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> 、メソッドまたはラムダ式を返すデリゲート`true`デリゲートまたはラムダ式で定義された条件に一致することに、オブジェクトが渡された場合。  要素`array`に個別に渡される、<xref:System.Predicate%601>で最初の要素で始まると、最後の要素で終了します。  一致が見つかった場合は、処理が停止しました。  
  
 このメソッドは O (`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例では、<xref:System.Predicate%601>を持つデリゲート、<xref:System.Array.Find%2A>ジェネリック メソッドの配列を検索する<xref:System.Drawing.Point>構造体。 デリゲートが表すメソッド`ProductGT10`、返します`true`X と Y のフィールドの製品が 100,000 より大きい場合。 <xref:System.Array.Find%2A>メソッドがテスト条件を満たす最初のポイントを返す配列の各要素に対してデリゲートを呼び出します。  
  
> [!NOTE]
>  Visual Basic および C# では、デリゲートを明示的に作成またはジェネリック メソッドの型引数を指定する必要はありません。 コンパイラは、指定したメソッドの引数から必要な型を決定します。  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 必要なシグネチャを持つメソッドを明示的に定義するのではなくをインスタンス化する、<xref:System.Predicate%601>デリゲート、およびデリゲートを渡すこと、<xref:System.Array.Find%2A>メソッド、ラムダ式を使用してよく使用されるは。 としてラムダ式を使用する点を除いて、次の例は前のものと同じ、`match`引数。  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。  または、<paramref name="match" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>指定された述語によって定義された条件と一致するすべての要素を取得します。</summary>
        <returns>見つかった場合は、指定された述語によって定義された条件と一致するすべての要素を格納した <see cref="T:System.Array" />。それ以外の場合は、空の <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>を返すメソッドにデリゲート`true`デリゲートで定義されている条件に一致するオブジェクトが渡された場合。  要素`array`に個別に渡される、<xref:System.Predicate%601>条件に一致する要素が返される配列に保存されます。  
  
 このメソッドは O (`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例では、0 から 1000 の範囲は値を持つ 50 の乱数の配列を作成します。 呼び出して、<xref:System.Array.FindAll%2A>を 600 に 300 から値の範囲を返すラムダ式を持つメソッド。 ラムダ式のという名前のパラメーターが渡されることに注意してください`x`;。 これに渡される個々 の配列のメンバーを表します、<xref:System.Predicate%601>します。 また、ローカル`lBound`と`uBound`変数は、ラムダ式内でアクセスできます。  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 次のコード例に示します、 <xref:System.Array.Find%2A>、 <xref:System.Array.FindLast%2A>、および<xref:System.Array.FindAll%2A>ジェネリック メソッド。 "Saurus"で終わる (位置 1 と 5) での 2 つの 8 恐竜の名前を含む文字列の配列が作成されます。 コード例では、という名前の検索述語メソッドも定義します`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値します。  
  
 <xref:System.Array.Find%2A>ジェネリック メソッドでは、配列を走査の各要素を順番に渡す、最初から、`EndsWithSaurus`メソッド。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`要素"Amargasaurus"。  
  
> [!NOTE]
>  C# および Visual Basic の場合でない作成に必要な`Predicate<string>`デリゲート (`Predicate(Of String)` Visual Basic で) 明示的にします。 これらの言語では、コンテキストから適切なデリゲート推測し、自動的に作成します。  
  
 <xref:System.Array.FindLast%2A>末尾から旧バージョンとの配列を検索するジェネリック メソッドを使用します。 5 番目の位置にある"Dilophosaurus"要素を検索します。 <xref:System.Array.FindAll%2A>で終わるすべての要素を含む配列を返すジェネリック メソッドを使用します。 要素が表示されます。  
  
 コード例も示しています、<xref:System.Array.Exists%2A>と<xref:System.Array.TrueForAll%2A>ジェネリック メソッド。  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。  または、<paramref name="match" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された述語によって定義された条件と一致する要素を、<see cref="T:System.Array" /> またはその一部分を対象に検索し、最もインデックス番号の小さい要素の 0 から始まるインデックスを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>
          <see cref="T:System.Array" /> 全体から、指定した述語によって定義される条件に一致する要素を検索し、最もインデックス番号の小さい要素の 0 から始まるインデックスを返します。</summary>
        <returns>
          <paramref name="match" /> で定義された条件と一致する要素が存在した場合、最もインデックス番号の小さい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>転送の最初の要素から開始し、最後の要素の終了が検索されます。  
  
 <xref:System.Predicate%601>を返すメソッドにデリゲート`true`デリゲートで定義されている条件に一致するオブジェクトが渡された場合。  要素`array`に個別に渡される、<xref:System.Predicate%601>します。  
  
 このメソッドは O (`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例は、の 3 つすべてのオーバー ロードを示して、<xref:System.Array.FindIndex%2A>ジェネリック メソッド。 "Saurus"で終わる (位置 1 と 5) での 2 つの 8 恐竜の名前を含む文字列の配列が作成されます。 コード例では、という名前の検索述語メソッドも定義します`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、各要素を順番に渡す、最初から配列を走査、`EndsWithSaurus`メソッド。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の位置 1 にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合でない作成に必要な`Predicate<string>`デリゲート (`Predicate(Of String)` Visual Basic で) 明示的にします。 これらの言語では、コンテキストから適切なデリゲート推測し、自動的に作成します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から開始し、配列の末尾に継続の配列を検索するメソッド オーバー ロードを使用します。 5 番目の位置にある要素を検索します。 最後に、<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から 3 つの要素の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に襲わは名前がないために、-1 を返します。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。  または、<paramref name="match" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>
          <see cref="T:System.Array" /> の指定したインデックスから最後の要素までの範囲内で、指定した述語にで定義される条件に一致する要素を検索し、最初に見つかった 0 から始まるインデックスを返します。</summary>
        <returns>
          <paramref name="match" /> で定義された条件と一致する要素が存在した場合、最もインデックス番号の小さい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>転送を開始位置として検索`startIndex`と最後の要素で終了します。  
  
 <xref:System.Predicate%601>を返すメソッドにデリゲート`true`デリゲートで定義されている条件に一致するオブジェクトが渡された場合。  要素`array`に個別に渡される、<xref:System.Predicate%601>します。  
  
 このメソッドは O (`n`) 操作、`n`から要素の数は、`startIndex`の末尾に`array`します。  
  
   
  
## Examples  
 次のコード例は、の 3 つすべてのオーバー ロードを示して、<xref:System.Array.FindIndex%2A>ジェネリック メソッド。 "Saurus"で終わる (位置 1 と 5) での 2 つの 8 恐竜の名前を含む文字列の配列が作成されます。 コード例では、という名前の検索述語メソッドも定義します`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、各要素を順番に渡す、最初から配列を走査、`EndsWithSaurus`メソッド。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の位置 1 にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合でない作成に必要な`Predicate<string>`デリゲート (`Predicate(Of String)` Visual Basic で) 明示的にします。 これらの言語では、コンテキストから適切なデリゲート推測し、自動的に作成します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から開始し、配列の末尾に継続の配列を検索するメソッド オーバー ロードを使用します。 5 番目の位置にある要素を検索します。 最後に、<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から 3 つの要素の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に襲わは名前がないために、-1 を返します。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。  または、<paramref name="match" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>
          <see cref="T:System.Array" /> のうち、指定したインデックスから始まり、指定した要素数が含まれる範囲の中で、指定した述語によって定義される条件に一致する要素を検索し、そのうち最もインデックス番号の小さい要素の 0 から始まるインデックスを返します。</summary>
        <returns>
          <paramref name="match" /> で定義された条件と一致する要素が存在した場合、最もインデックス番号の小さい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>転送を開始位置として検索が`startIndex`で終わる`startIndex`plus`count`から 1 を引いた場合`count`が 0 より大きい。  
  
 <xref:System.Predicate%601>を返すメソッドにデリゲート`true`デリゲートで定義されている条件に一致するオブジェクトが渡された場合。  要素`array`に個別に渡される、<xref:System.Predicate%601>します。  
  
 このメソッドは O (`n`) 操作、`n`は`count`します。  
  
   
  
## Examples  
 次のコード例は、の 3 つすべてのオーバー ロードを示して、<xref:System.Array.FindIndex%2A>ジェネリック メソッド。 "Saurus"で終わる (位置 1 と 5) での 2 つの 8 恐竜の名前を含む文字列の配列が作成されます。 コード例では、という名前の検索述語メソッドも定義します`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、各要素を順番に渡す、最初から配列を走査、`EndsWithSaurus`メソッド。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の位置 1 にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合でない作成に必要な`Predicate<string>`デリゲート (`Predicate(Of String)` Visual Basic で) 明示的にします。 これらの言語では、コンテキストから適切なデリゲート推測し、自動的に作成します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から開始し、配列の末尾に継続の配列を検索するメソッド オーバー ロードを使用します。 5 番目の位置にある要素を検索します。 最後に、<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から 3 つの要素の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に襲わは名前がないために、-1 を返します。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。  または、<paramref name="match" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  または、<paramref name="count" /> が 0 未満です。  または、<paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>指定された述語によって定義された条件と一致する要素を、<see cref="T:System.Array" /> 全体を対象に検索し、最もインデックス番号の大きい要素を返します。</summary>
        <returns>見つかった場合は、指定された述語によって定義された条件と一致する最後の要素。それ以外の場合は、型 <paramref name="T" /> の既定値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>を返すメソッドにデリゲート`true`デリゲートで定義されている条件に一致するオブジェクトが渡された場合。  要素`array`に個別に渡される、<xref:System.Predicate%601>への移行の旧バージョンと、 <xref:System.Array>、以降の最後の要素では、最初の要素で終わる。  一致が見つかった場合は、処理が停止しました。  
  
 このメソッドは O (`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例に示します、 <xref:System.Array.Find%2A>、 <xref:System.Array.FindLast%2A>、および<xref:System.Array.FindAll%2A>ジェネリック メソッド。 "Saurus"で終わる (位置 1 と 5) での 2 つの 8 恐竜の名前を含む文字列の配列が作成されます。 コード例では、という名前の検索述語メソッドも定義します`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値します。  
  
 <xref:System.Array.Find%2A>ジェネリック メソッドでは、配列を走査の各要素を順番に渡す、最初から、`EndsWithSaurus`メソッド。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`要素"Amargasaurus"。  
  
> [!NOTE]
>  C# および Visual Basic の場合でない作成に必要な`Predicate<string>`デリゲート (`Predicate(Of String)` Visual Basic で) 明示的にします。 これらの言語では、コンテキストから適切なデリゲート推測し、自動的に作成します。  
  
 <xref:System.Array.FindLast%2A>末尾から旧バージョンとの配列を検索するジェネリック メソッドを使用します。 5 番目の位置にある"Dilophosaurus"要素を検索します。 <xref:System.Array.FindAll%2A>で終わるすべての要素を含む配列を返すジェネリック メソッドを使用します。 要素が表示されます。  
  
 コード例も示しています、<xref:System.Array.Exists%2A>と<xref:System.Array.TrueForAll%2A>ジェネリック メソッド。  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。  または、<paramref name="match" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された述語によって定義された条件と一致する要素を、<see cref="T:System.Array" /> またはその一部分を対象に検索し、最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>
          <see cref="T:System.Array" /> 全体から、指定した述語によって定義される条件に一致する要素を検索し、最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
        <returns>
          <paramref name="match" /> で定義された条件と一致する要素が存在する場合、最もインデックス番号の大きい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>後方の最後の要素から開始し、最初の要素の終了が検索されます。  
  
 <xref:System.Predicate%601>を返すメソッドにデリゲート`true`デリゲートで定義されている条件に一致するオブジェクトが渡された場合。  要素`array`に個別に渡される、<xref:System.Predicate%601>します。  
  
 このメソッドは O (`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例は、の 3 つすべてのオーバー ロードを示して、<xref:System.Array.FindLastIndex%2A>ジェネリック メソッド。 "Saurus"で終わる (位置 1 と 5) での 2 つの 8 恐竜の名前を含む文字列の配列が作成されます。 コード例では、という名前の検索述語メソッドも定義します`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードでは、旧バージョンとの配列を走査最後に、各要素を順番に渡すことから、`EndsWithSaurus`メソッド。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の 5 番目の位置にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合でない作成に必要な`Predicate<string>`デリゲート (`Predicate(Of String)` Visual Basic で) 明示的にします。 これらの言語では、コンテキストから適切なデリゲート推測し、自動的に作成します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 4 から開始し、配列の先頭に後方継続の配列を検索するメソッド オーバー ロードを使用します。 位置 1 である要素を検索します。 最後に、<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは 3 つの要素 4 の位置から開始し、逆方向 (つまり、4、3、および 2) の範囲を検索するために使用します。 "Saurus"で終わる範囲に襲わは名前がないために、-1 を返します。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。  または、<paramref name="match" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="startIndex">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>
          <see cref="T:System.Array" /> のうち、先頭の要素から指定したインデックスまでの範囲の中で、指定した述語によって定義される条件に一致する要素を検索し、そのうち最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
        <returns>
          <paramref name="match" /> で定義された条件と一致する要素が存在する場合、最もインデックス番号の大きい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>で検索された旧バージョンと開始`startIndex`と最初の要素で終了します。  
  
 <xref:System.Predicate%601>を返すメソッドにデリゲート`true`デリゲートで定義されている条件に一致するオブジェクトが渡された場合。  要素`array`に個別に渡される、<xref:System.Predicate%601>します。  
  
 このメソッドは O (`n`) 操作、`n`の先頭から要素の数は、`array`に`startIndex`します。  
  
   
  
## Examples  
 次のコード例は、の 3 つすべてのオーバー ロードを示して、<xref:System.Array.FindLastIndex%2A>ジェネリック メソッド。 "Saurus"で終わる (位置 1 と 5) での 2 つの 8 恐竜の名前を含む文字列の配列が作成されます。 コード例では、という名前の検索述語メソッドも定義します`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードでは、旧バージョンとの配列を走査最後に、各要素を順番に渡すことから、`EndsWithSaurus`メソッド。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の 5 番目の位置にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合でない作成に必要な`Predicate<string>`デリゲート (`Predicate(Of String)` Visual Basic で) 明示的にします。 これらの言語では、コンテキストから適切なデリゲート推測し、自動的に作成します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 4 から開始し、配列の先頭に後方継続の配列を検索するメソッド オーバー ロードを使用します。 位置 1 である要素を検索します。 最後に、<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは 3 つの要素 4 の位置から開始し、逆方向 (つまり、4、3、および 2) の範囲を検索するために使用します。 "Saurus"で終わる範囲に襲わは名前がないために、-1 を返します。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。  または、<paramref name="match" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="startIndex">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>
          <see cref="T:System.Array" /> のうち、指定したインデックスで終わり、指定した要素数が含まれる範囲の中で、指定した述語によって定義される条件に一致する要素を検索し、そのうち最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
        <returns>
          <paramref name="match" /> で定義された条件と一致する要素が存在する場合、最もインデックス番号の大きい要素の 0 から始まるインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>で検索された旧バージョンと開始`startIndex`で終わる`startIndex`マイナス`count`+ 1 場合、`count`が 0 より大きい。  
  
 <xref:System.Predicate%601>を返すメソッドにデリゲート`true`デリゲートで定義されている条件に一致するオブジェクトが渡された場合。  要素`array`に個別に渡される、<xref:System.Predicate%601>します。  
  
 このメソッドは O (`n`) 操作、`n`は`count`します。  
  
   
  
## Examples  
 次のコード例は、の 3 つすべてのオーバー ロードを示して、<xref:System.Array.FindLastIndex%2A>ジェネリック メソッド。 "Saurus"で終わる (位置 1 と 5) での 2 つの 8 恐竜の名前を含む文字列の配列が作成されます。 コード例では、という名前の検索述語メソッドも定義します`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードでは、旧バージョンとの配列を走査最後に、各要素を順番に渡すことから、`EndsWithSaurus`メソッド。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の 5 番目の位置にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合でない作成に必要な`Predicate<string>`デリゲート (`Predicate(Of String)` Visual Basic で) 明示的にします。 これらの言語では、コンテキストから適切なデリゲート推測し、自動的に作成します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 4 から開始し、配列の先頭に後方継続の配列を検索するメソッド オーバー ロードを使用します。 位置 1 である要素を検索します。 最後に、<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは 3 つの要素 4 の位置から開始し、逆方向 (つまり、4、3、および 2) の範囲を検索するために使用します。 "Saurus"で終わる範囲に襲わは名前がないために、-1 を返します。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。  または、<paramref name="match" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  または、<paramref name="count" /> が 0 未満です。  または、<paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">要素に処理を適用する、インデックス番号が 0 から始まる 1 次元の <see cref="T:System.Array" />。</param>
        <param name="action">
          <c>array</c> の各要素に対して実行する <see cref="T:System.Action`1" />。</param>
        <summary>指定された配列内の各要素に対して、指定された処理を実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601>はオブジェクトの操作を実行するメソッドへのデリゲートが渡されました。  要素`array`に個別に渡される、<xref:System.Action%601>します。  
  
 このメソッドは O (`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例は、使用する方法を示します<xref:System.Array.ForEach%2A>整数の配列の各要素の四角形を表示します。  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。  または、<paramref name="action" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.IEnumerator" /> の <see cref="T:System.Array" /> を返します。</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> の <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic、c#]  
  
 `foreach` C# 言語のステートメント (`for each` C++ では、 `For Each` Visual basic) 列挙子の複雑さが隠されています。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。 <xref:System.Collections.IEnumerator.Reset%2A> を実行した場合も、列挙子はこの位置に戻されます。  この位置では、<xref:System.Collections.IEnumerator.Current%2A> が未定義です。 そのため、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.IEnumerator.Current%2A> を呼び出して列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.IEnumerator.Current%2A> は、<xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> が呼び出されるまでは同じオブジェクトを返します。 <xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.IEnumerator.Current%2A> を次の要素に設定します。  
  
 場合<xref:System.Collections.IEnumerator.MoveNext%2A>列挙子、コレクションの末尾がコレクション内の最後の要素の後に配置されているパスと<xref:System.Collections.IEnumerator.MoveNext%2A>返します`false`します。 この位置では、後続の呼び出しで列挙子の場合<xref:System.Collections.IEnumerator.MoveNext%2A>を返すことも`false`します。 最後の呼び出し場合<xref:System.Collections.IEnumerator.MoveNext%2A>返される`false`、<xref:System.Collections.IEnumerator.Current%2A>が定義されていません。 <xref:System.Collections.IEnumerator.Current%2A> をコレクションの最初の要素にもう一度設定するには、<xref:System.Collections.IEnumerator.Reset%2A> を呼び出してから <xref:System.Collections.IEnumerator.MoveNext%2A> を呼び出します。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 (要素の追加、変更、削除など) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子には、コレクションへの排他アクセスがありません。したがって、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示しています。<xref:System.Array.GetEnumerator%2A>を配列の要素を一覧表示します。  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">長さを指定する <see cref="T:System.Array" /> の 0 から始まる次元。</param>
        <summary>
          <see cref="T:System.Array" /> の指定した次元にある要素の数を表す 32 ビット整数を取得します。</summary>
        <returns>指定した次元にある要素の数を表す 32 ビット整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例の<xref:System.Array.GetLength%2A>は`GetLength(0)`の最初の次元の要素の数を返します<xref:System.Array>します。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次の例は、使用する方法を示します<xref:System.Array.GetLength%2A>ランクが異なる 2 つの配列の寸法を表示します。  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> が 0 未満です。  -または-  <paramref name="dimension" /> が <see cref="P:System.Array.Rank" /> 以上になっています。</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">長さを指定する <see cref="T:System.Array" /> の 0 から始まる次元。</param>
        <summary>
          <see cref="T:System.Array" /> の指定した次元にある要素の数を表す 64 ビット整数を取得します。</summary>
        <returns>指定した次元にある要素の数を表す 64 ビット整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例の<xref:System.Array.GetLongLength%2A>は`GetLongLength(0)`の最初の次元の要素の数を返します<xref:System.Array>します。  
  
 このメソッドは、o (1) 操作です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> が 0 未満です。  -または-  <paramref name="dimension" /> が <see cref="P:System.Array.Rank" /> 以上になっています。</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">開始インデックスを指定する配列の 0 から始まる次元。</param>
        <summary>配列内で指定した次元の、最初の要素のインデックスを取得します。</summary>
        <returns>配列内で指定した次元の、最初の要素のインデックス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` 配列の最初の次元の開始インデックスを返しますと`GetLowerBound(Rank - 1)`配列の最後の次元の開始インデックスを返します。  
  
 <xref:System.Array.GetLowerBound%2A>メソッドは、配列が空の場合でも常に、配列の下限のインデックスを示す値を返します。  
  
 .NET Framework のほとんどの配列は 0 から始まりますが (は、<xref:System.Array.GetLowerBound%2A>配列の各次元のゼロが返される)、.NET Framework では、0 から始まるないアレイをサポートします。 このような配列を作成できます、<xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29>メソッドをおよびアンマネージ コードから返されることもできます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドを 1 次元、2 次元配列の境界を表示し、配列要素の値を表示します。  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> が 0 未満です。  -または-  <paramref name="dimension" /> が <see cref="P:System.Array.Rank" /> 以上になっています。</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">上限を指定する配列の 0 から始まる次元。</param>
        <summary>配列内で指定した次元の、最後の要素のインデックスを取得します。</summary>
        <returns>配列内で指定した次元の最後の要素のインデックス、または指定した次元が空の場合は -1 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` 配列の最初の次元の最後のインデックスを返しますと`GetUpperBound(Rank - 1)`配列の最後の次元の最後のインデックスを返します。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドを 1 次元、2 次元配列の境界を表示し、配列要素の値を表示します。  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> が 0 未満です。  -または-  <paramref name="dimension" /> が <see cref="P:System.Array.Rank" /> 以上になっています。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Array" /> 内の指定した要素の値を取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">取得する <see cref="T:System.Array" /> 要素の位置を表す 32 ビット整数。</param>
        <summary>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 32 ビット整数値として指定します。</summary>
        <returns>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドを調べるかどうかの値`index`が範囲外です。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> が完全な 1 次元ではありません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> が、現在の <see cref="T:System.Array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">取得する <see cref="T:System.Array" /> 要素の位置を指定するインデックスを表す 32 ビット整数の 1 次元配列。</param>
        <summary>多次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 32 ビット整数値の配列として指定します。</summary>
        <returns>多次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素数`indices`の次元数と同じにする必要があります、<xref:System.Array>します。 すべての要素、`indices`配列が多次元で、目的の要素の位置をまとめて指定する必要があります<xref:System.Array>します。  
  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドが範囲外のインデックスのいずれかがいるかどうかを判断することができます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> の次元数が、<paramref name="indices" /> 内の要素数と等しくありません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="indices" /> 内のいずれかの要素が、現在の <see cref="T:System.Array" /> 内の対応する次元の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">取得する <see cref="T:System.Array" /> 要素の位置を表す 64 ビット整数。</param>
        <summary>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 このインデックスは 64 ビット整数値として指定されます。</summary>
        <returns>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドを調べるかどうかの値`index`が範囲外です。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> が完全な 1 次元ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、現在の <see cref="T:System.Array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">取得する <see cref="T:System.Array" /> 要素の位置を指定するインデックスを表す 64 ビット整数の 1 次元配列。</param>
        <summary>多次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 64 ビット整数値の配列として指定します。</summary>
        <returns>多次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素数`indices`の次元数と同じにする必要があります、<xref:System.Array>します。 すべての要素、`indices`配列が多次元で、目的の要素の位置をまとめて指定する必要があります<xref:System.Array>します。  
  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドが範囲外のインデックスのいずれかがいるかどうかを判断することができます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> の次元数が、<paramref name="indices" /> 内の要素数と等しくありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indices" /> 内のいずれかの要素が、現在の <see cref="T:System.Array" /> 内の対応する次元の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">取得する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 32 ビット整数。</param>
        <param name="index2">取得する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 32 ビット整数。</param>
        <summary>2 次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 32 ビット整数値として指定します。</summary>
        <returns>2 次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドが範囲外のインデックスのいずれかがいるかどうかを判断することができます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確な 2 次元配列ではありません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> または <paramref name="index2" /> が、現在の <see cref="T:System.Array" /> の対応する次元の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">取得する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index2">取得する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 64 ビット整数。</param>
        <summary>2 次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 64 ビット整数として指定します。</summary>
        <returns>2 次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドが範囲外のインデックスのいずれかがいるかどうかを判断することができます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確な 2 次元配列ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> または <paramref name="index2" /> が、現在の <see cref="T:System.Array" /> の対応する次元の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">取得する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 32 ビット整数。</param>
        <param name="index2">取得する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 32 ビット整数。</param>
        <param name="index3">取得する <see cref="T:System.Array" /> 要素の 3 番目の次元のインデックスを表す 32 ビット整数。</param>
        <summary>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 32 ビット整数値として指定します。</summary>
        <returns>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドが範囲外のインデックスのいずれかがいるかどうかを判断することができます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確な 3 次元配列ではありません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" />、<paramref name="index2" />、または <paramref name="index3" /> が、現在の <see cref="T:System.Array" /> の対応する次元の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">取得する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index2">取得する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index3">取得する <see cref="T:System.Array" /> 要素の 3 番目の次元のインデックスを表す 64 ビット整数。</param>
        <summary>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 64 ビット整数として指定します。</summary>
        <returns>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドが範囲外のインデックスのいずれかがいるかどうかを判断することができます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確な 3 次元配列ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" />、<paramref name="index2" />、または <paramref name="index3" /> が、現在の <see cref="T:System.Array" /> の対応する次元の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定されたオブジェクトを 1 次元の配列または配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">検索する 1 次元配列。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <summary>指定したオブジェクトを検索し、1 次元配列でそのオブジェクトが最初に見つかった位置のインデックス番号を返します。</summary>
        <returns>
          <paramref name="array" /> で <paramref name="value" /> が見つかった場合は、最初に見つかった位置のインデックス。それ以外の場合は、配列の下限 - 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、1 次元 arrayfor のすべての要素を検索`value`します。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して各要素の等値比較を実行する`Equals`メソッドの一致が見つかるまでです。 つまり、要素をオーバーライドする場合、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッド、そのオーバーライドが呼び出されます。  
  
 ほとんどの配列の下限を 0 ため、このメソッド一般に-1 を返します`value`が見つからない。 配列の下限の境界が等しく、まれなケースで<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF)。  
  
 このメソッドは O (`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 例では、次の 3 つオーバー ロードを呼び出し、<xref:System.Array.IndexOf%2A>文字列配列に文字列のインデックスを検索するメソッド。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>、、文字列に最初に出現する位置を決定する文字列の配列「、」。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>、、文字列に最初に出現する位置を決定する文字列配列の最後の要素に 4 つ目で"the"。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>、、文字列に最初に出現する位置を決定する文字列で「、」配列の最後の一致、配列の末尾に次の場所からします。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">検索する 1 次元配列。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <param name="startIndex">検索の開始インデックス。 空の配列の場合 0 (ゼロ) は有効です。</param>
        <summary>指定されたオブジェクトを 1 次元配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。 要素範囲は、指定されたインデックスから、配列の最後までの範囲です。</summary>
        <returns>
          <paramref name="array" /> の <paramref name="startIndex" /> から最後の要素までを範囲として <paramref name="value" /> を検索し、見つかった場合は、インデックス番号の最も小さい要素のインデックス番号。それ以外の場合は、配列の下限 - 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは検索インデックスにある要素から 1 次元配列`startIndex`最後の要素。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行します、`Equals`一致が見つかるまでのすべての要素のメソッド。 つまり、要素をオーバーライドする場合、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッド、そのオーバーライドが呼び出されます。  
  
 ほとんどの配列の下限を 0 ため、このメソッド一般に-1 を返します`value`が見つからない。 配列の下限の境界が等しく、まれなケースで<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF)。  
  
 場合`startIndex`equals<xref:System.Array.Length%2A?displayProperty=nameWithType>メソッドは-1 を返します。 場合`startIndex`がより大きい<xref:System.Array.Length%2A?displayProperty=nameWithType>がスローされます、<xref:System.ArgumentOutOfRangeException>します。  
  
 このメソッドは O (`n`) 操作、`n`から要素の数は、`startIndex`の末尾に`array`します。  
  
   
  
## Examples  
 例では、次の 3 つオーバー ロードを呼び出し、<xref:System.Array.IndexOf%2A>文字列配列に文字列のインデックスを検索するメソッド。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>、、文字列に最初に出現する位置を決定する文字列の配列「、」。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>、、文字列に最初に出現する位置を決定する文字列配列の最後の要素に 4 つ目で"the"。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>、、文字列に最初に出現する位置を決定する文字列で「、」配列の最後の一致、配列の末尾に次の場所からします。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">検索する 1 次元配列。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <param name="startIndex">検索の開始インデックス。 空の配列の場合 0 (ゼロ) は有効です。</param>
        <param name="count">検索する要素数。</param>
        <summary>指定されたオブジェクトを 1 次元配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。 範囲は、指定されたインデックスから始まり、指定された数の要素を含む範囲です。</summary>
        <returns>インデックス <paramref name="startIndex" /> から <paramref name="startIndex" /> + <paramref name="count" /> - 1 までの <paramref name="array" /> 内で見つかった場合は、<paramref name="value" /> の最初の出現箇所のインデックス。それ以外の場合は、配列の下限 - 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、1 次元 arrayfrom の要素を検索`startIndex`に`startIndex`plus`count`から 1 を引いた場合`count`が 0 より大きい。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行します、`Equals`一致が見つかるまでのすべての要素のメソッド。 つまり、要素をオーバーライドする場合、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッド、そのオーバーライドが呼び出されます。  
  
 Becausemost 配列が下限を 0 が、一般に、このメソッドは – 1 の場合を返します`value`が見つからない。 配列の下限の境界が等しく、まれなケースで<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF)。  
  
 場合`startindex`equals<xref:System.Array.Length%2A?displayProperty=nameWithType>メソッドは-1 を返します。 場合`startIndex`がより大きい<xref:System.Array.Length%2A?displayProperty=nameWithType>がスローされます、<xref:System.ArgumentOutOfRangeException>します。  
  
 このメソッドは O (`n`) 操作、`n`は`count`します。  
  
   
  
## Examples  
 例では、次の 3 つオーバー ロードを呼び出し、<xref:System.Array.IndexOf%2A>文字列配列に文字列のインデックスを検索するメソッド。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>、、文字列に最初に出現する位置を決定する文字列の配列「、」。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>、、文字列に最初に出現する位置を決定する文字列配列の最後の要素に 4 つ目で"the"。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>、、文字列に最初に出現する位置を決定する文字列で「、」配列の最後の一致、配列の末尾に次の場所からします。 値を決定する、`count`引数、開始インデックスから配列の上限値を減算し、1 つ追加します。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  または、<paramref name="count" /> が 0 未満です。  または、<paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の配列。インデックス番号が 0 から始まる必要があります。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <summary>指定したオブジェクトを検索し、1 次元配列でそのオブジェクトが最初に見つかった位置のインデックス番号を返します。</summary>
        <returns>
          <paramref name="array" /> 全体を対象とする <paramref name="value" /> の検索で最初に見つかった位置のインデックス (0 から始まる)。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの 1 次元配列のすべての要素を検索する`value`します。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行します、`T.Equals`要素ごとにメソッド。 つまり、`T`オーバーライド、<xref:System.Object.Equals%2A>メソッド、そのオーバーライドが呼び出されます。  
  
 このメソッドは O (`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例では、すべて次の 3 つのジェネリック オーバー ロード、<xref:System.Array.IndexOf%2A>メソッド。 インデックス位置 0 と 5 のインデックスの場所に 2 回、表示する 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、最初から配列を検索し、文字列の最初の出現箇所を検索します。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードを使用して配列のインデックス位置 3 以降と、配列の最後の検索し、文字列の 2 つ目の項目を検索します。 最後に、<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>は 2 つのインデックス位置にある先頭の 2 つのエントリの範囲を検索するメソッドのオーバー ロードが使用されます。 その範囲内で検索文字列のインスタンスがないため、-1 を返します。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の配列。インデックス番号が 0 から始まる必要があります。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。 空の配列の場合 0 (ゼロ) は有効です。</param>
        <summary>指定されたオブジェクトを 1 次元配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。 要素範囲は、指定されたインデックスから、配列の最後までの範囲です。</summary>
        <returns>
          <paramref name="value" /> の <paramref name="array" /> から最後の要素までを範囲として <paramref name="startIndex" /> を検索し、見つかった場合は、インデックス番号の最も小さい要素の 0 から始まるインデックス番号。それ以外の場合は –1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを 1 次元配列にある要素からは検索`startIndex`配列の末尾にします。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行します、`T.Equals`要素ごとにメソッド。 つまり、`T`オーバーライド、<xref:System.Object.Equals%2A>メソッド、そのオーバーライドが呼び出されます。  
  
 場合`startIndex`equals <xref:System.Array.Length%2A>、メソッドを返します - 1.If`startIndex`がより大きい<xref:System.Array.Length%2A?displayProperty=nameWithType>がスローされます、<xref:System.ArgumentOutOfRangeException>します。  
  
 このメソッドは O (`n`) 操作、`n`から要素の数は、`startIndex`の末尾に`array`します。  
  
   
  
## Examples  
 次の例では、すべて次の 3 つのジェネリック オーバー ロード、<xref:System.Array.IndexOf%2A>メソッド。 インデックス位置 0 と 5 のインデックスの場所に 2 回、表示する 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、最初から配列を検索し、文字列の最初の出現箇所を検索します。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードを使用して配列のインデックス位置 3 以降と、配列の最後の検索し、文字列の 2 つ目の項目を検索します。 最後に、<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>は 2 つのインデックス位置にある先頭の 2 つのエントリの範囲を検索するメソッドのオーバー ロードが使用されます。 その範囲内で検索文字列のインスタンスがないため、-1 を返します。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の配列。インデックス番号が 0 から始まる必要があります。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。 空の配列では 0 (ゼロ) は正しい値です。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <summary>指定されたオブジェクトを 1 次元配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。 範囲は、指定されたインデックスから始まり、指定された数の要素を含む範囲です。</summary>
        <returns>
          <paramref name="value" /> の <paramref name="array" /> から <paramref name="startIndex" /> 個の要素を範囲として <paramref name="count" /> を検索し、見つかった場合は、インデックス番号の最も小さい要素の 0 から始まるインデックス番号。それ以外の場合は –1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの searchesthe 要素から 1 次元配列の`startIndex`に`startIndex`plus`count`から 1 を引いた場合`count`が 0 より大きい。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行します、`T.Equals`要素ごとにメソッド。 つまり、`T`オーバーライド、<xref:System.Object.Equals%2A>メソッド、そのオーバーライドが呼び出されます。  
  
 場合`startIndex`equals<xref:System.Array.Length%2A?displayProperty=nameWithType>メソッドは-1 を返します。  場合`startIndex`がより大きい<xref:System.Array.Length%2A?displayProperty=nameWithType>がスローされます、<xref:System.ArgumentOutOfRangeException>します。  
  
 このメソッドは O (`n`) 操作、`n`は`count`します。  
  
   
  
## Examples  
 次の例では、すべて次の 3 つのジェネリック オーバー ロード、<xref:System.Array.IndexOf%2A>メソッド。 インデックス位置 0 と 5 のインデックスの場所に 2 回、表示する 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、最初から配列を検索し、文字列の最初の出現箇所を検索します。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードを使用して配列のインデックス位置 3 以降と、配列の最後の検索し、文字列の 2 つ目の項目を検索します。 最後に、<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>は 2 つのインデックス位置にある先頭の 2 つのエントリの範囲を検索するメソッドのオーバー ロードが使用されます。 その範囲内で検索文字列のインスタンスがないため、-1 を返します。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  または、<paramref name="count" /> が 0 未満です。  または、<paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>値型の既定のコンストラクターを呼び出して、この値型 <see cref="T:System.Array" /> の各要素を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの目的は、コンパイラが値型の配列をサポートするにはほとんどのユーザーには、このメソッドは必要ありません。 参照型の配列でない使用する必要があります。  
  
 場合、<xref:System.Array>値型ではない<xref:System.Array>または値の型に既定のコンス トラクターがあるない場合、<xref:System.Array>は変更されません。  
  
 値型<xref:System.Array>の下限の境界とディメンションの任意の数を持つことができます。  
  
 このメソッドは O (`n`) 操作、`n`は<xref:System.Array.Length%2A>します。  
  
> [!CAUTION]
>  このメソッドはコンス トラクター; がある値型でのみ使用できます。ただし、c# にネイティブな値の型には、コンス トラクターはありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> が固定サイズかどうかを示す値を取得します。</summary>
        <value>このプロパティは、すべての配列に対して常に <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 実装して、<xref:System.Array.IsFixedSize%2A>プロパティが必要としているため、<xref:System.Collections.IList?displayProperty=nameWithType>インターフェイス。  
  
 固定サイズの配列は、追加または削除できません要素の後、配列が作成されますが、既存の要素は変更できます。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> が読み取り専用かどうかを示す値を取得します。</summary>
        <value>このプロパティは、すべての配列に対して常に <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 実装して、<xref:System.Array.IsReadOnly%2A>プロパティが必要としているため、<xref:System.Collections.IList?displayProperty=nameWithType>インターフェイス。 読み取り専用である配列はできません、追加、削除、または要素の変更、配列を作成した後。  
  
 読み取り専用コレクションを必要とする場合、<xref:System.Collections>を実装するクラス、<xref:System.Collections.IList?displayProperty=nameWithType>インターフェイス。  
  
 キャストまたは配列に変換する場合、<xref:System.Collections.IList>インターフェイス オブジェクト、<xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType>プロパティが返す`false`します。 ただし、キャストまたは配列に変換する場合、<xref:System.Collections.Generic.IList%601>インターフェイス、`IsReadOnly`プロパティが返す`true`します。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> へのアクセスが同期されている (スレッド セーフである) かどうかを示す値を取得します。</summary>
        <value>このプロパティは、すべての配列に対して常に <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 実装して、<xref:System.Array.IsSynchronized%2A>プロパティが必要としているため、<xref:System.Collections.ICollection?displayProperty=nameWithType>インターフェイス。  
  
 .NET framework クラスに基づいた<xref:System.Array>のコレクションを使用して、独自の同期バージョンの提供、<xref:System.Array.SyncRoot%2A>プロパティ。  
  
 配列を使用するクラスは、独自の同期を使用しても実装できます、<xref:System.Array.SyncRoot%2A>プロパティ。 同期されたコードで操作を実行する必要があります、`SyncRoot`コレクションの直接ではなく、コレクションの。 これにより、他のオブジェクトから派生したコレクションを適切に操作できるようになります。 具体的には、コレクションを同時に変更する可能性があるその他のスレッドと適切な同期を維持します。 注意の実装によって<xref:System.Array.SyncRoot%2A>返す可能性があります、<xref:System.Array>自体。  
  
 コレクションの列挙は、スレッド セーフな方法では本質的にします。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
   
  
## Examples  
 次のコード例を使用して、すべての列挙中に配列をロックする方法を示しています、<xref:System.Array.SyncRoot%2A>プロパティ。  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1 次元 <see cref="T:System.Array" /> 内または <see cref="T:System.Array" /> の範囲内で値が最後に見つかった位置のインデックス番号を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <summary>指定したオブジェクトを検索し、1 次元の <see cref="T:System.Array" /> 全体でそのオブジェクトが最後に見つかった位置のインデックス番号を返します。</summary>
        <returns>
          <paramref name="value" /> 全体を対象に <paramref name="array" /> を検索し、見つかった場合は、インデックス番号の最も大きい要素のインデックス番号。それ以外の場合は、配列の下限 - 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1 次元<xref:System.Array>後方の最後の要素から開始し、最初の要素の終了が検索されます。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッド。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装が使用されます。  
  
 ほとんどの配列が下限を 0 であるためこのメソッドは、通常 – 1 の場合に`value`が見つかりません。 配列の下限の境界が等しく、まれなケースで<xref:System.Int32.MinValue?displayProperty=nameWithType>と`value`が検出されなければ、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>、これは`System.Int32.MinValue - 1`します。  
  
 このメソッドは O (`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
 .NET framework version 2.0 では、このメソッドを使用して、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、<xref:System.Array>を決定するかどうか、<xref:System.Object>で指定された、`value`パラメーターが存在します。 以前のバージョンの .NET Framework では、この判断を使用して行われた、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、 `value` <xref:System.Object>自体。  
  
 <xref:System.IComparable.CompareTo%2A> メソッド、`item`パラメーター コレクション内のオブジェクトにします。  
  
   
  
## Examples  
 次のコード例では、配列内の指定した要素の最後に見つかった位置のインデックスを確認する方法を示します。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <param name="startIndex">逆方向検索の開始インデックス。</param>
        <summary>1 次元 <see cref="T:System.Array" /> の先頭の要素から、指定したインデックスまでを対象に指定したオブジェクトを検索し、インデックス番号の最も大きい要素のインデックス番号を返します。</summary>
        <returns>
          <paramref name="value" /> の先頭の要素から <paramref name="array" /> までを範囲として <paramref name="startIndex" /> を検索し、見つかった場合は、インデックス番号の最も大きい要素のインデックス番号。それ以外の場合は、配列の下限 - 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1 次元<xref:System.Array>で検索された旧バージョンと開始`startIndex`と最初の要素で終了します。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッド。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装が使用されます。  
  
 ほとんどの配列が下限を 0 であるためこのメソッドは、通常 – 1 の場合に`value`が見つかりません。 配列の下限の境界が等しく、まれなケースで<xref:System.Int32.MinValue?displayProperty=nameWithType>と`value`が検出されなければ、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>、これは`System.Int32.MinValue - 1`します。  
  
 このメソッドは O (`n`) 操作、`n`の先頭から要素の数は、`array`に`startIndex`します。  
  
 .NET framework version 2.0 では、このメソッドを使用して、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、<xref:System.Array>を決定するかどうか、<xref:System.Object>で指定された、`value`パラメーターが存在します。 以前のバージョンの .NET Framework では、この判断を使用して行われた、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、 `value` <xref:System.Object>自体。  
  
   
  
## Examples  
 次のコード例では、配列内の指定した要素の最後に見つかった位置のインデックスを確認する方法を示します。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <param name="startIndex">逆方向検索の開始インデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <summary>指定したオブジェクトを、1 次元 <see cref="T:System.Array" /> の指定したインデックス位置から、指定した要素数を範囲として検索し、インデックス番号の最も大きい要素のインデックス番号を返します。</summary>
        <returns>
          <paramref name="value" /> の <paramref name="array" /> から、<paramref name="count" /> で指定された要素数を範囲として <paramref name="startIndex" /> を検索し、見つかった場合は、インデックス番号の最も大きい要素のインデックス番号。それ以外の場合は、配列の下限 - 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1 次元<xref:System.Array>で検索された旧バージョンと開始`startIndex`で終わる`startIndex`マイナス`count`+ 1 場合、`count`が 0 より大きい。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッド。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装が使用されます。  
  
 ほとんどの配列が下限を 0 であるためこのメソッドは、通常 – 1 の場合に`value`が見つかりません。 配列の下限の境界が等しく、まれなケースで<xref:System.Int32.MinValue?displayProperty=nameWithType>と`value`が検出されなければ、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>、これは`System.Int32.MinValue - 1`します。  
  
 このメソッドは O (`n`) 操作、`n`は`count`します。  
  
 .NET framework version 2.0 では、このメソッドを使用して、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、<xref:System.Array>を決定するかどうか、<xref:System.Object>で指定された、`value`パラメーターが存在します。 以前のバージョンの .NET Framework では、この判断を使用して行われた、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、 `value` <xref:System.Object>自体。  
  
   
  
## Examples  
 次のコード例では、配列内の指定した要素の最後に見つかった位置のインデックスを確認する方法を示します。 なお、<xref:System.Array.LastIndexOf%2A>メソッドは、旧バージョンとの検索。 したがって、`count`に等しいまたはそれよりも小さい必要があります (`startIndex`マイナス 1 を足した数、配列の下限の境界)。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  または、<paramref name="count" /> が 0 未満です。  または、<paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <summary>指定したオブジェクトを <see cref="T:System.Array" /> 全体を対象に検索し、インデックス番号の最も大きい要素のインデックスを返します。</summary>
        <returns>
          <paramref name="value" /> 全体を対象として <paramref name="array" /> を検索し、見つかった場合は、インデックス番号の最も大きい要素の 0 から始まるインデックス番号。それ以外の場合は –1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>後方の最後の要素から開始し、最初の要素の終了が検索されます。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッド。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装が使用されます。  
  
 このメソッドは O (`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例は、すべて次の 3 つのジェネリック オーバー ロードを示して、<xref:System.Array.LastIndexOf%2A>メソッド。 インデックス位置 0 と 5 のインデックスの場所に 2 回、表示する 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードがから最後に、配列全体を検索し、文字列の 2 つ目の項目を検索します。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードを使用して検索インデックス 3 の場所で旧バージョンと開始位置の配列と、配列の先頭に進むと文字列の最初の出現箇所を検索します。 最後に、<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>メソッドのオーバー ロードを使用して検索インデックス位置 4 から、逆方向に拡張して、4 つのエントリの範囲 (つまり、その検索 4、3、2、および 1 の場所にある項目の場合); 検索のインスタンスが存在しないために、この検索は-1 を返しますその範囲内の文字列。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <param name="startIndex">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <summary>指定したオブジェクトを、<see cref="T:System.Array" /> の先頭の要素から、指定されたインデックス位置までを範囲として検索し、インデックス番号の最も大きい要素のインデックス番号を返します。</summary>
        <returns>
          <paramref name="value" /> の先頭の要素から <paramref name="array" /> までを範囲として <paramref name="startIndex" /> を検索し、見つかった場合は、インデックス番号の最も大きい要素の 0 から始まるインデックス番号。それ以外の場合は –1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>で検索された旧バージョンと開始`startIndex`と最初の要素で終了します。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッド。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装が使用されます。  
  
 このメソッドは O (`n`) 操作、`n`の先頭から要素の数は、`array`に`startIndex`します。  
  
   
  
## Examples  
 次のコード例は、すべて次の 3 つのジェネリック オーバー ロードを示して、<xref:System.Array.LastIndexOf%2A>メソッド。 インデックス位置 0 と 5 のインデックスの場所に 2 回、表示する 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードがから最後に、配列全体を検索し、文字列の 2 つ目の項目を検索します。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードを使用して検索インデックス 3 の場所で旧バージョンと開始位置の配列と、配列の先頭に進むと文字列の最初の出現箇所を検索します。 最後に、<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>メソッドのオーバー ロードを使用して検索インデックス位置 4 から、逆方向に拡張して、4 つのエントリの範囲 (つまり、その検索 4、3、2、および 1 の場所にある項目の場合); 検索のインスタンスが存在しないために、この検索は-1 を返しますその範囲内の文字列。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <param name="startIndex">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <summary>指定したオブジェクトを、<see cref="T:System.Array" /> の指定したインデックス位置から、指定した要素数を範囲として検索し、インデックス番号の最も大きい要素のインデックス番号を返します。</summary>
        <returns>
          <paramref name="value" /> の <paramref name="array" /> から <paramref name="count" /> 個の要素を範囲として <paramref name="startIndex" /> を検索し、見つかった場合は、インデックス番号の最も大きい要素の 0 から始まるインデックス番号。それ以外の場合は –1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>で検索された旧バージョンと開始`startIndex`で終わる`startIndex`マイナス`count`+ 1 場合、`count`が 0 より大きい。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッド。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装が使用されます。  
  
 このメソッドは O (`n`) 操作、`n`は`count`します。  
  
   
  
## Examples  
 次のコード例は、すべて次の 3 つのジェネリック オーバー ロードを示して、<xref:System.Array.LastIndexOf%2A>メソッド。 インデックス位置 0 と 5 のインデックスの場所に 2 回、表示する 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードがから最後に、配列全体を検索し、文字列の 2 つ目の項目を検索します。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードを使用して検索インデックス 3 の場所で旧バージョンと開始位置の配列と、配列の先頭に進むと文字列の最初の出現箇所を検索します。 最後に、<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>メソッドのオーバー ロードを使用して検索インデックス位置 4 から、逆方向に拡張して、4 つのエントリの範囲 (つまり、その検索 4、3、2、および 1 の場所にある項目の場合); 検索のインスタンスが存在しないために、この検索は-1 を返しますその範囲内の文字列。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。  または、<paramref name="count" /> が 0 未満です。  または、<paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> のすべての次元内の要素の総数を取得します。</summary>
        <value>すべての次元内の要素の合計数、<see cref="T:System.Array" />配列の要素がない場合はゼロ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.Length%2A>配列の要素の合計数を取得するプロパティ。 また、使用、<xref:System.Array.GetUpperBound%2A>多次元配列の各次元内の要素の数を決定するメソッド。  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">配列は多次元配列で、<see cref="F:System.Int32.MaxValue" /> 以上の要素を含みます。</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> のすべての次元内の要素の総数を表す 64 ビット整数を取得します。</summary>
        <value>
          <see cref="T:System.Array" /> のすべての次元内の要素の総数を表す 64 ビット整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> のランク (次元数) を取得します。 たとえば、1 次元配列は 1 を返し、2 次元配列は 2 を返すなどです。</summary>
        <value>
          <see cref="T:System.Array" /> のランク (次元数)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば、Visual Basic コード  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 c# コード  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 次の 3 つの次元の配列を作成、<xref:System.Array.Rank%2A>プロパティの値は 3 です。  
  
 ジャグ配列 (配列の配列) が 1 次元の配列です。値、<xref:System.Array.Rank%2A>プロパティが 1 にします。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
   
  
## Examples  
 次の例は、1 次元配列、2 次元の配列およびジャグ配列を初期化し、取得、<xref:System.Array.Rank%2A>の各プロパティ。  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize :  * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]&amp;" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">サイズ変更の対象となる、インデックス番号が 0 から始まる 1 次元配列。指定したサイズの新しい配列を作成する場合は <see langword="null" />。</param>
        <param name="newSize">新しい配列のサイズ。</param>
        <summary>1 次元配列の要素数を、指定した新しいサイズに変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、指定したサイズを新しい配列を割り当てますに、元の配列から要素をコピーし、元の配列を新しいものに置き換えます。 `array` 1 次元配列である必要があります。  
  
 場合`array`は`null`、このメソッドは、指定したサイズを新しい配列を作成します。  
  
 場合`newSize`がより大きい、<xref:System.Array.Length%2A>元の配列の新しい配列が割り当てられているし、新しいに元の配列からすべての要素がコピーされます。  場合`newSize`がより小さい<xref:System.Array.Length%2A>元の配列の新しい配列が割り当てられていると要素は、新しいに新しいが塗りつぶされるまでで、元の配列からコピーされます。 古い配列内の要素の残りの部分は無視されます。  場合`newSize`と等しい、<xref:System.Array.Length%2A>の元の配列では、このメソッドは何も行いません。  
  
 このメソッドは O (`n`) 操作、`n`は`newSize`します。  
  
 <xref:System.Array.Resize%2A>メソッドのみを 1 次元配列のサイズを変更します。 <xref:System.Array>多次元配列のサイズを変更するためのメソッドがクラスに含まれません。 これを行うには、独自のコードを提供するか、サード パーティ製ライブラリの特殊なメソッドを呼び出す必要があります。 次のコードが配列のサイズを変更する方法の 1 つの考えられる実装を示します*n*ディメンション。  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 次の例では、配列のサイズ変更の影響を示します。  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newSize" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1 次元 <see cref="T:System.Array" /> 内または <see cref="T:System.Array" /> の範囲内の要素の順序を反転させます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">反転させる 1 次元の <see cref="T:System.Array" />。</param>
        <summary>1 次元の <see cref="T:System.Array" /> 内全体の要素のシーケンスを反転させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出しの後にある要素は、このメソッドに`myArray[i]`ここで、`i`配列内のすべてのインデックスに移動します`myArray[j]`ここで、 `j` equals`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`します。  
  
 このメソッドは O (`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
 次の例に示すように、<xref:System.Array.Reverse%2A>ジャグ配列を反転させるメソッドを使用できます。 現在のカルチャのカレンダーの現在の年の各月の 1 つの要素でのジャグ配列を初期化します。 各要素には、その月の日と同じ数の要素の配列が含まれています。 例では、呼び出しを配列の内容を表示する、<xref:System.Array.Reverse%2A>メソッド、および、逆順の配列の内容が表示されます。  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 次のコード例の値の並べ替えを取り消す方法を示しています、<xref:System.Array>します。  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">反転させる 1 次元の <see cref="T:System.Array" />。</param>
        <param name="index">反転させる範囲の先頭位置を示すインデックス。</param>
        <param name="length">反転対象の範囲内にある要素の数。</param>
        <summary>1 次元 <see cref="T:System.Array" /> 内の要素範囲の並び順を反転させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出しの後にある要素は、このメソッドに`myArray[i]`ここで、`i`配列内のすべてのインデックスに移動します`myArray[j]`ここで、 `j` equals`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`します。  
  
 <xref:System.Array.Reverse%2A>ジャグ配列を反転させるメソッドを使用できます。  
  
 このメソッドは O (`n`) 操作、`n`は`length`します。  
  
   
  
## Examples  
 次のコード例は、内の要素の範囲内の値の並べ替えを取り消す方法を示しています、<xref:System.Array>します。  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  または、<paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Array" /> 内の指定した要素を指定した値に設定します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="index">設定する <see cref="T:System.Array" /> 要素の位置を表す 32 ビット整数。</param>
        <summary>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドを調べるかどうかの値`index`が範囲外です。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>します。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありませんし、null 参照を検索して見つかったことはできません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> が完全な 1 次元ではありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> を現在の <see cref="T:System.Array" /> の要素の型にキャストできません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> が、現在の <see cref="T:System.Array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="indices">設定する要素の位置を指定するインデックスを表す 32 ビット整数の 1 次元配列。</param>
        <summary>多次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 32 ビット整数値の配列として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素数`indices`の次元数と同じにする必要があります、<xref:System.Array>します。 すべての要素、`indices`配列が多次元で、目的の要素の位置をまとめて指定する必要があります<xref:System.Array>します。  
  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>かどうかの値のいずれかの方法を調べる、`indices`配列が範囲外です。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>します。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありませんし、null 参照を検索して見つかったことはできません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> の次元数が、<paramref name="indices" /> 内の要素数と等しくありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> を現在の <see cref="T:System.Array" /> の要素の型にキャストできません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="indices" /> 内のいずれかの要素が、現在の <see cref="T:System.Array" /> 内の対応する次元の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="index">設定する <see cref="T:System.Array" /> 要素の位置を表す 64 ビット整数。</param>
        <summary>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 このインデックスは 64 ビット整数値として指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドを調べるかどうかの値`index`が範囲外です。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>します。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありませんし、null 参照を検索して見つかったことはできません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> が完全な 1 次元ではありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> を現在の <see cref="T:System.Array" /> の要素の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が、現在の <see cref="T:System.Array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="indices">設定する要素の位置を指定するインデックスを表す 64 ビット整数の 1 次元配列。</param>
        <summary>多次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 64 ビット整数値の配列として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素数`indices`の次元数と同じにする必要があります、<xref:System.Array>します。 すべての要素、`indices`配列が多次元で、目的の要素の位置をまとめて指定する必要があります<xref:System.Array>します。  
  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>かどうかの値のいずれかの方法を調べる、`indices`配列が範囲外です。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>します。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありませんし、null 参照を検索して見つかったことはできません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> の次元数が、<paramref name="indices" /> 内の要素数と等しくありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> を現在の <see cref="T:System.Array" /> の要素の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indices" /> 内のいずれかの要素が、現在の <see cref="T:System.Array" /> 内の対応する次元の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="index1">設定する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 32 ビット整数。</param>
        <param name="index2">設定する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 32 ビット整数。</param>
        <summary>2 次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドが範囲外のインデックスのいずれかがいるかどうかを判断することができます。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>します。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありませんし、null 参照を検索して見つかったことはできません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確な 2 次元配列ではありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> を現在の <see cref="T:System.Array" /> の要素の型にキャストできません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> または <paramref name="index2" /> が、現在の <see cref="T:System.Array" /> の対応する次元の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="index1">設定する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index2">設定する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 64 ビット整数。</param>
        <summary>2 次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 64 ビット整数として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドが範囲外のインデックスのいずれかがいるかどうかを判断することができます。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>します。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありませんし、null 参照を検索して見つかったことはできません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確な 2 次元配列ではありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> を現在の <see cref="T:System.Array" /> の要素の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> または <paramref name="index2" /> が、現在の <see cref="T:System.Array" /> の対応する次元の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="index1">設定する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 32 ビット整数。</param>
        <param name="index2">設定する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 32 ビット整数。</param>
        <param name="index3">設定する <see cref="T:System.Array" /> 要素の 3 番目の次元のインデックスを表す 32 ビット整数。</param>
        <summary>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドが範囲外のインデックスのいずれかがいるかどうかを判断することができます。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>します。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありませんし、null 参照を検索して見つかったことはできません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確な 3 次元配列ではありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> を現在の <see cref="T:System.Array" /> の要素の型にキャストできません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" />、<paramref name="index2" />、または <paramref name="index3" /> が、現在の <see cref="T:System.Array" /> の対応する次元の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="index1">設定する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index2">設定する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index3">設定する <see cref="T:System.Array" /> 要素の 3 番目の次元のインデックスを表す 64 ビット整数。</param>
        <summary>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 64 ビット整数として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドが範囲外のインデックスのいずれかがいるかどうかを判断することができます。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>します。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありませんし、null 参照を検索して見つかったことはできません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確な 3 次元配列ではありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> を現在の <see cref="T:System.Array" /> の要素の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" />、<paramref name="index2" />、または <paramref name="index3" /> が、現在の <see cref="T:System.Array" /> の対応する次元の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1 次元配列の要素を並べ替えます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">並べ替え対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <summary>
          <see cref="T:System.Array" /> の各要素によって実装された <see cref="T:System.IComparable" /> を使用して、1 次元 <see cref="T:System.Array" /> 全体の要素を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各要素`array`実装する必要があります、<xref:System.IComparable>の他のすべての要素との比較ができるようにするインターフェイス`array`します。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、とおり内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズム。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲は、使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズム。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズム。  
  
 この実装は、不安定な並べ替えを実行します。2 つの要素が等しい場合は、その順序は保持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例の値を並べ替える方法を示しています、<xref:System.Array>既定の比較子と並べ替え順序を反転するカスタム比較子を使用します。 結果は、現在によって異なる場合がありますので注意<xref:System.Globalization.CultureInfo>します。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" /> の 1 つ以上の要素が、<see cref="T:System.IComparable" /> インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys">並べ替え対象となるキーを格納する 1 次元 <see cref="T:System.Array" />。</param>
        <param name="items">
          <c>keys</c>
          <see cref="T:System.Array" /> 内の各キーに対応する項目を格納する 1 次元 <see cref="T:System.Array" />。  または、<c>keys</c><see cref="T:System.Array" /> のみを並べ替える場合は <see langword="null" />。</param>
        <summary>2 つの 1 次元 <see cref="T:System.Array" /> オブジェクト (一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する) を、最初の <see cref="T:System.Array" /> 内のキーに基づき、各キーによって実装された <see cref="T:System.IComparable" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>します。 並べ替え、対応する項目の中に、キーが移動したときに、 `items` <xref:System.Array>同様の位置を変更します。 そのため、 `items` <xref:System.Array>が内の対応するキーの並べ替えに従って並び替え、 `keys`<xref:System.Array>します。  
  
 各キーに、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable>他のすべてのキーの比較ができるようにするインターフェイス。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合は並べ替えることができます。 項目よりも多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>します。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、とおり内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズム。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲は、使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズム。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズム。  
  
 この実装は、不安定な並べ替えを実行します。2 つの要素が等しい場合は、その順序は保持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`keys`します。  
  
   
  
## Examples  
 次の例では、キーと値を格納する 2 番目の配列の 2 つの関連付けられている配列を並べ替える方法を示します。 並べ替えが完了したら、既定の比較子と並べ替え順序を反転するカスタム比較子を使用します。 結果は、現在によって異なる場合がありますので注意<xref:System.Globalization.CultureInfo>します。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> が多次元です。  または、<paramref name="items" /><see cref="T:System.Array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> が <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さを超えています。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 内の 1 つ以上の要素に <see cref="T:System.IComparable" /> インターフェイスが実装されていません。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">並べ替え対象となる 1 次元配列。</param>
        <param name="comparer">要素を比較する場合に使用する実装。  または、各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>1 次元 <see cref="T:System.Array" /> 内の要素を、指定した <see cref="T:System.Collections.IComparer" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`comparer`は`null`の各要素`array`実装する必要があります、<xref:System.IComparable>の他のすべての要素との比較ができるようにするインターフェイス`array`します。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、とおり内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズム。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲は、使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズム。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズム。  
  
 この実装は、不安定な並べ替えを実行します。2 つの要素が等しい場合は、その順序は保持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
 .NET Framework が含まれています定義済み<xref:System.Collections.IComparer>実装は、次の表に一覧表示します。  
  
|実装|説明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|任意の 2 つのオブジェクトを比較しますが、大文字と小文字の文字列を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|現在のカルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|インバリアント カルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|型の 2 つのオブジェクトを比較`T`型の既定の並べ替え順序を使用しています。|  
  
 独自のインスタンスを提供することで、カスタム比較をサポートすることも<xref:System.Collections.IComparer>を実装、`comparer`パラメーター。 定義することでこの例では、`ReverseComparer`クラスの既定の並べ替え順序を反転する型のインスタンスと大文字の文字列比較を実行します。  
  
   
  
## Examples  
 次の例では、既定の比較子を使用して文字列 arrayby 内の値を並べ替えます。 カスタムも定義されています。<xref:System.Collections.IComparer>という名前の実装`ReverseComparer`大文字の文字列比較の実行中に、オブジェクトの既定の並べ替え順序を反転します。 出力は、現在のカルチャによって異なる場合がありますに注意してください。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="array" /> の 1 つ以上の要素が <see cref="T:System.IComparable" /> インターフェイスを実装していません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 と以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートは、状況によっては、並べ替え操作がスローされます、無効な比較演算子を識別、 <see cref="T:System.IndexOutOfRangeException" /> 、例外をスローします、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降では、[!INCLUDE[net_v45](~/includes/net-v45-md.md)]、並べ替え操作が以前スローしたことは<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較子が検出されないため、例外をスローできません。ほとんどの場合、これよりも少ない 16 個の要素を配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">並べ替え対象となるキーを格納する 1 次元 <see cref="T:System.Array" />。</param>
        <param name="items">
          <c>keys</c>
          <see cref="T:System.Array" /> 内の各キーに対応する項目を格納する 1 次元 <see cref="T:System.Array" />。  または、<c>keys</c><see cref="T:System.Array" /> のみを並べ替える場合は <see langword="null" />。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  または、各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>2 つの 1 次元 <see cref="T:System.Array" /> オブジェクト (一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する) を、最初の <see cref="T:System.Array" /> 内のキーに基づき、指定した <see cref="T:System.Collections.IComparer" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>します。 並べ替え、対応する項目の中に、キーが移動したときに、 `items` <xref:System.Array>同様の位置を変更します。 そのため、 `items` <xref:System.Array>が内の対応するキーの並べ替えに従って並び替え、 `keys`<xref:System.Array>します。  
  
 場合`comparer`は`null`、それぞれのキー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable>他のすべてのキーの比較ができるようにするインターフェイス。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合は並べ替えることができます。 項目よりも多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>します。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 .NET Framework が含まれています定義済み<xref:System.Collections.IComparer>実装は、次の表に一覧表示します。  
  
|実装|説明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|任意の 2 つのオブジェクトを比較しますが、大文字と小文字の文字列を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|現在のカルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|インバリアント カルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|型の 2 つのオブジェクトを比較`T`型の既定の並べ替え順序を使用しています。|  
  
 独自のインスタンスを提供することで、カスタム比較をサポートすることも<xref:System.Collections.IComparer>を実装、`comparer`パラメーター。 定義することでこの例では、<xref:System.Collections.IComparer>既定の並べ替え順序を反転し、大文字の文字列を比較する実装。  
  
 このメソッドは、とおり内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズム。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲は、使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズム。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズム。  
  
 この実装は、不安定な並べ替えを実行します。2 つの要素が等しい場合は、その順序は保持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`keys`します。  
  
   
  
## Examples  
 次の例では、キーと値を格納する 2 番目の配列の 2 つの関連付けられている配列を並べ替える方法を示します。 並べ替えが完了したら、既定の比較子と並べ替え順序を反転するカスタム比較子を使用します。 結果は、現在によって異なる場合がありますので注意<xref:System.Globalization.CultureInfo>します。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> が多次元です。  または、<paramref name="items" /><see cref="T:System.Array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> が <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さを超えています。  または、<paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> であり、<paramref name="keys" /><see cref="T:System.Array" /> 内の 1 つ以上の要素に <see cref="T:System.IComparable" /> インターフェイスが実装されていません。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 と以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートは、状況によっては、並べ替え操作がスローされます、無効な比較演算子を識別、 <see cref="T:System.IndexOutOfRangeException" /> 、例外をスローします、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降では、[!INCLUDE[net_v45](~/includes/net-v45-md.md)]、可能性がする並べ替え操作をその previouslythrew<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較子が検出されないため、例外をスローできません。ほとんどの場合、これよりも少ない 16 個の要素を配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">並べ替え対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <summary>
          <see cref="T:System.Array" /> の各要素によって実装された <see cref="T:System.IComparable" /> を使用して、1 次元 <see cref="T:System.Array" /> の要素範囲を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内の要素の指定した範囲内の各要素`array`実装する必要があります、<xref:System.IComparable>の他のすべての要素との比較ができるようにするインターフェイス`array`します。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、とおり内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズム。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲は、使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズム。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズム。  
  
 この実装は、不安定な並べ替えを実行します。2 つの要素が等しい場合は、その順序は保持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作、`n`は`length`します。  
  
   
  
## Examples  
 次のコード例の値を並べ替える方法を示しています、<xref:System.Array>既定の比較子と並べ替え順序を反転するカスタム比較子を使用します。 結果は、現在によって異なる場合がありますので注意<xref:System.Globalization.CultureInfo>します。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  または、<paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" /> の 1 つ以上の要素が、<see cref="T:System.IComparable" /> インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys">並べ替え対象となるキーを格納する 1 次元 <see cref="T:System.Array" />。</param>
        <param name="items">
          <c>keys</c>
          <see cref="T:System.Array" /> 内の各キーに対応する項目を格納する 1 次元 <see cref="T:System.Array" />。  または、<c>keys</c><see cref="T:System.Array" /> のみを並べ替える場合は <see langword="null" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <summary>2 つの 1 次元 <see cref="T:System.Array" /> オブジェクト (一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する) の要素範囲を、最初の <see cref="T:System.Array" /> 内のキーに基づき、各キーによって実装された <see cref="T:System.IComparable" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>します。 並べ替え、対応する項目の中に、キーが移動したときに、 `items` <xref:System.Array>同様の位置を変更します。 そのため、 `items` <xref:System.Array>が内の対応するキーの並べ替えに従って並び替え、 `keys`<xref:System.Array>します。  
  
 指定した範囲内の要素の各キー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable>他のすべてのキーの比較ができるようにするインターフェイス。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合は並べ替えることができます。 項目よりも多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>します。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、とおり内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズム。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲は、使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズム。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズム。  
  
 この実装は、不安定な並べ替えを実行します。2 つの要素が等しい場合は、その順序は保持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作、`n`は`length`します。  
  
   
  
## Examples  
 次のコード例では、キーと値を格納する 2 番目の配列の 2 つの関連付けられている配列を並べ替える方法を示します。 並べ替えが完了したら、既定の比較子と並べ替え順序を反転するカスタム比較子を使用します。 結果は、現在によって異なる場合がありますので注意<xref:System.Globalization.CultureInfo>します。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> が多次元です。  または、<paramref name="items" /><see cref="T:System.Array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="keys" /> の下限を下回っています。  または、<paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> が <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さを超えています。  または、<paramref name="index" /> および <paramref name="length" /> は <paramref name="keys" /><see cref="T:System.Array" /> において有効な範囲を指定していません。  または、<paramref name="items" /> は <see langword="null" /> でなく、<paramref name="index" /> と <paramref name="length" /> は <paramref name="items" /><see cref="T:System.Array" /> において有効な範囲を指定していません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 内の 1 つ以上の要素に <see cref="T:System.IComparable" /> インターフェイスが実装されていません。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">並べ替え対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  または、各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>1 次元 <see cref="T:System.Array" /> の範囲内の要素範囲を、指定した <see cref="T:System.Collections.IComparer" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`comparer`は`null`、内の要素の指定した範囲内の各要素`array`実装する必要があります、<xref:System.IComparable>の他のすべての要素との比較ができるようにするインターフェイス`array`します。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 .NET Framework が含まれています定義済み<xref:System.Collections.IComparer>実装は、次の表に一覧表示します。  
  
|実装|説明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|任意の 2 つのオブジェクトを比較しますが、大文字と小文字の文字列を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|現在のカルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|インバリアント カルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|型の 2 つのオブジェクトを比較`T`型の既定の並べ替え順序を使用しています。|  
  
 独自のインスタンスを提供することで、カスタム比較をサポートすることも<xref:System.Collections.IComparer>を実装、`comparer`パラメーター。 定義することでこの例では、`ReverseComparer`クラスの既定の並べ替え順序を反転する型のインスタンスと大文字の文字列比較を実行します。  
  
 このメソッドは、とおり内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズム。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲は、使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズム。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズム。  
  
 この実装は、不安定な並べ替えを実行します。2 つの要素が等しい場合は、その順序は保持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作、`n`は`length`します。  
  
   
  
## Examples  
 次のコード例の値を並べ替える方法を示しています、<xref:System.Array>既定の比較子と並べ替え順序を反転するカスタム比較子を使用します。 結果は、現在によって異なる場合がありますので注意<xref:System.Globalization.CultureInfo>します。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  または、<paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  または、<paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="array" /> の 1 つ以上の要素が <see cref="T:System.IComparable" /> インターフェイスを実装していません。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 と以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートは、状況によっては、並べ替え操作がスローされます、無効な比較演算子を識別、 <see cref="T:System.IndexOutOfRangeException" /> 、例外をスローします、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降では、[!INCLUDE[net_v45](~/includes/net-v45-md.md)]、並べ替え操作が以前スローしたことは<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較子が検出されないため、例外をスローできません。ほとんどの場合、これよりも少ない 16 個の要素を配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">並べ替え対象となるキーを格納する 1 次元 <see cref="T:System.Array" />。</param>
        <param name="items">
          <c>keys</c>
          <see cref="T:System.Array" /> 内の各キーに対応する項目を格納する 1 次元 <see cref="T:System.Array" />。  または、<c>keys</c><see cref="T:System.Array" /> のみを並べ替える場合は <see langword="null" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  または、各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>2 つの 1 次元 <see cref="T:System.Array" /> オブジェクト (一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する) 内の要素範囲を、最初の <see cref="T:System.Array" /> 内のキーに基づき、指定した <see cref="T:System.Collections.IComparer" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>します。 並べ替え、対応する項目の中に、キーが移動したときに、 `items` <xref:System.Array>同様の位置を変更します。 そのため、 `items` <xref:System.Array>が内の対応するキーの並べ替えに従って並び替え、 `keys`<xref:System.Array>します。  
  
 場合`comparer`は`null`、内の要素の指定された範囲内の各キー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable>他のすべてのキーの比較ができるようにするインターフェイス。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合は並べ替えることができます。 項目よりも多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>します。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 .NET Framework が含まれています定義済み<xref:System.Collections.IComparer>実装は、次の表に一覧表示します。  
  
|実装|説明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|任意の 2 つのオブジェクトを比較しますが、大文字と小文字の文字列を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|現在のカルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|インバリアント カルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|型の 2 つのオブジェクトを比較`T`型の既定の並べ替え順序を使用しています。|  
  
 独自のインスタンスを提供することで、カスタム比較をサポートすることも<xref:System.Collections.IComparer>を実装、`comparer`パラメーター。 この例ではこのカスタムを定義することで<xref:System.Collections.IComparer>既定の並べ替え順序を反転し、大文字の文字列を比較する実装。  
  
 このメソッドは、とおり内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズム。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲は、使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズム。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズム。  
  
 この実装は、不安定な並べ替えを実行します。2 つの要素が等しい場合は、その順序は保持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作、`n`は`length`します。  
  
   
  
## Examples  
 次のコード例では、キーと値を格納する 2 番目の配列の 2 つの関連付けられている配列を並べ替える方法を示します。 並べ替えが完了したら、既定の比較子と並べ替え順序を反転するカスタム比較子を使用します。 結果は、現在によって異なる場合がありますので注意<xref:System.Globalization.CultureInfo>します。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> が多次元です。  または、<paramref name="items" /><see cref="T:System.Array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="keys" /> の下限を下回っています。  または、<paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> が <see langword="null" /> ではなく、<paramref name="keys" /> の下限が <paramref name="items" /> の下限と一致していません。  または、<paramref name="items" /> が <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さを超えています。  または、<paramref name="index" /> および <paramref name="length" /> は <paramref name="keys" /><see cref="T:System.Array" /> において有効な範囲を指定していません。  または、<paramref name="items" /> は <see langword="null" /> でなく、<paramref name="index" /> と <paramref name="length" /> は <paramref name="items" /><see cref="T:System.Array" /> において有効な範囲を指定していません。  または、<paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> であり、<paramref name="keys" /><see cref="T:System.Array" /> 内の 1 つ以上の要素に <see cref="T:System.IComparable" /> インターフェイスが実装されていません。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 と以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートは、状況によっては、並べ替え操作がスローされます、無効な比較演算子を識別、 <see cref="T:System.IndexOutOfRangeException" /> 、例外をスローします、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降では、[!INCLUDE[net_v45](~/includes/net-v45-md.md)]、並べ替え操作が以前スローしたことは<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較子が検出されないため、例外をスローできません。ほとんどの場合、これよりも少ない 16 個の要素を配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">並べ替え対象となる、インデックス番号が 0 から始まる 1 次元 <see cref="T:System.Array" />。</param>
        <summary>
          <see cref="T:System.Array" /> の各要素によって実装された <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用して、<see cref="T:System.Array" /> 全体の要素を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各要素`array`実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスの他のすべての要素との比較ができるようにする`array`します。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、とおり内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズム。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲は、使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズム。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズム。  
  
 この実装は、不安定な並べ替えを実行します。2 つの要素が等しい場合は、その順序は保持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例に示します、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>ジェネリック メソッドのオーバー ロードと<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ジェネリック メソッドのオーバー ロードします。 文字列の配列は、任意の順序に作成されます。  
  
 配列が表示され、並べ替え、もう一度表示されます。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%2A>と<xref:System.Array.BinarySearch%2A>Visual Basic、c#、および C++ は、最初の引数の型とジェネリック型パラメーターの型を推論するため、ジェネリック メソッドの呼び出しを非ジェネリックの対応する間に違い探さないです。 使用する場合、 [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ジェネリック メソッドのオーバー ロードが 2 つの文字列を検索するために使用しではない配列および 1 つを 1 つです。 配列との戻り値、<xref:System.Array.BinarySearch%2A>メソッドに渡される、`ShowWhere`ジェネリック メソッドは、それ以外の場合、要素検索文字列が間に、配列を使用した場合、文字列が見つかった場合は、インデックス値を表示します。 インデックスが負の値、文字列は、n がない場合、配列のため、`ShowWhere`メソッドは、ビットごとの補数 (、~ c# および Visual C は、演算子`Xor`Visual Basic で-1) 検索からよりも大きい一覧の最初の要素のインデックスを取得するにはng です。  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" /> の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">並べ替える 1 次元の <see cref="T:System.Array" />。インデックス番号が 0 から始まる必要があります。</param>
        <param name="comparer">要素を比較する際に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスの実装。各要素が実装する <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用する場合は <see langword="null" />。</param>
        <summary>
          <see cref="T:System.Array" /> 内の要素を、指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`comparer`は`null`の各要素`array`実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスの他のすべての要素との比較ができるようにする`array`します。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、とおり内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズム。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲は、使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズム。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズム。  
  
 この実装は、不安定な並べ替えを実行します。2 つの要素が等しい場合は、その順序は保持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例に示します、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードと<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードします。  
  
 コード例では、という名前の文字列の代替の比較子を定義します。 `ReverseCompare`、実装、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual c で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッドは、文字列は、低-高のではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 配列が表示され、並べ替え、もう一度表示されます。 使用するには、配列を並べ替える必要があります、<xref:System.Array.BinarySearch%2A>メソッド。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>と<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>Visual Basic、c#、および C++ は、最初の引数の型とジェネリック型パラメーターの型を推論するため、ジェネリック メソッドの呼び出しを非ジェネリックの対応する間に違い探さないです。 使用する場合、 [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードが 2 つの文字列を検索するために使用しではない配列および 1 つを 1 つです。 配列との戻り値、<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>メソッドに渡される、`ShowWhere`ジェネリック メソッドは、それ以外の場合、要素検索文字列が間に、配列を使用した場合、文字列が見つかった場合は、インデックス値を表示します。 インデックスが負の値、文字列は、n がない場合、配列のため、`ShowWhere`メソッドは、ビットごとの補数 (、~ c# および Visual C は、演算子`Xor`Visual Basic で-1) 検索からよりも大きい一覧の最初の要素のインデックスを取得するにはng です。  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="array" /> の 1 つ以上の要素が <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 と以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートは、状況によっては、並べ替え操作がスローされます、無効な比較演算子を識別、 <see cref="T:System.IndexOutOfRangeException" /> 、例外をスローします、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降では、[!INCLUDE[net_v45](~/includes/net-v45-md.md)]、並べ替え操作が以前スローしたことは<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較子が検出されないため、例外をスローできません。ほとんどの場合、これよりも少ない 16 個の要素を配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">並べ替える 1 次元の <see cref="T:System.Array" />。インデックス番号が 0 から始まる必要があります。</param>
        <param name="comparison">要素を比較する場合に使用する <see cref="T:System.Comparison`1" />。</param>
        <summary>
          <see cref="T:System.Array" /> 内の要素を、指定した <see cref="T:System.Comparison`1" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、とおり内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズム。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲は、使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズム。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズム。  
  
 この実装は、不安定な並べ替えを実行します。2 つの要素が等しい場合は、その順序は保持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例に示します、<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>メソッドのオーバー ロードします。  
  
 コード例は、という名前の文字列の代替の比較メソッドを定義`CompareDinosByLength`します。 このメソッドは次のように機能します。 最初に、テスト、comparandsare`null`、し、null 参照が null でない未満として扱われます。 次に、文字列の長さを比較してより長い文字列が大きいと見なされます。 3 番目に、長さが等しい場合は、通常の文字列比較が使用されます。  
  
 文字列の配列が作成され、任意の順序で、4 つの文字列に設定されます。 一覧には、空の文字列と null 参照も含まれています。 一覧を表示すると、並べ替えを使用して、<xref:System.Comparison%601>を表すジェネリック デリゲート、`CompareDinosByLength`メソッドを再び表示されます。  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。  または、<paramref name="comparison" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparison" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparison" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 と以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートは、状況によっては、並べ替え操作がスローされます、無効な比較演算子を識別、 <see cref="T:System.IndexOutOfRangeException" /> 、例外をスローします、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降では、[!INCLUDE[net_v45](~/includes/net-v45-md.md)]、並べ替え操作が以前スローしたことは<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較子が検出されないため、例外をスローできません。ほとんどの場合、これよりも少ない 16 個の要素を配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">並べ替える 1 次元の <see cref="T:System.Array" />。インデックス番号が 0 から始まる必要があります。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <summary>
          <see cref="T:System.Array" /> の各要素によって実装された <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用して、<see cref="T:System.Array" /> の要素範囲を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内の要素の指定した範囲内の各要素`array`実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスの他のすべての要素との比較ができるようにする`array`します。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、とおり内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズム。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲は、使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズム。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズム。  
  
 この実装は、不安定な並べ替えを実行します。2 つの要素が等しい場合は、その順序は保持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作、`n`は`length`します。  
  
   
  
## Examples  
 次のコード例に示します、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>ジェネリック メソッドのオーバー ロードと<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>配列内の範囲の並べ替えのジェネリック メソッドのオーバー ロードします。  
  
 コード例では、という名前の文字列の代替の比較子を定義します。 `ReverseCompare`、実装、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual c で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッドは、文字列は、低-高のではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、配列では、正確に) 後に次の 3 つの恐竜から成る、恐竜名が表示されます。 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>ジェネリック メソッドのオーバー ロードが表示されると、配列の最後の 3 つの要素の並べ替えに使用します。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードが併用`ReverseCompare`最後の 3 つの要素を逆の順序で並べ替える。 完全に混乱した恐竜が再度表示されます。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>と<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>Visual Basic、c#、および C++ は、最初の引数の型とジェネリック型パラメーターの型を推論するため、ジェネリック メソッドの呼び出しを非ジェネリックの対応する間に違い探さないです。 使用する場合、 [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  または、<paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" /> の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">並べ替え対象となる、インデックス番号が 0 から始まる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <param name="comparer">要素を比較する際に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスの実装。各要素が実装する <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用する場合は <see langword="null" />。</param>
        <summary>指定した <see cref="T:System.Array" /> ジェネリック インターフェイスを使用して、<see cref="T:System.Collections.Generic.IComparer`1" /> 内の要素範囲を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`comparer`は`null`、内の要素の指定した範囲内の各要素`array`実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスの他のすべての要素との比較ができるようにする`array`します。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、とおり内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズム。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲は、使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズム。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズム。  
  
 この実装は、不安定な並べ替えを実行します。2 つの要素が等しい場合は、その順序は保持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作、`n`は`length`します。  
  
   
  
## Examples  
 次のコード例に示します、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>ジェネリック メソッドのオーバー ロードと<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>配列内の範囲の並べ替えのジェネリック メソッドのオーバー ロードします。  
  
 コード例では、という名前の文字列の代替の比較子を定義します。 `ReverseCompare`、実装、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual c で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッドは、文字列は、低-高のではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、配列では、正確に) 後に次の 3 つの恐竜から成る、恐竜名が表示されます。 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>ジェネリック メソッドのオーバー ロードが表示されると、配列の最後の 3 つの要素の並べ替えに使用します。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードが併用`ReverseCompare`最後の 3 つの要素を逆の順序で並べ替える。 完全に混乱した恐竜が再度表示されます。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>と<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>Visual Basic、c#、および C++ は、最初の引数の型とジェネリック型パラメーターの型を推論するため、ジェネリック メソッドの呼び出しを非ジェネリックの対応する間に違い探さないです。 使用する場合、 [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  または、<paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  または、<paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="array" /> の 1 つ以上の要素が <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 と以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートは、状況によっては、並べ替え操作がスローされます、無効な比較演算子を識別、 <see cref="T:System.IndexOutOfRangeException" /> 、例外をスローします、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降では、[!INCLUDE[net_v45](~/includes/net-v45-md.md)]、並べ替え操作が以前スローしたことは<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較子が検出されないため、例外をスローできません。ほとんどの場合、これよりも少ない 16 個の要素を配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">並べ替えるキーを格納している 1 次元の <see cref="T:System.Array" />。インデックス番号が 0 から始まる必要があります。</param>
        <param name="items">
          <c>keys</c> 内のキーに対応する項目が格納されている 1 次元の <see cref="T:System.Array" /> (インデックス番号は 0 から始まります)。<c>keys</c> のみを並べ替える場合は <see langword="null" />。</param>
        <summary>2 つの <see cref="T:System.Array" /> オブジェクト (一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する) を、最初の <see cref="T:System.Array" /> 内のキーに基づき、各キーによって実装された <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>します。 並べ替え、対応する項目の中に、キーが移動したときに、 `items` <xref:System.Array>同様の位置を変更します。 そのため、 `items` <xref:System.Array>が内の対応するキーの並べ替えに従って並び替え、 `keys`<xref:System.Array>します。  
  
 各キーに、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスとその他のすべてのキーの比較ができるようにします。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合は並べ替えることができます。 項目よりも多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>します。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、とおり内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズム。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲は、使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズム。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズム。  
  
 この実装は、不安定な並べ替えを実行します。2 つの要素が等しい場合は、その順序は保持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例に示します、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>、および<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>の並べ替えキーと値を表す配列のペアのジェネリック メソッドのオーバー ロードします。  
  
 コード例では、という名前の文字列の代替の比較子を定義します。 `ReverseCompare`、実装、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual c で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッドは、文字列は、低-高のではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前 (キー) の配列と各恐竜 (値) のメートル単位の最大長を表す整数の配列が表示されます。 アレイは、並べ替えし、複数回表示されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>オーバー ロードは、最初の配列での恐竜名の順序で両方の配列の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロードのインスタンスおよび`ReverseCompare`ペアの配列の並べ替え順序を反転させるために使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードが両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロードは逆の順序で両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
> [!NOTE]
>  ジェネリック メソッドの呼び出しを探さない、対応する非への呼び出しから、さまざまな Visual Basic、c#、および C++ 最初の 2 つの引数の型からのジェネリック型パラメーターの型を推論するためです。 使用する場合、 [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> が <see langword="null" /> ではなく、<paramref name="keys" /> の下限が <paramref name="items" /> の下限と一致していません。  または、<paramref name="items" /> が <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さを超えています。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 内の 1 つ以上の要素に <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスが実装されていません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">並べ替えるキーを格納している 1 次元の <see cref="T:System.Array" />。インデックス番号が 0 から始まる必要があります。</param>
        <param name="items">
          <c>keys</c> 内のキーに対応する項目が格納されている 1 次元の <see cref="T:System.Array" /> (インデックス番号は 0 から始まります)。<c>keys</c> のみを並べ替える場合は <see langword="null" />。</param>
        <param name="comparer">要素を比較する際に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスの実装。各要素が実装する <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用する場合は <see langword="null" />。</param>
        <summary>2 つの <see cref="T:System.Array" /> オブジェクト (一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する) を、最初の <see cref="T:System.Array" /> 内のキーに基づき、指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>します。 並べ替え、対応する項目の中に、キーが移動したときに、 `items` <xref:System.Array>同様の位置を変更します。 そのため、 `items` <xref:System.Array>が内の対応するキーの並べ替えに従って並び替え、 `keys`<xref:System.Array>します。  
  
 場合`comparer`は`null`、それぞれのキー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスとその他のすべてのキーの比較ができるようにします。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合は並べ替えることができます。 項目よりも多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>します。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、とおり内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズム。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲は、使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズム。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズム。  
  
 この実装は、不安定な並べ替えを実行します。2 つの要素が等しい場合は、その順序は保持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例に示します、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、[\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>の並べ替えキーと値を表す配列のペアのジェネリック メソッドのオーバー ロードします。  
  
 コード例では、という名前の文字列の代替の比較子を定義します。 `ReverseCompare`、実装、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual c で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッドは、文字列は、低-高のではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前 (キー) の配列と各恐竜 (値) のメートル単位の最大長を表す整数の配列が表示されます。 アレイは、並べ替えし、複数回表示されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>オーバー ロードは、最初の配列での恐竜名の順序で両方の配列の並べ替えに使用します。  
  
-   [\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > オーバー ロードのインスタンスおよび`ReverseCompare`並べ替え順序を反転させるために使用ペアの配列。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードが両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロードは逆の順序で両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
> [!NOTE]
>  ジェネリック メソッドの呼び出しを探さない、対応する非への呼び出しから、さまざまな Visual Basic、c#、および C++ 最初の 2 つの引数の型からのジェネリック型パラメーターの型を推論するためです。 使用する場合、 [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> が <see langword="null" /> ではなく、<paramref name="keys" /> の下限が <paramref name="items" /> の下限と一致していません。  または、<paramref name="items" /> が <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さを超えています。  または、<paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> であり、<paramref name="keys" /><see cref="T:System.Array" /> 内の 1 つ以上の要素に <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスが実装されていません。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 と以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートは、状況によっては、並べ替え操作がスローされます、無効な比較演算子を識別、 <see cref="T:System.IndexOutOfRangeException" /> 、例外をスローします、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降では、[!INCLUDE[net_v45](~/includes/net-v45-md.md)]、並べ替え操作が以前スローしたことは<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較子が検出されないため、例外をスローできません。ほとんどの場合、これよりも少ない 16 個の要素を配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">並べ替えるキーを格納している 1 次元の <see cref="T:System.Array" />。インデックス番号が 0 から始まる必要があります。</param>
        <param name="items">
          <c>keys</c> 内のキーに対応する項目が格納されている 1 次元の <see cref="T:System.Array" /> (インデックス番号は 0 から始まります)。<c>keys</c> のみを並べ替える場合は <see langword="null" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <summary>2 つの <see cref="T:System.Array" /> オブジェクト (一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する) の要素範囲を、最初の <see cref="T:System.Array" /> 内のキーに基づき、各キーによって実装された <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>します。 並べ替え、対応する項目の中に、キーが移動したときに、 `items` <xref:System.Array>同様の位置を変更します。 そのため、 `items` <xref:System.Array>が内の対応するキーの並べ替えに従って並び替え、 `keys`<xref:System.Array>します。  
  
 指定した範囲内の要素の各キー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスとその他のすべてのキーの比較ができるようにします。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合は並べ替えることができます。 項目よりも多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>します。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、とおり内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズム。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲は、使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズム。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズム。  
  
 この実装は、不安定な並べ替えを実行します。2 つの要素が等しい場合は、その順序は保持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作、`n`は`length`します。  
  
   
  
## Examples  
 次のコード例に示します、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、[\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >、および<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロード、並べ替えキーと値を表す配列のペア。  
  
 コード例では、という名前の文字列の代替の比較子を定義します。 `ReverseCompare`、実装、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual c で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッドは、文字列は、低-高のではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前 (キー) の配列と各恐竜 (値) のメートル単位の最大長を表す整数の配列が表示されます。 アレイは、並べ替えし、複数回表示されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>オーバー ロードは、最初の配列での恐竜名の順序で両方の配列の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロードのインスタンスおよび`ReverseCompare`ペアの配列の並べ替え順序を反転させるために使用します。  
  
-   [\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > オーバー ロードが両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロードは逆の順序で両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
> [!NOTE]
>  ジェネリック メソッドの呼び出しを探さない、対応する非への呼び出しから、さまざまな Visual Basic、c#、および C++ 最初の 2 つの引数の型からのジェネリック型パラメーターの型を推論するためです。 使用する場合、 [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="keys" /> の下限を下回っています。  または、<paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> が <see langword="null" /> ではなく、<paramref name="keys" /> の下限が <paramref name="items" /> の下限と一致していません。  または、<paramref name="items" /> が <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さを超えています。  または、<paramref name="index" /> および <paramref name="length" /> は <paramref name="keys" /><see cref="T:System.Array" /> において有効な範囲を指定していません。  または、<paramref name="items" /> は <see langword="null" /> でなく、<paramref name="index" /> と <paramref name="length" /> は <paramref name="items" /><see cref="T:System.Array" /> において有効な範囲を指定していません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 内の 1 つ以上の要素に <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスが実装されていません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">並べ替えるキーを格納している 1 次元の <see cref="T:System.Array" />。インデックス番号が 0 から始まる必要があります。</param>
        <param name="items">
          <c>keys</c> 内のキーに対応する項目が格納されている 1 次元の <see cref="T:System.Array" /> (インデックス番号は 0 から始まります)。<c>keys</c> のみを並べ替える場合は <see langword="null" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <param name="comparer">要素を比較する際に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスの実装。各要素が実装する <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用する場合は <see langword="null" />。</param>
        <summary>2 つの <see cref="T:System.Array" /> オブジェクト (一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する) 内の要素範囲を、最初の <see cref="T:System.Array" /> 内のキーに基づき、指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>します。 並べ替え、対応する項目の中に、キーが移動したときに、 `items` <xref:System.Array>同様の位置を変更します。 そのため、 `items` <xref:System.Array>が内の対応するキーの並べ替えに従って並び替え、 `keys`<xref:System.Array>します。  
  
 場合`comparer`は`null`、内の要素の指定された範囲内の各キー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスとその他のすべてのキーの比較ができるようにします。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合は並べ替えることができます。 項目よりも多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>します。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、とおり内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズム。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲は、使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズム。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズム。  
  
 この実装は、不安定な並べ替えを実行します。2 つの要素が等しい場合は、その順序は保持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作、`n`は`length`します。  
  
   
  
## Examples  
 次のコード例に示します、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>、および [\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > ペアのキーと値を表す配列を並べ替えるためのジェネリック メソッドのオーバー ロードします。  
  
 コード例では、という名前の文字列の代替の比較子を定義します。 `ReverseCompare`、実装、 `IComparer<string>`(`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual c で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッドは、文字列は、低-高のではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前 (キー) の配列と各恐竜 (値) のメートル単位の最大長を表す整数の配列が表示されます。 アレイは、並べ替えし、複数回表示されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>オーバー ロードは、最初の配列での恐竜名の順序で両方の配列の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロードのインスタンスおよび`ReverseCompare`ペアの配列の並べ替え順序を反転させるために使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードが両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
-   [\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > オーバー ロードは最後の 3 つの並べ替えに使用逆の順序で両方の要素を配列します。  
  
> [!NOTE]
>  ジェネリック メソッドの呼び出しを探さない、対応する非への呼び出しから、さまざまな Visual Basic、c#、および C++ 最初の 2 つの引数の型からのジェネリック型パラメーターの型を推論するためです。 使用する場合、 [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="keys" /> の下限を下回っています。  または、<paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> が <see langword="null" /> ではなく、<paramref name="keys" /> の下限が <paramref name="items" /> の下限と一致していません。  または、<paramref name="items" /> が <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さを超えています。  または、<paramref name="index" /> および <paramref name="length" /> は <paramref name="keys" /><see cref="T:System.Array" /> において有効な範囲を指定していません。  または、<paramref name="items" /> は <see langword="null" /> でなく、<paramref name="index" /> と <paramref name="length" /> は <paramref name="items" /><see cref="T:System.Array" /> において有効な範囲を指定していません。  または、<paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> であり、<paramref name="keys" /><see cref="T:System.Array" /> 内の 1 つ以上の要素に <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスが実装されていません。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 と以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートは、状況によっては、並べ替え操作がスローされます、無効な比較演算子を識別、 <see cref="T:System.IndexOutOfRangeException" /> 、例外をスローします、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降では、[!INCLUDE[net_v45](~/includes/net-v45-md.md)]、並べ替え操作が以前スローしたことは<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較子が検出されないため、例外をスローできません。ほとんどの場合、これよりも少ない 16 個の要素を配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> へのアクセスを同期するために使用できるオブジェクトを取得します。</summary>
        <value>
          <see cref="T:System.Array" /> へのアクセスの同期に使用できるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを実装して、<xref:System.Collections.ICollection?displayProperty=nameWithType>インターフェイス。  
  
 .NET framework クラスに基づいた<xref:System.Array>のコレクションを使用して、独自の同期バージョンの提供、<xref:System.Array.SyncRoot%2A>プロパティ。  
  
 配列を使用するクラスは、独自の同期を使用しても実装できます、<xref:System.Array.SyncRoot%2A>プロパティ。 同期されたコードで操作を実行する必要があります、`SyncRoot`コレクションの直接ではなく、コレクションの。 これにより、他のオブジェクトから派生したコレクションを適切に操作できるようになります。 具体的には、コレクションを同時に変更する可能性があるその他のスレッドと適切な同期を維持します。 注意の実装によって<xref:System.Array.SyncRoot%2A>返す可能性があります、<xref:System.Array>自体。  
  
 コレクションの列挙は、スレッド セーフな方法では本質的にします。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
   
  
## Examples  
 次のコード例を使用して、すべての列挙中に配列をロックする方法を示しています、<xref:System.Array.SyncRoot%2A>プロパティ。  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System.Collections.ICollection.Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> に格納されている要素の数を取得します。</summary>
        <value>コレクションに格納されている要素の数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.ICollection> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Collections.IList" /> に追加するオブジェクト。</param>
        <summary>このメソッドを呼び出すと、必ず <see cref="T:System.NotSupportedException" /> 例外がスローされます。</summary>
        <returns>配列への値の追加はサポートされていません。 値は返されません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、<xref:System.Collections.IList.Add%2A?displayProperty=nameWithType>実装は、コレクションにメンバーを追加します。 ただし、配列サイズは固定であるため、(、<xref:System.Array.IsFixedSize%2A>プロパティは常に返します`true`)、このメソッドは常にスロー、<xref:System.NotSupportedException>例外。  
  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> は固定サイズです。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.IList" /> からすべての項目を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> は読み取り専用です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">現在のリスト内で検索するオブジェクト。 参照型の場合は、検索する要素として <see langword="null" /> を指定できます。</param>
        <summary>ある要素が <see cref="T:System.Collections.IList" /> 内に存在するかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="value" /> に存在する場合は <see cref="T:System.Collections.IList" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">現在のリスト内で検索するオブジェクト。</param>
        <summary>
          <see cref="T:System.Collections.IList" /> 内の特定の項目のインデックスを確認します。</summary>
        <returns>値がリストに存在する場合はそのインデックス。それ以外の場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">
          <c>value</c> 値を挿入する位置のインデックス。</param>
        <param name="value">挿入するオブジェクト。</param>
        <summary>指定したインデックスの <see cref="T:System.Collections.IList" /> に項目を挿入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が <see cref="T:System.Collections.IList" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> は読み取り専用です。  または、<see cref="T:System.Collections.IList" /> は固定サイズです。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> は、<see cref="T:System.Collections.IList" /> 内の null 参照です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">取得または設定する要素のインデックス。</param>
        <summary>指定したインデックスにある要素を取得または設定します。</summary>
        <value>指定したインデックス位置にある要素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が 0 未満です。  -または-  <paramref name="index" /> が <see cref="P:System.Collections.ICollection.Count" /> 以上になっています。</exception>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> が完全な 1 次元ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Collections.IList" /> から削除するオブジェクト。</param>
        <summary>特定のオブジェクトが <see cref="T:System.Collections.IList" /> 内にあるときに、最初に出現したものを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> は読み取り専用です。  または、<see cref="T:System.Collections.IList" /> は固定サイズです。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">削除する要素のインデックス。</param>
        <summary>指定したインデックスにある <see cref="T:System.Collections.IList" /> 項目を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">index が <see cref="T:System.Collections.IList" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> は読み取り専用です。  または、<see cref="T:System.Collections.IList" /> は固定サイズです。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">現在のインスタンスと比較するオブジェクト。</param>
        <param name="comparer">現在のオブジェクトと <c>other</c> とを比較するオブジェクト。</param>
        <summary>現在のコレクション オブジェクトの並べ替え順序での位置が、別のオブジェクトと比べて前か、後か、または同じかを判断します。</summary>
        <returns>現在のコレクション オブジェクトと他のオブジェクトとの関係を示す整数。次の表を参照してください。  
  
 <list type="table"><listheader><term> 戻り値  </term><description> 説明  </description></listheader><item><term> -1  </term><description> 現在のインスタンスが <paramref name="other" /> よりも前。</description></item><item><term> 0  </term><description> 現在のインスタンスと <paramref name="other" /> が等しい。</description></item><item><term> 1  </term><description> 現在のインスタンスが <paramref name="other" /> よりも後。  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IStructuralComparable> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">現在のインスタンスと比較するオブジェクト。</param>
        <param name="comparer">現在のインスタンスと <c>other</c> が等しいかどうかを判断するオブジェクト。</param>
        <summary>オブジェクトが現在のインスタンスと等しいかどうかを判断します。</summary>
        <returns>2 つのオブジェクトが等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IStructuralEquatable> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">現在のオブジェクトのハッシュ コードを計算するオブジェクト。</param>
        <summary>現在のインスタンスのハッシュ コードを返します。</summary>
        <returns>現在のインスタンスのハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IStructuralEquatable> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">条件が一致するかどうかをチェックする 1 次元の <see cref="T:System.Array" />。インデックス番号が 0 から始まる必要があります。</param>
        <param name="match">要素の条件を定義する述語。</param>
        <summary>配列内のすべての要素が、指定された述語によって定義された条件と一致するかどうかを調べます。</summary>
        <returns>
          <paramref name="array" /> 内のすべての要素が、指定された述語によって定義された条件と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 配列内に要素がない場合、戻り値は <see langword="true" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>を返すメソッドにデリゲート`true`デリゲートで定義されている条件に一致するオブジェクトが渡された場合。  要素`array`に個別に渡される、 <xref:System.Predicate%601>、デリゲートが戻るとき、処理が停止していると`false`任意の要素。  
  
 このメソッドは O (`n`) 操作、`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例は、文字列配列内の各要素の最後の文字が数字かどうかを判断します。 2 つの文字列配列を作成します。 両方の文字列の文字のアルファベットと数字で終わる文字列で終わる最初 arrayincludes します。2 番目の配列は、数字で終わる文字列ののみで構成されます。 また、`EndWithANumber`シグネチャと一致するメソッド、<xref:System.Predicate%601>デリゲートします。 例には、各配列では、<xref:System.Array.TrueForAll%2A>メソッドを表すデリゲートと、`EndsWithANumber`メソッド。  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 次の例は、文字列配列を通過する点を除いて、最初に似ています、<xref:System.Array.TrueForAll%2A>メソッドとラムダ式を特定の配列要素は、数値の文字列形式で終わるかどうかを判断します。  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 どちらの場合で、<xref:System.Array.TrueForAll%2A>メソッドを返します。`false`が数値で終わらない: 最初の配列要素が発生するとすぐにします。 返しますそれ以外の場合、`true`後、配列内のすべての要素を反復処理します。  
  
> [!NOTE]
>  どちらの例に示すとおり、c# および Visual Basic の場合を作成する必要はありません、`Predicate<string>`デリゲート (`Predicate(Of String)` Visual Basic で) 明示的にします。 これらの言語では、コンテキストから適切なデリゲート推測し、自動的に作成します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" />です。  または、<paramref name="match" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>