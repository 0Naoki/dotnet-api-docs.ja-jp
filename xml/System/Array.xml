<Type Name="Array" FullName="System.Array">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e84e497cc9b3a9531978b8704b5e107ac8cfda55" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36435086" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>クラスは、の一部、<xref:System.Collections>名前空間。 ただし、まだと見なされます、コレクションに基づいているため、<xref:System.Collections.IList>インターフェイスです。  
  
 <xref:System.Array>クラスは、配列をサポートする言語の実装で基底クラスです。 ただし、システムとコンパイラから派生できる明示的に、<xref:System.Array>クラスです。 ユーザーは、言語によって提供される配列構造を使用する必要があります。  
  
 要素の値は、<xref:System.Array>です。 長さ、<xref:System.Array>に格納できる要素の合計数です。 下限の境界、<xref:System.Array>最初の要素のインデックスです。 <xref:System.Array>下限を持つことができますが、既定では 0 の下限の境界があります。 インスタンスを作成するときに、別の下限を定義することができます、<xref:System.Array>クラスを使用して<xref:System.Array.CreateInstance%2A>です。多次元<xref:System.Array>各次元の下限を持つことができます。 配列には、最大 32 次元を持つことができます。  
  
 内のクラスとは異なり、<xref:System.Collections>名前空間、<xref:System.Array>固定容量があります。 容量を増やす必要がありますを作成する新しい<xref:System.Array>必要な容量を持つオブジェクトを古い要素のコピー<xref:System.Array>を新しいオブジェクトを古い<xref:System.Array>です。  
  
 既定では、最大サイズ、 <xref:System.Array> 2 ギガバイト (GB)。 64 ビット環境では、設定してサイズの制限を回避できます、`enabled`の属性、 [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)構成要素を`true`実行時環境でします。 ただし、配列が 40億要素の合計と 0X7FEFFFFF の特定のディメンション (0X7FFFFFC7 バイト配列および 1 バイト構造体の配列の場合) 内の最大のインデックスに制限できます。  
  
 1 次元配列の実装、 <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>、 <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>、 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>、<xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType>と<xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType>ジェネリック インターフェイス。 実装は実行時に、配列に提供され、その結果、ジェネリック インターフェイスに表示されないの宣言の構文、<xref:System.Array>クラスです。 さらに、ジェネリック インターフェイスの種類 (明示的なインターフェイスの実装) の配列をキャストによってのみアクセス可能なインターフェイス メンバーの参照トピックではありません。 これらのインターフェイスの 1 つの配列をキャストするときの注意すべき重要な点は、追加するメンバーが挿入、または、要素のスローを削除<xref:System.NotSupportedException>です。  
  
 <xref:System.Type> オブジェクトは、配列型の宣言に関する情報を提供します。 <xref:System.Array> 同じ配列の型を持つオブジェクトが同じ<xref:System.Type>オブジェクト。  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> <xref:System.Type.GetElementType%2A?displayProperty=nameWithType>で期待どおりの結果を返さない可能性があります<xref:System.Array>ため場合、配列は、型にキャスト<xref:System.Array>結果は配列ではなく、オブジェクト。 つまり、`typeof(System.Array).IsArray`返します`false`、および`typeof(System.Array).GetElementType`を返します`null`です。  
  
 <xref:System.Array.Copy%2A?displayProperty=nameWithType>メソッドだけでなく配列間の同じ型が、さまざまな種類の標準的な配列間の要素のコピーです。 型キャストを自動的に処理します。  
  
 一部のメソッドでなど<xref:System.Array.CreateInstance%2A>、 <xref:System.Array.Copy%2A>、 <xref:System.Array.CopyTo%2A>、 <xref:System.Array.GetValue%2A>、および<xref:System.Array.SetValue%2A>大容量の配列に対応するパラメーターとして 64 ビット整数値を許容するオーバー ロードを提供します。 <xref:System.Array.LongLength%2A> および<xref:System.Array.GetLongLength%2A>64 ビット整数の配列の長さを示すを返します。  
  
 <xref:System.Array>並べ替えは保証されません。  並べ替える必要があります、<xref:System.Array>操作を実行する前に (など<xref:System.Array.BinarySearch%2A>) を必要とする、<xref:System.Array>並べ替えられます。  
  
 使用して、<xref:System.Array>オブジェクトのネイティブ コード内のポインターではサポートされていませんがスローされます、<xref:System.NotSupportedException>のいくつかの方法です。  
  
   
  
## Examples  
 次のコード例に示す方法<xref:System.Array.Copy%2A?displayProperty=nameWithType>整数型の配列と型の配列の要素をコピー<xref:System.Object>です。  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 次のコード例は、作成し、初期化、<xref:System.Array>し、そのプロパティおよびその要素を表示します。  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>パブリック静的 (<see langword="Shared" /> Visual Basic で) この型のメンバーは、スレッド セーフであります。 インスタンス メンバーの場合は、スレッド セーフであるとは限りません。  この実装は同期済みは提供されません (スレッド セーフな) ラッパーを<see cref="T:System.Array" />。 ただし、.NET Framework のクラスがに基づいて<see cref="T:System.Array" />独自の同期されたバージョンを使用して、コレクションの提供、<see cref="P:System.Array.SyncRoot" />プロパティです。  コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based array to wrap in a read-only <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> wrapper.</param>
        <summary>Returns a read-only wrapper for the specified array.</summary>
        <returns>A read-only <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> wrapper for the specified array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 配列へのすべての変更を防ぐためには、このラッパーを介してのみ配列を公開します。  
  
 読み取り専用であるコレクションは、コレクションのコレクションの変更を防止するラッパーです。そのため、基になるコレクションの変更が加えられた、読み取り専用コレクションはそれらの変更を反映します。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次の例は、読み取り専用の配列をラップ<xref:System.Collections.ObjectModel.ReadOnlyCollection%601>です。  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Searches a one-dimensional sorted <see cref="T:System.Array" /> for a value, using a binary search algorithm.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">The sorted one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">The object to search for.</param>
        <summary>Searches an entire one-dimensional sorted array for a specific element, using the <see cref="T:System.IComparable" /> interface implemented by each element of the array and by the specified object.</summary>
        <returns>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number. If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />. If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1). If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。 `array` このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、 <xref:System.Array> 、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます (~、C# の場合は、 `Not` Visual Basic では) インデックスを生成するために負の値の結果にします。 このインデックスが 1 つである場合、配列の上限よりも大きい要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 いずれか`value`のすべての要素または`array`実装する必要があります、<xref:System.IComparable>比較に使用されるインターフェイス。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`value`を実装しません、<xref:System.IComparable>インターフェイスの要素の`array`用にテストされていません<xref:System.IComparable>で検索を開始する前にします。 検索が実装されていない要素が発生した場合、例外がスローされます<xref:System.IComparable>です。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null` 常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O (ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示しています。<xref:System.Array.BinarySearch%2A>の特定のオブジェクトを検索する、<xref:System.Array>です。  
  
> [!NOTE]
>  配列には、昇順で並べ替え順序では、要素が作成されます。 <xref:System.Array.BinarySearch%2A>メソッドには、昇順で並べ替えられて、配列が必要です。  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">The sorted one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">The object to search for.</param>
        <param name="comparer">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.  -or-  <see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</param>
        <summary>Searches an entire one-dimensional sorted array for a value using the specified <see cref="T:System.Collections.IComparer" /> interface.</summary>
        <returns>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number. If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />. If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1). If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。 `array` このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、 <xref:System.Array> 、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます (~、C# の場合は、 `Not` Visual Basic では) インデックスを生成するために負の値の結果にします。 このインデックスが 1 つである場合、配列の上限よりも大きい要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 比較演算子は、要素を比較する方法をカスタマイズします。 たとえば、使用することができます、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>として大文字と小文字の文字列検索を実行する比較子。  
  
 場合`comparer`は`null`の要素`array`指定して、指定した値と比較<xref:System.Collections.IComparer>実装します。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります`comparer`以外の場合、結果が正しくない可能性があります。  
  
 場合`comparer`は`null`、比較が行われますを使用して、<xref:System.IComparable>または指定した値によって、要素自体によって提供される実装します。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`comparer`は`null`と`value`を実装しません、<xref:System.IComparable>インターフェイスの要素の`array`用にテストされていません<xref:System.IComparable>で検索を開始する前にします。 検索が実装されていない要素が発生した場合、例外がスローされます<xref:System.IComparable>です。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null` 常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O (ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" />, <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">The sorted one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="index">The starting index of the range to search.</param>
        <param name="length">The length of the range to search.</param>
        <param name="value">The object to search for.</param>
        <summary>Searches a range of elements in a one-dimensional sorted array for a value, using the <see cref="T:System.IComparable" /> interface implemented by each element of the array and by the specified value.</summary>
        <returns>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number. If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />. If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1). If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。 `array` このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、 <xref:System.Array> 、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます (~、C# の場合は、 `Not` Visual Basic では) インデックスを生成するために負の値の結果にします。 このインデックスが 1 つである場合、配列の上限よりも大きい要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 いずれか`value`のすべての要素または`array`実装する必要があります、<xref:System.IComparable>比較に使用されるインターフェイス。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`value`を実装しません、<xref:System.IComparable>インターフェイスの要素の`array`用にテストされていません<xref:System.IComparable>で検索を開始する前にします。 検索が実装されていない要素が発生した場合、例外がスローされます<xref:System.IComparable>です。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null` 常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O (ログ`n`) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than the lower bound of <paramref name="array" />.  -or-  <paramref name="length" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.  -or-  <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">The sorted one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="index">The starting index of the range to search.</param>
        <param name="length">The length of the range to search.</param>
        <param name="value">The object to search for.</param>
        <param name="comparer">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.  -or-  <see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</param>
        <summary>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <see cref="T:System.Collections.IComparer" /> interface.</summary>
        <returns>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number. If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />. If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1). If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。 `array` このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、 <xref:System.Array> 、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます (~、C# の場合は、 `Not` Visual Basic では) インデックスを生成するために負の値の結果にします。 このインデックスが 1 つである場合、配列の上限よりも大きい要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 比較演算子は、要素を比較する方法をカスタマイズします。 たとえば、使用することができます、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>として大文字と小文字の文字列検索を実行する比較子。  
  
 場合`comparer`は`null`の要素`array`指定して、指定した値と比較<xref:System.Collections.IComparer>実装します。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります`comparer`以外の場合、結果が正しくない可能性があります。  
  
 場合`comparer`は`null`、比較が行われますを使用して、<xref:System.IComparable>または指定した値によって、要素自体によって提供される実装します。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`comparer`は`null`と`value`を実装しません、<xref:System.IComparable>インターフェイスの要素の`array`用にテストされていません<xref:System.IComparable>で検索を開始する前にします。 検索が実装されていない要素が発生した場合、例外がスローされます<xref:System.IComparable>です。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null` 常に参照型; と比較できます。そのため、比較で`null`を使用する場合に例外を生成しない<xref:System.IComparable>です。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O (ログ`n`) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than the lower bound of <paramref name="array" />.  -or-  <paramref name="length" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.  -or-  <paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" />, <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="value">The object to search for.</param>
        <summary>Searches an entire one-dimensional sorted array for a specific element, using the <see cref="T:System.IComparable`1" /> generic interface implemented by each element of the <see cref="T:System.Array" /> and by the specified object.</summary>
        <returns>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number. If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />. If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1). If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。 `array` このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合`array`、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます (~、C# の場合は、 `Not` Visual Basic では) インデックスを生成するために負の値の結果にします。 このインデックスが配列のサイズに等しい場合は、要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 `T` 実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスは、比較に使用します。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable%601>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null` 常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable%601>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable%601>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O (ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>ジェネリック メソッドのオーバー ロードおよび<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ジェネリック メソッドのオーバー ロードします。 任意の順序で、文字列の配列が作成されます。  
  
 配列が表示され、並べ替え、もう一度表示されます。 配列を使用するために並べ替える必要があります、<xref:System.Array.BinarySearch%2A>メソッドです。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%2A>と<xref:System.Array.BinarySearch%2A>ジェネリック メソッドの表示が、対応する非への呼び出しから、他と同じため、Visual Basic、c#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ジェネリック メソッドのオーバー ロードが 2 つの文字列の検索に使用しに含まれていない、配列と 1 つを 1 つです。 配列との戻り値、<xref:System.Array.BinarySearch%2A>メソッドに渡される、`ShowWhere`場合は、文字列が検出され、それ以外の場合、要素検索文字列が間に配列を使用した場合は、インデックス値を表示するジェネリック メソッドです。 インデックスは負の場合は、文字列が、配列であるため、`ShowWhere`メソッドにはビットごとの補数 (、~ c# および Visual C は、演算子`Xor`Visual Basic では-1) を検索するよりも大きい一覧の最初の要素のインデックスを取得する strいます。  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="value">The object to search for.</param>
        <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1" /> implementation to use when comparing elements.  -or-  <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> implementation of each element.</param>
        <summary>Searches an entire one-dimensional sorted array for a value using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</summary>
        <returns>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number. If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />. If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1). If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。 `array` このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、 <xref:System.Array> 、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます (~、C# の場合は、 `Not` Visual Basic では) インデックスを生成するために負の値の結果にします。 このインデックスが配列のサイズに等しい場合は、要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 比較演算子は、要素を比較する方法をカスタマイズします。 たとえば、使用することができます、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>として大文字と小文字の文字列検索を実行する比較子。  
  
 場合`comparer`は`null`の要素`array`指定して、指定した値と比較<xref:System.Collections.Generic.IComparer%601>ジェネリック インターフェイスの実装です。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります`comparer`以外の場合、結果が正しくない可能性があります。  
  
 場合`comparer`は`null`、比較が行われますを使用して、<xref:System.IComparable%601>で提供されるジェネリック インターフェイス実装`T`です。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable%601>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`comparer`は`null`と`value`を実装しません、<xref:System.IComparable%601>ジェネリック インターフェイスでの要素`array`用にテストされていません<xref:System.IComparable%601>で検索を開始する前にします。 検索が実装されていない要素が発生した場合、例外がスローされます<xref:System.IComparable%601>です。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null` 常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable%601>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable%601>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O (ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例で、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードおよび<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 配列が表示され、並べ替え、もう一度表示されます。 配列を使用するために並べ替える必要があります、<xref:System.Array.BinarySearch%2A>メソッドです。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>と<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドの表示が、対応する非への呼び出しから、他と同じため、Visual Basic、c#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードが 2 つの文字列の検索に使用しに含まれていない、配列と 1 つを 1 つです。 配列との戻り値、<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>メソッドに渡される、`ShowWhere`場合は、文字列が検出され、それ以外の場合、要素検索文字列が間に配列を使用した場合は、インデックス値を表示するジェネリック メソッドです。 インデックスが負の値、文字列は、n がない場合、配列のため、`ShowWhere`メソッドにはビットごとの補数 (、~ c# および Visual C は、演算子`Xor`Visual Basic では-1) が検索からより大きい一覧の最初の要素のインデックスを取得ng です。  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" />, and <paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="index">The starting index of the range to search.</param>
        <param name="length">The length of the range to search.</param>
        <param name="value">The object to search for.</param>
        <summary>Searches a range of elements in a one-dimensional sorted array for a value, using the <see cref="T:System.IComparable`1" /> generic interface implemented by each element of the <see cref="T:System.Array" /> and by the specified value.</summary>
        <returns>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number. If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />. If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1). If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。 `array` このメソッドを呼び出す前に並べ替える必要があります。  
  
 配列に指定された値が含まれていない場合、このメソッドは負の整数を返します。 ビットごとの補数演算子を適用することができます (~、C# の場合は、 `Not` Visual Basic では) インデックスを生成するために負の値の結果にします。 このインデックスが配列のサイズに等しい場合は、要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 `T` 実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスは、比較に使用します。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable%601>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null` 常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable%601>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable%601>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O (ログ`n`) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than the lower bound of <paramref name="array" />.  -or-  <paramref name="length" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.  -or-  <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="index">The starting index of the range to search.</param>
        <param name="length">The length of the range to search.</param>
        <param name="value">The object to search for.</param>
        <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1" /> implementation to use when comparing elements.  -or-  <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> implementation of each element.</param>
        <summary>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</summary>
        <returns>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number. If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />. If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1). If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。 `array` このメソッドを呼び出す前に並べ替える必要があります。  
  
 配列に指定された値が含まれていない場合、このメソッドは負の整数を返します。 ビットごとの補数演算子を適用することができます (~、C# の場合は、 `Not` Visual Basic では) インデックスを生成するために負の値の結果にします。 このインデックスが配列のサイズに等しい場合は、要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 比較演算子は、要素を比較する方法をカスタマイズします。 たとえば、使用することができます、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>として大文字と小文字の文字列検索を実行する比較子。  
  
 場合`comparer`は`null`の要素`array`指定して、指定した値と比較<xref:System.Collections.Generic.IComparer%601>ジェネリック インターフェイスの実装です。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります`comparer`以外の場合、結果が正しくない可能性があります。  
  
 場合`comparer`は`null`、比較が行われますを使用して、<xref:System.IComparable%601>ジェネリック インターフェイスの実装の種類指定した`T`です。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable%601>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null` 常に参照型; と比較できます。そのため、比較で`null`を使用する場合に例外を生成しない<xref:System.IComparable%601>です。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable%601>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable%601>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O (ログ`n`) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than the lower bound of <paramref name="array" />.  -or-  <paramref name="length" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.  -or-  <paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" />, and <paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The array whose elements need to be cleared.</param>
        <param name="index">The starting index of the range of elements to clear.</param>
        <param name="length">The number of elements to clear.</param>
        <summary>Sets a range of elements in an array to the default value of each element type.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、配列内の各要素を要素の型の既定値にリセットします。 参照型の要素を設定 (など<xref:System.String>要素) を`null`、し、値型の要素を次の表に示すように既定値に設定します。  
  
|型|[値]|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|すべての整数と浮動小数点数値型|0 (ゼロ)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|他の値型|型のフィールドの既定値|  
  
 範囲は、要素のラップが行ごとに多次元配列内にクリアされます。  
  
 このメソッドは、要素の値のみをクリアします。要素自体は削除されません。 配列が固定サイズです。そのため、要素を追加または削除することはできません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.Clear%2A>メソッドを 1 次元、2 次元、および 3 次元の配列内の整数値をリセットします。  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 次の例では定義、`TimeZoneTime`を含む構造体、<xref:System.TimeZoneInfo>フィールドおよび<xref:System.DateTimeOffset>フィールドです。 呼び出して、<xref:System.Array.Clear%2A>の 2 つの要素の配列内の 1 つの要素を消去するメソッドを`TimeZoneTime`値。 メソッドの既定値に消去された要素の値を設定する、<xref:System.TimeZoneInfo>オブジェクトは`null`、および既定値の<xref:System.DateTimeOffset>オブジェクトは<xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>です。  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> is less than the lower bound of <paramref name="array" />.  -or-  <paramref name="length" /> is less than zero.  -or-  The sum of <paramref name="index" /> and <paramref name="length" /> is greater than the size of <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a shallow copy of the <see cref="T:System.Array" />.</summary>
        <returns>A shallow copy of the <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 簡易コピー、<xref:System.Array>の要素のみをコピー、<xref:System.Array>は参照型または値の型が、参照先のオブジェクトはコピーされませんがあるかどうか、します。 新しい参照<xref:System.Array>オブジェクトを指す同じ元の参照<xref:System.Array> をポイントします。  
  
 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が直接または間接的に参照するすべてコピーします。  
  
 クローンは、同じ<xref:System.Type>元<xref:System.Array>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は<xref:System.Array.Length%2A>します。  
  
   
  
## Examples  
 次のコード例のクローン、<xref:System.Globalization.CultureInfo?displayProperty=nameWithType>配列し、シャロー コピーの動作を示します。  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">The <see cref="T:System.Array" /> that contains the data to copy.</param>
        <param name="sourceIndex">A 32-bit integer that represents the index in the <c>sourceArray</c> at which copying begins.</param>
        <param name="destinationArray">The <see cref="T:System.Array" /> that receives the data.</param>
        <param name="destinationIndex">A 32-bit integer that represents the index in the <c>destinationArray</c> at which storing begins.</param>
        <param name="length">A 32-bit integer that represents the number of elements to copy.</param>
        <summary>Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index.  Guarantees that all changes are undone if the copy does not succeed completely.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`と`destinationArray`パラメーターが同じ次元数を持つ必要があります。  `sourceArray`型と同じである必要がありますかから派生した、`destinationArray`入力です。 それ以外の場合、<xref:System.ArrayTypeMismatchException>がスローされます。  異なり<xref:System.Array.Copy%2A>、<xref:System.Array.ConstrainedCopy%2A>任意の操作を実行する前に、配列型の互換性を確認します。  
  
 多次元配列間でコピーする場合、配列動作長い 1 次元配列のように、行 (または列) が概念的にレイアウトされるエンド ツー エンドします。 たとえば、配列要素がある 3 つの行 (列) 4 つの要素で、各コピー 6 つの配列の先頭から場合は、最初の行 (または列) の 4 つすべての要素と、2 番目の行 (または列) の最初の 2 つの要素コピーします。 3 番目の行 (または列の)、2 番目の要素からコピーを開始する`sourceIndex`さらに、2 番目の行 (または列) の長さ + 2、最初の行 (または列) の上限をする必要があります。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作としての元の値`sourceArray`する前に一時的な場所に保存された`destinationArray`は上書きされます。  
  
 [C++]  
  
 このメソッドは、標準の C/C++ 関数`memmove`ではなく、`memcpy`です。  
  
 配列は、参照型の配列または値型の配列になります。  場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列は、 <xref:System.Object>、シャロー コピーを実行します。 簡易コピー、<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を含む<xref:System.Array>です。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が直接または間接的に参照するすべてコピーします。  
  
 このメソッドは、コピー中に例外をスローした場合、`destinationArray`は変更されていません。 したがって、<xref:System.Array.ConstrainedCopy%2A>制約された実行領域内で使用できます (<xref:System.Runtime.ConstrainedExecution.Cer>)。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> is <see langword="null" />.  -or-  <paramref name="destinationArray" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">The <paramref name="sourceArray" /> type is neither the same as nor derived from the <paramref name="destinationArray" /> type.</exception>
        <exception cref="T:System.InvalidCastException">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> is less than the lower bound of the first dimension of <paramref name="sourceArray" />.  -or-  <paramref name="destinationIndex" /> is less than the lower bound of the first dimension of <paramref name="destinationArray" />.  -or-  <paramref name="length" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" /> to the end of <paramref name="sourceArray" />.  -or-  <paramref name="length" /> is greater than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">元の配列要素の型。</typeparam>
        <typeparam name="TOutput">変換後の配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to convert to a target type.</param>
        <param name="converter">A <see cref="T:System.Converter`2" /> that converts each element from one type to another type.</param>
        <summary>Converts an array of one type to an array of another type.</summary>
        <returns>An array of the target type containing the converted elements from the source array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602>オブジェクトを対象の型に変換するメソッドにデリゲートします。  要素`array`に個別に渡される、 <xref:System.Converter%602>、し、新しい配列に変換された要素が保存されます。  
  
 ソース`array`は変更されません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例は、という名前のメソッドを定義`PointFToPoint`変換する、<xref:System.Drawing.PointF>に構造体、<xref:System.Drawing.Point>構造体。 配列を作成し<xref:System.Drawing.PointF>構造と、作成、`Converter<PointF, Point>`委任 (`Converter(Of PointF, Point)` Visual Basic で) を表す、`PointFToPoint`メソッドにデリゲートを渡します、<xref:System.Array.ConvertAll%2A>メソッドです。 <xref:System.Array.ConvertAll%2A>メソッドは成功する入力の一覧の各要素、`PointFToPoint`メソッドの新しいリストに変換された要素を格納および<xref:System.Drawing.Point>構造体。 両方の一覧が表示されます。  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.  -or-  <paramref name="converter" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copies a range of elements in one <see cref="T:System.Array" /> to another <see cref="T:System.Array" /> and performs type casting and boxing as required.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">The <see cref="T:System.Array" /> that contains the data to copy.</param>
        <param name="destinationArray">The <see cref="T:System.Array" /> that receives the data.</param>
        <param name="length">A 32-bit integer that represents the number of elements to copy.</param>
        <summary>Copies a range of elements from an <see cref="T:System.Array" /> starting at the first element and pastes them into another <see cref="T:System.Array" /> starting at the first element. The length is specified as a 32-bit integer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`と`destinationArray`パラメーターが同じ次元数を持つ必要があります。 さらに、`destinationArray`次元されて既に必要があり、十分な数の要素にコピーしたデータを対応する必要があります。  
  
 多次元配列間でコピーする場合、配列動作長い 1 次元配列のように、行 (または列) が概念的にレイアウトされるエンド ツー エンドします。 たとえば、配列要素がある 3 つの行 (列) 4 つの要素で、各コピー 6 つの配列の先頭から場合は、最初の行 (または列) の 4 つすべての要素と、2 番目の行 (または列) の最初の 2 つの要素コピーします。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作としての元の値`sourceArray`する前に一時的な場所に保存された`destinationArray`は上書きされます。  
  
 [C++]  
  
 このメソッドは、標準の C/C++ 関数`memmove`ではなく、`memcpy`です。  
  
 配列は、参照型の配列または値型の配列になります。 型のダウン キャストを実行すると、必要に応じて。  
  
-   参照型の配列から値型の配列にコピーするとき、各要素はボックス化解除され、コピーします。 参照型の配列に値型の配列からコピーする場合は、各要素がボックス化され、コピーされます。  
  
-   参照型または値型の配列からコピーするとき、 <xref:System.Object> 、配列、<xref:System.Object>がそれぞれの値または参照を保持するために作成され、その後、コピーします。 コピーするとき、 <xref:System.Object> 、参照型または値型の配列と割り当て先の配列が可能であれば、<xref:System.InvalidCastException>がスローされます。  
  
-   場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列は、 <xref:System.Object>、シャロー コピーを実行します。 簡易コピー、<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を含む<xref:System.Array>です。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が直接または間接的に参照するすべてコピーします。  
  
 <xref:System.ArrayTypeMismatchException>の配列が互換性のない型である場合にスローされます。 型の互換性の定義は次のとおりです。  
  
-   型と互換性のあります。  
  
-   値型と互換性が<xref:System.Object>とその値の型によって実装されたインターフェイス型を使用します。 値型では、直接そのインターフェイスを実装する場合にのみ、インターフェイスに接続されていると見なされます。 切断されている型に互換性がありません。  
  
-   2 つの組み込みの (定義済み) の値型に拡大変換元の型から変換先の型へのコピーがある場合に互換性がします。 拡大変換では縮小変換には、情報が失われる可能性が一方については、失われます。 たとえば、拡大変換は、32 ビット符号付き整数に変換する 64 ビット符号付き整数にし、縮小変換は、64 ビット符号付き整数に変換する 32 ビット符号付き整数。 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
-   非組み込みの (ユーザー定義) の値の型とのみ互換性が自体です。  
  
-   列挙型に暗黙的な変換がある<xref:System.Enum>とその基になる型。  
  
 場合のすべての要素`sourceArray`キャスト (たとえば、派生クラスを基底クラスまたはオブジェクトへのインターフェイスから) が必要ですし、1 つまたは複数の要素に対応する型にキャストできません`destinationArray`、<xref:System.InvalidCastException>がスローされます。  
  
 このメソッドの状態のコピー中に例外をスローした場合`destinationArray`が定義されていません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> is <see langword="null" />.  -or-  <paramref name="destinationArray" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</exception>
        <exception cref="T:System.InvalidCastException">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> is greater than the number of elements in <paramref name="sourceArray" />.  -or-  <paramref name="length" /> is greater than the number of elements in <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">The <see cref="T:System.Array" /> that contains the data to copy.</param>
        <param name="destinationArray">The <see cref="T:System.Array" /> that receives the data.</param>
        <param name="length">A 64-bit integer that represents the number of elements to copy. The integer must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</param>
        <summary>Copies a range of elements from an <see cref="T:System.Array" /> starting at the first element and pastes them into another <see cref="T:System.Array" /> starting at the first element. The length is specified as a 64-bit integer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`と`destinationArray`パラメーターが同じ次元数を持つ必要があります。 さらに、`destinationArray`次元されて既に必要があり、十分な数の要素にコピーしたデータを対応する必要があります。  
  
 多次元配列間でコピーする場合、配列動作長い 1 次元配列のように、行 (または列) が概念的にレイアウトされるエンド ツー エンドします。 たとえば、配列要素がある 3 つの行 (列) 4 つの要素で、各コピー 6 つの配列の先頭から場合は、最初の行 (または列) の 4 つすべての要素と、2 番目の行 (または列) の最初の 2 つの要素コピーします。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作としての元の値`sourceArray`する前に一時的な場所に保存された`destinationArray`は上書きされます。  
  
 [C++]  
  
 このメソッドは、標準の C/C++ 関数`memmove`ではなく、`memcpy`です。  
  
 配列は、参照型の配列または値型の配列になります。 型のダウン キャストを実行すると、必要に応じて。  
  
-   参照型の配列から値型の配列にコピーするとき、各要素はボックス化解除され、コピーします。 参照型の配列に値型の配列からコピーする場合は、各要素がボックス化され、コピーされます。  
  
-   参照型または値型の配列からコピーするとき、 <xref:System.Object> 、配列、<xref:System.Object>がそれぞれの値または参照を保持するために作成され、その後、コピーします。 コピーするとき、 <xref:System.Object> 、参照型または値型の配列と割り当て先の配列が可能であれば、<xref:System.InvalidCastException>がスローされます。  
  
-   場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列は、 <xref:System.Object>、シャロー コピーを実行します。 簡易コピー、<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を含む<xref:System.Array>です。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が直接または間接的に参照するすべてコピーします。  
  
 <xref:System.ArrayTypeMismatchException>の配列が互換性のない型である場合にスローされます。 型の互換性の定義は次のとおりです。  
  
-   型と互換性のあります。  
  
-   値型と互換性が<xref:System.Object>とその値の型によって実装されたインターフェイス型を使用します。 値型では、直接そのインターフェイスを実装する場合にのみ、インターフェイスに接続されていると見なされます。 切断されている型に互換性がありません。  
  
-   2 つの組み込みの (定義済み) の値型に拡大変換元の型から変換先の型へのコピーがある場合に互換性がします。 拡大変換では縮小変換には、情報が失われる可能性が一方については、失われます。 たとえば、拡大変換は、32 ビット符号付き整数に変換する 64 ビット符号付き整数にし、縮小変換は、64 ビット符号付き整数に変換する 32 ビット符号付き整数。 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
-   非組み込みの (ユーザー定義) の値の型とのみ互換性が自体です。  
  
-   列挙型に暗黙的な変換がある<xref:System.Enum>とその基になる型。  
  
 場合のすべての要素`sourceArray`キャスト (たとえば、派生クラスを基底クラスまたはオブジェクトへのインターフェイスから) が必要ですし、1 つまたは複数の要素に対応する型にキャストできません`destinationArray`、<xref:System.InvalidCastException>がスローされます。  
  
 このメソッドの状態のコピー中に例外をスローした場合`destinationArray`が定義されていません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> is <see langword="null" />.  -or-  <paramref name="destinationArray" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</exception>
        <exception cref="T:System.InvalidCastException">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> is less than 0 or greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> is greater than the number of elements in <paramref name="sourceArray" />.  -or-  <paramref name="length" /> is greater than the number of elements in <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">The <see cref="T:System.Array" /> that contains the data to copy.</param>
        <param name="sourceIndex">A 32-bit integer that represents the index in the <c>sourceArray</c> at which copying begins.</param>
        <param name="destinationArray">The <see cref="T:System.Array" /> that receives the data.</param>
        <param name="destinationIndex">A 32-bit integer that represents the index in the <c>destinationArray</c> at which storing begins.</param>
        <param name="length">A 32-bit integer that represents the number of elements to copy.</param>
        <summary>Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index. The length and the indexes are specified as 32-bit integers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`と`destinationArray`パラメーターが同じ次元数を持つ必要があります。 さらに、`destinationArray`次元されて既に必要があり、十分な数の要素から始まる必要があります、`destinationIndex`にコピーしたデータを対応する位置。  
  
 多次元配列間でコピーする場合、配列動作長い 1 次元配列のように、行 (または列) が概念的にレイアウトされるエンド ツー エンドします。 たとえば、配列要素がある 3 つの行 (列) 4 つの要素で、各コピー 6 つの配列の先頭から場合は、最初の行 (または列) の 4 つすべての要素と、2 番目の行 (または列) の最初の 2 つの要素コピーします。 3 番目の行 (または列の)、2 番目の要素からコピーを開始する`sourceIndex`さらに、2 番目の行 (または列) の長さ + 2、最初の行 (または列) の上限をする必要があります。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作としての元の値`sourceArray`する前に一時的な場所に保存された`destinationArray`は上書きされます。  
  
 [C++]  
  
 このメソッドは、標準の C/C++ 関数`memmove`ではなく、`memcpy`です。  
  
 配列は、参照型の配列または値型の配列になります。 型のダウン キャストを実行すると、必要に応じて。  
  
-   参照型の配列から値型の配列にコピーするとき、各要素はボックス化解除され、コピーします。 参照型の配列に値型の配列からコピーする場合は、各要素がボックス化され、コピーされます。  
  
-   参照型または値型の配列からコピーするとき、 <xref:System.Object> 、配列、<xref:System.Object>がそれぞれの値または参照を保持するために作成され、その後、コピーします。 コピーするとき、 <xref:System.Object> 、参照型または値型の配列と割り当て先の配列が可能であれば、<xref:System.InvalidCastException>がスローされます。  
  
-   場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列は、 <xref:System.Object>、シャロー コピーを実行します。 簡易コピー、<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を含む<xref:System.Array>です。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が直接または間接的に参照するすべてコピーします。  
  
 <xref:System.ArrayTypeMismatchException>の配列が互換性のない型である場合にスローされます。 型の互換性の定義は次のとおりです。  
  
-   型と互換性のあります。  
  
-   値型と互換性が<xref:System.Object>とその値の型によって実装されたインターフェイス型を使用します。 値型では、直接そのインターフェイスを実装する場合にのみ、インターフェイスに接続されていると見なされます。 切断されている型に互換性がありません。  
  
-   2 つの組み込みの (定義済み) の値型に拡大変換元の型から変換先の型へのコピーがある場合に互換性がします。 拡大変換では縮小変換には、情報が失われる可能性が一方については、失われます。 たとえば、拡大変換は、32 ビット符号付き整数に変換する 64 ビット符号付き整数にし、縮小変換は、64 ビット符号付き整数に変換する 32 ビット符号付き整数。 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
-   非組み込みの (ユーザー定義) の値の型とのみ互換性が自体です。  
  
-   列挙型に暗黙的な変換がある<xref:System.Enum>とその基になる型。  
  
 場合のすべての要素`sourceArray`キャスト (たとえば、派生クラスを基底クラスまたはオブジェクトへのインターフェイスから) が必要ですし、1 つまたは複数の要素に対応する型にキャストできません`destinationArray`、<xref:System.InvalidCastException>がスローされます。  
  
 このメソッドの状態のコピー中に例外をスローした場合`destinationArray`が定義されていません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例は、1 つをコピーする方法を示しています。<xref:System.Array>型の<xref:System.Object>別<xref:System.Array>整数型。  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> is <see langword="null" />.  -or-  <paramref name="destinationArray" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</exception>
        <exception cref="T:System.InvalidCastException">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> is less than the lower bound of the first dimension of <paramref name="sourceArray" />.  -or-  <paramref name="destinationIndex" /> is less than the lower bound of the first dimension of <paramref name="destinationArray" />.  -or-  <paramref name="length" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" /> to the end of <paramref name="sourceArray" />.  -or-  <paramref name="length" /> is greater than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">The <see cref="T:System.Array" /> that contains the data to copy.</param>
        <param name="sourceIndex">A 64-bit integer that represents the index in the <c>sourceArray</c> at which copying begins.</param>
        <param name="destinationArray">The <see cref="T:System.Array" /> that receives the data.</param>
        <param name="destinationIndex">A 64-bit integer that represents the index in the <c>destinationArray</c> at which storing begins.</param>
        <param name="length">A 64-bit integer that represents the number of elements to copy. The integer must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</param>
        <summary>Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index. The length and the indexes are specified as 64-bit integers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`と`destinationArray`パラメーターが同じ次元数を持つ必要があります。 さらに、`destinationArray`次元されて既に必要があり、十分な数の要素から始まる必要があります、`destinationIndex`にコピーしたデータを対応する位置。  
  
 多次元配列間でコピーする場合、配列動作長い 1 次元配列のように、行 (または列) が概念的にレイアウトされるエンド ツー エンドします。 たとえば、配列要素がある 3 つの行 (列) 4 つの要素で、各コピー 6 つの配列の先頭から場合は、最初の行 (または列) の 4 つすべての要素と、2 番目の行 (または列) の最初の 2 つの要素コピーします。 3 番目の行 (または列の)、2 番目の要素からコピーを開始する`sourceIndex`さらに、2 番目の行 (または列) の長さ + 2、最初の行 (または列) の上限をする必要があります。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作としての元の値`sourceArray`する前に一時的な場所に保存された`destinationArray`は上書きされます。  
  
 [C++]  
  
 このメソッドは、標準の C/C++ 関数`memmove`ではなく、`memcpy`です。  
  
 配列は、参照型の配列または値型の配列になります。 型のダウン キャストを実行すると、必要に応じて。  
  
-   参照型の配列から値型の配列にコピーするとき、各要素はボックス化解除され、コピーします。 参照型の配列に値型の配列からコピーする場合は、各要素がボックス化され、コピーされます。  
  
-   参照型または値型の配列からコピーするとき、 <xref:System.Object> 、配列、<xref:System.Object>がそれぞれの値または参照を保持するために作成され、その後、コピーします。 コピーするとき、 <xref:System.Object> 、参照型または値型の配列と割り当て先の配列が可能であれば、<xref:System.InvalidCastException>がスローされます。  
  
-   場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列は、 <xref:System.Object>、シャロー コピーを実行します。 簡易コピー、<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を含む<xref:System.Array>です。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が直接または間接的に参照するすべてコピーします。  
  
 <xref:System.ArrayTypeMismatchException>の配列が互換性のない型である場合にスローされます。 型の互換性の定義は次のとおりです。  
  
-   型と互換性のあります。  
  
-   値型と互換性が<xref:System.Object>とその値の型によって実装されたインターフェイス型を使用します。 値型では、直接そのインターフェイスを実装する場合にのみ、インターフェイスに接続されていると見なされます。 切断されている型に互換性がありません。  
  
-   2 つの組み込みの (定義済み) の値型に拡大変換元の型から変換先の型へのコピーがある場合に互換性がします。 拡大変換では縮小変換には、情報が失われる可能性が一方については、失われます。 たとえば、拡大変換は、32 ビット符号付き整数に変換する 64 ビット符号付き整数にし、縮小変換は、64 ビット符号付き整数に変換する 32 ビット符号付き整数。 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
-   非組み込みの (ユーザー定義) の値の型とのみ互換性が自体です。  
  
-   列挙型に暗黙的な変換がある<xref:System.Enum>とその基になる型。  
  
 場合のすべての要素`sourceArray`キャスト (たとえば、派生クラスを基底クラスまたはオブジェクトへのインターフェイスから) が必要ですし、1 つまたは複数の要素に対応する型にキャストできません`destinationArray`、<xref:System.InvalidCastException>がスローされます。  
  
 このメソッドの状態のコピー中に例外をスローした場合`destinationArray`が定義されていません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例は、1 つをコピーする方法を示しています。<xref:System.Array>型の<xref:System.Object>別<xref:System.Array>整数型。  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> is <see langword="null" />.  -or-  <paramref name="destinationArray" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</exception>
        <exception cref="T:System.InvalidCastException">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> is outside the range of valid indexes for the <paramref name="sourceArray" />.  -or-  <paramref name="destinationIndex" /> is outside the range of valid indexes for the <paramref name="destinationArray" />.  -or-  <paramref name="length" /> is less than 0 or greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" /> to the end of <paramref name="sourceArray" />.  -or-  <paramref name="length" /> is greater than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copies all the elements of the current one-dimensional array to the specified one-dimensional array.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional array that is the destination of the elements copied from the current array.</param>
        <param name="index">A 32-bit integer that represents the index in <c>array</c> at which copying begins.</param>
        <summary>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index. The index is specified as a 32-bit integer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在の配列インスタンスのすべての要素をコピー、`array`コピー先の配列、インデックスから始まります`index`です。 `array`コピー先の配列次元されて既に必要があり、十分な数の要素をコピーした要素に対応する必要があります。 そうしないと、例外がスローされます。  
  
 このメソッドは、サポート、<xref:System.Collections.ICollection?displayProperty=nameWithType>インターフェイスです。 実装する場合<xref:System.Collections.ICollection?displayProperty=nameWithType>が使用して明示的に必要な<xref:System.Array.Copy%2A>余分な間接参照を回避します。  
  
 このメソッドの状態のコピー中に例外をスローした場合`array`が定義されていません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は<xref:System.Array.Length%2A>します。のみの簡易コピーを実行します。  
  
   
  
## Examples  
 次のコード例をコピーする方法を示しています、<xref:System.Array>別<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 次のコード例をコピーする方法を示しています、<xref:System.Array>別<xref:System.Array>下限が 0 にします。 なおソース全体<xref:System.Array>をコピーすると、ターゲット内の既存の要素を上書きする空の要素を含む<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than the lower bound of <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> is multidimensional.  -or-  The number of elements in the source array is greater than the available number of elements from <paramref name="index" /> to the end of the destination <paramref name="array" />.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">The type of the source <see cref="T:System.Array" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">The source array is multidimensional.</exception>
        <exception cref="T:System.InvalidCastException">At least one element in the source <see cref="T:System.Array" /> cannot be cast to the type of destination <paramref name="array" />.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional array that is the destination of the elements copied from the current array.</param>
        <param name="index">A 64-bit integer that represents the index in <c>array</c> at which copying begins.</param>
        <summary>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index. The index is specified as a 64-bit integer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在の配列インスタンスのすべての要素をコピー、`array`コピー先の配列、インデックスから始まります`index`です。 `array`コピー先の配列次元されて既に必要があり、十分な数の要素をコピーした要素に対応する必要があります。 そうしないと、例外がスローされます。  
  
 このメソッドは、サポート、<xref:System.Collections.ICollection?displayProperty=nameWithType>インターフェイスです。 実装する場合<xref:System.Collections.ICollection?displayProperty=nameWithType>が使用して明示的に必要な<xref:System.Array.Copy%2A>余分な間接参照を回避します。  
  
 このメソッドの状態のコピー中に例外をスローした場合`array`が定義されていません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は<xref:System.Array.Length%2A>します。のみの簡易コピーを実行します。  
  
   
  
## Examples  
 次のコード例をコピーする方法を示しています、<xref:System.Array>別<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 次のコード例をコピーする方法を示しています、<xref:System.Array>別<xref:System.Array>下限が 0 にします。 なおソース全体<xref:System.Array>をコピーすると、ターゲット内の既存の要素を上書きする空の要素を含む<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is outside the range of valid indexes for <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> is multidimensional.  -or-  The number of elements in the source array is greater than the available number of elements from <paramref name="index" /> to the end of the destination <paramref name="array" />.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">The type of the source <see cref="T:System.Array" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">The source <see cref="T:System.Array" /> is multidimensional.</exception>
        <exception cref="T:System.InvalidCastException">At least one element in the source <see cref="T:System.Array" /> cannot be cast to the type of destination <paramref name="array" />.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Array" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</param>
        <param name="length">The size of the <see cref="T:System.Array" /> to create.</param>
        <summary>Creates a one-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and length, with zero-based indexing.</summary>
        <returns>A new one-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length, using zero-based indexing.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例は、作成し、1 次元を初期化する方法を示しています。<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> is not supported. For example, <see cref="T:System.Void" /> is not supported.  -or-  <paramref name="elementType" /> is an open generic type.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> is less than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</param>
        <param name="lengths">An array of 32-bit integers that represent the size of each dimension of the <see cref="T:System.Array" /> to create.</param>
        <summary>Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing. The dimension lengths are specified in an array of 32-bit integers.</summary>
        <returns>A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 内の要素の数、`lengths`配列で、新しいディメンションの数でなければなりません。<xref:System.Array>です。 各要素、`lengths`配列は、新たに対応する次元の長さを指定する必要があります<xref:System.Array>です。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`のすべての値の積は、`lengths`です。  
  
   
  
## Examples  
 次のコード例は、作成し、多次元を初期化する方法を示しています。<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> is <see langword="null" />.  -or-  <paramref name="lengths" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.  -or-  The <paramref name="lengths" /> array contains less than one element.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> is not supported. For example, <see cref="T:System.Void" /> is not supported.  -or-  <paramref name="elementType" /> is an open generic type.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Any value in <paramref name="lengths" /> is less than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</param>
        <param name="lengths">An array of 64-bit integers that represent the size of each dimension of the <see cref="T:System.Array" /> to create. Each integer in the array must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</param>
        <summary>Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing. The dimension lengths are specified in an array of 64-bit integers.</summary>
        <returns>A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 内の要素の数、`lengths`配列で、新しいディメンションの数でなければなりません。<xref:System.Array>です。 各要素、`lengths`配列は、新たに対応する次元の長さを指定する必要があります<xref:System.Array>です。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`のすべての値の積は、`lengths`です。  
  
   
  
## Examples  
 次のコード例は、作成し、多次元を初期化する方法を示しています。<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> is <see langword="null" />.  -or-  <paramref name="lengths" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.  -or-  The <paramref name="lengths" /> array contains less than one element.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> is not supported. For example, <see cref="T:System.Void" /> is not supported.  -or-  <paramref name="elementType" /> is an open generic type.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Any value in <paramref name="lengths" /> is less than zero or greater than <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</param>
        <param name="length1">The size of the first dimension of the <see cref="T:System.Array" /> to create.</param>
        <param name="length2">The size of the second dimension of the <see cref="T:System.Array" /> to create.</param>
        <summary>Creates a two-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</summary>
        <returns>A new two-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`の製品は、`length1`と`length2`です。  
  
   
  
## Examples  
 次のコード例は、作成し、2 次元を初期化する方法を示しています。<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> is not supported. For example, <see cref="T:System.Void" /> is not supported.  -or-  <paramref name="elementType" /> is an open generic type.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> is less than zero.  -or-  <paramref name="length2" /> is less than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</param>
        <param name="lengths">A one-dimensional array that contains the size of each dimension of the <see cref="T:System.Array" /> to create.</param>
        <param name="lowerBounds">A one-dimensional array that contains the lower bound (starting index) of each dimension of the <see cref="T:System.Array" /> to create.</param>
        <summary>Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with the specified lower bounds.</summary>
        <returns>A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length and lower bound for each dimension.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 `lengths`と`lowerBounds`配列は同じ数の要素を持つ必要があります。 内の要素の数、`lengths`配列で、新しいディメンションの数でなければなりません。<xref:System.Array>です。  
  
 各要素、`lengths`配列は、新たに対応する次元の長さを指定する必要があります<xref:System.Array>です。  
  
 各要素、`lowerBounds`配列は新たに対応する次元の下限を指定する必要があります<xref:System.Array>です。 一般に、.NET Framework クラス ライブラリと多くのプログラミング言語は、0 以外の下限を処理しません。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`のすべての値の積は、`lengths`です。  
  
   
  
## Examples  
 次のコード例は、作成し、多次元を初期化する方法を示しています。<xref:System.Array>下限を指定します。  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> is <see langword="null" />.  -or-  <paramref name="lengths" /> is <see langword="null" />.  -or-  <paramref name="lowerBounds" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.  -or-  The <paramref name="lengths" /> array contains less than one element.  -or-  The <paramref name="lengths" /> and <paramref name="lowerBounds" /> arrays do not contain the same number of elements.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> is not supported. For example, <see cref="T:System.Void" /> is not supported.  -or-  <paramref name="elementType" /> is an open generic type.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Any value in <paramref name="lengths" /> is less than zero.  -or-  Any value in <paramref name="lowerBounds" /> is very large, such that the sum of a dimension's lower bound and length is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</param>
        <param name="length1">The size of the first dimension of the <see cref="T:System.Array" /> to create.</param>
        <param name="length2">The size of the second dimension of the <see cref="T:System.Array" /> to create.</param>
        <param name="length3">The size of the third dimension of the <see cref="T:System.Array" /> to create.</param>
        <summary>Creates a three-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</summary>
        <returns>A new three-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O (`n`) 操作、場所`n`の製品は、 `length1`、 `length2`、および`length3`です。  
  
   
  
## Examples  
 次のコード例は、作成し、3 次元を初期化する方法を示しています。<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> is not supported. For example, <see cref="T:System.Void" /> is not supported.  -or-  <paramref name="elementType" /> is an open generic type.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> is less than zero.  -or-  <paramref name="length2" /> is less than zero.  -or-  <paramref name="length3" /> is less than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <summary>Returns an empty array.</summary>
        <returns>Returns an empty <see cref="T:System.Array" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="match">The <see cref="T:System.Predicate`1" /> that defines the conditions of the elements to search for.</param>
        <summary>Determines whether the specified array contains elements that match the conditions defined by the specified predicate.</summary>
        <returns>
          <see langword="true" /> if <paramref name="array" /> contains one or more elements that match the conditions defined by the specified predicate; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>一致が見つかったときに処理が停止しているとします。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、<xref:System.Predicate%601>明示的に委任します。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例についての一致条件を指定する、<xref:System.Array.Exists%2A>メソッド usinglambda 式かどうか、地球から始まり、指定した文字または、渡された配列の地球が見つかったかどうかを確認します。  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 次の例では、<xref:System.Array.Exists%2A>メソッドを文字列配列の任意の名前が指定された文字で始まるかどうかを示します。 この例のインスタンスを作成、`StringSearcher`クラス コンス トラクターを検索する文字列を渡すことによってオブジェクト。 `StringSearcher.StartsWith`メソッドと同じシグネチャを持つ、<xref:System.Predicate%601>を委任します。 ときに、<xref:System.Array.Exists%2A>メソッドが呼び出されると、返されるまで、配列の各メンバーが、デリゲートに渡された`true`または配列内のすべての要素を反復処理します。  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 ことができますもラムダ式を使用ではなく、デリゲートのシグネチャを持つ対応するメソッドを明示的に定義します。 次の例が置き換えられます、`StringSearcher`クラスとその`StartsWith`ラムダ式を持つメソッドです。  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.  -or-  <paramref name="match" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based array to search.</param>
        <param name="match">The predicate that defines the conditions of the element to search for.</param>
        <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire <see cref="T:System.Array" />.</summary>
        <returns>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>メソッドまたはラムダ式を返すデリゲート`true`デリゲートまたはラムダ式で定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、 <xref:System.Predicate%601>、最初の要素で開始および終了の最後の要素。  一致が見つかった場合は、処理が停止しました。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例では、<xref:System.Predicate%601>を持つデリゲート、<xref:System.Array.Find%2A>ジェネリック メソッドの配列を検索する<xref:System.Drawing.Point>構造体。 デリゲートが表すメソッド`ProductGT10`、返します`true`X と Y のフィールドの製品が 100,000 より大きい場合。 <xref:System.Array.Find%2A>メソッドがテスト条件を満たす最初のポイントを返す、配列の各要素に対してデリゲートを呼び出します。  
  
> [!NOTE]
>  Visual Basic および C# では、デリゲートを明示的に作成またはジェネリック メソッドの型引数を指定する必要はありません。 コンパイラでは、指定したメソッドの引数から必要な型を決定します。  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 必要なシグネチャを持つメソッドを明示的に定義するのではなくインスタンス化する、<xref:System.Predicate%601>を委任して、デリゲートに渡すこと、<xref:System.Array.Find%2A>メソッド、ラムダ式を使用する一般的なは。 ラムダ式として使用する点を除いては、次の例は、1 つ前と同じ、`match`引数。  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.  -or-  <paramref name="match" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="match">The <see cref="T:System.Predicate`1" /> that defines the conditions of the elements to search for.</param>
        <summary>Retrieves all the elements that match the conditions defined by the specified predicate.</summary>
        <returns>An <see cref="T:System.Array" /> containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>条件に一致する要素が返される配列に保存されます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例では、範囲は 0 ~ 1,000 値を持つ 50 個のランダムな数値の配列を作成します。 呼び出して、<xref:System.Array.FindAll%2A>を 600 に 300 の値の範囲を返すラムダ式を持つメソッドです。 ラムダ式のという名前のパラメーターが渡されることに注意してください`x`です。 渡される個々 の配列のメンバーを表すこの、<xref:System.Predicate%601>です。 またを注意してください。 ローカル`lBound`と`uBound`変数は、ラムダ式内でアクセス可能です。  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 次のコード例を示しています、 <xref:System.Array.Find%2A>、 <xref:System.Array.FindLast%2A>、および<xref:System.Array.FindAll%2A>ジェネリック メソッドです。 "Saurus"で終わる (位置 1 から 5 など) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 <xref:System.Array.Find%2A>ジェネリック メソッドは、最初に、各要素を順番に渡してから、配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`要素"Amargasaurus"です。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 <xref:System.Array.FindLast%2A>末尾から旧バージョンとの配列を検索するジェネリック メソッドを使用します。 "Dilophosaurus"5 番目の位置にある要素を検索します。 <xref:System.Array.FindAll%2A>で"終了するすべての要素を含む配列を返すジェネリック メソッドを使用します。 要素が表示されます。  
  
 このコード例も示します、<xref:System.Array.Exists%2A>と<xref:System.Array.TrueForAll%2A>ジェネリック メソッドです。  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.  -or-  <paramref name="match" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the first occurrence within an <see cref="T:System.Array" /> or a portion of it.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="match">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</param>
        <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire <see cref="T:System.Array" />.</summary>
        <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>はフォワード最初の要素を起点と最後の要素で終わる検索します。  
  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例に示しますの 3 つすべてのオーバー ロード、<xref:System.Array.FindIndex%2A>ジェネリック メソッドです。 "Saurus"で終わる (位置 1 から 5 など) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、各要素を順番に渡して、先頭から、配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の位置 1 にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から開始し、配列の末尾を続行する配列を検索するメソッド オーバー ロードを使用します。 5 番目の位置にある要素を検索します。 最後に、<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から 3 つの要素の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に恐竜の名前が存在しないために、-1 を返します。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.  -or-  <paramref name="match" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="startIndex">The zero-based starting index of the search.</param>
        <param name="match">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</param>
        <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <see cref="T:System.Array" /> that extends from the specified index to the last element.</summary>
        <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>転送を開始位置として検索`startIndex`と最後の要素で終了します。  
  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`から要素の数は、`startIndex`の末尾に`array`です。  
  
   
  
## Examples  
 次のコード例に示しますの 3 つすべてのオーバー ロード、<xref:System.Array.FindIndex%2A>ジェネリック メソッドです。 "Saurus"で終わる (位置 1 から 5 など) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、各要素を順番に渡して、先頭から、配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の位置 1 にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から開始し、配列の末尾を続行する配列を検索するメソッド オーバー ロードを使用します。 5 番目の位置にある要素を検索します。 最後に、<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から 3 つの要素の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に恐竜の名前が存在しないために、-1 を返します。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.  -or-  <paramref name="match" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="startIndex">The zero-based starting index of the search.</param>
        <param name="count">The number of elements in the section to search.</param>
        <param name="match">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</param>
        <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <see cref="T:System.Array" /> that starts at the specified index and contains the specified number of elements.</summary>
        <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>転送を開始位置として検索が`startIndex`で終わる`startIndex`plus`count`から 1 を引いた場合`count`が 0 より大きい。  
  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`count`します。  
  
   
  
## Examples  
 次のコード例に示しますの 3 つすべてのオーバー ロード、<xref:System.Array.FindIndex%2A>ジェネリック メソッドです。 "Saurus"で終わる (位置 1 から 5 など) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、各要素を順番に渡して、先頭から、配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の位置 1 にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から開始し、配列の末尾を続行する配列を検索するメソッド オーバー ロードを使用します。 5 番目の位置にある要素を検索します。 最後に、<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から 3 つの要素の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に恐竜の名前が存在しないために、-1 を返します。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.  -or-  <paramref name="match" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.  -or-  <paramref name="count" /> is less than zero.  -or-  <paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="match">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</param>
        <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <see cref="T:System.Array" />.</summary>
        <returns>The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>への移行の旧バージョンと、 <xref:System.Array>、最後の要素で開始および終了の最初の要素。  一致が見つかった場合は、処理が停止しました。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例を示しています、 <xref:System.Array.Find%2A>、 <xref:System.Array.FindLast%2A>、および<xref:System.Array.FindAll%2A>ジェネリック メソッドです。 "Saurus"で終わる (位置 1 から 5 など) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 <xref:System.Array.Find%2A>ジェネリック メソッドは、最初に、各要素を順番に渡してから、配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`要素"Amargasaurus"です。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 <xref:System.Array.FindLast%2A>末尾から旧バージョンとの配列を検索するジェネリック メソッドを使用します。 "Dilophosaurus"5 番目の位置にある要素を検索します。 <xref:System.Array.FindAll%2A>で"終了するすべての要素を含む配列を返すジェネリック メソッドを使用します。 要素が表示されます。  
  
 このコード例も示します、<xref:System.Array.Exists%2A>と<xref:System.Array.TrueForAll%2A>ジェネリック メソッドです。  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.  -or-  <paramref name="match" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the last occurrence within an <see cref="T:System.Array" /> or a portion of it.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="match">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</param>
        <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire <see cref="T:System.Array" />.</summary>
        <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>後方の最後の要素の最初と最後の最初の要素を検索します。  
  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例に示しますの 3 つすべてのオーバー ロード、<xref:System.Array.FindLastIndex%2A>ジェネリック メソッドです。 "Saurus"で終わる (位置 1 から 5 など) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、最後に、各要素を順番に渡してから旧バージョンとの配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の 5 番目の位置にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 4 から開始し、配列の先頭を続行する前に、配列を検索するメソッド オーバー ロードを使用します。 位置 1 である要素を検索します。 最後に、 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 3 つの要素位置 4 から開始し、逆方向 (つまり、4、3、および 2) の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に恐竜の名前が存在しないために、-1 を返します。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.  -or-  <paramref name="match" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="startIndex">The zero-based starting index of the backward search.</param>
        <param name="match">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</param>
        <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that extends from the first element to the specified index.</summary>
        <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>検索旧バージョンとを開始位置として、`startIndex`と最初の要素で終了します。  
  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`の先頭から要素の数は、`array`に`startIndex`です。  
  
   
  
## Examples  
 次のコード例に示しますの 3 つすべてのオーバー ロード、<xref:System.Array.FindLastIndex%2A>ジェネリック メソッドです。 "Saurus"で終わる (位置 1 から 5 など) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、最後に、各要素を順番に渡してから旧バージョンとの配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の 5 番目の位置にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 4 から開始し、配列の先頭を続行する前に、配列を検索するメソッド オーバー ロードを使用します。 位置 1 である要素を検索します。 最後に、 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 3 つの要素位置 4 から開始し、逆方向 (つまり、4、3、および 2) の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に恐竜の名前が存在しないために、-1 を返します。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.  -or-  <paramref name="match" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="startIndex">The zero-based starting index of the backward search.</param>
        <param name="count">The number of elements in the section to search.</param>
        <param name="match">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</param>
        <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that contains the specified number of elements and ends at the specified index.</summary>
        <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>検索旧バージョンとを開始位置として、`startIndex`で終わる`startIndex`マイナス`count`1、さらに場合`count`が 0 より大きい。  
  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、<xref:System.Predicate%601>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`count`します。  
  
   
  
## Examples  
 次のコード例に示しますの 3 つすべてのオーバー ロード、<xref:System.Array.FindLastIndex%2A>ジェネリック メソッドです。 "Saurus"で終わる (位置 1 から 5 など) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、最後に、各要素を順番に渡してから旧バージョンとの配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の 5 番目の位置にある要素。  
  
> [!NOTE]
>  C# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 4 から開始し、配列の先頭を続行する前に、配列を検索するメソッド オーバー ロードを使用します。 位置 1 である要素を検索します。 最後に、 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 3 つの要素位置 4 から開始し、逆方向 (つまり、4、3、および 2) の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に恐竜の名前が存在しないために、-1 を返します。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.  -or-  <paramref name="match" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.  -or-  <paramref name="count" /> is less than zero.  -or-  <paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> on whose elements the action is to be performed.</param>
        <param name="action">The <see cref="T:System.Action`1" /> to perform on each element of <c>array</c>.</param>
        <summary>Performs the specified action on each element of the specified array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601>を渡すとき、オブジェクトが操作を実行するメソッドにデリゲートします。  要素`array`に個別に渡される、<xref:System.Action%601>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例は、使用する方法を示しています。<xref:System.Array.ForEach%2A>整数配列の各要素の四角形を表示します。  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.  -or-  <paramref name="action" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Array" />.</summary>
        <returns>An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic、C# の場合]  
  
 `foreach` C# 言語のステートメント (`for each` C++ では、 `For Each` Visual Basic で)、列挙子の複雑さが隠されています。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。 <xref:System.Collections.IEnumerator.Reset%2A> を実行した場合も、列挙子はこの位置に戻されます。  この位置では、<xref:System.Collections.IEnumerator.Current%2A> が未定義です。 そのため、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.IEnumerator.Current%2A> を呼び出して列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.IEnumerator.Current%2A> は、<xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> が呼び出されるまでは同じオブジェクトを返します。 <xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.IEnumerator.Current%2A> を次の要素に設定します。  
  
 場合<xref:System.Collections.IEnumerator.MoveNext%2A>列挙子をコレクションの末尾が、コレクション内の最後の要素の後に配置されているパスと<xref:System.Collections.IEnumerator.MoveNext%2A>返します`false`です。 列挙子がこの位置では、後続の呼び出しの場合<xref:System.Collections.IEnumerator.MoveNext%2A>を返すことも`false`します。 最後の呼び出し場合<xref:System.Collections.IEnumerator.MoveNext%2A>返される`false`、<xref:System.Collections.IEnumerator.Current%2A>が定義されていません。 <xref:System.Collections.IEnumerator.Current%2A> をコレクションの最初の要素にもう一度設定するには、<xref:System.Collections.IEnumerator.Reset%2A> を呼び出してから <xref:System.Collections.IEnumerator.MoveNext%2A> を呼び出します。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 (要素の追加、変更、削除など) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子には、コレクションへの排他アクセスがありません。したがって、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示しています。<xref:System.Array.GetEnumerator%2A>を配列の要素を一覧表示します。  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">A zero-based dimension of the <see cref="T:System.Array" /> whose length needs to be determined.</param>
        <summary>Gets a 32-bit integer that represents the number of elements in the specified dimension of the <see cref="T:System.Array" />.</summary>
        <returns>A 32-bit integer that represents the number of elements in the specified dimension.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例<xref:System.Array.GetLength%2A>は`GetLength(0)`の最初の次元で要素の数が返されます、<xref:System.Array>です。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次の例は、使用する方法を示しています。<xref:System.Array.GetLength%2A>ランクが異なる 2 つの配列のサイズを表示します。  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> is less than zero.  -or-  <paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">A zero-based dimension of the <see cref="T:System.Array" /> whose length needs to be determined.</param>
        <summary>Gets a 64-bit integer that represents the number of elements in the specified dimension of the <see cref="T:System.Array" />.</summary>
        <returns>A 64-bit integer that represents the number of elements in the specified dimension.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例<xref:System.Array.GetLongLength%2A>は`GetLongLength(0)`の最初の次元で要素の数が返されます、<xref:System.Array>です。  
  
 このメソッドは、o (1) 操作です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> is less than zero.  -or-  <paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">A zero-based dimension of the array whose starting index needs to be determined.</param>
        <summary>Gets the index of the first element of the specified dimension in the array.</summary>
        <returns>The index of the first element of the specified dimension in the array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` 配列の最初の次元の開始インデックスを返しますと`GetLowerBound(Rank - 1)`配列の最後の次元の開始インデックスを返します。  
  
 <xref:System.Array.GetLowerBound%2A>メソッドは、配列が空の場合でも常に、配列の下限のインデックスを示す値を返します。  
  
 なお、.NET Framework でのほとんどの配列は 0 から始まる (は、<xref:System.Array.GetLowerBound%2A>配列の各次元のゼロが返される)、.NET Framework は 0 から始まる配列をサポートします。 そのような配列を作成できます、<xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29>メソッド、およびアンマネージ コードから返すこともできます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドを 1 次元、2 次元配列の境界を表示して、配列要素の値を表示します。  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> is less than zero.  -or-  <paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">A zero-based dimension of the array whose upper bound needs to be determined.</param>
        <summary>Gets the index of the last element of the specified dimension in the array.</summary>
        <returns>The index of the last element of the specified dimension in the array, or -1 if the specified dimension is empty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` 配列の最初の次元の最後のインデックスを返しますと`GetUpperBound(Rank - 1)`配列の最後の次元の最後のインデックスを返します。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドを 1 次元、2 次元配列の境界を表示して、配列要素の値を表示します。  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> is less than zero.  -or-  <paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the value of the specified element in the current <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">A 32-bit integer that represents the position of the <see cref="T:System.Array" /> element to get.</param>
        <summary>Gets the value at the specified position in the one-dimensional <see cref="T:System.Array" />. The index is specified as a 32-bit integer.</summary>
        <returns>The value at the specified position in the one-dimensional <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>方法を決定できるかどうかの値`index`が範囲外です。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current <see cref="T:System.Array" /> does not have exactly one dimension.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the <see cref="T:System.Array" /> element to get.</param>
        <summary>Gets the value at the specified position in the multidimensional <see cref="T:System.Array" />. The indexes are specified as an array of 32-bit integers.</summary>
        <returns>The value at the specified position in the multidimensional <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内の要素の数`indices`内のディメンションの数と同じにする必要があります、<xref:System.Array>です。 すべての要素、`indices`配列が多次元で、目的の要素の位置をまとめて指定する必要があります<xref:System.Array>です。  
  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">A 64-bit integer that represents the position of the <see cref="T:System.Array" /> element to get.</param>
        <summary>Gets the value at the specified position in the one-dimensional <see cref="T:System.Array" />. The index is specified as a 64-bit integer.</summary>
        <returns>The value at the specified position in the one-dimensional <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>方法を決定できるかどうかの値`index`が範囲外です。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current <see cref="T:System.Array" /> does not have exactly one dimension.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the <see cref="T:System.Array" /> element to get.</param>
        <summary>Gets the value at the specified position in the multidimensional <see cref="T:System.Array" />. The indexes are specified as an array of 64-bit integers.</summary>
        <returns>The value at the specified position in the multidimensional <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内の要素の数`indices`内のディメンションの数と同じにする必要があります、<xref:System.Array>です。 すべての要素、`indices`配列が多次元で、目的の要素の位置をまとめて指定する必要があります<xref:System.Array>です。  
  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</param>
        <param name="index2">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</param>
        <summary>Gets the value at the specified position in the two-dimensional <see cref="T:System.Array" />. The indexes are specified as 32-bit integers.</summary>
        <returns>The value at the specified position in the two-dimensional <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</param>
        <param name="index2">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</param>
        <summary>Gets the value at the specified position in the two-dimensional <see cref="T:System.Array" />. The indexes are specified as 64-bit integers.</summary>
        <returns>The value at the specified position in the two-dimensional <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</param>
        <param name="index2">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</param>
        <param name="index3">A 32-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to get.</param>
        <summary>Gets the value at the specified position in the three-dimensional <see cref="T:System.Array" />. The indexes are specified as 32-bit integers.</summary>
        <returns>The value at the specified position in the three-dimensional <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</param>
        <param name="index2">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</param>
        <param name="index3">A 64-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to get.</param>
        <summary>Gets the value at the specified position in the three-dimensional <see cref="T:System.Array" />. The indexes are specified as 64-bit integers.</summary>
        <returns>The value at the specified position in the three-dimensional <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 このメソッドは、o (1) 操作です。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array or in a range of elements in the array.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional array to search.</param>
        <param name="value">The object to locate in <c>array</c>.</param>
        <summary>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</summary>
        <returns>The index of the first occurrence of <paramref name="value" /> in <paramref name="array" />, if found; otherwise, the lower bound of the array minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、1 次元 arrayfor のすべての要素を検索`value`です。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して各要素の等値比較を実行する`Equals`メソッドの一致が見つかるまでです。 つまり、この要素をオーバーライドする場合、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッド、その上書きが呼び出されます。  
  
 ほとんどの配列の下限を 0 ため、このメソッドは、– 1 返します通常を行う場合`value`が見つかりません。 配列の下限の境界と等しいというまれなケース<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF) です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 例がの次の 3 つオーバー ロードを呼び出して、<xref:System.Array.IndexOf%2A>文字列配列の文字列のインデックスを検索するメソッド。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>、文字列の最初に見つかった位置を決定する、文字列配列の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する文字列配列の最後の要素の 4 番目の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する、文字列"the"の配列を配列の末尾に最後の一致を後ろにある要素。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional array to search.</param>
        <param name="value">The object to locate in <c>array</c>.</param>
        <param name="startIndex">The starting index of the search. 0 (zero) is valid in an empty array.</param>
        <summary>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence. The range extends from a specified index to the end of the array.</summary>
        <returns>The index of the first occurrence of <paramref name="value" />, if it’s found, within the range of elements in <paramref name="array" /> that extends from <paramref name="startIndex" /> to the last element; otherwise, the lower bound of the array minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを 1 次元配列のインデックス位置にある要素からは検索`startIndex`最後の要素。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行し、`Equals`一致が見つかるまでのすべての要素のメソッドです。 つまり、この要素をオーバーライドする場合、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッド、その上書きが呼び出されます。  
  
 ほとんどの配列の下限を 0 ため、このメソッドは、– 1 返します通常を行う場合`value`が見つかりません。 配列の下限の境界と等しいというまれなケース<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF) です。  
  
 場合`startIndex`equals <xref:System.Array.Length%2A?displayProperty=nameWithType>-1 を返します。 場合`startIndex`がより大きい<xref:System.Array.Length%2A?displayProperty=nameWithType>がスローされます、<xref:System.ArgumentOutOfRangeException>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`から要素の数は、`startIndex`の末尾に`array`です。  
  
   
  
## Examples  
 例がの次の 3 つオーバー ロードを呼び出して、<xref:System.Array.IndexOf%2A>文字列配列の文字列のインデックスを検索するメソッド。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>、文字列の最初に見つかった位置を決定する、文字列配列の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する文字列配列の最後の要素の 4 番目の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する、文字列"the"の配列を配列の末尾に最後の一致を後ろにある要素。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional array to search.</param>
        <param name="value">The object to locate in <c>array</c>.</param>
        <param name="startIndex">The starting index of the search. 0 (zero) is valid in an empty array.</param>
        <param name="count">The number of elements to search.</param>
        <summary>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of ifs first occurrence. The range extends from a specified index for a specified number of elements.</summary>
        <returns>The index of the first occurrence of <paramref name="value" />, if it’s found in the <paramref name="array" /> from index <paramref name="startIndex" /> to <paramref name="startIndex" /> + <paramref name="count" /> - 1; otherwise, the lower bound of the array minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、1 次元 arrayfrom の要素を検索`startIndex`に`startIndex`plus`count`から 1 を引いた場合`count`が 0 より大きい。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行し、`Equals`一致が見つかるまでのすべての要素のメソッドです。 つまり、この要素をオーバーライドする場合、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッド、その上書きが呼び出されます。  
  
 Becausemost 配列の下限を 0 である一般的に、このメソッドは – 1 時を返します`value`が見つかりません。 配列の下限の境界と等しいというまれなケース<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF) です。  
  
 場合`startindex`equals <xref:System.Array.Length%2A?displayProperty=nameWithType>-1 を返します。 場合`startIndex`がより大きい<xref:System.Array.Length%2A?displayProperty=nameWithType>がスローされます、<xref:System.ArgumentOutOfRangeException>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`count`します。  
  
   
  
## Examples  
 例がの次の 3 つオーバー ロードを呼び出して、<xref:System.Array.IndexOf%2A>文字列配列の文字列のインデックスを検索するメソッド。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>、文字列の最初に見つかった位置を決定する、文字列配列の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する文字列配列の最後の要素の 4 番目の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する、文字列"the"の配列を配列の末尾に最後の一致を後ろにある要素。 値を決定する、`count`引数を配列の開始インデックスからの上限値を減算し、1 を追加します。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.  -or-  <paramref name="count" /> is less than zero.  -or-  <paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based array to search.</param>
        <param name="value">The object to locate in <c>array</c>.</param>
        <summary>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</summary>
        <returns>The zero-based index of the first occurrence of <paramref name="value" /> in the entire <paramref name="array" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの 1 次元配列のすべての要素を検索する`value`です。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行し、`T.Equals`メソッドのすべての要素をします。 つまり、`T`よりも優先、<xref:System.Object.Equals%2A>メソッド、その上書きが呼び出されます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例では、すべて次の 3 つジェネリック オーバー ロードの<xref:System.Array.IndexOf%2A>メソッドです。 インデックス位置 0 と 5 のインデックス位置に 2 回、表示される 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、最初から配列を検索し、文字列の最初の出現箇所を検索します。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードが 3 のインデックスの場所を開始位置として、配列と、配列の末尾まで続行を検索するために使用し、文字列の 2 番目の出現箇所を検索します。 最後に、<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>その範囲内で検索文字列のインスタンスが存在しないため – 1 を返しますではメソッドのオーバー ロードを使用して、インデックス位置 2 から 2 つのエントリの範囲を検索します。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based array to search.</param>
        <param name="value">The object to locate in <c>array</c>.</param>
        <param name="startIndex">The zero-based starting index of the search. 0 (zero) is valid in an empty array.</param>
        <summary>Searches for the specified object in a range of elements of a one dimensional array, and returns the index of its first occurrence. The range extends from a specified index to the end of the array.</summary>
        <returns>The zero-based index of the first occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that extends from <paramref name="startIndex" /> to the last element, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを 1 次元配列にある要素からは検索`startIndex`配列の末尾にします。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行し、`T.Equals`メソッドのすべての要素をします。 つまり、`T`よりも優先、<xref:System.Object.Equals%2A>メソッド、その上書きが呼び出されます。  
  
 場合`startIndex`equals <xref:System.Array.Length%2A>、メソッドを返します - 1.If`startIndex`がより大きい<xref:System.Array.Length%2A?displayProperty=nameWithType>がスローされます、<xref:System.ArgumentOutOfRangeException>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`から要素の数は、`startIndex`の末尾に`array`です。  
  
   
  
## Examples  
 次の例では、すべて次の 3 つジェネリック オーバー ロードの<xref:System.Array.IndexOf%2A>メソッドです。 インデックス位置 0 と 5 のインデックス位置に 2 回、表示される 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、最初から配列を検索し、文字列の最初の出現箇所を検索します。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードが 3 のインデックスの場所を開始位置として、配列と、配列の末尾まで続行を検索するために使用し、文字列の 2 番目の出現箇所を検索します。 最後に、<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>その範囲内で検索文字列のインスタンスが存在しないため – 1 を返しますではメソッドのオーバー ロードを使用して、インデックス位置 2 から 2 つのエントリの範囲を検索します。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based array to search.</param>
        <param name="value">The object to locate in <c>array</c>.</param>
        <param name="startIndex">The zero-based starting index of the search. 0 (zero) is valid in an empty array.</param>
        <param name="count">The number of elements in the section to search.</param>
        <summary>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence. The range extends from a specified index for a specified number of elements.</summary>
        <returns>The zero-based index of the first occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that starts at <paramref name="startIndex" /> and contains the number of elements specified in <paramref name="count" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッド searchesthe、1 次元の配列の要素から`startIndex`に`startIndex`plus`count`から 1 を引いた場合`count`が 0 より大きい。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行し、`T.Equals`メソッドのすべての要素をします。 つまり、`T`よりも優先、<xref:System.Object.Equals%2A>メソッド、その上書きが呼び出されます。  
  
 場合`startIndex`equals <xref:System.Array.Length%2A?displayProperty=nameWithType>-1 を返します。  場合`startIndex`がより大きい<xref:System.Array.Length%2A?displayProperty=nameWithType>がスローされます、<xref:System.ArgumentOutOfRangeException>です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`count`します。  
  
   
  
## Examples  
 次の例では、すべて次の 3 つジェネリック オーバー ロードの<xref:System.Array.IndexOf%2A>メソッドです。 インデックス位置 0 と 5 のインデックス位置に 2 回、表示される 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、最初から配列を検索し、文字列の最初の出現箇所を検索します。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードが 3 のインデックスの場所を開始位置として、配列と、配列の末尾まで続行を検索するために使用し、文字列の 2 番目の出現箇所を検索します。 最後に、<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>その範囲内で検索文字列のインスタンスが存在しないため – 1 を返しますではメソッドのオーバー ロードを使用して、インデックス位置 2 から 2 つのエントリの範囲を検索します。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.  -or-  <paramref name="count" /> is less than zero.  -or-  <paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initializes every element of the value-type <see cref="T:System.Array" /> by calling the default constructor of the value type.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドがコンパイラが値型の配列をサポートするように設計されていますほとんどのユーザーには、このメソッドは必要ありません。 これは参照型の配列で使用しないでください。  
  
 場合、<xref:System.Array>値型ではない<xref:System.Array>または値の型に既定のコンス トラクターがあるない場合、<xref:System.Array>は変更されません。  
  
 値型<xref:System.Array>ディメンションの任意の数と、下限を持つことができます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は<xref:System.Array.Length%2A>します。  
  
> [!CAUTION]
>  このメソッドはコンス トラクター; を持つ値型でのみ使用できます。ただし、ネイティブに C# の場合は、値型には、コンス トラクターはありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Array" /> has a fixed size.</summary>
        <value>このプロパティは常に<see langword="true" />のすべての配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 実装する、<xref:System.Array.IsFixedSize%2A>プロパティが必要としているため、<xref:System.Collections.IList?displayProperty=nameWithType>インターフェイスです。  
  
 固定サイズの配列は、追加または削除できません要素の配列が作成された後で既存の要素は変更できます。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Array" /> is read-only.</summary>
        <value>このプロパティは常に<see langword="false" />のすべての配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 実装する、<xref:System.Array.IsReadOnly%2A>プロパティが必要としているため、<xref:System.Collections.IList?displayProperty=nameWithType>インターフェイスです。 読み取り専用配列を追加、削除、または要素の変更後にできません、配列を作成します。  
  
 読み取り専用コレクションを必要とする場合を使用して、<xref:System.Collections>を実装するクラス、<xref:System.Collections.IList?displayProperty=nameWithType>インターフェイスです。  
  
 キャストの配列に変換するか、<xref:System.Collections.IList>インターフェイス オブジェクト、<xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType>プロパティから返される`false`です。 ただし、キャストを配列に変換するか、 <xref:System.Collections.Generic.IList%601> 、インターフェイス、`IsReadOnly`プロパティから返される`true`です。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether access to the <see cref="T:System.Array" /> is synchronized (thread safe).</summary>
        <value>このプロパティは常に<see langword="false" />のすべての配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 実装する、<xref:System.Array.IsSynchronized%2A>プロパティが必要としているため、<xref:System.Collections.ICollection?displayProperty=nameWithType>インターフェイスです。  
  
 .NET framework のクラスがに基づいて<xref:System.Array>独自の同期されたバージョンを使用して、コレクションの提供、<xref:System.Array.SyncRoot%2A>プロパティです。  
  
 配列を使用するクラスに、独自の同期を使用することができますも実装、<xref:System.Array.SyncRoot%2A>プロパティです。 同期されたコードで操作を実行する必要があります、`SyncRoot`コレクションの操作は、コレクションのです。 これにより、他のオブジェクトから派生したコレクションを適切に操作できるようになります。 具体的には、コレクションを同時に変更する可能性がある別スレッドとの適切な同期を維持します。 なおの実装によって<xref:System.Array.SyncRoot%2A>返す可能性があります、<xref:System.Array>自体です。  
  
 コレクションの列挙は本質的にスレッド セーフな方法です。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
   
  
## Examples  
 次のコード例を使用して配列を列挙中にロックする方法を示しています、<xref:System.Array.SyncRoot%2A>プロパティです。  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the index of the last occurrence of a value in a one-dimensional <see cref="T:System.Array" /> or in a portion of the <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">The object to locate in <c>array</c>.</param>
        <summary>Searches for the specified object and returns the index of the last occurrence within the entire one-dimensional <see cref="T:System.Array" />.</summary>
        <returns>The index of the last occurrence of <paramref name="value" /> within the entire <paramref name="array" />, if found; otherwise, the lower bound of the array minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1 次元<xref:System.Array>後方の最後の要素の最初と最後の最初の要素を検索します。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッドです。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装を使用します。  
  
 ほとんどの配列が下限を 0 であるためこのメソッドは、通常 – 1 の場合に`value`が見つかりません。 配列の下限の境界と等しいというまれなケース<xref:System.Int32.MinValue?displayProperty=nameWithType>と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>、これは`System.Int32.MinValue - 1`します。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
 .NET framework version 2.0 では、このメソッドを使用して、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、<xref:System.Array>を決定するかどうか、<xref:System.Object>によって指定された、`value`パラメーターが存在します。 .NET Framework の以前のバージョンでは、この決定を使用して行われた、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、 `value` <xref:System.Object>自体です。  
  
 <xref:System.IComparable.CompareTo%2A> メソッド、`item`パラメーター コレクション内のオブジェクトにします。  
  
   
  
## Examples  
 次のコード例では、配列内の指定した要素の最後に見つかった位置のインデックスを確認する方法を示します。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">The object to locate in <c>array</c>.</param>
        <param name="startIndex">The starting index of the backward search.</param>
        <summary>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <see cref="T:System.Array" /> that extends from the first element to the specified index.</summary>
        <returns>The index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that extends from the first element to <paramref name="startIndex" />, if found; otherwise, the lower bound of the array minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1 次元<xref:System.Array>検索旧バージョンとを開始位置として、`startIndex`と最初の要素で終了します。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッドです。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装を使用します。  
  
 ほとんどの配列が下限を 0 であるためこのメソッドは、通常 – 1 の場合に`value`が見つかりません。 配列の下限の境界と等しいというまれなケース<xref:System.Int32.MinValue?displayProperty=nameWithType>と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>、これは`System.Int32.MinValue - 1`します。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`の先頭から要素の数は、`array`に`startIndex`です。  
  
 .NET framework version 2.0 では、このメソッドを使用して、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、<xref:System.Array>を決定するかどうか、<xref:System.Object>によって指定された、`value`パラメーターが存在します。 .NET Framework の以前のバージョンでは、この決定を使用して行われた、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、 `value` <xref:System.Object>自体です。  
  
   
  
## Examples  
 次のコード例では、配列内の指定した要素の最後に見つかった位置のインデックスを確認する方法を示します。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">The object to locate in <c>array</c>.</param>
        <param name="startIndex">The starting index of the backward search.</param>
        <param name="count">The number of elements in the section to search.</param>
        <summary>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <see cref="T:System.Array" /> that contains the specified number of elements and ends at the specified index.</summary>
        <returns>The index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that contains the number of elements specified in <paramref name="count" /> and ends at <paramref name="startIndex" />, if found; otherwise, the lower bound of the array minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1 次元<xref:System.Array>検索旧バージョンとを開始位置として、`startIndex`で終わる`startIndex`マイナス`count`1、さらに場合`count`が 0 より大きい。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッドです。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装を使用します。  
  
 ほとんどの配列が下限を 0 であるためこのメソッドは、通常 – 1 の場合に`value`が見つかりません。 配列の下限の境界と等しいというまれなケース<xref:System.Int32.MinValue?displayProperty=nameWithType>と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=nameWithType>、これは`System.Int32.MinValue - 1`します。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`count`します。  
  
 .NET framework version 2.0 では、このメソッドを使用して、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、<xref:System.Array>を決定するかどうか、<xref:System.Object>によって指定された、`value`パラメーターが存在します。 .NET Framework の以前のバージョンでは、この決定を使用して行われた、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、 `value` <xref:System.Object>自体です。  
  
   
  
## Examples  
 次のコード例では、配列内の指定した要素の最後に見つかった位置のインデックスを確認する方法を示します。 注意してください、<xref:System.Array.LastIndexOf%2A>メソッドは逆方向検索です。 したがって、`count`以下にする必要があります (`startIndex`マイナス 1 を足した数、配列の下限値)。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.  -or-  <paramref name="count" /> is less than zero.  -or-  <paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="value">The object to locate in <c>array</c>.</param>
        <summary>Searches for the specified object and returns the index of the last occurrence within the entire <see cref="T:System.Array" />.</summary>
        <returns>The zero-based index of the last occurrence of <paramref name="value" /> within the entire <paramref name="array" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>後方の最後の要素の最初と最後の最初の要素を検索します。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッドです。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装を使用します。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例をすべて次の 3 つジェネリックのオーバー ロードを示しています、<xref:System.Array.LastIndexOf%2A>メソッドです。 インデックス位置 0 と 5 のインデックス位置に 2 回、表示される 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、末尾から配列全体を検索し、文字列の 2 番目の出現箇所を検索します。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードは、旧バージョンと配列はインデックスの場所に 3 と、配列の先頭に継続を検索するために使用し、文字列の最初の出現箇所を検索します。 最後に、<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>メソッドのオーバー ロードが、インデックスの位置 4 に開始し、逆方向に拡張する 4 つのエントリの範囲を検索に使用される (つまり、その項目を検索、4、3、2、および 1 の場所で); 検索のインスタンスが存在しないために、この検索は – 1 を返しますその範囲内の文字列。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="value">The object to locate in <c>array</c>.</param>
        <param name="startIndex">The zero-based starting index of the backward search.</param>
        <summary>Searches for the specified object and returns the index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that extends from the first element to the specified index.</summary>
        <returns>The zero-based index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that extends from the first element to <paramref name="startIndex" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>検索旧バージョンとを開始位置として、`startIndex`と最初の要素で終了します。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッドです。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装を使用します。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`の先頭から要素の数は、`array`に`startIndex`です。  
  
   
  
## Examples  
 次のコード例をすべて次の 3 つジェネリックのオーバー ロードを示しています、<xref:System.Array.LastIndexOf%2A>メソッドです。 インデックス位置 0 と 5 のインデックス位置に 2 回、表示される 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、末尾から配列全体を検索し、文字列の 2 番目の出現箇所を検索します。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードは、旧バージョンと配列はインデックスの場所に 3 と、配列の先頭に継続を検索するために使用し、文字列の最初の出現箇所を検索します。 最後に、<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>メソッドのオーバー ロードが、インデックスの位置 4 に開始し、逆方向に拡張する 4 つのエントリの範囲を検索に使用される (つまり、その項目を検索、4、3、2、および 1 の場所で); 検索のインスタンスが存在しないために、この検索は – 1 を返しますその範囲内の文字列。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="value">The object to locate in <c>array</c>.</param>
        <param name="startIndex">The zero-based starting index of the backward search.</param>
        <param name="count">The number of elements in the section to search.</param>
        <summary>Searches for the specified object and returns the index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that contains the specified number of elements and ends at the specified index.</summary>
        <returns>The zero-based index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that contains the number of elements specified in <paramref name="count" /> and ends at <paramref name="startIndex" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>検索旧バージョンとを開始位置として、`startIndex`で終わる`startIndex`マイナス`count`1、さらに場合`count`が 0 より大きい。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=nameWithType>メソッドです。 要素の型が非組み込みの (ユーザー定義) 型の場合、`Equals`その型の実装を使用します。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`count`します。  
  
   
  
## Examples  
 次のコード例をすべて次の 3 つジェネリックのオーバー ロードを示しています、<xref:System.Array.LastIndexOf%2A>メソッドです。 インデックス位置 0 と 5 のインデックス位置に 2 回、表示される 1 つのエントリで、文字列の配列が作成されます。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、末尾から配列全体を検索し、文字列の 2 番目の出現箇所を検索します。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードは、旧バージョンと配列はインデックスの場所に 3 と、配列の先頭に継続を検索するために使用し、文字列の最初の出現箇所を検索します。 最後に、<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>メソッドのオーバー ロードが、インデックスの位置 4 に開始し、逆方向に拡張する 4 つのエントリの範囲を検索に使用される (つまり、その項目を検索、4、3、2、および 1 の場所で); 検索のインスタンスが存在しないために、この検索は – 1 を返しますその範囲内の文字列。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.  -or-  <paramref name="count" /> is less than zero.  -or-  <paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the total number of elements in all the dimensions of the <see cref="T:System.Array" />.</summary>
        <value>すべてのディメンション内の要素の合計数、<see cref="T:System.Array" />配列の要素が存在しない場合はゼロです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
   
  
## Examples  
 次の例では、<xref:System.Array.Length%2A>配列内の要素の合計数を取得するプロパティです。 また、使用、<xref:System.Array.GetUpperBound%2A>多次元配列の各次元内の要素の数を決定するメソッド。  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">The array is multidimensional and contains more than <see cref="F:System.Int32.MaxValue" /> elements.</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a 64-bit integer that represents the total number of elements in all the dimensions of the <see cref="T:System.Array" />.</summary>
        <value>すべてのディメンション内の要素の合計数を表す 64 ビットの整数、<see cref="T:System.Array" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the rank (number of dimensions) of the <see cref="T:System.Array" />. For example, a one-dimensional array returns 1, a two-dimensional array returns 2, and so on.</summary>
        <value>ランク (次元数)、<see cref="T:System.Array" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば、Visual Basic コード  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 および c# コード  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 次の 3 つの次元の配列を作成、<xref:System.Array.Rank%2A>プロパティの値は 3 です。  
  
 ジャグ配列 (配列の配列) が 1 次元配列です。値、<xref:System.Array.Rank%2A>プロパティは 1 です。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
   
  
## Examples  
 次の例は、1 次元の配列、2 次元の配列およびジャグ配列を初期化し、取得、<xref:System.Array.Rank%2A>それぞれのプロパティです。  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize :  * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]&amp;" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based array to resize, or <see langword="null" /> to create a new array with the specified size.</param>
        <param name="newSize">The size of the new array.</param>
        <summary>Changes the number of elements of a one-dimensional array to the specified new size.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、指定したサイズで新しい配列を割り当てます、元の配列から新しい 1 つに要素をコピーし、し、元の配列を新しいものに置き換えます。 `array` 1 次元配列である必要があります。  
  
 場合`array`は`null`、このメソッドは、指定したサイズで新しい配列を作成します。  
  
 場合`newSize`がより大きい、<xref:System.Array.Length%2A>元の配列の新しい配列が割り当てられ、すべての要素が元の配列から新しい 1 つにコピーします。  場合`newSize`はより小さい<xref:System.Array.Length%2A>元の配列の新しい配列が割り当てられている、要素がコピーされた元の配列から新しいゲートウェイに新しいが塗りつぶされるまで以外の場合は元の配列内の要素の残りの部分は無視されます。  場合`newSize`と等しい、<xref:System.Array.Length%2A>の元の配列では、このメソッドでは何も行われません。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`newSize`します。  
  
 <xref:System.Array.Resize%2A>メソッド サイズを 1 次元配列のみを変更します。 <xref:System.Array>多次元配列のサイズを変更するためのメソッドがクラスに含まれません。 これを行うには、独自のコードを指定するか、サード パーティ ライブラリで特殊なメソッドを呼び出す必要があります。 次のコードは、1 つの配列のサイズを変更するメソッドの実装を示しています。 *n*ディメンションです。  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 次の例では、配列のサイズを変更するしくみを示します。  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newSize" /> is less than zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reverses the order of the elements in a one-dimensional <see cref="T:System.Array" /> or in a portion of the <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> to reverse.</param>
        <summary>Reverses the sequence of the elements in the entire one-dimensional <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、位置にある要素への呼び出し後`myArray[i]`ここで、`i`配列内のすべてのインデックスに移動`myArray[j]`ここで、`j`と等しい`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`です。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
 次の例に示すように、<xref:System.Array.Reverse%2A>ジャグ配列を反転させるメソッドを使用できます。 現在のカルチャのカレンダーの現在の年の各月の 1 つの要素を持つジャグ配列を初期化します。 各要素には、その月の日と同じ数の要素を配列が含まれています。 例では、呼び出し、配列の内容を表示する、<xref:System.Array.Reverse%2A>メソッド、および、逆順の配列の内容を表示します。  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 次のコード例の値の並べ替えを取り消す方法を示しています、<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> to reverse.</param>
        <param name="index">The starting index of the section to reverse.</param>
        <param name="length">The number of elements in the section to reverse.</param>
        <summary>Reverses the sequence of the elements in a range of elements in the one-dimensional <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、位置にある要素への呼び出し後`myArray[i]`ここで、`i`配列内のすべてのインデックスに移動`myArray[j]`ここで、`j`と等しい`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`です。  
  
 <xref:System.Array.Reverse%2A>ジャグ配列を反転させるメソッドを使用できます。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例は、内の要素の範囲内の値の並べ替えを取り消す方法を示しています、<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than the lower bound of <paramref name="array" />.  -or-  <paramref name="length" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sets the specified element in the current <see cref="T:System.Array" /> to the specified value.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The new value for the specified element.</param>
        <param name="index">A 32-bit integer that represents the position of the <see cref="T:System.Array" /> element to set.</param>
        <summary>Sets a value to the element at the specified position in the one-dimensional <see cref="T:System.Array" />. The index is specified as a 32-bit integer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>方法を決定できるかどうかの値`index`が範囲外です。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current <see cref="T:System.Array" /> does not have exactly one dimension.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">The new value for the specified element.</param>
        <param name="indices">A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the element to set.</param>
        <summary>Sets a value to the element at the specified position in the multidimensional <see cref="T:System.Array" />. The indexes are specified as an array of 32-bit integers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内の要素の数`indices`内のディメンションの数と同じにする必要があります、<xref:System.Array>です。 すべての要素、`indices`配列が多次元で、目的の要素の位置をまとめて指定する必要があります<xref:System.Array>です。  
  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドは、かどうかの値のいずれかを判断できます、`indices`配列が範囲外です。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">The new value for the specified element.</param>
        <param name="index">A 64-bit integer that represents the position of the <see cref="T:System.Array" /> element to set.</param>
        <summary>Sets a value to the element at the specified position in the one-dimensional <see cref="T:System.Array" />. The index is specified as a 64-bit integer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>方法を決定できるかどうかの値`index`が範囲外です。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current <see cref="T:System.Array" /> does not have exactly one dimension.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">The new value for the specified element.</param>
        <param name="indices">A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the element to set.</param>
        <summary>Sets a value to the element at the specified position in the multidimensional <see cref="T:System.Array" />. The indexes are specified as an array of 64-bit integers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内の要素の数`indices`内のディメンションの数と同じにする必要があります、<xref:System.Array>です。 すべての要素、`indices`配列が多次元で、目的の要素の位置をまとめて指定する必要があります<xref:System.Array>です。  
  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドは、かどうかの値のいずれかを判断できます、`indices`配列が範囲外です。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The new value for the specified element.</param>
        <param name="index1">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</param>
        <param name="index2">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</param>
        <summary>Sets a value to the element at the specified position in the two-dimensional <see cref="T:System.Array" />. The indexes are specified as 32-bit integers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">The new value for the specified element.</param>
        <param name="index1">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</param>
        <param name="index2">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</param>
        <summary>Sets a value to the element at the specified position in the two-dimensional <see cref="T:System.Array" />. The indexes are specified as 64-bit integers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The new value for the specified element.</param>
        <param name="index1">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</param>
        <param name="index2">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</param>
        <param name="index3">A 32-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to set.</param>
        <summary>Sets a value to the element at the specified position in the three-dimensional <see cref="T:System.Array" />. The indexes are specified as 32-bit integers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">The new value for the specified element.</param>
        <param name="index1">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</param>
        <param name="index2">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</param>
        <param name="index3">A 64-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to set.</param>
        <summary>Sets a value to the element at the specified position in the three-dimensional <see cref="T:System.Array" />. The indexes are specified as 64-bit integers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o (1) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## Examples  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sorts the elements in a one-dimensional array.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> to sort.</param>
        <summary>Sorts the elements in an entire one-dimensional <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each element of the <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各要素`array`実装する必要があります、<xref:System.IComparable>の他のすべての要素との比較ができるようにするインターフェイス`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例の値を並べ替える方法を示しています、<xref:System.Array>既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
        <exception cref="T:System.InvalidOperationException">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</param>
        <param name="items">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <c>keys</c><see cref="T:System.Array" />.  -or-  <see langword="null" /> to sort only the <c>keys</c><see cref="T:System.Array" />.</param>
        <summary>Sorts a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each key.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items` <xref:System.Array>同様の位置を変更します。 したがって、 `items` <xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 各キーに、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable>他のすべてのキーの比較ができるようにするインターフェイスです。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`keys`します。  
  
   
  
## Examples  
 次の例では、キーと値を格納する 2 番目の配列の 2 つの関連付けられている配列を並べ替える方法を示します。 並べ替えを行います既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.  -or-  The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional array to sort.</param>
        <param name="comparer">The implementation to use when comparing elements.  -or-  <see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</param>
        <summary>Sorts the elements in a one-dimensional <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`comparer`は`null`の各要素`array`実装する必要があります、<xref:System.IComparable>の他のすべての要素との比較ができるようにするインターフェイス`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
 .NET Framework は定義済み<xref:System.Collections.IComparer>実装は、次の表に示されています。  
  
|実装|説明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|任意の 2 つのオブジェクトを比較しますが、文字列の大文字と小文字の比較を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|現在のカルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|インバリアント カルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|型の 2 つのオブジェクトを比較`T`型の既定の並べ替え順序を使用しています。|  
  
 独自のインスタンスを提供することによって、カスタム比較をサポートすることも<xref:System.Collections.IComparer>実装を`comparer`パラメーター。 この例ではこれを定義して、`ReverseComparer`クラスの既定の並べ替え順序を反転する型のインスタンス大文字と小文字の文字列比較を実行します。  
  
   
  
## Examples  
 次の例では、既定の比較子を使用して文字列 arrayby で値が並べ替えられます。 カスタムも定義<xref:System.Collections.IComparer>という名前の実装`ReverseComparer`を反転し、結果オブジェクトの既定の並べ替え順序、大文字と小文字の文字列の比較を実行します。 出力は、現在のカルチャによって異なる場合がありますに注意してください。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <exception cref="T:System.ArgumentException">The implementation of <paramref name="comparer" /> caused an error during the sort. For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降で、[です。以前の操作の並べ替えがスローされました可能であれば INCLUDE[net_v45](~/includes/net-v45-md.md)]、<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</param>
        <param name="items">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <c>keys</c><see cref="T:System.Array" />.  -or-  <see langword="null" /> to sort only the <c>keys</c><see cref="T:System.Array" />.</param>
        <param name="comparer">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.  -or-  <see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</param>
        <summary>Sorts a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items` <xref:System.Array>同様の位置を変更します。 したがって、 `items` <xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 場合`comparer`は`null`、それぞれのキー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable>他のすべてのキーの比較ができるようにするインターフェイスです。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 .NET Framework は定義済み<xref:System.Collections.IComparer>実装は、次の表に示されています。  
  
|実装|説明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|任意の 2 つのオブジェクトを比較しますが、文字列の大文字と小文字の比較を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|現在のカルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|インバリアント カルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|型の 2 つのオブジェクトを比較`T`型の既定の並べ替え順序を使用しています。|  
  
 独自のインスタンスを提供することによって、カスタム比較をサポートすることも<xref:System.Collections.IComparer>実装を`comparer`パラメーター。 この例ではこれを定義して、<xref:System.Collections.IComparer>既定の並べ替え順序を反転し、大文字と小文字の文字列比較を実行する実装。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`keys`します。  
  
   
  
## Examples  
 次の例では、キーと値を格納する 2 番目の配列の 2 つの関連付けられている配列を並べ替える方法を示します。 並べ替えを行います既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.  -or-  The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.  -or-  The implementation of <paramref name="comparer" /> caused an error during the sort. For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降で、[です。可能であれば INCLUDE[net_v45](~/includes/net-v45-md.md)]、する並べ替え操作を previouslythrew<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> to sort.</param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <summary>Sorts the elements in a range of elements in a one-dimensional <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each element of the <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内の要素の指定した範囲内の各要素`array`実装する必要があります、<xref:System.IComparable>の他のすべての要素との比較ができるようにするインターフェイス`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例の値を並べ替える方法を示しています、<xref:System.Array>既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than the lower bound of <paramref name="array" />.  -or-  <paramref name="length" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</param>
        <param name="items">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <c>keys</c><see cref="T:System.Array" />.  -or-  <see langword="null" /> to sort only the <c>keys</c><see cref="T:System.Array" />.</param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <summary>Sorts a range of elements in a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each key.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items` <xref:System.Array>同様の位置を変更します。 したがって、 `items` <xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 内の要素の指定された範囲内の各キー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable>他のすべてのキーの比較ができるようにするインターフェイスです。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例では、キーと値を格納する 2 番目の配列の 2 つの関連付けられている配列を並べ替える方法を示します。 並べ替えを行います既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.  -or-  The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than the lower bound of <paramref name="keys" />.  -or-  <paramref name="length" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.  -or-  <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.  -or-  <paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> to sort.</param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <param name="comparer">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.  -or-  <see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</param>
        <summary>Sorts the elements in a range of elements in a one-dimensional <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`comparer`は`null`、内の要素の指定した範囲内の各要素`array`実装する必要があります、<xref:System.IComparable>の他のすべての要素との比較ができるようにするインターフェイス`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 .NET Framework は定義済み<xref:System.Collections.IComparer>実装は、次の表に示されています。  
  
|実装|説明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|任意の 2 つのオブジェクトを比較しますが、文字列の大文字と小文字の比較を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|現在のカルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|インバリアント カルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|型の 2 つのオブジェクトを比較`T`型の既定の並べ替え順序を使用しています。|  
  
 独自のインスタンスを提供することによって、カスタム比較をサポートすることも<xref:System.Collections.IComparer>実装を`comparer`パラメーター。 この例ではこれを定義して、`ReverseComparer`クラスの既定の並べ替え順序を反転する型のインスタンス大文字と小文字の文字列比較を実行します。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例の値を並べ替える方法を示しています、<xref:System.Array>既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than the lower bound of <paramref name="array" />.  -or-  <paramref name="length" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.  -or-  The implementation of <paramref name="comparer" /> caused an error during the sort. For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降で、[です。以前の操作の並べ替えがスローされました可能であれば INCLUDE[net_v45](~/includes/net-v45-md.md)]、<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</param>
        <param name="items">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <c>keys</c><see cref="T:System.Array" />.  -or-  <see langword="null" /> to sort only the <c>keys</c><see cref="T:System.Array" />.</param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <param name="comparer">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.  -or-  <see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</param>
        <summary>Sorts a range of elements in a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items` <xref:System.Array>同様の位置を変更します。 したがって、 `items` <xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 場合`comparer`は`null`、内の要素の指定された範囲内の各キー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable>他のすべてのキーの比較ができるようにするインターフェイスです。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 .NET Framework は定義済み<xref:System.Collections.IComparer>実装は、次の表に示されています。  
  
|実装|説明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|任意の 2 つのオブジェクトを比較しますが、文字列の大文字と小文字の比較を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|現在のカルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|インバリアント カルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|型の 2 つのオブジェクトを比較`T`型の既定の並べ替え順序を使用しています。|  
  
 独自のインスタンスを提供することによって、カスタム比較をサポートすることも<xref:System.Collections.IComparer>実装を`comparer`パラメーター。 この例ではこのカスタムを定義することで<xref:System.Collections.IComparer>既定の並べ替え順序を反転し、大文字と小文字の文字列比較を実行する実装。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例では、キーと値を格納する 2 番目の配列の 2 つの関連付けられている配列を並べ替える方法を示します。 並べ替えを行います既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.  -or-  The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than the lower bound of <paramref name="keys" />.  -or-  <paramref name="length" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.  -or-  <paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.  -or-  <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.  -or-  <paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.  -or-  The implementation of <paramref name="comparer" /> caused an error during the sort. For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降で、[です。以前の操作の並べ替えがスローされました可能であれば INCLUDE[net_v45](~/includes/net-v45-md.md)]、<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort.</param>
        <summary>Sorts the elements in an entire <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each element of the <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各要素`array`実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスの他のすべての要素との比較ができるようにする`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>ジェネリック メソッドのオーバー ロードおよび<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ジェネリック メソッドのオーバー ロードします。 任意の順序で、文字列の配列が作成されます。  
  
 配列が表示され、並べ替え、もう一度表示されます。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%2A>と<xref:System.Array.BinarySearch%2A>ジェネリック メソッドの表示が、対応する非への呼び出しから、他と同じため、Visual Basic、c#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ジェネリック メソッドのオーバー ロードが 2 つの文字列の検索に使用しに含まれていない、配列と 1 つを 1 つです。 配列との戻り値、<xref:System.Array.BinarySearch%2A>メソッドに渡される、`ShowWhere`場合は、文字列が検出され、それ以外の場合、要素検索文字列が間に配列を使用した場合は、インデックス値を表示するジェネリック メソッドです。 インデックスが負の値、文字列は、n がない場合、配列のため、`ShowWhere`メソッドにはビットごとの補数 (、~ c# および Visual C は、演算子`Xor`Visual Basic では-1) が検索からより大きい一覧の最初の要素のインデックスを取得ng です。  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-base <see cref="T:System.Array" /> to sort</param>
        <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</param>
        <summary>Sorts the elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`comparer`は`null`の各要素`array`実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスの他のすべての要素との比較ができるようにする`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードおよび<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 配列が表示され、並べ替え、もう一度表示されます。 配列を使用するために並べ替える必要があります、<xref:System.Array.BinarySearch%2A>メソッドです。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>と<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドの表示が、対応する非への呼び出しから、他と同じため、Visual Basic、c#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードが 2 つの文字列の検索に使用しに含まれていない、配列と 1 つを 1 つです。 配列との戻り値、<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>メソッドに渡される、`ShowWhere`場合は、文字列が検出され、それ以外の場合、要素検索文字列が間に配列を使用した場合は、インデックス値を表示するジェネリック メソッドです。 インデックスが負の値、文字列は、n がない場合、配列のため、`ShowWhere`メソッドにはビットごとの補数 (、~ c# および Visual C は、演算子`Xor`Visual Basic では-1) が検索からより大きい一覧の最初の要素のインデックスを取得ng です。  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</exception>
        <exception cref="T:System.ArgumentException">The implementation of <paramref name="comparer" /> caused an error during the sort. For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降で、[です。以前の操作の並べ替えがスローされました可能であれば INCLUDE[net_v45](~/includes/net-v45-md.md)]、<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort</param>
        <param name="comparison">The <see cref="T:System.Comparison`1" /> to use when comparing elements.</param>
        <summary>Sorts the elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列に対して代替の比較のメソッドを定義`CompareDinosByLength`です。 このメソッドは次のように機能します。 最初に、テスト、comparandsare`null`、し、null 参照が null でないより小さいとして扱われます。 次に、文字列の長さが比較され、長い文字列は、大きい値を指定するものと見なされます。 3 番目に、長さが等しい場合は、通常の文字列比較は使用されます。  
  
 文字列の配列が作成され、任意の順序で、4 つの文字列に設定されます。 一覧は、空の文字列と null 参照にも含まれます。 使用して並べ替えられて、一覧が表示されます、<xref:System.Comparison%601>を表すジェネリック デリゲート、`CompareDinosByLength`メソッドを再び表示されます。  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.  -or-  <paramref name="comparison" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The implementation of <paramref name="comparison" /> caused an error during the sort. For example, <paramref name="comparison" /> might not return 0 when comparing an item with itself.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降で、[です。以前の操作の並べ替えがスローされました可能であれば INCLUDE[net_v45](~/includes/net-v45-md.md)]、<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort</param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <summary>Sorts the elements in a range of elements in an <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each element of the <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内の要素の指定した範囲内の各要素`array`実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスの他のすべての要素との比較ができるようにする`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>ジェネリック メソッドのオーバー ロードおよび<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>配列内の範囲を並べ替えるためのジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前では、正確に言うと) 後に次の 3 つの恐竜から成る配列を表示します。 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>ジェネリック メソッドのオーバー ロードが表示されると、配列の最後の 3 つの要素の並べ替えに使用します。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>とジェネリック メソッドのオーバー ロードを使用`ReverseCompare`最後の 3 つの要素を逆の順序で並べ替える。 徹底的に混乱を防ぐ恐竜が再度表示されます。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>と<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドの表示が、対応する非への呼び出しから、他と同じため、Visual Basic、c#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than the lower bound of <paramref name="array" />.  -or-  <paramref name="length" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort.</param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</param>
        <summary>Sorts the elements in a range of elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`comparer`は`null`、内の要素の指定した範囲内の各要素`array`実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスの他のすべての要素との比較ができるようにする`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例を示しています、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>ジェネリック メソッドのオーバー ロードおよび<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>配列内の範囲を並べ替えるためのジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前では、正確に言うと) 後に次の 3 つの恐竜から成る配列を表示します。 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>ジェネリック メソッドのオーバー ロードが表示されると、配列の最後の 3 つの要素の並べ替えに使用します。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>とジェネリック メソッドのオーバー ロードを使用`ReverseCompare`最後の 3 つの要素を逆の順序で並べ替える。 徹底的に混乱を防ぐ恐竜が再度表示されます。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>と<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドの表示が、対応する非への呼び出しから、他と同じため、Visual Basic、c#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than the lower bound of <paramref name="array" />.  -or-  <paramref name="length" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.  -or-  The implementation of <paramref name="comparer" /> caused an error during the sort. For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降で、[です。以前の操作の並べ替えがスローされました可能であれば INCLUDE[net_v45](~/includes/net-v45-md.md)]、<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</param>
        <param name="items">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <c>keys</c>, or <see langword="null" /> to sort only <c>keys</c>.</param>
        <summary>Sorts a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each key.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items` <xref:System.Array>同様の位置を変更します。 したがって、 `items` <xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 各キーに、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスとその他のすべてのキーの比較ができるようにします。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例を示しています、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>、および<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>の並べ替えキーと値を表す配列のペアのジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前 (キー) の配列と各恐竜メートル (値) の最大長を表す整数の配列が表示されます。 配列の並べ替え、および複数回表示されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>オーバー ロードは最初の配列で恐竜名の順序で両方の配列の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロード クラスのインスタンスおよび`ReverseCompare`ペアの配列の並べ替え順序を反転させるために使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードは両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロードは逆の順序で両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
> [!NOTE]
>  ジェネリック メソッドの呼び出しの表示が、対応する非への呼び出しの間に違い Visual Basic、c#、および C++ の最初の 2 つの引数の型のジェネリック型パラメーターの型を推論するため。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.  -or-  <paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</param>
        <param name="items">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <c>keys</c>, or <see langword="null" /> to sort only <c>keys</c>.</param>
        <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</param>
        <summary>Sorts a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items` <xref:System.Array>同様の位置を変更します。 したがって、 `items` <xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 場合`comparer`は`null`、それぞれのキー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスとその他のすべてのキーの比較ができるようにします。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次のコード例を示しています、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、[\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>、および<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>の並べ替えキーと値を表す配列のペアのジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前 (キー) の配列と各恐竜メートル (値) の最大長を表す整数の配列が表示されます。 配列の並べ替え、および複数回表示されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>オーバー ロードは最初の配列で恐竜名の順序で両方の配列の並べ替えに使用します。  
  
-   [\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > のインスタンスおよびオーバー ロード`ReverseCompare`を並べ替え順序を逆にするために使用ペアの配列。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードは両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロードは逆の順序で両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
> [!NOTE]
>  ジェネリック メソッドの呼び出しの表示が、対応する非への呼び出しの間に違い Visual Basic、c#、および C++ の最初の 2 つの引数の型のジェネリック型パラメーターの型を推論するため。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.  -or-  <paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.  -or-  The implementation of <paramref name="comparer" /> caused an error during the sort. For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降で、[です。以前の操作の並べ替えがスローされました可能であれば INCLUDE[net_v45](~/includes/net-v45-md.md)]、<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</param>
        <param name="items">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <c>keys</c>, or <see langword="null" /> to sort only <c>keys</c>.</param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <summary>Sorts a range of elements in a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each key.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items` <xref:System.Array>同様の位置を変更します。 したがって、 `items` <xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 内の要素の指定された範囲内の各キー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスとその他のすべてのキーの比較ができるようにします。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例を示しています、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、[\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >、および<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロード、並べ替えキーと値を表す配列のペア。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` (`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前 (キー) の配列と各恐竜メートル (値) の最大長を表す整数の配列が表示されます。 配列の並べ替え、および複数回表示されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>オーバー ロードは最初の配列で恐竜名の順序で両方の配列の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロード クラスのインスタンスおよび`ReverseCompare`ペアの配列の並べ替え順序を反転させるために使用します。  
  
-   [\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > オーバー ロードは両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロードは逆の順序で両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
> [!NOTE]
>  ジェネリック メソッドの呼び出しの表示が、対応する非への呼び出しの間に違い Visual Basic、c#、および C++ の最初の 2 つの引数の型のジェネリック型パラメーターの型を推論するため。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than the lower bound of <paramref name="keys" />.  -or-  <paramref name="length" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.  -or-  <paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.  -or-  <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.  -or-  <paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</param>
        <param name="items">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <c>keys</c>, or <see langword="null" /> to sort only <c>keys</c>.</param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</param>
        <summary>Sorts a range of elements in a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各キーに、 `keys` <xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items` <xref:System.Array>同様の位置を変更します。 したがって、 `items` <xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 場合`comparer`は`null`、内の要素の指定された範囲内の各キー、 `keys` <xref:System.Array>実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスとその他のすべてのキーの比較ができるようにします。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え (introsort) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[挿入ソート](https://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 * ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](https://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、[クイック ソート](https://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O (`n`ログ`n`) 操作では、ここで`n`は`length`します。  
  
   
  
## Examples  
 次のコード例を示しています、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>、および [\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > の並べ替えキーと値を表す配列のペアのジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>`(`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で) ジェネリック インターフェイス。 比較演算子の呼び出し、<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前 (キー) の配列と各恐竜メートル (値) の最大長を表す整数の配列が表示されます。 配列の並べ替え、および複数回表示されます。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>オーバー ロードは最初の配列で恐竜名の順序で両方の配列の並べ替えに使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロード クラスのインスタンスおよび`ReverseCompare`ペアの配列の並べ替え順序を反転させるために使用します。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードは両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
-   [\]、TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > オーバー ロードは、最後の 3 つの並べ替えに使用逆の順序で両方の要素を配列します。  
  
> [!NOTE]
>  ジェネリック メソッドの呼び出しの表示が、対応する非への呼び出しの間に違い Visual Basic、c#、および C++ の最初の 2 つの引数の型のジェネリック型パラメーターの型を推論するため。 使用する場合、 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を Microsoft intermediate language (MSIL) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than the lower bound of <paramref name="keys" />.  -or-  <paramref name="length" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.  -or-  <paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.  -or-  <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.  -or-  <paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.  -or-  The implementation of <paramref name="comparer" /> caused an error during the sort. For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 およびそれ以前のバージョンは、クイック ソート アルゴリズムのみを使用します。クイック ソートを状況によっては、並べ替え操作によってスローされる無効な比較演算子を識別、<see cref="T:System.IndexOutOfRangeException" />例外、およびスロー、<see cref="T:System.ArgumentException" />呼び出し元の例外。以降で、[です。以前の操作の並べ替えがスローされました可能であれば INCLUDE[net_v45](~/includes/net-v45-md.md)]、<see cref="T:System.ArgumentException" />挿入の並べ替えと heapsort アルゴリズムでは、無効な比較演算子が検出されないため、例外がスローされません。ほとんどの場合、これより少ない 16 個の要素を持つ配列に適用されます。</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that can be used to synchronize access to the <see cref="T:System.Array" />.</summary>
        <value>
          <see cref="T:System.Array" /> へのアクセスの同期に使用できるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを実装して、<xref:System.Collections.ICollection?displayProperty=nameWithType>インターフェイスです。  
  
 .NET framework のクラスがに基づいて<xref:System.Array>独自の同期されたバージョンを使用して、コレクションの提供、<xref:System.Array.SyncRoot%2A>プロパティです。  
  
 配列を使用するクラスに、独自の同期を使用することができますも実装、<xref:System.Array.SyncRoot%2A>プロパティです。 同期されたコードで操作を実行する必要があります、`SyncRoot`コレクションの操作は、コレクションのです。 これにより、他のオブジェクトから派生したコレクションを適切に操作できるようになります。 具体的には、コレクションを同時に変更する可能性がある別スレッドとの適切な同期を維持します。 なおの実装によって<xref:System.Array.SyncRoot%2A>返す可能性があります、<xref:System.Array>自体です。  
  
 コレクションの列挙は本質的にスレッド セーフな方法です。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
 このプロパティ値を取得することは、O(1) 操作になります。  
  
   
  
## Examples  
 次のコード例を使用して配列を列挙中にロックする方法を示しています、<xref:System.Array.SyncRoot%2A>プロパティです。  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System.Collections.ICollection.Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of elements contained in the <see cref="T:System.Array" />.</summary>
        <value>コレクションに格納されている要素の数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.ICollection> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The object to be added to the <see cref="T:System.Collections.IList" />.</param>
        <summary>Calling this method always throws a <see cref="T:System.NotSupportedException" /> exception.</summary>
        <returns>Adding a value to an array is not supported. No value is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、<xref:System.Collections.IList.Add%2A?displayProperty=nameWithType>実装では、コレクションにメンバーを追加します。 ただし、配列がある固定サイズのため (、<xref:System.Array.IsFixedSize%2A>プロパティは常に返します`true`)、このメソッドは常にスロー、<xref:System.NotSupportedException>例外。  
  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IList" /> has a fixed size.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes all items from the <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IList" /> is read-only.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The object to locate in the current list. The element to locate can be <see langword="null" /> for reference types.</param>
        <summary>Determines whether an element is in the <see cref="T:System.Collections.IList" />.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is found in the <see cref="T:System.Collections.IList" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The object to locate in the current list.</param>
        <summary>Determines the index of a specific item in the <see cref="T:System.Collections.IList" />.</summary>
        <returns>The index of value if found in the list; otherwise, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">The index at which <c>value</c> should be inserted.</param>
        <param name="value">The object to insert.</param>
        <summary>Inserts an item to the <see cref="T:System.Collections.IList" /> at the specified index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IList" /> is read-only.  -or-  The <see cref="T:System.Collections.IList" /> has a fixed size.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> is null reference in the <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The index of the element to get or set.</param>
        <summary>Gets or sets the element at the specified index.</summary>
        <value>指定したインデックス位置にある要素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero.  -or-  <paramref name="index" /> is equal to or greater than <see cref="P:System.Collections.ICollection.Count" />.</exception>
        <exception cref="T:System.ArgumentException">The current <see cref="T:System.Array" /> does not have exactly one dimension.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The object to remove from the <see cref="T:System.Collections.IList" />.</param>
        <summary>Removes the first occurrence of a specific object from the <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IList" /> is read-only.  -or-  The <see cref="T:System.Collections.IList" /> has a fixed size.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The index of the element to remove.</param>
        <summary>Removes the <see cref="T:System.Collections.IList" /> item at the specified index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IList" /> is read-only.  -or-  The <see cref="T:System.Collections.IList" /> has a fixed size.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">The object to compare with the current instance.</param>
        <param name="comparer">An object that compares the current object and <c>other</c>.</param>
        <summary>Determines whether the current collection object precedes, occurs in the same position as, or follows another object in the sort order.</summary>
        <returns>An integer that indicates the relationship of the current collection object to other, as shown in the following table.  
  
 <list type="table"><listheader><term> Return value  </term><description> Description  </description></listheader><item><term> -1  </term><description> The current instance precedes <paramref name="other" />.  </description></item><item><term> 0  </term><description> The current instance and <paramref name="other" /> are equal.  </description></item><item><term> 1  </term><description> The current instance follows <paramref name="other" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IStructuralComparable> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">The object to compare with the current instance.</param>
        <param name="comparer">An object that determines whether the current instance and <c>other</c> are equal.</param>
        <summary>Determines whether an object is equal to the current instance.</summary>
        <returns>
          <see langword="true" /> if the two objects are equal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IStructuralEquatable> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">An object that computes the hash code of the current object.</param>
        <summary>Returns a hash code for the current instance.</summary>
        <returns>The hash code for the current instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IStructuralEquatable> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to check against the conditions.</param>
        <param name="match">The predicate that defines the conditions to check against the elements.</param>
        <summary>Determines whether every element in the array matches the conditions defined by the specified predicate.</summary>
        <returns>
          <see langword="true" /> if every element in <paramref name="array" /> matches the conditions defined by the specified predicate; otherwise, <see langword="false" />. If there are no elements in the array, the return value is <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、 <xref:System.Predicate%601>、デリゲートが返されるときの処理が停止および`false`任意の要素。  
  
 このメソッドは、O (`n`) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## Examples  
 次の例は、文字列の配列内の各要素の最後の文字が数字かどうかを判断します。 2 つの文字列配列を作成します。 両方の文字列の文字のアルファベットと数字で終わる文字列で終わる最初 arrayincludes です。2 番目の配列は、数字で終わる文字列ののみで構成されます。 定義、`EndWithANumber`シグネチャと一致するメソッド、<xref:System.Predicate%601>を委任します。 各配列を渡します、<xref:System.Array.TrueForAll%2A>メソッドを表すデリゲートと、`EndsWithANumber`メソッドです。  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 次の例は、文字列配列を通過する点を除いて、最初に似ています、<xref:System.Array.TrueForAll%2A>メソッドと、特定の配列要素は、数値の文字列形式で終わるかどうかを決定するラムダ式。  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 どちらの場合、<xref:System.Array.TrueForAll%2A>メソッドを返します。`false`数値の中で終わっていない最初の配列要素に到達したとすぐにします。 返しますそれ以外の場合、`true`後、配列内のすべての要素を反復処理します。  
  
> [!NOTE]
>  どちらの例から分かるように、c# および Visual Basic では、作成する必要はありません、`Predicate<string>`委任 (`Predicate(Of String)` Visual Basic の) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.  -or-  <paramref name="match" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>