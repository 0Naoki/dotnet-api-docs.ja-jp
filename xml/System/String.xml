<Type Name="String" FullName="System.String">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c5d5458977f00b28e9dac7eaf4dc6e97474d1d2b" />
    <Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="12/01/2018" />
    <Meta Name="ms.locfileid" Value="52740936" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>テキストを一連の UTF-16 コード単位として表現します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 文字列は、テキストを表すために使用される文字のシーケンシャル コレクションです。 A<xref:System.String>オブジェクトのシーケンシャル コレクションは、<xref:System.Char?displayProperty=nameWithType>するは、文字列を表すオブジェクト<xref:System.Char?displayProperty=nameWithType>オブジェクトは utf-16 コード単位に対応します。 値、<xref:System.String>オブジェクトのシーケンシャル コレクションの内容は、<xref:System.Char?displayProperty=nameWithType>オブジェクト、および変更可能な値がある (つまり、これが読み取り専用)。 文字列の詳細については、不変性は、次を参照してください。、[の不変性と StringBuilder クラス](#Immutability)このトピックで後述します。 最大サイズを<xref:System.String>メモリ内のオブジェクトが 2 GB、つまり約 10億文字。  
  
 このセクションの内容:  
  
 [文字列オブジェクトをインスタンス化します。](#Instantiation)   
 [オブジェクトと Unicode 文字を char します。](#Characters)   
 [文字列と Unicode 標準](#Unicode)   
 [文字列と埋め込まれた null 文字](#EmbeddedNulls)   
 [文字列とインデックス](#Indexes)   
 [Null 文字列と空の文字列](#Nulls)   
 [不変性と StringBuilder クラス](#Immutability)   
 [序数とカルチャに依存する操作](#CultureSensitive)   
 [正規化](#Normalization)   
 [カテゴリ別の文字列操作](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>文字列オブジェクトをインスタンス化します。  
 インスタンス化することができます、<xref:System.String>次の方法でオブジェクト。  
  
-   文字列リテラルを割り当てることで、<xref:System.String>変数。 これは、文字列を作成するための最もよく使用されるメソッドです。 次の例では、いくつかの文字列を作成するのに割り当てを使用します。 ため、c# の場合は、注意、円記号 (\\) は、エスケープ文字、文字列リテラルの円記号をエスケープする必要がありますまたは文字列全体である必要があります@-quotedします。  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   呼び出すことによって、<xref:System.String>クラスのコンス トラクター。 次の例では、いくつかのクラスのコンス トラクターを呼び出すことによって文字列がインスタンス化します。 文字配列またはパラメーターとして符号付きバイト配列へのポインターが含まれてコンス トラクターのいくつかのことに注意してください。 Visual Basic では、これらのコンス トラクターの呼び出しはサポートされません。 詳細については<xref:System.String>コンス トラクターを参照してください、<xref:System.String.%23ctor%2A>コンス トラクターの概要。  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   文字列連結演算子を使用して、(+ (C#) と (& a) または Visual Basic では、+) の任意の組み合わせから 1 つの文字列を作成する<xref:System.String>インスタンスと文字列リテラル。 次の例では、文字列連結演算子の使用を示します。  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   プロパティを取得するか、メソッドを呼び出すことによって、文字列を返します。 次の例のメソッドを使用して、<xref:System.String>より大きな文字列から部分文字列を抽出するクラス。  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   値またはオブジェクトを文字列表現に変換する書式指定メソッドを呼び出します。 次の例では、[複合書式指定](~/docs/standard/base-types/composite-formatting.md)を文字列に 2 つのオブジェクトの文字列表現を埋め込むには機能します。  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>オブジェクトと Unicode 文字を char します。  
 文字列内の各文字は Unicode コード ポイントまたは Unicode 文字の序数 (数値) 値とも呼ばれる、Unicode スカラー値によって定義されます。 各コード ポイントは utf-16 エンコーディングを使用してエンコードされ、エンコードの各要素の数値の値がによって表される、<xref:System.Char>オブジェクト。  
  
> [!NOTE]
>  に、注意してください、 <xref:System.String> utf-16 コード単位のシーケンシャル コレクションのインスタンスを構成、作成することは、<xref:System.String>が整形式の Unicode 文字列でないオブジェクト。 たとえば、対応する上位サロゲートせず、下位サロゲートである文字列を作成することは。 エンコードとデコード内のオブジェクトのメソッドなど、いくつかの方法、<xref:System.Text>名前空間には、文字列が整形式であることを確認するためのチェックを実行可能性があります<xref:System.String>クラスのメンバーはない文字列が整形式であることを確認します。  
  
 1 つ<xref:System.Char>オブジェクトは、通常は 1 つを表しますコード ポイント。 つまり、数値の値、<xref:System.Char>コード ポイントに等しい。 たとえば、コード ポイントの文字"a"、U + 0061 します。 ただし、コード ポイントはエンコードされた 1 つ以上の要素を必要があります (1 つ以上<xref:System.Char>オブジェクト)。 Unicode 標準では、2 種類の対応する文字を定義する複数<xref:System.Char>オブジェクト: graphemes、および Unicode 補助平面内の文字に対応する Unicode 補助コード ポイント。  
  
-   書記素は、1 つまたは複数の組み合わせ文字の後に、基本文字で表されます。 たとえば、ä 文字が a で表されます<xref:System.Char>コード ポイントが U + a 続けて 0061 オブジェクト<xref:System.Char>コード ポイントが u+0308 オブジェクト。 この文字は、1 つで定義することも<xref:System.Char>U + 00E4 のコード ポイントを持つオブジェクト。 次の例に示すようにが、通常の序数比較ではこれら 2 つの表現が等しいか、等しいかどうかをカルチャに依存した比較を示します。 ただし、2 つの文字列が正規化される場合、序数の比較も示しますが等しい。 (文字列の正規化の詳細については、次を参照してください、[正規化](#Normalization)セクションです。)。  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   補助コード ポイント (サロゲート ペア) がによって表される Unicode、<xref:System.Char>コード ポイントが上位サロゲート オブジェクトが続く、<xref:System.Char>コード ポイントが下位サロゲートであるオブジェクト。 高サロゲート範囲が u+d800 から U+DBFF のコード単位です。 低サロゲート範囲が u+dc00 から U+DFFF のコード単位です。 サロゲート ペアは、16 の Unicode 補助平面内の文字を表すために使用されます。 次の例は、サロゲート文字を作成し、それを<xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType>サロゲート ペアがあるかどうかを判断するメソッド。  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>文字列と Unicode 標準  
 文字列内の文字に対応する utf-16 でエンコードされたコード単位で表される<xref:System.Char>値。  
  
 文字列内の各文字が、関連付けられている Unicode 文字カテゴリでの .NET で表される、<xref:System.Globalization.UnicodeCategory>列挙体。 文字またはサロゲート ペアのカテゴリを呼び出すことによって決定できます、<xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType>メソッド。  

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]
  
 さらに、.NET は、文字列比較をサポートし、Unicode 標準に基づく並べ替え。 使用して、.NET Framework のバージョンでは、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、.NET Framework は、独自の文字列データのテーブルを保持します。 以降では、.NET Framework のバージョンの場合は true。 これはまた、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] Windows 7 で実行されています。 以降では、[!INCLUDE[net_v45](~/includes/net-v45-md.md)]で Window 8 および Windows オペレーティング システムの以降のバージョンを実行して、ランタイムのデリゲート文字列比較と並べ替え、オペレーティング システムを操作します。 .NET Core では、文字列比較と並べ替えの情報によって提供される[International Components for Unicode](http://site.icu-project.org/)ライブラリ。次の表は、.NET のバージョンとの比較と並べ替えのベース文字の Unicode 標準のバージョンを示します。  
  
|.NET のバージョン|Unicode 標準のバージョン|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Unicode 標準、バージョン 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[Unicode 標準、バージョン 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Unicode 標準、バージョン 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Unicode 標準、バージョン 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] Windows 7 以降|[Unicode 標準、バージョン 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] および Windows 8 以降の Windows オペレーティング システムでそれ以降|[Unicode 標準、バージョン 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|.NET Core (すべてのバージョン)|基になるオペレーティング システムでサポートされている Unicode 標準のバージョンによって異なります。|

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>文字列と埋め込まれた null 文字  
 .NET を<xref:System.String>オブジェクトは、文字列の長さの一部としてカウント埋め込まれた null 文字を含めることができます。 ただし、C や C++ などの一部の言語で null 文字値を示す文字列。文字列の一部とは見なされません、文字列の長さの一部としてはカウントされません。 つまり、文字列の C および C++ のプログラマまたは C または C++ で記述されたライブラリを使用する次の一般的な前提条件に適用すると、必ずしも有効なこと<xref:System.String>オブジェクト。  
  
-   によって返される値、`strlen`または`wcslen`関数が必ずしも等しく<xref:System.String.Length%2A?displayProperty=nameWithType>します。  
  
-   によって作成される文字列、`strcpy_s`または`wcscpy_s`関数は、必ずしもによって作成される文字列と同じですが、<xref:System.String.Copy%2A?displayProperty=nameWithType>メソッド。  
  
 ネイティブ C および C++ コードをインスタンス化することを確認する必要があります<xref:System.String>オブジェクト、および渡されるコード<xref:System.String>プラットフォームを通じてオブジェクト呼び出しは、埋め込みの null 文字が文字列の末尾をマークとは考えないでください。  
  
 文字列に埋め込まれた null 文字は文字列が検索される文字列が並べ替えられます (または比較) と異なる方法でも扱われます。 インバリアント カルチャを使用して比較を含む 2 つの文字列間のカルチャに依存した比較を実行するときに、null 文字は無視されます。 序数または大文字の序数に基づく比較ののみと見なされます。 これに対して、埋め込まれた null 文字は常と見なされますなどの方法で文字列を検索するときに<xref:System.String.Contains%2A>、 <xref:System.String.StartsWith%2A>、および<xref:System.String.IndexOf%2A>します。  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>文字列とインデックス  
 インデックスの位置とは、<xref:System.Char>内のオブジェクト (Unicode 文字ではありません)、<xref:System.String>します。 インデックスは、0 から始まる、負でないインデックス位置 0 であると、文字列内の最初の位置から始まる数値です。 検索方法の数など<xref:System.String.IndexOf%2A>と<xref:System.String.LastIndexOf%2A>文字列インスタンスの部分文字列や文字のインデックスを返します。  
  
 <xref:System.String.Chars%2A>プロパティでは、個別にアクセスできます。<xref:System.Char>インデックス位置を示す文字列内でのオブジェクト。 <xref:System.String.Chars%2A>プロパティは (Visual Basic) で既定のプロパティまたはインデクサー (c#) を個別にアクセスすることができます<xref:System.Char>など、次のコードを使用して文字列内のオブジェクト。 このコードは、空白文字または文字列が含まれる文字数を決定する文字列の区切り文字を検索します。  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 <xref:System.String>クラスが実装する、<xref:System.Collections.IEnumerable>インターフェイスも反復処理する、<xref:System.Char>を使用して文字列内のオブジェクト、`foreach`構築は、次の例を示します。  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 文字は、Unicode でエンコードされた 1 つ以上にするため、連続したインデックス値は、連続する Unicode 文字に対応しない可能性があります<xref:System.Char>オブジェクト。 具体的には、文字列は、テキスト、基本文字の後に 1 つまたは複数の組み合わせ文字またはサロゲート ペアで形成される単位が複数の文字を含めることができます。 代わりに Unicode 文字を使用する<xref:System.Char>、オブジェクトを使用して、<xref:System.Globalization.StringInfo?displayProperty=nameWithType>と<xref:System.Globalization.TextElementEnumerator>クラス。 次の例で動作するコードの違いを示しています。<xref:System.Char>オブジェクトと Unicode 文字で動作するコードです。 文字または文の各単語内のテキスト要素の数を比較します。 文字列には、組み合わせ文字が続く基本文字の 2 つのシーケンスが含まれています。  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 この例は、テキスト要素を使用して動作、<xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType>メソッドと<xref:System.Globalization.TextElementEnumerator>文字列内のすべてのテキスト要素を列挙するクラス。 呼び出すことによってテキストの各要素の開始インデックスを含む配列を取得することも、<xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType>メソッド。  
  
 個人ではなく、テキストの単位の操作の詳細については<xref:System.Char>値を参照してください、<xref:System.Globalization.StringInfo>クラス。  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Null 文字列と空の文字列  
 宣言されていますが、値が割り当てられていない文字列が`null`します。 その文字列でメソッドを呼び出すしようとするとスロー、<xref:System.NullReferenceException>します。 Null 文字列とは異なる値が文字列である空の文字列""または<xref:System.String.Empty?displayProperty=nameWithType>します。 場合によっては、メソッド呼び出しの引数として文字列を null または空の文字列のいずれかを渡すことは、例外をスローします。 たとえば、null 文字列を渡すこと、<xref:System.Int32.Parse%2A?displayProperty=nameWithType>メソッドがスローされます、<xref:System.ArgumentNullException>がスローされます、空の文字列を渡すと、 <xref:System.FormatException>。 それ以外の場合は、メソッド引数は文字列を null または空の文字列のいずれかを指定できます。 指定する場合など、<xref:System.IFormattable>を一般 ("G") 書式指定子では、null 文字列と空の文字列の両方を調べる場合に必要なクラスの実装、します。  
  
 <xref:System.String>クラスには、文字列があるかどうかをテストするための次の 2 つの便利なメソッドが含まれています。`null`または空。  
  
-   <xref:System.String.IsNullOrEmpty%2A>、文字列がいずれかどうかを示す`null`と等しいか<xref:System.String.Empty?displayProperty=nameWithType>します。 このメソッドでは、次のコードを使用する必要があります。  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>、文字列があるかどうかを示す`null`、と等しい<xref:System.String.Empty?displayProperty=nameWithType>、または空白文字だけで構成されています。 このメソッドでは、次のコードを使用する必要があります。  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 次の例では、<xref:System.String.IsNullOrEmpty%2A>メソッドで、<xref:System.IFormattable.ToString%2A?displayProperty=nameWithType>のカスタム実装`Temperature`クラス。 メソッドは、"G"、"C"、"F"および"K"書式指定文字列をサポートします。 空の文字列または形式の文字列値を持つ場合は、`null`が渡される、メソッドにその値は、"G"書式指定文字列に変更します。  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>不変性と StringBuilder クラス  
 A<xref:System.String>オブジェクトは不変と呼ばれます (読み取り専用)、作成した後、その値を変更できないためです。 表示を変更する方法、<xref:System.String>オブジェクトは実際には、新しい返す<xref:System.String>変更を格納しているオブジェクト。  
  
 文字列は変更できないために、追加または削除する 1 つの文字列が、大幅なパフォーマンスの低下を正確に見えるものを実行する文字列操作ルーチンが繰り返されます。 たとえば、次のコードは、範囲 0x052F を 0x0001 に 1000 文字を含む文字列を作成するのに乱数ジェネレーターを使用します。 という名前の既存の文字列に新しい文字を追加する文字列の連結を使用するコードが表示されますが`str`、実際に作成、新しい<xref:System.String>連結操作ごとのオブジェクト。  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 使用することができます、<xref:System.Text.StringBuilder>クラスの代わりに、<xref:System.String>クラスの複数の変更を文字列の値を操作します。 インスタンスとは異なり、<xref:System.String>クラス、<xref:System.Text.StringBuilder>オブジェクトは変更可能な。 1 つの文字列で、操作を実行ときに、連結、追加、または文字列から部分文字列を削除します。 値の変更が完了したら、<xref:System.Text.StringBuilder>オブジェクトを呼び出すことができます、<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>文字列に変換するメソッド。 次の例は、<xref:System.String>で 0x052F を 0x0001 に範囲のランダムな文字で 1000 を連結する前の例で使用される、<xref:System.Text.StringBuilder>オブジェクト。  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>序数とカルチャに依存する操作  
 メンバー、<xref:System.String>クラスが、序数またはカルチャ (言語) 操作を実行する<xref:System.String>オブジェクト。 各数値の値は、序数に基づく操作<xref:System.Char>オブジェクト。 値は、カルチャに依存する操作、<xref:System.String>オブジェクト、およびはカルチャに固有の大文字小文字の区別、並べ替え、書式設定、および解析規則を考慮します。 カルチャに依存する操作は、明示的に宣言されたカルチャまたは現在のカルチャのコンテキストで実行します。 同じ文字列で実行されると、2 種類の操作は非常に異なる結果を生成できます。  
  
.NET は、インバリアント カルチャを使用してカルチャに依存しない言語的な文字列操作をサポートすることも (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>)、これは、リージョンの独立した、英語のカルチャ設定に基づいて疎です。 その他とは異なり<xref:System.Globalization.CultureInfo?displayProperty=nameWithType>インバリアント カルチャの設定の設定、システム、および .NET のバージョン間でのシステムからの 1 台のコンピューター上の一貫性を保持することが保証されます。 インバリアント カルチャでは、すべてのカルチャの文字列比較の安定性に確実に黒いボックスの一種として表示し、順序付けを指定できます。  
  
> [!IMPORTANT]
>  アプリケーションがファイル名などのシンボリック識別子に関するセキュリティ上の決定は、または名前付きパイプ場合、または XML ファイルにテキスト ベースのデータなどの永続化されたデータについて、操作は、カルチャに依存した比較ではなく、序数に基づく比較を使用してください。 これは、序数の比較が比較対象の文字のバイナリ値にのみ異なりますが、ため、カルチャに依存した比較が実際には、カルチャによって異なる結果を生成できます。  
  
> [!IMPORTANT]
>  文字列操作を実行するほとんどのメソッドは、型のパラメーターを持つオーバー ロードを含める<xref:System.StringComparison>メソッドが序数またはカルチャに依存する操作を実行するかどうかを指定できます。 一般に、明確に呼び出すメソッドの意図をこのオーバー ロードを呼び出す必要があります。 ベスト プラクティスと文字列の序数とカルチャに依存する操作の使用に関するガイダンスは、次を参照してください。[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)します。  
  
 操作を[大文字小文字の区別](#casing)、[解析および書式設定](#parsing)、[比較と並べ替え](#comparison)と[等しいかどうかをテスト](#equality)は、いずれかの序数またはカルチャに依存します。 次のセクションでは、操作の各カテゴリについて説明します。  
  
> [!TIP]
>  クリア呼び出し、メソッドの意図は、メソッドのオーバー ロードを常に呼び出す必要があります。 呼び出す代わりに、たとえば、 <xref:System.String.Compare%28System.String%2CSystem.String%29> 、現在のカルチャの規則を使用して、2 つの文字列のカルチャに依存した比較を実行するメソッドを呼び出す必要があります、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>の値を持つメソッド<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>の`comparisonType`引数。 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  

Windows オペレーティング システムの並べ替え操作と比較操作で使用される文字の重みに関する情報を含む一連のテキスト ファイルである[並べ替え重みテーブル](https://www.microsoft.com/en-us/download/details.aspx?id=10921) と、Linux と macOS 用の並べ替え重みテーブルである [デフォルト Unicode 照合基本テーブル](https://www.unicode.org/Public/UCA/latest/allkeys.txt)をダウンロードできます。

<a name="casing"></a>   
### <a name="casing"></a>大文字小文字の区別  
 大文字小文字の規則は Unicode 文字の大文字と小文字を変更する方法を決定します。たとえばから小文字を大文字にします。 多くの場合、文字列比較の前に、大文字と小文字の操作が実行します。 たとえば、もう 1 つの大文字の文字列を比較できるように文字列を大文字に変換する可能性があります。 呼び出すことで小文字の文字列内の文字に変換することができます、<xref:System.String.ToLower%2A>または<xref:System.String.ToLowerInvariant%2A>メソッドをおよびはそれらを呼び出すことで大文字で変換できます、<xref:System.String.ToUpper%2A>または<xref:System.String.ToUpperInvariant%2A>メソッド。 さらに、使用、<xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType>文字列を大文字に変換するメソッド。  
  
 大文字小文字操作は、現在のカルチャや指定されたカルチャの場合は、インバリアント カルチャの規則に基づくことができます。 大文字小文字マップは、使用されるカルチャによって異なることができます、ため大文字と小文字の操作の結果がカルチャによって異なることができます。 大文字と小文字の実際の相違点は、3 種類のことです。  
  
-   LATIN CAPITAL LETTER I の大文字と小文字のマッピングの相違点 (u+0049) ラテン小さな文字 I (u+0069) LATIN CAPITAL LETTER I (u+0130) 上のドットとラテン小さな文字ドット I (U + 0131)。 TR-TR (トルコ語 (トルコ)) と Latn-AZ-AZ (アゼルバイジャン、ラテン文字) のカルチャと、tr、az、az Latn ニュートラル カルチャでラテン大文字の I の小文字表現は、ラテン語小さな文字ドット I、およびラテン小さな文字 I の大文字表現がラテン文字の大文字の文字は上記の丸印が付きます。 その他のすべてのカルチャでラテン小さな文字 I および大文字と小文字の対応は私 LATIN CAPITAL LETTER、インバリアント カルチャを含むです。  
  
     次の例は、ファイル システムへのアクセスを防ぐためには、カルチャの大文字と小文字の比較に依存している場合は失敗に設計された文字列の比較方法を示します。 (インバリアント カルチャのケース表記規則が使用されています。)  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   インバリアント カルチャと他のすべてのカルチャで大文字小文字マップ違いです。 このような場合、インバリアント カルチャの大文字小文字の規則を使用して、文字を大文字または小文字を変更すると、同じ文字を返します。 他のすべてのカルチャの場合は、別の文字を返します。 影響を受ける文字の一部は、次の表に一覧表示されます。  
  
    |文字|変更された場合|戻り値|  
    |---------------|-------------------|-------------|  
    |ミクロン記号 (U + 00B5)|大文字|ギリシャ文字 MU (U +-39 C)|  
    |LATIN CAPITAL LETTER は丸印が付きます (U+0130) の上|小文字|小規模のラテン文字は (U+0069)|  
    |ラテン文字ドットは (U + 0131)|大文字|LATIN CAPITAL LETTER は (U+0049)|  
    |ラテン文字の長い S (U + 017F)|大文字|LATIN CAPITAL LETTER S (U + 0053)|  
    |CARON で小さな文字 Z で LATIN CAPITAL LETTER D (U + 01C 5)|小文字|CARON でラテン文字の小さな DZ (U + 01C 6)|  
    |結合ギリシャ YPOGEGRAMMENI (U + 0345)|大文字|ギリシャ文字 IOTA (U + 0399)|  
  
-   ASCII 文字の範囲の小文字が混在ペアの 2 文字の大文字と小文字のマッピングの相違。 ほとんどのカルチャでは、2 文字の小文字が混在ペアは、同等 2 文字の大文字または小文字の組み合わせと同じです。 いずれの場合も、digraph を比較するために次のカルチャでは、次の 2 文字のペアの場合は true はありません。  
  
    -   "lJ"と"nJ"(クロアチア語 (クロアチア)) を HR-HR カルチャ。  
  
    -   "cH"で、cs CZ (チェコ語 (チェコ共和国)) と sk SK (スロバキア語 (スロバキア)) のカルチャ。  
  
    -   "aA"da DK (デンマーク語 (デンマーク)) のカルチャ。  
  
    -   "cS"、"dZ"、"dZS"、"nY"、"sZ"、"tY"および"zS"HU-HU (ハンガリー語 (ハンガリー)) のカルチャ。  
  
    -   "cH"と"lL"es-es_tradnl (スペイン語 (スペイン、トラディショナル ソート)) のカルチャ。  
  
    -   "cH"、"gI"、"kH"、"nG""nH"、"pH"、"qU"、"tH"と"tR"vi VN (ベトナム語 (ベトナム)) のカルチャ。  
  
     ただし、これらのペアは固定文字列または識別子が一般的ではないため、これらのペアのカルチャに依存した比較が、問題を作成します状況が発生する一般的なは。  
  
 次の例は、大文字小文字の規則で文字列を大文字に変換するときに、カルチャ間の違いの一部を示しています。  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>解析および書式設定  
 書式設定と解析は、逆の操作です。 書式設定規則は、解析規則など、日付と時刻の値を文字列形式に変換する方法を決定する一方、日付と時刻や数値などの値を文字列表現に変換する方法を決定します。 書式設定と解析規則の両方には、文化的な慣習に依存します。 次の例は、カルチャ固有の日付文字列を解釈するときに生じる可能性のある、あいまいさを示しています。 日付文字列を生成するために使用されたカルチャの規則を知ることがなく、2011 年 1 月 3 日か、2011 年 3 月 1 日の 03/01/2011、2011 年 3 月 1 日および 01/03/2011 を表現するかどうかを把握することはできません。  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 同様に、次の例に示すようには、1 つの文字列は解析操作である規則を使用するカルチャによって異なる日付を生成できます。  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>文字列比較と並べ替え  
 文字列の並べ替えと比較の規則では、カルチャによって異なります。 たとえば、並べ替え順序は、発音や文字の視覚的表現に基づいて可能性があります。 東アジア圏の言語では、文字が表意文字の画数と部首によって並べ替えられます。 また、並べ替えは、言語やカルチャで使用されているアルファベットの順序によっても異なります。 たとえば、デンマーク語の文字 "Æ" は、アルファベットでは "Z" の後に位置します。 さらに、大文字や大文字と小文字の比較ができるし、場合によっては大文字小文字の規則もカルチャによって異なります。 序数に基づく比較は、その一方で、文字列を比較すると、文字列の並べ替えで個々 の文字の Unicode コード ポイントを使用します。  
  
 並べ替え規則は、Unicode 文字のアルファベット順と 2 つの文字列が相互に比較を決定します。 たとえば、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType>メソッドに基づいて 2 つの文字列を比較し、<xref:System.StringComparison>パラメーター。 パラメーターの値が場合<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>、パラメーター値がある場合、メソッドは、現在のカルチャの規則を使用する言語的な比較を実行します。 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>、メソッドは、序数に基づく比較を実行します。 その結果、次の例は、現在のカルチャが米国の場合英語、最初の呼び出し、 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> (カルチャに依存した比較を使用して) メソッドが"A"、"a"未満と見なしますが、(序数に基づく比較を使用して)、同じメソッドの 2 番目の呼び出しは"a"、"A"より大きい。  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET には、単語、文字列、および序数の並べ替え規則がサポートされています。  
  
-   単語での並べ替えでは、英数字以外の特定の Unicode 文字には特別な重みが割り当てられる、カルチャに依存した文字列の比較が行われます。 たとえば、ハイフン (-) は、"coop"と"co-op"、並べ替えられたリストで互いの横に表示されるように、それに割り当てられている重みが非常に小さい場合があります。 一覧については、<xref:System.String>単語の並べ替え規則を使用して 2 つの文字列を比較するメソッドを参照してください、[カテゴリ別の文字列操作](#ByCategory)セクション。  
  
-   文字列の並べ替えには、カルチャに依存した比較も実行します。 点を除いて、特殊なケースがないと、英数字以外のすべてのシンボルは、すべての英数字の Unicode 文字の前に単語の並べ替えに似ています。 文字列の並べ替え規則を使用して呼び出すことによって 2 つの文字列を比較することができます、<xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType>メソッドのオーバー ロードを持つ、`options`であるパラメーターの値を指定する<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>します。 これは文字列の並べ替え規則を使用して 2 つの文字列を比較する .NET が提供する唯一の方法であることに注意してください。  
  
-   序数の並べ替えでは、文字列内の各 <xref:System.Char> オブジェクトの数値に基づいて文字列を比較します。 序数の比較は、文字の大文字と小文字のバージョンがあるコード ポイントが異なるため、自動的に大文字小文字を区別します。 ただし、ケースが重要ではない場合は、ケースを区別しない、序数に基づく比較を指定できます。 これは、インバリアント カルチャを使用して、結果に対して序数に基づく比較を実行することで大文字に文字列を変換するのと同じです。 一覧については、<xref:System.String>序数の並べ替え規則を使用して 2 つの文字列を比較するメソッドを参照してください、[カテゴリ別の文字列操作](#ByCategory)セクション。  
  
 カルチャに依存する比較は、明示的または暗黙的に使用する比較を<xref:System.Globalization.CultureInfo>インバリアント カルチャで指定されているを含むオブジェクト、<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>プロパティ。 暗黙のカルチャは、現在のカルチャで指定されている、<xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>と<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>プロパティ。 アルファベット文字の並べ替え順序ではかなりのばらつきがある (つまり、対象の文字、<xref:System.Char.IsLetter%2A?displayProperty=nameWithType>プロパティが返す`true`) カルチャに関係なく。 指定することによって、特定のカルチャの規則を使用する、カルチャに依存した比較を指定することができます、<xref:System.Globalization.CultureInfo>などオブジェクトの文字列比較メソッドを<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>します。 指定することによって、現在のカルチャの規則を使用する、カルチャに依存した比較を指定する<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>、 <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>、またはのメンバーはすべて、<xref:System.Globalization.CompareOptions>以外の列挙<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>または<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>に適切なオーバー ロード、<xref:System.String.Compare%2A>メソッド。 カルチャに依存する比較は、並べ替えの序数の比較では、一方の一般に適しています。 序数の比較は 2 つの文字列が等しいかどうかを決定するために一般的に適切な (つまり、アイデンティティを決定するため) カルチャに依存する比較では、一方です。  
  
 次の例は、カルチャ、および序数の比較の違いを示しています。 次の 3 つの文字列、"Apple"、"Æble"および"AEble"、序数に基づく比較と DA-DK および EN-US カルチャの規則を使用して評価されます (それぞれが、時の既定のカルチャ、<xref:System.String.Compare%2A>メソッドが呼び出されます)。 デンマーク語は、文字「Æ」個々 の文字として扱うし、"Z"の後にアルファベット順で並べ替えて、ため、文字列"Æble"は"Apple"を超えています。 ただし、"Æble"がないと見なされます"AEble"に相当"Æble"も"AEble"よりも長くなります。 EN-US カルチャでは、「Æ」文字が含まれていませんが、"AE"は、"Æble"が"Apple"よりも"AEble"に等しい未満である理由について説明しますと同等として扱われます。 序数の比較は、その一方で、"AEble"より大きい値を指定するには、"Æble"と"Æble"よりも小さくするには、"Apple"を考慮します。  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 適切な並べ替え、または文字列の比較方法を選択するのにには、次の一般的なガイドラインを使用します。  
  
-   順序を指定する文字列をユーザーのカルチャに基づいて、する場合、現在のカルチャの規則に基づいてそれらを注文する必要があります。 ユーザーのカルチャが変更された場合の文字列の並べ替え順序も変化します。 たとえば、類義語辞典アプリケーションでは、ユーザーのカルチャに基づいて単語の並べ替えに常に。  
  
-   指定して注文する必要があります順序を指定する文字列を特定のカルチャの規則に基づいて、する場合、<xref:System.Globalization.CultureInfo>比較メソッドにそのカルチャを表すオブジェクト。 たとえば、アプリケーションは、特定の言語について説明するように設計、する順序を指定する文字列で、その言語のカルチャのいずれかの規則に基づいて。  
  
-   そのまま複数のカルチャで文字列の順序を設定する場合は、インバリアント カルチャの規則に基づいて順序をまたは序数の比較を使用する必要があります。 たとえば、ファイル、プロセス、ミュー テックスの名前を整理する序数の並べ替えを使用して、または、名前付きパイプ。  
  
-   (ユーザー名が有効かどうか) などのセキュリティに関する決定は、比較のオーバー ロードを呼び出すことによって、序数に基づくテスト等しいかどうかを常に実行する必要があります、<xref:System.String.Equals%2A>メソッド。  
  
> [!NOTE]
>  カルチャの並べ替えと文字列の比較で使用されるルール大文字小文字の区別は、.NET のバージョンによって異なります。 .NET Framework 4.5 およびそれ以降のバージョンで実行されている、 [!INCLUDE[win8](~/includes/win8-md.md)] Unicode 6.0 標準に準拠しているオペレーティング システム、並べ替え、大文字小文字の区別、正規化、および Unicode 文字に関する情報。 その他の Windows オペレーティング システムでは、Unicode 5.0 の標準に準拠しています。 .NET Core での基になるオペレーティング システムでサポートされている Unicode Standard バージョンに依存します。 
  
 詳細については、単語、文字列、および序数の並べ替え規則は、次を参照してください。、<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>トピック。 ときに、各ルールを使用する追加の推奨事項を参照してください[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)します。  
  
 通常、呼び出すことがない文字列などの比較メソッド<xref:System.String.Compare%2A>文字列の並べ替え順序を決定するには、直接します。 などのメソッドを並べ替えて比較メソッドが呼び出されます代わりに、<xref:System.Array.Sort%2A?displayProperty=nameWithType>または<xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>します。 次の例では、文字列の比較方法を明示的に呼び出さずに 4 つの異なる並べ替え操作 (単語の並べ替えが現在のカルチャ、インバリアント カルチャを使用して単語の並べ替え、序数の並べ替え、およびインバリアント カルチャを使用して文字列の並べ替えを使用して) を実行します使用する比較の種類を指定する操作を行います。 並べ替えの種類ごとにその配列内の文字列の一意の順序が生成されることに注意してください。  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  内部的には、.NET では、カルチャに依存する文字列比較をサポートするために並べ替えキーが使用されます。 文字列内の各文字には、アルファベット順、大文字と小文字の区別、発音の区別など、さまざまなカテゴリの並べ替えウェイトが指定されます。 によって表される並べ替えキーで、<xref:System.Globalization.SortKey>クラス、特定の文字列をこのような重みのリポジトリを提供します。 アプリでは、多数の検索や並べ替え文字列の同じセットに対して操作を実行する場合は、生成するために使用するすべての文字列の並べ替えキーを格納することによって、パフォーマンスを向上できます。 並べ替えまたは比較操作が必要な場合、文字列ではなく並べ替えキーを使用します。 詳細については、<xref:System.Globalization.SortKey> クラスを参照してください。  
  
 文字列比較の規則を指定しない場合などのメソッドを並べ替え<xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>文字列にカルチャ、大文字小文字を区別する並べ替えを実行します。 次の例では、現在のカルチャを変更すると、配列の文字列の並べ替え順序にどのように影響する方法を示しています。 3 つの文字列の配列を作成します。 最初に、`System.Threading.Thread.CurrentThread.CurrentCulture` プロパティを en-US に設定し、<xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> メソッドを呼び出します。 これよって、英語 (米国) カルチャの並べ替え規則に基づく並べ替え順序が適用されます。 次に、`System.Threading.Thread.CurrentThread.CurrentCulture` プロパティを da-DK に設定し、再度 <xref:System.Array.Sort%2A?displayProperty=nameWithType> メソッドを呼び出します。 適用される並べ替え順序が en-US の並べ替え順序と異なる点に注意してください。これは、デンマーク語 (デンマーク) の並べ替え規則が使用されるためです。  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  文字列を比較する主な目的を呼び出す必要がありますが等しいかどうかを判断する場合、<xref:System.String.Equals%2A?displayProperty=nameWithType>メソッド。 通常、使用する必要があります<xref:System.String.Equals%2A>序数の比較を実行します。 <xref:System.String.Compare%2A?displayProperty=nameWithType>主に、文字列の並べ替えメソッドが対象としています。  
  
 などの文字列検索メソッドでは、<xref:System.String.StartsWith%2A?displayProperty=nameWithType>と<xref:System.String.IndexOf%2A?displayProperty=nameWithType>も、カルチャに依存または序数の文字列比較を実行することができます。 次の例を使用する比較の序数とカルチャの違いを示しています、<xref:System.String.IndexOf%2A>メソッド。 これで、現在のカルチャが英語 (米国) カルチャを認識する検索では、"oe"合字「œ」と一致する部分文字列と見なします。 ソフト ハイフン (U + 00AD) は、ゼロ幅の文字であるため、検索が同等ソフト ハイフンを扱います<xref:System.String.Empty>文字列の先頭に一致を検索します。 、序数に基づく検索一方で検索しません。 一致するいずれの場合も。  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>文字列の検索  
 などの文字列検索メソッドでは、<xref:System.String.StartsWith%2A?displayProperty=nameWithType>と<xref:System.String.IndexOf%2A?displayProperty=nameWithType>、またカルチャを実行または指定した文字列の文字または部分文字列かどうかを決定する文字列の順序比較が見つかった。  
  
 検索方法、<xref:System.String>クラスなど、個々 の文字を検索する、<xref:System.String.IndexOf%2A>メソッド、または、文字のセットのいずれかなど、<xref:System.String.IndexOfAny%2A>メソッドすべて序数に基づく検索を実行します。 呼び出す必要があります文字のカルチャに依存する検索を実行する、<xref:System.Globalization.CompareInfo>などのメソッド<xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>または<xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>します。 非常に異なる序数とカルチャに依存した比較を使用して文字の検索の結果であることに注意してください。 などの合字「Æ」などの構成済みの Unicode 文字の検索 (U + 00 C 6) は"AE"など、正しいシーケンスでは、そのコンポーネントの出現が一致 (U + 041U + 0045)、カルチャによって異なります。 次の例では、違いを示しています、<xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType>と<xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>個々 の文字を検索するときのメソッド。 合字「æ」(U + 00E6) は、文字列に「[航空写真]」、EN-US カルチャの規則を使用する場合が DA-DK カルチャの規則を使用するときではなくまたは見つかりました序数に基づく比較を実行するときに。  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 その一方で、<xref:System.String>を検索する文字ではなく、文字列検索オプションが明示的に型のパラメーターで指定されていない場合、カルチャに依存する検索を実行するメソッドをクラス<xref:System.StringComparison>します。 唯一の例外は<xref:System.String.Contains%2A>、序数に基づく検索を実行します。  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>等しいかどうかテスト  
 使用して、<xref:System.String.Compare%2A?displayProperty=nameWithType>並べ替え順序において 2 つの文字列の関係を判断するメソッド。 通常、これは、カルチャに依存する操作です。 これに対し、呼び出し、<xref:System.String.Equals%2A?displayProperty=nameWithType>等しいかどうかをテストするメソッド。 等しいかどうかテストが通常はユーザー入力を有効なユーザー名、パスワード、または、ファイル システム パスなど、既知の文字列を比較するため、序数に基づく操作では通常します。  
  
> [!WARNING]
>  呼び出して、等しいかどうかをテストすることができます、<xref:System.String.Compare%2A?displayProperty=nameWithType>メソッドと戻り値が 0 であるかどうかを決定します。 ただし、この方法は推奨されません。 2 つの文字列が等しいかどうかを判断する、いずれかのオーバー ロードを呼び出す必要があります、<xref:System.String.Equals%2A?displayProperty=nameWithType>メソッド。 優先のオーバー ロードを呼び出すには、いずれかのインスタンス<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>メソッドまたは静的な<xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29>メソッドでは、両方のメソッドが含まれるため、<xref:System.StringComparison?displayProperty=nameWithType>パラメーターを明示的に比較の種類を指定します。  
  
 次の例は、カルチャに依存した比較を実行するときにいずれかの代わりに使用する必要があります、序数に等しいかどうかの危険性を示しています。 この場合、コードの目的は、文字列 FILE:// で URL の先頭の大文字と小文字を実行することによって FILE:// または file:// で始まる Url のファイル システムへのアクセスを禁止するは。 ただし、file:// で始まる URL でトルコ語 (トルコ) カルチャを使用して、カルチャに依存した比較を実行すると、比較で等しいかどうかは、失敗、小文字の"i"のトルコ語の大文字表現が「İ」のため、"I"の代わりにします。 その結果、ファイル システム アクセスは許可されている誤ってします。 その一方で、序数の比較が実行される場合、等しいかどうか比較は成功し、ファイル システム アクセスが拒否されました。  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>正規化  
 Unicode 文字の一部では、複数の表現があります。 たとえば、次のコード ポイントのいずれか「いずれも」文字を表すことができます。  
  
-   U+1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 1 つの文字の複数の表現には、検索、並べ替え、照合、およびその他の文字列操作が複雑になります。  
  
 Unicode 規格では、そのバイナリ表現のいずれかの Unicode 文字の 1 つのバイナリ表現を返します正規化と呼ばれるプロセスを定義します。 正規化には、異なる規則に従って、正規化形式と呼ばれる、いくつかのアルゴリズムを使用できます。 .NET では、Unicode 正規化フォーム C、D、KC、および KD をサポートします。 文字列を同じ正規形に正規化されている、ときに、序数に基づく比較を使用して比較できます。  
  
 序数の比較は、対応する Unicode スカラー値のバイナリ比較を<xref:System.Char>それぞれの文字列。 <xref:System.String>クラスには、次を含む、序数に基づく比較を実行できるメソッドの数値が含まれています。  
  
-   オーバー ロード、 <xref:System.String.Compare%2A>、 <xref:System.String.Equals%2A>、 <xref:System.String.StartsWith%2A>、 <xref:System.String.EndsWith%2A>、 <xref:System.String.IndexOf%2A>、および<xref:System.String.LastIndexOf%2A>メソッドを含む、<xref:System.StringComparison>パラメーター。 値を指定する場合、メソッドは、序数に基づく比較を実行します。<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>または<xref:System.StringComparison.OrdinalIgnoreCase>このパラメーターにします。  
  
-   オーバー ロード、<xref:System.String.CompareOrdinal%2A>メソッド。  
  
-   既定では、序数に基づく比較を使用するメソッド<xref:System.String.Contains%2A>、 <xref:System.String.Replace%2A>、および<xref:System.String.Split%2A>します。  
  
-   検索する方法、<xref:System.Char>値内の要素、または、<xref:System.Char>文字列インスタンスの配列。 このようなメソッドを含める<xref:System.String.IndexOf%28System.Char%29>と<xref:System.String.Split%28System.Char%5B%5D%29>します。  
  
 呼び出して、文字列が正規形 C に正規化されたかどうかを判断することができます、<xref:System.String.IsNormalized?displayProperty=nameWithType>またはメソッドを呼び出すことができます、<xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType>文字列は、指定された正規形に正規化されているかどうかを判断するメソッド。 呼び出すことも、<xref:System.String.Normalize?displayProperty=nameWithType>正規化フォーム C、または文字列に変換するメソッドを呼び出すことができます、<xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType>文字列を指定した正規形に変換します。 正規化と文字列を比較する詳細な手順については、次を参照してください。、<xref:System.String.Normalize>と<xref:System.String.Normalize%28System.Text.NormalizationForm%29>メソッド。  
  
 次の簡単な例は、文字列の正規化を示しています。 3 つの異なる文字列に 3 つの異なる方法で文字「ố」を定義し、等しいかどうか、序数に基づく比較を使用して、各文字列が、その他の 2 つの文字列と異なることを決定します。 各文字列をサポートされている正規化形式に変換し、もう一度指定された正規形では各文字列の序数に基づく比較を実行します。 各ケースでは、等しいかどうかは、2 番目のテストは、文字列が等しいことを示します。  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 正規化と正規化フォームの詳細については、次を参照してください<xref:System.Text.NormalizationForm?displayProperty=nameWithType>、だけでなく[Unicode Standard Annex #15: Unicode 正規化フォーム](https://unicode.org/reports/tr15/)と[正規化 FAQ](https://www.unicode.org/faq/normalization.html)で、。unicode.org web サイト。  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>カテゴリ別の文字列操作  
 <xref:System.String>クラスが等しいかどうか、文字または文字列をコピーして、値の書式設定文字列の組み合わせ、文字列から部分文字列の抽出、文字列を変更する、文字列から部分文字列の検索文字列をテストする文字列を比較するためのメンバーを提供し、文字列を正規化します。  
  
### <a name="comparing-strings"></a>文字列の比較  
 次を使用して、並べ替え順序におけるそれらの相対位置を決定する文字列を比較することができます<xref:System.String>メソッド。  
  
-   <xref:System.String.Compare%2A> 並べ替え順序で 2 つ目の文字列に 1 つの文字列の関係を示す整数を返します。  
  
-   <xref:System.String.CompareOrdinal%2A> 文字列がコード ポイントの比較に基づいて、2 番目の文字列を 1 つのリレーションシップを示す整数を返します。  
  
-   <xref:System.String.CompareTo%2A> 並べ替え順序で 2 つ目の文字列には、現在の文字列インスタンスの関係を示す整数を返します。 <xref:System.String.CompareTo%28System.String%29>メソッドを提供、<xref:System.IComparable>と<xref:System.IComparable%601>の実装、<xref:System.String>クラス。  
  
### <a name="testing-strings-for-equality"></a>文字列が等しいかどうかをテストします。  
 呼び出す、<xref:System.String.Equals%2A>する 2 つの文字列が等しいかどうかを判断するメソッド。 インスタンス<xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29>と静的な<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>オーバー ロードを使用する比較ではカルチャに依存するか、序数に基づく、かどうかと、ケースを検討または無視するかどうかを指定できます。 等しいかどうかのほとんどのテストは、序数に基づくと等しいかどうか (ファイル システム オブジェクトの場合) などのシステム リソースへのアクセスを決定する比較は序数で常にする必要があります。  
  
### <a name="finding-characters-in-a-string"></a>文字列の文字を検索します。  
 <xref:System.String>クラスには、2 つの種類 search メソッドにはが含まれています。  
  
-   返すメソッドを<xref:System.Boolean>を特定の部分文字列が文字列のインスタンスに存在するかどうかを示す値。 以下の<xref:System.String.Contains%2A>、 <xref:System.String.EndsWith%2A>、および<xref:System.String.StartsWith%2A>メソッド。  
  
-   文字列インスタンス内の部分文字列の開始位置を示すメソッド。 以下の<xref:System.String.IndexOf%2A>、 <xref:System.String.IndexOfAny%2A>、 <xref:System.String.LastIndexOf%2A>、および<xref:System.String.LastIndexOfAny%2A>メソッド。  
  
> [!WARNING]
>  特定の部分文字列ではなく、特定のパターン文字列を検索する場合は、正規表現を使用する必要があります。 詳細については、次を参照してください。 [.NET の正規](~/docs/standard/base-types/regular-expressions.md)します。  
  
### <a name="modifying-a-string"></a>文字列を変更します。  
 <xref:System.String>クラスには、文字列の値を変更する表示される次のメソッドが含まれています。  
  
-   <xref:System.String.Insert%2A> 現在に文字列を挿入<xref:System.String>インスタンス。  
  
-   <xref:System.String.PadLeft%2A> 文字列の先頭には、指定した文字の 1 つ以上の出現回数を挿入します。  
  
-   <xref:System.String.PadRight%2A> 文字列の末尾には、指定した文字の 1 つ以上の出現回数を挿入します。  
  
-   <xref:System.String.Remove%2A> 現在から部分文字列を削除します。<xref:System.String>インスタンス。  
  
-   <xref:System.String.Replace%2A> 部分文字列を現在のもう 1 つの部分文字列に置き換えます<xref:System.String>インスタンス。  
  
-   <xref:System.String.ToLower%2A> <xref:System.String.ToLowerInvariant%2A>文字列内のすべての文字を小文字に変換します。  
  
-   <xref:System.String.ToUpper%2A> <xref:System.String.ToUpperInvariant%2A>文字列内のすべての文字を大文字に変換します。  
  
-   <xref:System.String.Trim%2A> 先頭と文字列の末尾から文字のすべての出現を削除します。  
  
-   <xref:System.String.TrimEnd%2A> 文字列の末尾から文字のすべての出現を削除します。  
  
-   <xref:System.String.TrimStart%2A> 文字列の先頭から文字のすべての出現を削除します。  
  
> [!IMPORTANT]
>  すべての文字列の変更メソッドを返す新しい<xref:System.String>オブジェクト。 現在のインスタンスの値が変更しないでください。  
  
### <a name="extracting-substrings-from-a-string"></a>文字列から部分文字列の抽出  
 <xref:System.String.Split%2A?displayProperty=nameWithType>メソッドで複数の文字列を 1 つの文字列に分割します。 メソッドのオーバー ロードを使用すると、複数の区切り記号、メソッドを抽出する部分文字列の最大数を決定し、(区切り記号が横にある場合に発生する) を空の文字列は、返される文字列に含まれているかどうかを決定するを指定できます。  
  
### <a name="combining-strings"></a>文字列の結合  
 次<xref:System.String>メソッドは、文字列の連結に使用できます。  
  
-   <xref:System.String.Concat%2A> 1 つの文字列に 1 つまたは複数の部分文字列を結合します。  
  
-   <xref:System.String.Join%2A> 1 つの要素に 1 つまたは複数の部分文字列を連結し、各部分文字列間の区切り記号を追加します。  
  
### <a name="formatting-values"></a>値の書式設定  
 <xref:System.String.Format%2A?displayProperty=nameWithType>メソッドでは、複合書式指定機能を使用して、文字列内の 1 つまたは複数のプレース ホルダーをいくつかのオブジェクトまたは値の文字列形式に置き換えます。 <xref:System.String.Format%2A>メソッドは、次の操作によく使用されます。  
  
-   文字列には、数値の文字列表現を埋め込む。  
  
-   文字列の日付と時刻の値の文字列表現を埋め込む。  
  
-   文字列の列挙値の文字列表現を埋め込む。  
  
-   サポートするいくつかのオブジェクトの文字列表現を埋め込むには、<xref:System.IFormattable>文字列内のインターフェイス。  
  
-   右揃えまたは左揃えの大きな文字列内のフィールド内の部分文字列。  
  
 操作と例を書式設定に関する詳細については、次を参照してください。、<xref:System.String.Format%2A>オーバー ロードの概要。  
  
### <a name="copying-a-string"></a>文字列のコピー  
 次に呼び出すことができます<xref:System.String>文字列のコピーを作成する方法。  
  
-   <xref:System.String.Clone%2A> 既存の参照を返します<xref:System.String>オブジェクト。  
  
-   <xref:System.String.Copy%2A> 既存の文字列のコピーを作成します。  
  
-   <xref:System.String.CopyTo%2A> 文字列の一部を文字配列にコピーします。  
  
### <a name="normalizing-a-string"></a>文字列の正規化  
 1 つの文字は Unicode では、複数のコード ポイントを持つことができます。 正規化は、これらの同等の文字を同じバイナリ表現に変換します。 <xref:System.String.Normalize%2A?displayProperty=nameWithType>メソッドは、正規化を実行し、<xref:System.String.IsNormalized%2A?displayProperty=nameWithType>メソッドは、文字列を正規化するかどうかを判断します。  
  
 詳細と例では、次を参照してください。、[正規化](#Normalization)このトピックの前半の「します。  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/en-us/download/details.aspx?id=10921">並べ替えの重みのテーブルの Windows オペレーティング システム</related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">Unicode 照合順序 Elemeent の既定のテーブル、Linux と macOS</related>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">.NET Framework で文字列を使用するためのベスト プラクティス</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このセクションの内容:  
  
 [オーバー ロードされたコンス トラクター構文](#Syntax)   
 [パラメーター](#Params)   
 [例外](#Exceptions)   
 [どのメソッドが呼び出しですか。](#Tasks)   
 [文字列の作成](#Creating_Strings)   
 [反復的な文字列を処理します。](#Repetitive)   
 インスタンス化する文字列の例:   
 [文字列の割り当てを使用します。](#Ctor1_Example)  
 [文字配列を使用します。](#Ctor2_Example)  
 [文字配列の一部を使用し、1 つの文字を繰り返す](#Ctor3_Example)  
 [文字配列へのポインターを使用します。](#Ctor4_Example)  
 [ポインターと配列の範囲を使用してください。](#Ctor5_Example)  
 [符号付きバイト配列へのポインターを使用します。](#Ctor6_Example)  
[バージョン情報](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>オーバー ロードされたコンス トラクター構文  
 文字列コンス トラクターは 2 つのカテゴリに分類されます。 ポインター パラメーターを指定せずとポインター パラメーターを使用します。 ポインターを使用するコンス トラクターは、CLS 準拠ではありません。 さらに、Visual Basic はポインターの使用をサポートしていませんし、c#、unsafe コンテキストで実行するポインターを使用するコードが必要です。 詳しくは、「[unsafe](~/docs/csharp/language-reference/keywords/unsafe.md)」をご覧ください。  
  
 オーバー ロードの選択に追加のガイダンスについては、次を参照してください[どのメソッドが呼び出しですか?。](#Tasks)  
  
 `String(Char[] value)`  
 Unicode 文字の配列により示される値の新しいインスタンスを初期化します。 このコンス トラクターは、Unicode 文字をコピー ([例](#Ctor2_Example))。  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 Unicode 文字配列、および長さ内の開始文字位置の配列により示される値の新しいインスタンスを初期化します ([例](#Ctor3_Example))。  
  
 `String(Char c, Int32 count)`  
 指定した Unicode 文字が示される値の新しいインスタンスを初期化しますが指定した回数だけ繰り返されます ([例](#Ctor3_Example))。  
  
 `String(char* value)`  
 **(CLS 非準拠)** は null 文字で終了する Unicode 文字の配列を指すポインターにより示される値に新しいインスタンスを初期化します (u+0000 または '\0')。 ([例](#Ctor4_Example))。  
  
 アクセス許可: <xref:System.Security.SecurityCriticalAttribute>、直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(CLS 非準拠)** Unicode 文字、配列、および長さ内の開始文字位置の配列を指すポインターにより示される値に新しいインスタンスを初期化します。 コンス トラクターから Unicode 文字をコピーする`value`インデックスから始まります`startIndex`とインデックス位置にある終了`startIndex`  +  `length` – 1 ([例](#Ctor5_Example))。  
  
 アクセス許可: <xref:System.Security.SecurityCriticalAttribute>、直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。  
  
 `String(SByte* value)`  
 **(CLS 非準拠)** 8 ビット符号付き整数の配列を指すポインターにより示される値に新しいインスタンスを初期化します。 配列は、現在のシステム コード ページを使用してエンコードされた文字列を表すと見なされます (で指定されたエンコーディングは、 <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>)。 コンス トラクターから文字を処理する`value`null 文字 (0x00) に達するまで、ポインターで指定された位置から開始 ([例](#Ctor6_Example))。  
  
 アクセス許可: <xref:System.Security.SecurityCriticalAttribute>、直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(CLS 非準拠)** 8 ビット符号付き整数、配列、および長さ内の開始位置の配列を指すポインターにより示される値に新しいインスタンスを初期化します。  配列は、現在のシステム コード ページを使用してエンコードされた文字列を表すと見なされます (で指定されたエンコーディングは、 <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>)。 コンス トラクターは、値の先頭から文字を処理する`startIndex`で終わる`startIndex`  +  `length` – 1 ([例](#Ctor6_Example))。  
  
 アクセス許可: <xref:System.Security.SecurityCriticalAttribute>、直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(CLS 非準拠)** その配列の長さ、内の開始位置を 8 ビット符号付き整数の配列を指すポインターにより示される値に新しいインスタンスを初期化し、<xref:System.Text.Encoding>オブジェクト。  
  
 アクセス許可: <xref:System.Security.SecurityCriticalAttribute>、直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。  
  
<a name="Params"></a>   
## <a name="parameters"></a>パラメーター  
 によって使用されるパラメーターの完全な一覧を次に示します<xref:System.String>ポインター パラメーターが含まれていないコンス トラクター。 各オーバー ロードによって使用されるパラメーター、上記のオーバー ロードの構文を参照してください。  
  
|パラメーター|型|説明|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Unicode 文字の配列。|  
|`c`|<xref:System.Char>|Unicode 文字。|  
|`startIndex`|<xref:System.Int32>|内の開始位置`value`の新しい文字列の最初の文字。<br /><br /> 既定値: 0|  
|`length`|<xref:System.Int32>|文字数`value`を新しい文字列に含めます。<br /><br /> 既定値: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|数を掛けたもの文字`c`は新しい文字列で繰り返されます。 場合`count`0 の場合は、新しいオブジェクトの値が<xref:System.String.Empty?displayProperty=nameWithType>します。|  
  
 によって使用されるパラメーターの完全な一覧を次に示します<xref:System.String>ポインター パラメーターを含むコンス トラクター。 各オーバー ロードによって使用されるパラメーター、上記のオーバー ロードの構文を参照してください。  
  
|パラメーター|型|説明|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> - または -<br /><br /> <xref:System.SByte>\*|Unicode 文字の null で終わる配列または 8 ビット符号付き整数の配列へのポインター。 場合`value`は`null`または空の配列の新しい文字列の値が<xref:System.String.Empty?displayProperty=nameWithType>します。|  
|`startIndex`|<xref:System.Int32>|新しい文字列の最初の文字を定義する配列要素のインデックス。<br /><br /> 既定値: 0|  
|`length`|<xref:System.Int32>|使用して新しい文字列を作成する配列要素の数。 長さが 0 の場合は、コンス トラクターは値が文字列を作成します<xref:System.String.Empty?displayProperty=nameWithType>します。<br /><br /> 既定値: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|オブジェクトを指定する方法、`value`配列をエンコードします。<br /><br /> 既定値: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>、またはシステムの現在の ANSI コード ページ|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>例外  
 ポインター パラメーターが含まれていないコンス トラクターによってスローされた例外の一覧を示します。  
  
|例外|条件|によってスローされます。|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` は `null` です。|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`、`length`、または`count`0 未満です。<br /><br /> - または -<br /><br /> `startIndex` と `length` の合計が、`value` にある要素の数を超えています。<br /><br /> - または -<br /><br /> `count` が 0 未満です。|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 ポインター パラメーターを含むコンス トラクターによってスローされた例外の一覧を示します。  
  
|例外|条件|によってスローされます。|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value` 無効な Unicode 文字を含む配列を指定します。<br /><br /> - または -<br /><br /> `value` または`value`  +  `startIndex` 64 K 未満のアドレスを指定します。<br /><br /> - または -<br /><br /> 新しい<xref:System.String>からインスタンスを初期化できませんでした、`value`バイト配列のため、`value`既定コード ページ エンコーディングを使用しません。|ポインターとすべてのコンス トラクター。|  
|<xref:System.ArgumentNullException>|`value` が null です。|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|現在のプロセスは、アドレス指定されたすべての文字に対する読み取りアクセス権を持っているわけではありません。<br /><br /> - または -<br /><br /> `startIndex` または `length` が 0 未満であるか、`value` + `startIndex` によりポインターのオーバーフローが発生するか、または現在のプロセスにはすべてのアドレス指定された文字に対する読み取りアクセス許可がありません。<br /><br /> - または -<br /><br /> 新しい文字列の長さが大きすぎて割り当てられません。|ポインターとすべてのコンス トラクター。|  
|<xref:System.AccessViolationException>|`value`、または`value`  +  `startIndex`  +  `length` – 1、無効なアドレスを指定します。|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>どのメソッドが呼び出しですか。  
  
|終了|呼び出しまたは使用|  
|--------|-----------------|  
|文字列を作成します。|文字列リテラルまたは既存の文字列からの割り当て ([例](#Ctor1_Example))|  
|全体の文字配列から文字列を作成します。|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([例](#Ctor2_Example))|  
|一部の文字配列から文字列を作成します。|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([例](#Ctor3_Example))|  
|同じ文字を複数回繰り返される、文字列を作成します。|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([例](#Ctor3_Example))|  
|Unicode またはワイド文字配列へのポインターから文字列を作成します。|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|Unicode またはワイド文字配列の部分から文字列を作成するには、そのポインターを使用します。|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|C++ から文字列を作成`char`配列。|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> - または -<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|ASCII 文字から文字列を作成します。|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>文字列の作成  
 最もよく使用される手法は、単純な割り当ての文字列をプログラムで作成するように[この例](#Ctor1_Example)します。 <xref:System.String>クラスには、次の値から文字列を作成することができますをコンス トラクター オーバー ロードの 4 つの型も含まれています。  
  
-   文字配列 (UTF 16 でエンコードされた文字の配列)。 新規に作成することができます<xref:System.String>配列全体またはその一部の文字からのオブジェクト。 <xref:System.String.%23ctor%28System.Char%5B%5D%29>コンス トラクターは、配列内のすべての文字を新しい文字列にコピーします。 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>コンス トラクターは、インデックスから文字をコピー`startIndex`インデックスに`startIndex`  +  `length` – 1 に、新しい文字列。 場合`length`0 の場合は、新しい文字列の値が<xref:System.String.Empty?displayProperty=nameWithType>します。  
  
     コードが繰り返し値が同じである文字列をインスタンス化する場合は、文字列の作成の別の方法を使用してアプリケーションのパフォーマンスを向上できます。 詳細については、次を参照してください。[反復的な文字列を処理する](#Repetitive)します。  
  
-   1 つの文字重複 0、1 つ、または他にも使用して、<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29>コンス トラクター。 場合`count`0 の場合は、新しい文字列の値が<xref:System.String.Empty?displayProperty=nameWithType>します。  
  
-   Null で終わる文字配列へのポインターから次を使用して、<xref:System.String.%23ctor%28System.Char%2A%29>または<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>コンス トラクター。 配列全体または指定した範囲のいずれかを文字列を初期化するために使用できます。 コンス トラクターは、指定したポインターから、またはプラスの指定したポインターから始まる Unicode 文字のシーケンスをコピーする`startIndex`または配列の末尾に至ると`length`文字。 場合`value`null ポインターまたは`length`0 の場合は、コンス トラクターは、値が文字列を作成します。<xref:System.String.Empty?displayProperty=nameWithType>します。 コピー操作は、配列の末尾に進みます配列が null で終わっていない場合は、システムに依存するが、コンス トラクターの動作。 このような条件へのアクセス違反が発生する可能性があります。  
  
     配列には、埋め込まれた null 文字が含まれている場合 (u+0000 または '\0') と<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードが呼び出されると、文字列のインスタンスに含まれる`length`など任意の文字の埋め込み null 値。 次の例に 2 つの null 文字を含む 10 個の要素の配列へのポインターが渡されるときに起こる、<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>メソッド。 配列の先頭は、アドレスは、配列内のすべての要素が文字列に追加されるため、コンス トラクターには、2 つの埋め込み null 値を含む 10 個の文字の文字列がインスタンス化します。 その一方で、同じ配列が渡された場合に、<xref:System.String.%23ctor%28System.Char%2A%29>コンス トラクターは、結果は最初の null 文字を含まない 4 文字の文字列。  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     配列には、Unicode 文字を含める必要があります。 C++ では、つまり文字配列でなければならないこと、管理対象として定義されている<xref:System.Char>型またはアンマネージ`wchar_t`型です。  
  
     場合、<xref:System.String.%23ctor%28System.Char%2A%29>オーバー ロードと呼ばれ、配列が null で終わっていない場合は、<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードが呼び出されますと`startIndex`  +  `length`-1 には、文字のシーケンスに割り当てられたメモリの外側に範囲が含まれていますコンス トラクターの動作がシステムに依存し、アクセス違反が発生する可能性があります。 さらに、Intel Itanium プロセッサを呼び出し、<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>コンス トラクターがスローされる、<xref:System.DataMisalignedException>例外。 この場合、呼び出し、<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>代わりにします。  
  
-   符号付きバイト配列へのポインター。 配列全体または指定した範囲のいずれかを文字列を初期化するために使用できます。 バイトのシーケンスをエンコードするには、既定のコード ページを使用して解釈できるまたはコンス トラクターの呼び出しで、エンコードを指定できます。 コンス トラクターは、全体が null で終わっていないを配列から文字列をインスタンス化しようとする場合、または場合から配列の範囲`value`  +  `startIndex`に`value`  +  `startIndex`  +  `length` -1 は、配列に割り当てられたメモリの外部では、このコンス トラクターの動作は、システムに依存、およびアクセス違反が発生する可能性があります。  
  
     パラメーターとして、符号付きバイト配列を含む 3 つのコンス トラクターは C++ に変換するには、主に、`char`この例で示すように、文字列配列。  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     値が 0、null 文字 ('\0') またはバイト配列が含まれている場合、<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードが呼び出されると、文字列のインスタンスに含まれる`length`など任意の文字の埋め込み null 値。 次の例に 2 つの null 文字を含む 10 個の要素の配列へのポインターが渡されるときに起こる、<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>メソッド。 配列の先頭は、アドレスは、配列内のすべての要素が文字列に追加されるため、コンス トラクターには、2 つの埋め込み null 値を含む 10 個の文字の文字列がインスタンス化します。 その一方で、同じ配列が渡された場合に、<xref:System.String.%23ctor%28System.SByte%2A%29>コンス トラクターは、結果は最初の null 文字を含まない 4 文字の文字列。  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     <xref:System.String.%23ctor%28System.SByte%2A%29>と<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>コンス トラクターを解釈`value`既定の ANSI コード ページを使用すると、同一のバイト配列でこれらのコンス トラクターを呼び出す可能性があります文字列の作成をさまざまなシステムで異なる値を持ちます。  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>反復的な文字列を処理します。  
 解析するか、多くの場合、テキストのストリームをデコードするアプリを使用して、<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>コンス トラクターまたは<xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>を文字列に文字のシーケンスに変換します。 メモリを浪費する繰り返しを作成して、1 つの文字列を再利用する代わりに同じ値を持つ新しい文字列を作成します。 繰り返し呼び出すことによって、同じ文字列値を作成する可能性が高いかどうかは、<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>コンス トラクターで不明な場合にも進み、これらの同じ文字列値があります、ルックアップ テーブルを代わりに使用することができます。  
  
 たとえば、読み取り、XML タグと属性を含むファイルからの文字のストリームを解析するとします。 ストリームを解析するときに特定のトークン (つまり、シンボルの意味を持つ文字のシーケンス) が繰り返し発生します。 文字列「0」、「1」、"true"と"false"に相当するトークンは、XML ストリームで頻繁に発生する可能性があります。  
  
 各トークンを新しい文字列に変換する代わりに作成することができます、<xref:System.Xml.NameTable?displayProperty=nameWithType>頻出する文字列を保持するオブジェクト。 <xref:System.Xml.NameTable>オブジェクトで一時的なメモリを割り当てずに格納された文字列を取得するためのパフォーマンスが向上します。 使用して、トークンが発生したときに、<xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>テーブルからトークンを取得します。 トークンが存在する場合、メソッドは、対応する文字列を返します。 トークンが存在しない場合は、使用、<xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>メソッド トークンをテーブルに挿入して、対応する文字列を取得します。  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>例 1: を使用して文字列の割り当て  
 次の例では、文字列リテラルを割り当てることで、新しい文字列を作成します。 これを最初の文字列の値を割り当てることで、2 番目の文字列を作成します。 これらの新しいインスタンスを作成する 2 つの最も一般的な方法は、<xref:System.String>オブジェクト。  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>例 2: 文字配列を使用します。  
 次の例は、新たに作成する方法を示します<xref:System.String>オブジェクト文字配列から。  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>例 3: 文字の配列の一部を使用し、1 つの文字の繰り返し  
 次の例は、新たに作成する方法を示します<xref:System.String>オブジェクトを新たに作成する方法と、文字配列の一部から<xref:System.String>を複数回出現 1 つの文字を含むオブジェクト。  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>例 4: 文字配列へのポインターを使用します。  
 次の例は、新たに作成する方法を示します<xref:System.String>文字の配列へのポインターからのオブジェクト。 使用して c# の例をコンパイルする必要があります、`/unsafe`コンパイラ スイッチ。  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>例 5: ポインターと配列の範囲からの文字列をインスタンス化します。  
 次の例では、ピリオド、または感嘆符のいずれかの文字配列の要素を調べます。 1 つが見つかった場合は、配列内の区切り記号の直前の文字の文字列がインスタンス化します。 それ以外の場合は、配列の内容全体を含む文字列がインスタンス化します。 C# の例を使用してコンパイルする必要があります、`/unsafe`コンパイラ スイッチ。  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>例 6: 符号付きバイト配列へのポインターから文字列をインスタンス化します。  
 次の例がのインスタンスを作成する方法を示しています、<xref:System.String>クラス、<xref:System.String.%23ctor%28System.SByte%2A%29>コンス トラクター。  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>バージョン情報  
 .NET Framework  
 すべてのオーバー ロードではサポートされて: 4.5、4、3.5、3.0、2.0、1.1、1.0  
  
 .NET Framework Client Profile  
 すべてのオーバー ロードではサポートされて: 4、3.5 SP1  
  
 ポータブル クラス ライブラリ  
 すべてのオーバー ロードせず、 <xref:System.SByte> `*`パラメーターがサポートされています  
  
 Windows ストア アプリ用 .NET  
 なくすべてのオーバー ロードを<xref:System.SByte>`*`でパラメーターがサポートされています: Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 文字の null で終わる配列へのポインター。</param>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、指定した Unicode 文字配列を指すポインターにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  例とこのおよびその他の操作について、包括的な使用状況の`String`コンス トラクター オーバー ロードを参照してください、<xref:System.String.%23ctor%2A>コンス トラクターの概要。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のプロセスは、アドレス指定されたすべての文字に対する読み取りアクセス権を持っているわけではありません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> が正しくない Unicode 文字を含む配列を指定しているか、<paramref name="value" /> が 64000 未満のアドレスを指定しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 文字の配列。</param>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、Unicode 文字の配列により示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  例とこのおよびその他の操作について、包括的な使用状況の`String`コンス トラクター オーバー ロードを参照してください、<xref:System.String.%23ctor%2A>コンス トラクターの概要。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value">終端が null の 8 ビット符号付き整数の配列へのポインター。 整数は、現在のシステム コード ページ エンコーディング (つまり、<see cref="P:System.Text.Encoding.Default" /> が指定したエンコーディング) を使用して解釈されます。</param>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、8 ビット符号付き整数の配列を指すポインターにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  例とこのおよびその他の操作について、包括的な使用状況の`String`コンス トラクター オーバー ロードを参照してください、<xref:System.String.%23ctor%2A>コンス トラクターの概要。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.String" /> の新しいインスタンス を、<paramref name="value" /> を使用して初期化できませんでした。<paramref name="value" /> が ANSI でエンコードされていると想定しています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> の Null 終端文字によって決定される初期化する新しい文字列の長さが、大きすぎて割り当てられません。</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" /> に指定されたアドレスが正しくありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Unicode 文字。</param>
        <param name="count">
          <paramref name="c" /> の発生回数。</param>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、指定した回数だけ繰り返した指定の Unicode 文字が示す値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  例とこのおよびその他の操作について、包括的な使用状況の`String`コンス トラクター オーバー ロードを参照してください、<xref:System.String.%23ctor%2A>コンス トラクターの概要。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 文字の配列を指すポインター。</param>
        <param name="startIndex">
          <paramref name="value" /> 内の開始位置。</param>
        <param name="length">使用する <paramref name="value" /> 内の文字数。</param>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、Unicode 文字の配列を指す指定のポインター、配列内の開始文字位置、および長さにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  例とこのおよびその他の操作について、包括的な使用状況の`String`コンス トラクター オーバー ロードを参照してください、<xref:System.String.%23ctor%2A>コンス トラクターの概要。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="length" /> が 0 未満であるか、<paramref name="value" /> + <paramref name="startIndex" /> によりポインターのオーバーフローが発生するか、または現在のプロセスにはすべてのアドレス指定された文字に対する読み取りアクセス許可がありません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> が正しくない Unicode 文字を含む配列を指定しているか、<paramref name="value" /> + <paramref name="startIndex" /> が 64000 未満のアドレスを指定しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 文字の配列。</param>
        <param name="startIndex">
          <paramref name="value" /> 内の開始位置。</param>
        <param name="length">使用する <paramref name="value" /> 内の文字数。</param>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、Unicode 文字の配列、配列内の開始文字位置、および長さにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  例とこのおよびその他の操作について、包括的な使用状況の`String`コンス トラクター オーバー ロードを参照してください、<xref:System.String.%23ctor%2A>コンス トラクターの概要。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
- または - 
<paramref name="startIndex" /> と <paramref name="length" /> の合計が、<paramref name="value" /> にある要素の数を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">8 ビット符号付き整数の配列へのポインター。 整数は、現在のシステム コード ページ エンコーディング (つまり、<see cref="P:System.Text.Encoding.Default" /> が指定したエンコーディング) を使用して解釈されます。</param>
        <param name="startIndex">
          <paramref name="value" /> 内の開始位置。</param>
        <param name="length">使用する <paramref name="value" /> 内の文字数。</param>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、8 ビット符号付き整数の配列を指す指定のポインター、配列内の開始位置、および長さにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  例とこのおよびその他の操作について、包括的な使用状況の`String`コンス トラクター オーバー ロードを参照してください、<xref:System.String.%23ctor%2A>コンス トラクターの概要。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
- または - 
<paramref name="value" /> + <paramref name="startIndex" /> で指定されたアドレスが現在のプラットフォームにとって大きすぎて、アドレス計算がオーバーフローしました。  
  
- または - 
初期化する新しい文字列の長さが大きすぎて割り当てられません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> + <paramref name="startIndex" /> で指定されるアドレスは 64 K 未満です。  
  
- または - 
<see cref="T:System.String" /> の新しいインスタンスを、<paramref name="value" /> を使用して初期化できませんでした (<paramref name="value" /> が ANSI でエンコードされていると想定)。</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />、<paramref name="startIndex" />、<paramref name="length" /> 全体で、正しくないアドレスを指定しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value">8 ビット符号付き整数の配列へのポインター。</param>
        <param name="startIndex">
          <paramref name="value" /> 内の開始位置。</param>
        <param name="length">使用する <paramref name="value" /> 内の文字数。</param>
        <param name="enc">
          <paramref name="value" /> が参照する配列のエンコード方法を指定するオブジェクト。 <paramref name="enc" /> が <see langword="null" /> の場合は、ANSI エンコーディングが指定されていると見なされます。</param>
        <summary>
          <see cref="T:System.String" /> クラスの新しいインスタンスを初期化し、8 ビット符号付き整数の配列を指す指定のポインター、配列内の開始位置、長さ、および <see cref="T:System.Text.Encoding" /> オブジェクトにより示される値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  例とこのおよびその他の操作について、包括的な使用状況の`String`コンス トラクター オーバー ロードを参照してください、<xref:System.String.%23ctor%2A>コンス トラクターの概要。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
- または - 
<paramref name="value" /> + <paramref name="startIndex" /> で指定されたアドレスが現在のプラットフォームにとって大きすぎて、アドレス計算がオーバーフローしました。  
  
- または - 
初期化する新しい文字列の長さが大きすぎて割り当てられません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> + <paramref name="startIndex" /> で指定されるアドレスは 64 K 未満です。  
  
- または - 
<see cref="T:System.String" /> の新しいインスタンスを、<paramref name="value" /> を使用して初期化できませんでした。<paramref name="value" /> が <paramref name="enc" /> の指定に従ってエンコードされていると想定しています。</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />、<paramref name="startIndex" />、<paramref name="length" /> 全体で、正しくないアドレスを指定しています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">現在の文字列内の位置。</param>
        <summary>現在の <see cref="T:System.String" /> オブジェクト内の指定された位置にある <see cref="T:System.Char" /> オブジェクトを取得します。</summary>
        <value>
          <paramref name="index" /> 位置にあるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index`パラメーターは 0 から始まります。  
  
 このプロパティを返します、<xref:System.Char>オブジェクトで指定された位置にある、`index`パラメーター。 ただし、Unicode 文字は、1 つ以上で表すこと可能性があります<xref:System.Char>します。 使用して、<xref:System.Globalization.StringInfo?displayProperty=nameWithType>の代わりに Unicode を使用するクラスが文字<xref:System.Char>オブジェクト。 詳細については、「オブジェクトと Unicode の文字を Char する」セクションを参照してください、<xref:System.String>クラスの概要。  
  
 C# で、<xref:System.String.Chars%2A>プロパティは、インデクサーです。 Visual basic での既定のプロパティは、<xref:System.String>クラス。 各<xref:System.Char>など、次のコードを使用して、文字列内のオブジェクトにアクセスできます。  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 次の例では、文字列を検証するルーチンでこのインデクサーを使用する方法を示します。  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> がこのオブジェクトの長さ以上か、0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.String" /> インスタンスへの参照を返します。</summary>
        <returns>この <see cref="T:System.String" /> のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 戻り値は、このインスタンスの独立したコピーではありません。同じデータを単に別のビューになります。 使用して、<xref:System.String.Copy%2A>または<xref:System.String.CopyTo%2A>メソッドを個別に作成する<xref:System.String>このインスタンスと同じ値を持つオブジェクト。  
  
 <xref:System.String.Clone%2A>メソッドは単に既存の文字列インスタンスを返します、これを直接呼び出す理由はほとんどがあります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、それらの相対位置を並べ替え順序で示す整数を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Compare%2A> メソッドのすべてのオーバーロードは、2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数を返します。  
  
|[値]|状態|  
|-----------|---------------|  
|0 より小さい値|2 番目の部分文字列の前に、並べ替え順で最初の部分文字列。|  
|0|部分文字列は並べ替え順序で同じ位置で発生するか、`length` はゼロです。|  
|0 より大きい値|最初の部分文字列では、並べ替え順序で 2 番目の部分文字列に従います。|  
  
> [!WARNING]
>  可能であればのオーバー ロードを呼び出す必要があります、<xref:System.String.Compare%2A>メソッドを含む、<xref:System.StringComparison>パラメーター。 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">.NET Framework で文字列を使用するためのベスト プラクティス</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、それらの相対位置を並べ替え順序で示す整数を返します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値 
 </term><description> 状態 
 </description></listheader><item><term> 0 より小さい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> は並べ替え順序で、<paramref name="strB" /> と同じ位置に出現します。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較では、現在のカルチャを使用して、個々 の文字のアルファベット順、大文字小文字の規則などのカルチャに固有の情報を取得します。 たとえば、カルチャが特定の文字の組み合わせが単一の文字として扱うか、特定の方法では、大文字と小文字を比較することを指定できますまたは文字の前に、文字の並べ替え順序が依存しているかそれに従います。  
  
 比較は、単語の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>します。  
  
> [!WARNING]
>  文字列を比較するときに呼び出す必要があります、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>メソッドで、明示的にメソッドを使用する文字列比較の種類を指定する必要があります。 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 比較対象値の 1 つまたは両方を指定できます`null`します。 定義上、任意の文字列を含む空の文字列 ("")、比較に null 参照; より大きい2 つの null 参照が互いに等しくない比較します。  
  
 比較では、非等値が検出されるか、両方の文字列を比較したときに終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列、場合、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
 比較がカルチャに固有の大文字小文字の規則によって影響を受けると、予期しない結果が発生します。 たとえば、トルコ語では次の例では、間違った結果が生成トルコ語でのファイル システムでは"i"の文字の言語的な大文字小文字の規則が使用されないため"file"にします。  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 序数に基づく比較を使用して、「ファイル」へのパス名を比較します。 これを行う適切なコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 次の例では、<xref:System.String.Compare%28System.String%2CSystem.String%29>文字列の 3 つのセットを比較するメソッド。  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 次の例では、`ReverseStringComparer`クラスは 2 つの文字列を評価する方法を示します、<xref:System.String.Compare%2A>メソッド。  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.String)" />カルチャに依存した比較を実行するときに、メソッドでこのような文字が考慮されません。 次のコードを実行する場合など、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]または、後で、"animal"と「ani-正しくない」(ソフト ハイフン、または U + 00AD 使用) のカルチャに依存する比較では 2 つの文字列が等価であることを示します。  
  
[! コード csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [! コード vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)] 
文字列比較で無視できる文字を認識するように呼び出す、<see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />メソッドと値のいずれかの供給<see cref="F:System.Globalization.CompareOptions.Ordinal" />または<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />の`comparisonType`パラメーター。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。比較時に、大文字と小文字を区別するかどうかを設定できます。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値 
 </term><description> 状態 
 </description></listheader><item><term> 0 より小さい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> は並べ替え順序で、<paramref name="strB" /> と同じ位置に出現します。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較では、現在のカルチャを使用して、個々 の文字のアルファベット順、大文字小文字の規則などのカルチャに固有の情報を取得します。 たとえば、カルチャが特定の文字の組み合わせが単一の文字として扱うか、特定の方法では、大文字と小文字を比較することを指定できますまたは文字の前に、文字の並べ替え順序が依存しているかそれに従います。  
  
 比較は、単語の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>します。  
  
> [!WARNING]
>  文字列を比較するときに呼び出す必要があります、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>メソッドで、明示的にメソッドを使用する文字列比較の種類を指定する必要があります。 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 比較対象値の 1 つまたは両方を指定できます`null`します。 定義上、任意の文字列を含む空の文字列 ("")、比較に null 参照; より大きい2 つの null 参照が互いに等しくない比較します。  
  
 比較では、非等値が検出されるか、両方の文字列を比較したときに終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列、場合、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
 比較がカルチャに固有の大文字小文字の規則によって影響を受けると、予期しない結果が発生します。 たとえば、トルコ語では次の例では、間違った結果が生成トルコ語でのファイル システムでは"i"の文字の言語的な大文字小文字の規則が使用されないため"file"にします。  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 序数に基づく比較を使用して、「ファイル」へのパス名を比較します。 これを行う適切なコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 次の例を示している、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29>メソッドを使用して<xref:System.String.ToUpper%2A>または<xref:System.String.ToLower%2A>文字列を比較するときにします。  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" />カルチャに依存した比較を実行するときに、メソッドでこのような文字が考慮されません。 次のコードを実行する場合など、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]または、後で、"animal"と「Ani-正しくない」(ソフト ハイフン、または U + 00AD 使用) のカルチャ、大文字の比較では 2 つの文字列が等価であることを示します。  
  
[! コード csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [! コード vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)] 
文字列比較で無視できる文字を認識するように呼び出す、<see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />メソッドと値のいずれかの供給<see cref="F:System.Globalization.CompareOptions.Ordinal" />または<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />の<paramref name="comparisonType" />パラメーター。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <param name="comparisonType">比較で使用する規則を指定する列挙値の 1 つ。</param>
        <summary>指定した規則を使用して、指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値 
 </term><description> 状態 
 </description></listheader><item><term> 0 より小さい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> は並べ替え順序で、<paramref name="strB" /> と同じ位置にあります。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType`パラメーターは、比較では、現在またはインバリアント カルチャを使用する必要があります、かどうかを優先または、比較対照値の大文字と小文字を無視または word (カルチャ) を使用して、ことを示します。 または、序数 (カルチャに依存しない) の並べ替え規則。  
  
 比較対象値の 1 つまたは両方を指定できます`null`します。 定義上、任意の文字列を含む空の文字列 ("")、比較に null 参照; より大きい2 つの null 参照が互いに等しくない比較します。  
  
 比較では、非等値が検出されるか、両方の文字列を比較したときに終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列、場合に残りの文字の文字列は大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
 比較がカルチャに固有の大文字小文字の規則によって影響を受けると、予期しない結果が発生します。 たとえば、トルコ語では次の例では、間違った結果が生成トルコ語でのファイル システムでは"i"の文字の言語的な大文字小文字の規則が使用されないため"file"にします。  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 序数に基づく比較を使用して、「ファイル」へのパス名を比較します。 これを行う適切なコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 次の例では、3 つのバージョン、文字の"I"。 結果は、カルチャ、ケースが無視されるかどうか、および序数の比較を実行するかどうかの選択肢の影響を受けます。  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.StringComparison" /> がサポートされていません。</exception>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />カルチャに依存した比較を実行するときに、メソッドでこのような文字が考慮されません。 比較で無視できる文字を認識するように、値を与える<see cref="F:System.StringComparison.Ordinal" />または<see cref="F:System.StringComparison.OrdinalIgnoreCase" />の<paramref name="comparisonType" />パラメーター。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="culture">カルチャ固有の比較情報を提供するオブジェクト。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。比較時に、大文字と小文字を区別するかどうかを指定し、比較に影響を及ぼすカルチャ固有の情報を使用します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値 
 </term><description> 状態 
 </description></listheader><item><term> 0 より小さい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> は並べ替え順序で、<paramref name="strB" /> と同じ位置に出現します。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較を使用して、`culture`個々 の文字のアルファベット順、大文字小文字の規則などのカルチャに固有の情報を取得するパラメーター。 たとえば、カルチャが特定の文字の組み合わせが単一の文字として扱うか、特定の方法では、大文字と小文字を比較することを指定できますまたは文字の前に、文字の並べ替え順序が依存しているかそれに従います。  
  
 比較は、単語の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>します。  
  
 比較対象値の 1 つまたは両方を指定できます`null`します。 定義上、任意の文字列を含む空の文字列 ("")、比較に null 参照; より大きい2 つの null 参照が互いに等しくない比較します。  
  
 比較では、非等値が検出されるか、両方の文字列を比較したときに終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列、場合、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
 比較がカルチャに固有の大文字小文字の規則によって影響を受けると、予期しない結果が発生します。 たとえば、トルコ語では次の例では、間違った結果が生成トルコ語でのファイル システムでは"i"の文字の言語的な大文字小文字の規則が使用されないため"file"にします。  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 序数に基づく比較を使用して、「ファイル」へのパス名を比較します。 これを行う適切なコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 次の例では、カルチャが比較に影響を及ぼすを示します。 チェコ語、チェコ共和国のカルチャでは、"ch"は、"d"よりも大きい 1 つの文字です。 ただし、英語 - 米国のカルチャでは"ch という"2 つの文字から成る、"c"は"d"より小さい。  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />カルチャに依存した比較を実行するときに、メソッドでこのような文字が考慮されません。 次のコードを実行する場合など、 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 「Ani-正しくない」(ソフト ハイフン、または U + 00AD 使用) では、"animal"の大文字と小文字が、不変性を使用して後で、またはカルチャでは、2 つの文字列が等価であることを示します。  
  
[! コード csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [! コード vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)] 
文字列比較で無視できる文字を認識するように呼び出す、<see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />メソッドと値のいずれかの供給<see cref="F:System.Globalization.CompareOptions.Ordinal" />または<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />の<paramref name="options" />パラメーター。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <param name="culture">カルチャ固有の比較情報を提供するカルチャ。</param>
        <param name="options">比較の実行時に使用するオプション (大文字と小文字の違いや記号を無視するなど)。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトを比較し、2 つの文字列の互いのリレーションシップを並べ替え順序で示す整数を返します。比較時に、指定した比較オプションと、比較に影響を及ぼすカルチャ固有の情報を使用します。</summary>
        <returns>
          <paramref name="strA" /> と <paramref name="strB" /> との構文上の関係を示す 32 ビット符号付き整数。次の表を参照してください。 
 <list type="table"><listheader><term> 値 
 </term><description> 状態 
 </description></listheader><item><term> 0 より小さい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の前になります。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> は並べ替え順序で、<paramref name="strB" /> と同じ位置に出現します。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description>並べ替え順序において <paramref name="strA" /> は <paramref name="strB" /> の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較を使用して、`culture`パラメーターを個々 の文字のアルファベット順、大文字小文字の規則など、カルチャに固有の情報を取得します。 たとえば、特定のカルチャは、特定の文字の組み合わせを 1 つの文字として扱うことで、特定の方法で大文字と小文字を比較することを指定できますまたは文字の並べ替え順序の文字が依存しているを前または後します。  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>メソッドが並べ替え操作をアルファベット順に並べ替えに使用する主な設計されています。 また、メソッドの呼び出しの主な目的は、(メソッド呼び出しでは、戻り値が 0 のテスト) の場合は、2 つの文字列が等しいかどうかを判断するときにない使用する必要があります。 2 つの文字列が等しいかどうかを確認するのには、呼び出し、<xref:System.String.Equals%2A>メソッド。  
  
 によってさらに、比較を指定することができます、`options`パラメーターは、1 つ以上のメンバーで構成される、<xref:System.Globalization.CompareOptions>列挙体。 ただし、このメソッドの目的は、カルチャに依存した文字列比較を実行するため、<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>と<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>値は影響ありません。  
  
 比較対象値のいずれかまたは両方を指定できます`null`します。 定義上、任意の文字列を含む<xref:System.String.Empty?displayProperty=nameWithType>、互いに等しくない比較に null 参照より大きく、2 つの null 参照を比較します。  
  
 比較では、非等値が検出されるか、両方の文字列を比較したときに終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列、場合に、残りの文字の文字列は大きいと見なされます。  
  
   
  
## Examples  
 次の例では、次の 3 つの異なる方法で 2 つの文字列を比較します。 EN-US カルチャでは、言語的な比較を使用します。EN-US カルチャの大文字小文字の言語的な比較を使用します。序数に基づく比較を使用してください。 比較の 3 つのメソッドが 3 つの異なる結果を生成する方法を示しています。  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> が <see cref="T:System.Globalization.CompareOptions" /> 値ではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />カルチャに依存した比較を実行するときに、メソッドでこのような文字が考慮されません。 比較で無視できる文字を認識するように、値を与える<see cref="F:System.Globalization.CompareOptions.Ordinal" />または<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />の<paramref name="options" />パラメーター。</para>
        </block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA">
          <paramref name="strA" /> 内の部分文字列の位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB">
          <paramref name="strB" /> 内の部分文字列の位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、それらの相対位置を並べ替え順序で示す整数を返します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値 
 </term><description> 状態 
 </description></listheader><item><term> 0 より小さい値 
 </term><description><paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0 
 </term><description> 部分文字列は並べ替え順序で同じ位置で発生するか、<paramref name="length" /> はゼロです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> 並べ替え順序で、<paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較する部分文字列の開始`strA`で`indexA`し`strB`で`indexB`します。 両方`indexA`と`indexB`は 0 から始まる。 つまり、最初の文字`strA`と`strB`が 0 の位置。 最初の部分文字列の長さがの長さと等しい`strA`マイナス`indexA`1 を加算します。 2 番目の部分文字列の長さがの長さと等しい`strB`マイナス`indexB`1 を加算します。  
  
 比較する文字の数が 2 つの部分文字列の長さのうちの小さい方と`length`します。 `indexA`、 `indexB`、および`length`パラメーターは、0 以上である必要があります。  
  
 比較では、現在のカルチャを使用して、個々 の文字のアルファベット順、大文字小文字の規則などのカルチャに固有の情報を取得します。 たとえば、カルチャが特定の文字の組み合わせが単一の文字として扱うか、特定の方法では、大文字と小文字を比較することを指定できますまたは文字の前に、文字の並べ替え順序が依存しているかそれに従います。  
  
 比較は、単語の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>します。  
  
> [!WARNING]
>  文字列を比較するときに呼び出す必要があります、<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>メソッドで、明示的にメソッドを使用する文字列比較の種類を指定する必要があります。 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 比較対象値の 1 つまたは両方を指定できます`null`します。 定義上、任意の文字列を含む空の文字列 ("")、比較に null 参照; より大きい2 つの null 参照が互いに等しくない比較します。  
  
 比較では、非等値が検出されるか、両方の部分文字列を比較したときに終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列、場合、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
 比較がカルチャに固有の大文字小文字の規則によって影響を受けると、予期しない結果が発生します。 たとえば、トルコ語では次の例では、間違った結果が生成トルコ語でのファイル システムでは"i"の文字の言語的な大文字小文字の規則が使用されないため"file"にします。  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 序数に基づく比較を使用して、「ファイル」へのパス名を比較します。 これを行う適切なコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 次の例では、2 つの部分文字列を比較します。  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> より大きいです。  
  
- または - 
 <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> より大きいです。  
  
- または - 
 <paramref name="indexA" />、<paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
- または - 
<paramref name="indexA" /> または <paramref name="indexB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 より大きいです。</exception>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />言語またはカルチャに依存した比較を実行するときに、メソッドでこれらの文字が考慮されません。 比較で無視できる文字を認識するように呼び出す、<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />メソッドの値を指定して<see cref="F:System.Globalization.CompareOptions.Ordinal" />または<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />の<paramref name="comparisonType" />パラメーター。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA">
          <paramref name="strA" /> 内の部分文字列の位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB">
          <paramref name="strB" /> 内の部分文字列の位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。比較時に、大文字と小文字を区別するかどうかを設定できます。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値 
 </term><description> 状態 
 </description></listheader><item><term> 0 より小さい値 
 </term><description><paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0 
 </term><description> 部分文字列は並べ替え順序で同じ位置で発生するか、<paramref name="length" /> はゼロです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> 並べ替え順序で、<paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較する部分文字列の開始`strA`で`indexA`、および`strB`で`indexB`します。 両方`indexA`と`indexB`は 0 から始まる。 つまり、最初の文字`strA`と`strB`が 0 の位置。 最初の部分文字列の長さがの長さと等しい`strA`マイナス`indexA`1 を加算します。 2 番目の部分文字列の長さがの長さと等しい`strB`マイナス`indexB`1 を加算します。  
  
 比較する文字の数が 2 つの部分文字列の長さのうちの小さい方と`length`します。 `indexA`、 `indexB`、および`length`パラメーターは、0 以上である必要があります。  
  
 比較では、現在のカルチャを使用して、個々 の文字のアルファベット順、大文字小文字の規則などのカルチャに固有の情報を取得します。 たとえば、カルチャが特定の文字の組み合わせが単一の文字として扱うか、特定の方法では、大文字と小文字を比較することを指定できますまたは文字の前に、文字の並べ替え順序が依存しているかそれに従います。  
  
 比較は、単語の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>します。  
  
> [!WARNING]
>  文字列を比較するときに呼び出す必要があります、<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>メソッドで、明示的にメソッドを使用する文字列比較の種類を指定する必要があります。 詳細については、「[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)」を参照してください。  
  
 比較対象値の 1 つまたは両方を指定できます`null`します。 定義上、任意の文字列を含む空の文字列 ("")、比較に null 参照; より大きい2 つの null 参照が互いに等しくない比較します。  
  
 比較では、非等値が検出されるか、両方の部分文字列を比較したときに終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列、場合、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
 比較がカルチャに固有の大文字小文字の規則によって影響を受けると、予期しない結果が発生します。 たとえば、トルコ語では次の例では、間違った結果が生成トルコ語でのファイル システムでは"i"の文字の言語的な大文字小文字の規則が使用されないため"file"にします。  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 パス名は、インバリアントの方法で比較する必要があります。 これを行う適切なコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 次の例では、場合のみが異なる 2 つの部分文字列の 2 つの比較を実行します。 大文字小文字が、最初に比較と、2 つ目の比較では大文字です。  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> より大きいです。  
  
- または - 
 <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> より大きいです。  
  
- または - 
 <paramref name="indexA" />、<paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
- または - 
<paramref name="indexA" /> または <paramref name="indexB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 より大きいです。</exception>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />言語またはカルチャに依存した比較を実行するときに、メソッドでこれらの文字が考慮されません。 比較で無視できる文字を認識するように呼び出す、<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />メソッドの値を指定して<see cref="F:System.Globalization.CompareOptions.Ordinal" />または<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />の<paramref name="comparisonType" />パラメーター。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA">
          <paramref name="strA" /> 内の部分文字列の位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB">
          <paramref name="strB" /> 内の部分文字列の位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <param name="comparisonType">比較で使用する規則を指定する列挙値の 1 つ。</param>
        <summary>指定した規則を使用して、指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値 
 </term><description> 状態 
 </description></listheader><item><term> 0 より小さい値 
 </term><description><paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0 
 </term><description> 部分文字列は並べ替え順序で同じ位置に出現するか、<paramref name="length" /> パラメーターはゼロです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> 並べ替えで、<paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較する部分文字列の開始`strA`で`indexA`し`strB`で`indexB`します。 両方`indexA`と`indexB`は 0 から始まる。 つまり、最初の文字`strA`と`strB`で位置の 0、1 つ配置できません。 最初の部分文字列の長さがの長さと等しい`strA`マイナス`indexA`1 を加算します。 2 番目の部分文字列の長さがの長さと等しい`strB`マイナス`indexB`1 を加算します。  
  
 比較する文字の数が 2 つの部分文字列の長さのうちの小さい方と`length`します。 `indexA`、 `indexB`、および`length`パラメーターは、0 以上である必要があります。  
  
 `comparisonType`パラメーターは、比較では、現在またはインバリアント カルチャを使用する必要があります、かどうかを優先または、比較対照値の大文字と小文字を無視または word (カルチャ) を使用して、ことを示します。 または、序数 (カルチャに依存しない) の並べ替え規則。  
  
 比較対象値の 1 つまたは両方を指定できます`null`します。 定義上、任意の文字列を含む空の文字列 ("")、比較に null 参照; より大きい2 つの null 参照が互いに等しくない比較します。  
  
 比較では、非等値が検出されるか、両方の部分文字列を比較したときに終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列、場合に残りの文字の文字列は大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
 比較がカルチャに固有の大文字小文字の規則によって影響を受けると、予期しない結果が発生します。 たとえば、トルコ語では次の例では、間違った結果が生成トルコ語でのファイル システムでは"i"の文字の言語的な大文字小文字の規則が使用されないため"file"にします。  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 序数に基づく比較を使用して、「ファイル」へのパス名を比較します。 これを行う適切なコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 次の例では、2 つの部分文字列を比較します。  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> より大きいです。  
  
- または - 
 <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> より大きいです。  
  
- または - 
 <paramref name="indexA" />、<paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
- または - 
<paramref name="indexA" /> または <paramref name="indexB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 を超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />言語またはカルチャに依存した比較を実行するときに、メソッドでこれらの文字が考慮されません。 比較で無視できる文字を認識するように、値を与える<see cref="F:System.StringComparison.Ordinal" />または<see cref="F:System.StringComparison.OrdinalIgnoreCase" />の<paramref name="comparisonType" />パラメーター。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA">
          <paramref name="strA" /> 内の部分文字列の位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB">
          <paramref name="strB" /> 内の部分文字列の位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="culture">カルチャ固有の比較情報を提供するオブジェクト。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、並べ替え順序におけるそれらの相対位置を示す整数を返します。比較時に、大文字と小文字を区別するかどうかを指定し、比較に影響を及ぼすカルチャ固有の情報を使用します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す整数。  
  
 <list type="table"><listheader><term> 値 
 </term><description> 状態 
 </description></listheader><item><term> 0 より小さい値 
 </term><description><paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0 
 </term><description> 部分文字列は並べ替え順序で同じ位置で発生するか、<paramref name="length" /> はゼロです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> 並べ替え順序で、<paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較する部分文字列の開始`strA`で`indexA`、および`strB`で`indexB`します。 両方`indexA`と`indexB`は 0 から始まる。 つまり、最初の文字`strA`と`strB`で位置の 0、1 つ配置できません。 最初の部分文字列の長さがの長さと等しい`strA`マイナス`indexA`1 を加算します。 2 番目の部分文字列の長さがの長さと等しい`strB`マイナス`indexB`1 を加算します。  
  
 比較する文字の数が 2 つの部分文字列の長さのうちの小さい方と`length`します。 `indexA`、 `indexB`、および`length`パラメーターは、0 以上である必要があります。  
  
 比較を使用して、`culture`個々 の文字のアルファベット順、大文字小文字の規則などのカルチャに固有の情報を取得するパラメーター。 たとえば、カルチャが特定の文字の組み合わせが単一の文字として扱うか、特定の方法では、大文字と小文字を比較することを指定できますまたは文字の前に、文字の並べ替え順序が依存しているかそれに従います。  
  
 比較は、単語の並べ替え規則を使用して実行されます。 単語、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>します。  
  
 比較対象値の 1 つまたは両方を指定できます`null`します。 定義上、任意の文字列を含む空の文字列 ("")、比較に null 参照; より大きい2 つの null 参照が互いに等しくない比較します。  
  
 比較では、非等値が検出されるか、両方の部分文字列を比較したときに終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列、場合、残りの文字を含む文字列が大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
 比較がカルチャに固有の大文字小文字の規則によって影響を受けると、予期しない結果が発生します。 たとえば、トルコ語では次の例では、間違った結果が生成トルコ語でのファイル システムでは"i"の文字の言語的な大文字小文字の規則が使用されないため"file"にします。  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 序数に基づく比較を使用して、「ファイル」へのパス名を比較します。 これを行う適切なコードは次のとおりです。  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 次の例では、異なるカルチャを使用して、部分文字列の大文字と小文字を無視して 2 つの部分文字列を比較します。 選択したカルチャに影響が"I"の文字方法と比較します。  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> より大きいです。  
  
- または - 
 <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> より大きいです。  
  
- または - 
 <paramref name="indexA" />、<paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
- または - 
<paramref name="strA" /> または <paramref name="strB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />言語またはカルチャに依存した比較を実行するときに、メソッドでこれらの文字が考慮されません。 比較で無視できる文字を認識するように呼び出す、<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />メソッドの値を指定して<see cref="F:System.Globalization.CompareOptions.Ordinal" />または<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />の<paramref name="options" />パラメーター。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA">
          <paramref name="strA" /> 内の部分文字列の開始位置。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB">
          <paramref name="strB" /> 内の部分文字列の開始位置。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <param name="culture">カルチャ固有の比較情報を提供するオブジェクト。</param>
        <param name="options">比較の実行時に使用するオプション (大文字と小文字の違いや記号を無視するなど)。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較し、2 つの部分文字列の互いのリレーションシップを並べ替え順序で示す整数を返します。比較時に、指定した比較オプションと、比較に影響を及ぼすカルチャ固有の情報を使用します。</summary>
        <returns>2 つの部分文字列の構文上の関係を示す整数。次の表を参照してください。  
  
 <list type="table"><listheader><term> 値 
 </term><description> 状態 
 </description></listheader><item><term> 0 より小さい値 
 </term><description><paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列に並べ替え順序において先行します。  
  
 </description></item><item><term> 0 
 </term><description> 部分文字列は並べ替え順序で同じ位置で発生するか、<paramref name="length" /> はゼロです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> 並べ替え順序で、<paramref name="strA" /> 内の部分文字列は <paramref name="strB" /> 内の部分文字列の後ろになります。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較する部分文字列の開始`strA`位置にある`indexA`し`strB`位置にある`indexB`します。 最初の部分文字列の長さがの長さ`strA`マイナス`indexA`します。 2 番目の部分文字列の長さは、の長さ`strB`マイナス`indexB`します。  
  
 比較する文字の数が 2 つの部分文字列の長さのうちの小さい方と`length`します。 `indexA`、 `indexB`、および`length`パラメーターは、0 以上である必要があります。  
  
 比較を使用して、`culture`パラメーターを個々 の文字のアルファベット順、大文字小文字の規則など、カルチャに固有の情報を取得します。 たとえば、特定のカルチャは、特定の文字の組み合わせを 1 つの文字として扱うことで、特定の方法で大文字と小文字を比較することを指定できますまたは文字の並べ替え順序の文字が依存しているを前または後します。  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>メソッドが並べ替え操作をアルファベット順に並べ替えに使用する主な設計されています。 また、メソッドの呼び出しの主な目的は、(メソッド呼び出しでは、戻り値が 0 のテスト) の場合は、2 つの部分文字列が等しいかどうかを判断するときにない使用する必要があります。 2 つの文字列が等しいかどうかを確認するのには、呼び出し、<xref:System.String.Equals%2A>メソッド。  
  
 いずれかまたは両方の`strA`と`strB`できる`null`します。 定義上、任意の文字列を含む<xref:System.String.Empty?displayProperty=nameWithType>、互いに等しくない比較に null 参照より大きく、2 つの null 参照を比較します。  
  
 によってさらに、比較を指定することができます、`options`パラメーターは、1 つ以上のメンバーで構成される、<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列挙体。 ただし、このメソッドの目的は、カルチャに依存した文字列比較を実行するため、<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>と<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>値は影響ありません。  
  
 比較では、非等値が検出されるか、両方の部分文字列を比較したときに終了します。 ただし、2 つの文字列の比較で 1 つの文字列の末尾に等しく、残りの文字があるその他の文字列、場合に、残りの文字の文字列は大きいと見なされます。 戻り値は、最後に実行される比較の結果です。  
  
   
  
## Examples  
 次の例では、 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> 2 人のユーザーの姓を比較するメソッド。 次にアルファベット順に表示されます。  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> が <see cref="T:System.Globalization.CompareOptions" /> 値ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> が <paramref name="strA" /><see langword=".Length" /> より大きくなっています。  
  
- または - 
 <paramref name="indexB" /> が <paramref name="strB" /><see langword=".Length" /> より大きくなっています。  
  
- または - 
 <paramref name="indexA" />、<paramref name="indexB" />、または <paramref name="length" /> が負の値です。  
  
- または - 
<paramref name="strA" /> または <paramref name="strB" /> のいずれかが <see langword="null" /> であり、<paramref name="length" /> が 0 を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />言語またはカルチャに依存した比較を実行するときに、メソッドでこれらの文字が考慮されません。 比較で無視できる文字を認識するように、値を与える<see cref="F:System.Globalization.CompareOptions.Ordinal" />または<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />の<paramref name="options" />パラメーター。</para>
        </block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>それぞれの文字列の対応する <see cref="T:System.String" /> オブジェクトの数値を評価することで、2 つの <see cref="T:System.Char" /> を比較します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">比較する最初の文字列。</param>
        <param name="strB">比較する 2 番目の文字列。</param>
        <summary>それぞれの文字列の対応する <see cref="T:System.String" /> オブジェクトの数値を評価することで、指定した 2 つの <see cref="T:System.Char" /> を比較します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す整数。  
  
 <list type="table"><listheader><term> 値 
 </term><description> 状態 
 </description></listheader><item><term> 0 より小さい値 
 </term><description><paramref name="strA" /> は <paramref name="strB" /> より小さい値です。  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" /> と <paramref name="strB" /> が等しい。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description><paramref name="strA" /> が <paramref name="strB" /> より大きくなっています。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、序数の並べ替え規則を使用して、大文字小文字の比較を実行します。 単語、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>します。 序数の並べ替え規則を使用して、区別しない比較を実行するには、呼び出し、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>メソッドを`comparisonType`引数に設定<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>します。  
  
 <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29>静的メソッドでは、`strA`と`strB`できる`null`します。 両方の値が場合`null`、ことを示す 0 (ゼロ) が返されます`strA`と`strB`が等しい。 値の 1 つだけ場合`null`メソッドが null 以外の値を大きくすると見なします。  
  
   
  
## Examples  
 次の例を実行し、2 つの序数に基づく比較文字列の場合のみが異なります。  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">比較で使用する最初の文字列。</param>
        <param name="indexA">
          <paramref name="strA" /> 内の部分文字列の開始インデックス。</param>
        <param name="strB">比較で使用する 2 番目の文字列。</param>
        <param name="indexB">
          <paramref name="strB" /> 内の部分文字列の開始インデックス。</param>
        <param name="length">比較する各部分文字列の最大文字数。</param>
        <summary>それぞれの部分文字列の対応する <see cref="T:System.Char" /> オブジェクトの数値を評価することにより、指定した 2 つの <see cref="T:System.String" /> オブジェクトの部分文字列を比較します。</summary>
        <returns>2 つの比較対照値の構文上の関係を示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値 
 </term><description> 状態 
 </description></listheader><item><term> 0 より小さい値 
 </term><description><paramref name="strA" /> 内の部分文字列が <paramref name="strB" /> 内の部分文字列より小さいです。  
  
 </description></item><item><term> 0 
 </term><description> これらの部分文字列が等しいか、または <paramref name="length" /> が 0 です。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description><paramref name="strA" /> 内の部分文字列が <paramref name="strB" /> 内の部分文字列より大きいです。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `indexA`、 `indexB`、および`length`パラメーターは、0 以上である必要があります。  
  
 比較する文字の数が小さい方の長さの`strA`少ない`indexA`の長さ`strB`少ない`indexB`、および`length`します。  
  
 このメソッドは、序数の並べ替え規則を使用して、大文字小文字の比較を実行します。 単語、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>します。 序数の並べ替え規則を使用して、区別しない比較を実行するには、呼び出し、<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>メソッドを`comparisonType`引数に設定<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>します。  
  
 <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29>静的メソッドでは、`strA`と`strB`できる`null`します。 両方の値が場合`null`、ことを示す 0 (ゼロ) が返されます`strA`と`strB`が等しい。 値の 1 つだけ場合`null`メソッドが null 以外の値を大きくすると見なします。  
  
   
  
## Examples  
 次の例を示している<xref:System.String.CompareOrdinal%2A>と<xref:System.String.Compare%2A>さまざまな並べ替え順序を使用します。  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="strA" /> は <see langword="null" /> でありません。また <paramref name="indexA" /> が <paramref name="strA" />.<see cref="P:System.String.Length" /> を超えています。  
  
- または - 
 <paramref name="strB" /> は <see langword="null" /> でありません。また <paramref name="indexB" /> が <paramref name="strB" />.<see cref="P:System.String.Length" /> を超えています。  
  
- または - 
 <paramref name="indexA" />、<paramref name="indexB" />、または <paramref name="length" /> が負の値です。</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスと指定したオブジェクトまたは <see cref="T:System.String" /> とを比較し、並べ替え順序において、このインスタンスの位置が指定したオブジェクトまたは <see cref="T:System.String" /> の前、後ろ、または同じのいずれであるかを示す整数を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 両方のオーバー ロード、<xref:System.String.CompareTo%2A>メソッドは、カルチャおよび大文字の比較を実行します。 このメソッドを使用して、カルチャに依存しないまたは序数比較を実行することはできません。 コードをわかりやすく、勧めしないこと、<xref:System.String.CompareTo%2A>メソッドを呼び出し、<xref:System.String.Compare%2A>メソッド代わりにします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.String" /> に評価されるオブジェクト。</param>
        <summary>このインスタンスと指定した <see cref="T:System.Object" /> とを比較し、並べ替え順序において、このインスタンスの位置が指定した <see cref="T:System.Object" /> の前、後ろ、または同じのいずれであるかを示します。</summary>
        <returns>並べ替え順序において、このインスタンスの位置が <paramref name="value" /> パラメーターよりも前、後ろ、または同じのいずれであるかを示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値 
 </term><description> 状態 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> このインスタンスの位置が <paramref name="value" /> よりも前です。  
  
 </description></item><item><term> 0 
 </term><description> このインスタンスの位置が、並べ替え順序において <paramref name="value" /> と同じです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> このインスタンスの位置が <paramref name="value" /> よりも後ろです。  
  
または 
 <paramref name="value" /> は <see langword="null" /> です。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` 必要があります、<xref:System.String>オブジェクト。  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A>メソッドが並べ替え操作をアルファベット順に並べ替えに使用する主な設計されています。 また、メソッドの呼び出しの主な目的は、2 つの文字列が等しいかどうかを判断するときにない使用する必要があります。 2 つの文字列が等しいかどうかを確認するのには、呼び出し、<xref:System.String.Equals%2A>メソッド。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字小文字を区別し、カルチャに依存) 比較を実行します。 単語、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>します。  
  
 このメソッドの動作に関する詳細については、の「解説」を参照してください、<xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType>メソッド。  
  
   
  
## Examples  
 次の例では、<xref:System.String.CompareTo%2A>メソッドを<xref:System.Object>します。 しようとすると比較するため、<xref:System.String>インスタンスを`TestClass`オブジェクト、メソッドがスローされます、<xref:System.ArgumentException>します。  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> が <see cref="T:System.String" /> ではありません。</exception>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.CompareTo(System.Object)" />カルチャに依存した比較を実行するときに、メソッドでこのような文字が考慮されません。 次のコードを実行する場合など、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]または、後で、「動物」「ani-正しくない」(ソフト ハイフン、または U + 00AD 使用) との比較では 2 つの文字列が等価であることを示します。  
  
[! コード csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [! コード vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)] 
文字列比較で無視できる文字を認識するように呼び出す、<see cref="M:System.String.CompareOrdinal(System.String,System.String)" />メソッド。</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">このインスタンスと比較する文字列。</param>
        <summary>このインスタンスと指定した <see cref="T:System.String" /> オブジェクトとを比較し、並べ替え順序において、このインスタンスの位置が指定した文字列の前、後ろ、または同じのいずれであるかを示します。</summary>
        <returns>並べ替え順序において、このインスタンスの位置が <paramref name="strB" /> パラメーターよりも前、後ろ、または同じのいずれであるかを示す 32 ビット符号付き整数。  
  
 <list type="table"><listheader><term> 値 
 </term><description> 状態 
 </description></listheader><item><term> 0 より小さい値 
 </term><description> このインスタンスの位置が <paramref name="strB" /> よりも前です。  
  
 </description></item><item><term> 0 
 </term><description> このインスタンスの位置が、並べ替え順序において <paramref name="strB" /> と同じです。  
  
 </description></item><item><term> 0 より大きい値 
 </term><description> このインスタンスの位置が <paramref name="strB" /> よりも後ろです。  
  
または 
 <paramref name="strB" /> は <see langword="null" /> です。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のカルチャを使用して、単語 (大文字小文字を区別し、カルチャに依存) 比較を実行します。 単語、文字列、および序数の並べ替えの詳細については、次を参照してください。<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>します。  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A>メソッドが並べ替え操作をアルファベット順に並べ替えに使用する主な設計されています。 また、メソッドの呼び出しの主な目的は、2 つの文字列が等しいかどうかを判断するときにない使用する必要があります。 2 つの文字列が等しいかどうかを確認するのには、呼び出し、<xref:System.String.Equals%2A>メソッド。  
  
 このメソッドの動作に関する詳細については、の「解説」を参照してください、<xref:System.String.Compare%28System.String%2CSystem.String%29>メソッド。  
  
 このメソッドを実装、<xref:System.IComparable%601?displayProperty=nameWithType>インターフェイスを実行しますよりも若干優れています、<xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType>メソッドを判断することがあるないためかどうか、`strB`引数が、ボックス化する必要がありますを変更可能な値型と、キャストすることはありません、パラメーターから、<xref:System.Object>を<xref:System.String>します。  
  
   
  
## Examples  
 次の例では、<xref:System.String.CompareTo%2A>を別の文字列の現在の文字列インスタンスと比較するメソッド。  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 次の例では、いくつかの値と参照型の CompareTo メソッドのジェネリックと非ジェネリックのバージョンを示します。  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。 <see cref="M:System.String.CompareTo(System.String)" />カルチャに依存した比較を実行するときに、メソッドでこのような文字が考慮されません。 次のコードを実行する場合など、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]または、後で、「動物」「ani-正しくない」(ソフト ハイフン、または U + 00AD 使用) との比較では 2 つの文字列が等価であることを示します。  
  
[! コード csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [! コード vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)] 
文字列比較で無視できる文字を認識するように呼び出す、<see cref="M:System.String.CompareOrdinal(System.String,System.String)" />メソッド。</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.String" /> の 1 つ以上のインスタンス、または <see cref="T:System.String" /> の 1 つ以上のインスタンスの <see cref="T:System.Object" /> 形式の値を連結します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> を実装し、ジェネリック型引数が <see cref="T:System.String" /> であるコレクション オブジェクト。</param>
        <summary>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 型の構築された <see cref="T:System.String" /> コレクションのメンバーを連結します。</summary>
        <returns>
          <paramref name="values" /> 内の文字列の連結結果。または、<paramref name="values" /> が空の <see langword="IEnumerable(Of String)" /> である場合は <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド内の各オブジェクトを連結する`values`; 任意の区切り記号は追加されません。 各メンバー間の区切り記号を指定する`values`を呼び出し、<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>メソッド。  
  
 <xref:System.String.Empty>で任意の null 要素の代わりに文字列が使用される`values`します。  
  
 場合`values`は、空`IEnumerable(Of String)`、メソッドを返します<xref:System.String.Empty?displayProperty=nameWithType>します。 場合`values`は`null`がスローされます、<xref:System.ArgumentNullException>例外。  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 便利なメソッド内の各要素を連結することができますが、`IEnumerable(Of String)`文字列配列に要素を変換しなくてもコレクション。 統合言語クエリ (LINQ) のクエリ式で特に便利です。 次の例では、`List(Of String)`と等しいか (つまり、例では、"M")、特定の文字を超える文字を選択するラムダ式にアルファベットの大文字または小文字の文字を含むオブジェクト。 `IEnumerable(Of String)`によって返されるコレクション、<xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>にメソッドが渡される、<xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>メソッドを 1 つの文字列として結果を表示します。  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 次の例では、エラトステネスの篩というアルゴリズムを使用して、100 小さい素数を計算します。 結果を割り当てます、<xref:System.Collections.Generic.List%601>型のオブジェクト<xref:System.String>、しに渡されます、<xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>メソッド。  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">表現するオブジェクトまたは <see langword="null" />。</param>
        <summary>指定されたオブジェクトの文字列形式を作成します。</summary>
        <returns>
          <paramref name="arg0" /> の値の文字列形式。<see cref="F:System.String.Empty" /> が <paramref name="arg0" /> の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Concat%28System.Object%29>メソッドを表します`arg0`を呼び出して、パラメーターなしの文字列として`ToString`メソッド。  
  
   
  
## Examples  
 次の例で、<xref:System.String.Concat%2A>メソッド。  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">連結する要素を格納しているオブジェクト配列。</param>
        <summary>指定された <see cref="T:System.Object" /> 配列の要素の文字列表記を連結します。</summary>
        <returns>
          <paramref name="args" /> の各要素の値を連結した文字列表記。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド内の各オブジェクトを連結する`args`パラメーターなしで呼び出すことによって`ToString`; オブジェクトのメソッドの区切り記号は追加されません。  
  
 <xref:System.String.Empty?displayProperty=nameWithType> 配列内の任意の null オブジェクトの代わりに使用されます。  
  
   
  
## Examples  
 次の例では、使用、<xref:System.String.Concat%2A>メソッドを<xref:System.Object>配列。  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しています。</exception>
        <block subset="none" type="usage">
          <para>このメソッドは、C++ コードでは呼び出されません。 C++ コンパイラへの呼び出しを解決する<see cref="Overload:System.String.Concat" />への呼び出しとして 4 つ以上のオブジェクト パラメーターがある<see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />します。</para>
        </block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">文字列インスタンスの配列。</param>
        <summary>指定した <see cref="T:System.String" /> 配列の要素を連結します。</summary>
        <returns>連結された <paramref name="values" /> の要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド内の各オブジェクトを連結する`values`; 任意の区切り記号は追加されません。  
  
 <xref:System.String.Empty>文字列は、配列内の任意の null オブジェクトの代わりに使用されます。  
  
   
  
## Examples  
 次の例では、使用、<xref:System.String.Concat%2A>メソッドを<xref:System.String>配列。  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しています。</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">連結する最初のオブジェクト。</param>
        <param name="arg1">連結する 2 番目のオブジェクト。</param>
        <summary>指定した 2 つのオブジェクトの文字列形式を連結します。</summary>
        <returns>
          <paramref name="arg0" /> および <paramref name="arg1" /> の値の文字列形式を連結した結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドを連結します`arg0`と`arg1`パラメーターなしで呼び出すことによって`ToString`メソッドの`arg0`と`arg1`; 任意の区切り記号は追加されません。  
  
 <xref:System.String.Empty?displayProperty=nameWithType> null 引数の代わりに使用されます。  
  
 場合か、引数の配列参照は、メソッドは、そのメンバー (たとえば、"System.String[]") 代わりに、その配列を表す文字列を連結します。  
  
   
  
## Examples  
 次の例で、<xref:System.String.Concat%2A>メソッド。  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の文字列。</param>
        <param name="str1">連結する 2 番目の文字列。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> インスタンスを連結します。</summary>
        <returns>
          <paramref name="str0" /> と <paramref name="str1" /> の連結。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドを連結します`str0`と`str1`; 任意の区切り記号は追加されません。  
  
> [!NOTE]
>  など、言語の文字列の連結演算子を使用することもできます`+`で c# の場合、または`&`と`+`Visual basic)。  
>   
>  、文字列を連結します。  
  
 <xref:System.String.Empty>文字列が null のいずれかの引数の代わりに使用されます。  
  
   
  
## Examples  
 次の例では、人名、ミドル ネーム、および姓の名前を連結します。  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">連結する最初のオブジェクト。</param>
        <param name="arg1">連結する 2 番目のオブジェクト。</param>
        <param name="arg2">連結する 3 番目のオブジェクト。</param>
        <summary>指定した 3 つのオブジェクトの文字列形式を連結します。</summary>
        <returns>
          <paramref name="arg0" />、<paramref name="arg1" /> および <paramref name="arg2" /> の値の文字列形式を連結した結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドを連結します`arg0`、 `arg1`、および`arg2`パラメーターなしで呼び出すことによって`ToString`; 各オブジェクトの任意の区切り記号は追加されません。  
  
 <xref:System.String.Empty?displayProperty=nameWithType> null 引数の代わりに使用されます。  
  
   
  
## Examples  
 次の例で、<xref:System.String.Concat%2A>メソッド。  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の文字列。</param>
        <param name="str1">連結する 2 番目の文字列。</param>
        <param name="str2">連結する 3 番目の文字列。</param>
        <summary>
          <see cref="T:System.String" /> の指定した 3 つのインスタンスを連結します。</summary>
        <returns>
          <paramref name="str0" />、<paramref name="str1" />、および <paramref name="str2" /> の連結。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドを連結します`str0`、 `str1`、および`str2`; 任意の区切り記号は追加されません。  
  
> [!NOTE]
>  など、言語の文字列の連結演算子を使用することもできます`+`で c# の場合、または`&`と`+`Visual basic)。  
>   
>  、文字列を連結します。  
  
 <xref:System.String.Empty>文字列が null のいずれかの引数の代わりに使用されます。  
  
   
  
## Examples  
 次の例では、<xref:System.String.Concat%2A>メソッドを連結する 3 つの文字列し、結果が表示されます。  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">連結する最初のオブジェクト。</param>
        <param name="arg1">連結する 2 番目のオブジェクト。</param>
        <param name="arg2">連結する 3 番目のオブジェクト。</param>
        <param name="arg3">連結する 4 番目のオブジェクト。</param>
        <summary>4 つの指定したオブジェクトと、オプションの可変長パラメーター リストで指定した任意のオブジェクトの文字列表現を連結します。</summary>
        <returns>パラメーター リスト内の各値の文字列を連結した結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  この API は、CLS に準拠していません。 CLS 準拠の代わりとして <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType> を使用できます。 C# および Visual Basic のコンパイラへの呼び出しとして、このメソッドの呼び出しを自動的に解決<xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>します。  
  
 メソッドのパラメーターなしで呼び出すことによって、パラメーター リスト内の各オブジェクトを連結します`ToString`メソッド; 任意の区切り記号は追加されません。  
  
 <xref:System.String.Empty?displayProperty=nameWithType> null 引数の代わりに使用されます。  
  
> [!NOTE]
>  最後のパラメーター、<xref:System.String.Concat%2A>メソッドは連結する追加のオブジェクトを 1 つまたは複数の省略可能なコンマ区切りのリスト。  
  
   
  
## Examples  
 次の例では、使用、<xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>変数のパラメーターのリストを連結するメソッド。 この場合、9 個のパラメーターでメソッドが呼び出されます。  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>このメソッドが設定されて、<see langword="vararg" />キーワードで、可変個のパラメーターをサポートしていることを意味します。 Visual C からメソッドを呼び出すことができますが、c# または Visual Basic コードから呼び出せることはできません。 C# および Visual Basic のコンパイラへの呼び出しを解決する<see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />呼び出しとして<see cref="M:System.String.Concat(System.Object[])" />します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">連結する最初の文字列。</param>
        <param name="str1">連結する 2 番目の文字列。</param>
        <param name="str2">連結する 3 番目の文字列。</param>
        <param name="str3">連結する 4 番目の文字列。</param>
        <summary>指定した 4 つの <see cref="T:System.String" /> インスタンスを連結します。</summary>
        <returns>
          <paramref name="str0" />、<paramref name="str1" />、<paramref name="str2" />、および <paramref name="str3" /> の連結。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドを連結します`str0`、 `str1`、 `str2`、および`str3`; 任意の区切り記号は追加されません。  
  
> [!NOTE]
>  など、言語の文字列の連結演算子を使用することもできます`+`で c# の場合、または`&`と`+`Visual basic)。  
>   
>  、文字列を連結します。  
  
 <xref:System.String.Empty>文字列は、配列内の任意の null オブジェクトの代わりに使用されます。  
  
   
  
## Examples  
 次の例では、4 文字の単語の配列を定義し、それらを暗号化するために、個々 の文字を文字列配列を格納します。 呼び出して、<xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29>スクランブルされた単語を再構成するためのメソッド。  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <paramref name="values" /> のメンバーの型。</typeparam>
        <param name="values">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> インターフェイスを実装するコレクション オブジェクト。</param>
        <summary>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 実装のメンバーを連結します。</summary>
        <returns>
          <paramref name="values" /> 内のメンバーの連結結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド内の各オブジェクトを連結する`values`; 任意の区切り記号は追加されません。  
  
 <xref:System.String.Empty>文字列が null のいずれかの引数の代わりに使用されます。  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 便利なメソッド内の各要素を連結することができますが、<xref:System.Collections.Generic.IEnumerable%601>文字列に要素を変換しなくてもコレクション。 例に示すように、統合言語クエリ (LINQ) のクエリ式で特に便利です。 内の各オブジェクトの文字列表現、<xref:System.Collections.Generic.IEnumerable%601>呼び出して、そのオブジェクトのコレクションは派生`ToString`メソッド。  
  
   
  
## Examples  
 次の例は非常に単純な定義`Animal`animal クラスとが所属する順序の名前を表すクラス。 定義し、<xref:System.Collections.Generic.List%601>の数を格納するオブジェクト`Animal`オブジェクト。 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>を抽出する拡張メソッドが呼び出される、`Animal`オブジェクト`Order`プロパティが「げっ歯類」に等しい。 結果が渡される、<xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッドと、コンソールに表示されます。  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <summary>指定した部分文字列がこの文字列内に存在するかどうかを示す値を返します。</summary>
        <returns>
          <paramref name="value" /> パラメーターがこの文字列内に存在するか、<paramref name="value" /> が空の文字列 ("") の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、序数に基づく (大文字と小文字およびカルチャに依存しない) 比較を実行します。 検索では、この文字列の最初の文字位置から開始し、最後の文字位置にこれを繰り返します。  
  
 序数に基づく比較 (カルチャに依存した比較、大文字と小文字序数など) 以外のものを使用して指定した部分文字列を含む文字列かどうかを判断する、カスタム メソッドを作成することができます。 次の例は、1 つの方法を示しています。 定義、<xref:System.String>拡張メソッドを含む、<xref:System.StringComparison>パラメーターと、文字列では、指定した文字列比較の形式を使用する場合に、部分文字列が含まれるかどうかを示します。  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 次の例を呼び出して、`Contains`序数に基づく比較と大文字の序数に基づく比較を使用する場合に、文字列の部分文字列が見つかったかどうかを判断する拡張メソッド。  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 部分文字列の位置に興味があるかどうかは`value`、現在のインスタンスで呼び出すことができます、 <xref:System.String.IndexOf%2A> 、最初に見つかった、またはの開始位置を取得するメソッドを呼び出すことができます、<xref:System.String.LastIndexOf%2A>の開始を取得するメソッドを配置、最後に出現します。 例への呼び出しが含まれています、<xref:System.String.IndexOf%28System.String%29>メソッド文字列インスタンスで部分文字列が見つかった場合します。  
  
   
  
## Examples  
 次の例"について fox"という文字列が使い慣れた引用符の部分文字列であるかどうかを判断します。 "Fox"文字列が見つかった場合も、開始位置を表示します。  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">コピーする文字列。</param>
        <summary>指定した <see cref="T:System.String" /> と同じ値を使用して、<see cref="T:System.String" /> の新しいインスタンスを作成します。</summary>
        <returns>
          <paramref name="str" /> と同じ値を持つ新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Copy%2A>メソッドを返します。 を<xref:System.String>オブジェクトを、元の文字列と同じ値が別のオブジェクトの参照を表します。 他のオブジェクトを変数への既存の文字列参照に割り当てる代入演算とは異なります。 この例では、違いを示します。  
  
   
  
## Examples  
 次の例では、値が異なる 2 つの文字列オブジェクトを作成します。 呼び出し時に、 <xref:System.String.Copy%2A> 2 番目の文字列を最初の値を割り当てるメソッドを出力は、その値と等しくなっていますが、文字列が別のオブジェクト参照を表すことを示します。 その一方で、最初の文字列が 2 番目の文字列に割り当てられると、2 つの文字列値を持つ同じ、同じオブジェクト参照を表すため。  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">コピーする、このインスタンス内の最初の文字のインデックス。</param>
        <param name="destination">このインスタンスの文字のコピー先となる Unicode 文字の配列。</param>
        <param name="destinationIndex">コピー操作を開始する <paramref name="destination" /> のインデックス。</param>
        <param name="count">
          <paramref name="destination" /> へコピーされるこのインスタンスの文字の数。</param>
        <summary>このインスタンスの指定位置から指定した数の文字を、Unicode 文字の配列内の指定位置へコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コピー`count`文字を`sourceIndex`とこのインスタンスの位置、`destinationIndex`の位置`destination`文字配列。 このメソッドがサイズ変更されない、`destination`文字配列。 十分な数の要素にコピーされた文字を対応する必要がありますまたはメソッドがスローされます、<xref:System.ArgumentOutOfRangeException>します。  
  
 `sourceIndex` `destinationIndex`は 0 から始まります。  
  
   
  
## Examples  
 次の例で、<xref:System.String.CopyTo%2A>メソッド。  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />、<paramref name="destinationIndex" />、または <paramref name="count" /> が負の値です。 
- または - 
 <paramref name="sourceIndex" /> が現在のインスタンス内の位置を識別していません。  
  
- または - 
 <paramref name="destinationIndex" /> が、<paramref name="destination" /> 配列内の有効なインデックスを識別していません。  
  
- または - 
 <paramref name="count" /> は、このインスタンスの <paramref name="sourceIndex" /> から末尾までの部分文字列の長さを超えています。 
- または - 
 <paramref name="count" /> は、<paramref name="destination" /> 配列の <paramref name="destinationIndex" /> から末尾までの部分配列の長さを超えています。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>空の文字列を表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィールドの値が長さ 0 の文字列""です。  
  
 アプリケーション コードでは、このフィールドは割り当てで空の文字列に文字列変数を初期化するために最もよく使用します。 文字列の値がいずれかであるかどうかをテストする`null`または<xref:System.String.Empty?displayProperty=nameWithType>を使用して、<xref:System.String.IsNullOrEmpty%2A>メソッド。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列インスタンスの末尾が、指定した文字列と一致するかどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスの末尾の部分文字列と比較する文字列。</param>
        <summary>この文字列インスタンスの末尾が、指定した文字列と一致するかどうかを判断します。</summary>
        <returns>このインスタンスの末尾が <paramref name="value" /> と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは比較`value`と同じ長さであるこのインスタンスの末尾に部分文字列`value`、それらが等しいかどうか示す値を返します。 等しく、`value`この同じインスタンスへの参照またはこのインスタンスの末尾と一致する必要があります。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字小文字を区別し、カルチャに依存) 比較を実行します。  
  
   
  
## Examples  
 次の例では、配列内の各文字列がピリオドで終わるかどうかを示します (".")。  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 次の例では、定義、`StripEndTags`メソッドを使用する、<xref:System.String.EndsWith%28System.String%29>行の末尾からの HTML 終了タグを削除する方法。 なお、`StripEndTags`メソッドには、行の最後に、複数の HTML 終了タグが削除されるようにするには、再帰的には呼び出されます。  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>説明したよう[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)既定値を代入しを明示的に指定するパラメーターを必要とするメソッドを呼び出す代わりに文字列比較メソッドを呼び出さないようにすることをお勧めします。 文字列が現在のカルチャの文字列比較の規則を使用して、特定の部分文字列で終わるかどうかを確認するのには、呼び出し、<see cref="M:System.String.EndsWith(System.String,System.StringComparison)" />メソッドのオーバー ロードの値を持つ<see cref="F:System.StringComparison.CurrentCulture" />の<paramref name="comparisonType" />パラメーター。</para>
        </block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスの末尾の部分文字列と比較する文字列。</param>
        <param name="comparisonType">この文字列と <paramref name="value" /> との比較方法を決定する列挙値の 1 つ。</param>
        <summary>指定された比較オプションを使って比較した場合に、この文字列インスタンスの末尾が、指定された文字列と一致するかどうかを判断します。</summary>
        <returns>
          <paramref name="value" /> パラメーターがこの文字列の末尾と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.EndsWith%2A>メソッドの比較、`value`この文字列の末尾の部分文字列のパラメーターが等しいかどうかを示す値を返します。 等しく、`value`この同じ文字列への参照である必要があります、空の文字列にする必要があります ("")、またはこの文字列の末尾に一致する必要があります。 によって実行される比較の種類、<xref:System.String.EndsWith%2A>メソッドの値によって異なります、`comparisonType`パラメーター。  
  
   
  
## Examples  
 次の例では、文字列が特定の部分文字列で終わるかどうかを判断します。 結果は、カルチャ、ケースが無視されるかどうか、および序数の比較を実行するかどうかの選択肢の影響を受けます。  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスの末尾の部分文字列と比較する文字列。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="culture">このインスタンスと <paramref name="value" /> との比較方法を決定するカルチャ情報。 <paramref name="culture" /> が <see langword="null" /> の場合は、現在のカルチャが使用されます。</param>
        <summary>指定されたカルチャを使って比較した場合に、この文字列インスタンスの末尾が、指定された文字列と一致するかどうかを判断します。</summary>
        <returns>
          <paramref name="value" /> パラメーターがこの文字列の末尾と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは比較、`value`パラメーターと同じ長さであるこの文字列の末尾の部分文字列を`value`、し、それらが等しいかどうかを示す値を返します。 等しく、`value`この同じインスタンスへの参照またはこの文字列の末尾と一致する必要があります。  
  
 このメソッドは、指定した大文字小文字の区別とカルチャを使用して、word (カルチャ) 比較を実行します。  
  
   
  
## Examples  
 次の例では、文字列が別の文字列の最後に発生したかどうかを判断します。 <xref:System.String.EndsWith%2A>大文字小文字の区別、大文字小文字の区別、および検索の結果に影響する異なるカルチャを使用していくつかのメソッドが呼び出されます。  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>2 つの <see cref="T:System.String" /> オブジェクトの値が同一かどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">このインスタンスと比較する文字列。</param>
        <summary>このインスタンスと、指定したオブジェクトの値が同一かどうかを判断します。<see cref="T:System.String" /> オブジェクトを指定する必要があります。</summary>
        <returns>
          <see langword="true" /> が <paramref name="obj" /> で、このインスタンスと同じ値を保持している場合は <see cref="T:System.String" />。それ以外の場合は <see langword="false" />。  <paramref name="obj" /> が <see langword="null" /> の場合、メソッドは <see langword="false" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、序数に基づく (大文字と小文字およびカルチャに依存しない) 比較を実行します。  
  
   
  
## Examples  
 次の例で、<xref:System.String.Equals%2A>メソッド。  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスと比較する文字列。</param>
        <summary>このインスタンスと、指定した別の <see cref="T:System.String" /> の値が同一かどうかを判断します。</summary>
        <returns>
          <see langword="true" /> パラメーターの値がこのインスタンスの値と同じ場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。 <paramref name="value" /> が <see langword="null" /> の場合、メソッドは <see langword="false" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、序数に基づく (大文字と小文字およびカルチャに依存しない) 比較を実行します。  
  
   
  
## Examples  
 次の例で、<xref:System.String.Equals%2A>メソッド。同等の用語を等価な小文字、等価な大文字、および単語 LATIN 小さな文字ドット I が含まれていますを持つタイトル大文字と小文字の単語"File"と比較します (U + 0131) ではなくラテン小さな文字 I (u+0069)。 <xref:System.String.Equals%28System.String%29>メソッドは、序数に基づく比較を実行、同一の単語との比較だけを返します`true`します。  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">比較する最初の文字列または <see langword="null" />。</param>
        <param name="b">比較する 2 番目の文字列または <see langword="null" />。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの値が同一かどうかを判断します。</summary>
        <returns>
          <paramref name="a" /> の値が <paramref name="b" /> の値と同じ場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 <paramref name="a" /> と <paramref name="b" /> の両方が <see langword="null" /> の場合、メソッドは <see langword="true" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、序数に基づく (大文字と小文字およびカルチャに依存しない) 比較を実行します。  
  
   
  
## Examples  
 次の例で、<xref:System.String.Equals%2A>メソッド。  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスと比較する文字列。</param>
        <param name="comparisonType">文字列の比較方法を指定する列挙値の 1 つ。</param>
        <summary>この文字列と、指定した <see cref="T:System.String" /> オブジェクトの値が同一かどうかを判断します。 比較に使用するカルチャ、大文字と小文字の区別、および、並べ替え規則をパラメーターで指定します。</summary>
        <returns>
          <see langword="true" /> パラメーターの値がこの文字列と同じ場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType`パラメーターは、比較では、現在またはインバリアント カルチャを使用する必要があります、かどうかを優先または比較対象となる 2 つの文字列の大文字と小文字を無視または word または序数の並べ替え規則を使用して、ことを示します。  
  
   
  
## Examples  
 次の例では、"I"、"i"小文字およびドットなしの「ı」の大文字で構成される文字列配列を作成します。 呼び出して、<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>可能性のある各を使用して比較するためのメソッド<xref:System.StringComparison>列挙値。  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 次の例では、4 つの単語のセットを比較の各メンバーを使用して、<xref:System.StringComparison>列挙体。  比較では、英語 (米国) とサーミ語 (上限スウェーデン) カルチャの規則を使用します。 文字列"encyclopædia"と「百科事典」が相当 Sami (北スウェーデン) カルチャではなく、EN-US カルチャで見なされますに注意してください。  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a">比較する最初の文字列または <see langword="null" />。</param>
        <param name="b">比較する 2 番目の文字列または <see langword="null" />。</param>
        <param name="comparisonType">比較の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した 2 つの <see cref="T:System.String" /> オブジェクトの値が同一かどうかを判断します。 比較に使用するカルチャ、大文字と小文字の区別、および、並べ替え規則をパラメーターで指定します。</summary>
        <returns>
          <see langword="true" /> パラメーターの値が <paramref name="a" /> パラメーターの値に等しい場合は <paramref name="b" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType`パラメーターは、比較では、現在またはインバリアント カルチャを使用する必要があります、かどうかを優先または比較対象となる 2 つの文字列の大文字と小文字を無視または word または序数の並べ替え規則を使用して、ことを示します。  
  
   
  
## Examples  
 次の例では、4 つの単語のセットを比較の各メンバーを使用して、<xref:System.StringComparison>列挙体。  比較では、英語 (米国) とサーミ語 (上限スウェーデン) カルチャの規則を使用します。 文字列"encyclopædia"と「百科事典」が相当 Sami (北スウェーデン) カルチャではなく、EN-US カルチャで見なされますに注意してください。  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された形式に基づいてオブジェクトの値を文字列に変換し、別の文字列に挿入します。  
  
`String.Format` メソッドを初めて使用する場合は、「[Get started with the String.Format method](#Starting)」(String.Format メソッドの概要) セクションを参照して、概要をご確認ください。  
  
`String.Format` メソッドの全般的な説明については、「[Remarks](#remarks-top)」 (解説) セクションを参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 このセクションの内容:  
  
 [String.Format メソッドを概要します。](#Starting)   
 [どのメソッドが呼び出しですか。](#FTaskList)   
 [Format メソッドの概要](#Format_Brief)   
 [書式指定項目](#FormatItem)   
 [引数の書式設定方法](#HowFormatted)   
 [インデックスが同じである書式指定項目](#SameIndex)   
 [書式とカルチャ](#Format_Culture)   
 [カスタムの書式設定操作](#Format_Custom)   
 [String.Format の Q & A](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>String.Format メソッドを概要します。  
 使用<xref:System.String.Format%2A?displayProperty=nameWithType>オブジェクト、変数、または式の値を別の文字列に挿入する必要がある場合。 値を挿入するなど、<xref:System.Decimal>に 1 つの文字列としてユーザーに表示する文字列値。  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 その値の書式を制御できます。  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 書式設定、だけでなく、配置と間隔も制御できます。  
  
 ### <a name="inserting-a-string"></a>文字列を挿入します。  

 <xref:System.String.Format%2A?displayProperty=nameWithType> 1 つ以上のオブジェクトまたは文字列に変換および書式指定文字列で指定された位置に挿入される式を続けて、書式指定文字列で始まります。 例:  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 `{0}`形式の文字列が書式指定項目。 `0` 文字列値を持つはその位置に挿入するオブジェクトのインデックスです。 (インデックスは 0 から始まる)。挿入されるオブジェクトが、文字列ではない場合、`ToString`結果の文字列に挿入する前にいずれかに変換するメソッドが呼び出されます。  
  
 オブジェクトの一覧で、2 つの書式指定項目と 2 つのオブジェクトを使用する別の例を次に示します。  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 多くの書式項目があることができ、に多くのオブジェクトとオブジェクトの一覧で、すべての書式指定項目のインデックスは、オブジェクトの一覧で一致するオブジェクトを持つ限り。 する必要はありません心配についてどのオーバー ロードを呼び出します。コンパイラは、適切な人を選択します。  
  
 ### <a name="controlling-formatting"></a>書式設定を制御します。  
 オブジェクトの書式設定方法を制御する書式指定文字列に書式指定項目のインデックスに従うことができます。 たとえば、 `{0:d}` "d"書式指定文字列をオブジェクトの一覧の最初のオブジェクトに適用されます。 1 つのオブジェクトの例を次に示し、2 つの項目の書式設定。  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 書式指定文字列、すべての数値型などのさまざまな型のサポート (両方[標準](~/docs/standard/base-types/standard-numeric-format-strings.md)と[カスタム](~/docs/standard/base-types/custom-numeric-format-strings.md)書式指定文字列)、すべての日付と時刻 (両方[標準](~/docs/standard/base-types/standard-date-and-time-format-strings.md)と[カスタム](~/docs/standard/base-types/custom-date-and-time-format-strings.md)書式指定文字列) と時間間隔 (両方[標準](~/docs/standard/base-types/standard-timespan-format-strings.md)と[カスタム](~/docs/standard/base-types/custom-timespan-format-strings.md)書式指定文字列)、すべての列挙型[列挙型](~/docs/standard/base-types/enumeration-format-strings.md)、および[Guid](https://msdn.microsoft.com/library/97af8hh4.aspx)します。 独自の型を書式指定文字列のサポートを追加することもできます。  
  
 ### <a name="controlling-spacing"></a>間隔を制御します。  
 などの構文を使用して、結果の文字列に挿入する文字列の幅を定義する`{0,12}`、12 文字の文字列が挿入されます。 この場合、最初のオブジェクトの文字列表現は右揃えで 12 文字のフィールドです。  (最初のオブジェクトの文字列表現が 12 以上の文字の場合は、ただし推奨されるフィールドの幅は無視され、文字列全体が、結果の文字列に挿入されます。)  
  
 次の例は、文字列を保持するために 6 文字のフィールドを定義"Year"と年の一部の文字列だけでなく、15 文字のフィールド"Population"文字列を保持するために、いくつかの人口データ。 文字が右揃え フィールドに注意してください。  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>配置を制御します。  
 既定では、文字列は、フィールド内で右揃えのフィールド幅を指定する場合です。 フィールド内の文字列を左揃えにするが付いて、負の符号でフィールドの幅など`{0,-12}`12 文字の左揃えのフィールドを定義します。  
  
 次の例は、点が異なりますが左揃えのラベルとデータの両方には、前に似ています。  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType> 複合書式指定機能を利用します。 詳細については、「[複合書式指定](~/docs/standard/base-types/composite-formatting.md)」をご覧ください。  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>どのメソッドが呼び出しですか。  
  
|終了|Call|  
|--------|----------|  
|現在のカルチャの規則を使用して 1 つまたは複数のオブジェクトの書式設定します。|含むオーバー ロードを除く、`provider`パラメーター、残りの<xref:System.String.Format%2A>オーバー ロードが含まれて、<xref:System.String>パラメーターの後に 1 つまたは複数のオブジェクトのパラメーター。 このため、決定する必要はありません<xref:System.String.Format%2A>オーバー ロードを呼び出そうとします。 ないオーバー ロードの中から適切なオーバー ロードを選択する、言語コンパイラを`provider`引数一覧に基づいて、パラメーター。 たとえば、引数リストに 5 つの引数がある場合は、コンパイラは、<xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>メソッド。|  
|特定のカルチャの規則を使用して 1 つまたは複数のオブジェクトの書式設定します。|各<xref:System.String.Format%2A>オーバー ロードで始まる、`provider`パラメーターが続く、<xref:System.String>パラメーターと 1 つ以上のパラメーターのオブジェクトします。 このため、対象となるを決定する必要はありません<xref:System.String.Format%2A>オーバー ロードを呼び出そうとします。 言語のコンパイラがオーバー ロードの中から適切なオーバー ロードを選択する、`provider`引数一覧に基づいて、パラメーター。 たとえば、引数リストに 5 つの引数がある場合は、コンパイラは、<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>メソッド。|  
|いずれかで、カスタムの書式設定操作の実行、<xref:System.ICustomFormatter>実装または<xref:System.IFormattable>実装します。|持つ 4 つのオーバー ロードのいずれかを`provider`パラメーター。 コンパイラがオーバー ロードの中から適切なオーバー ロードを選択する、`provider`引数リストに基づくパラメーター。|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>Format メソッドの概要 

 各オーバー ロード、<xref:System.String.Format%2A>メソッドは、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)と呼ばれる 0 から始まるプレース ホルダーのインデックスを含める*アイテムの書式*、複合書式指定文字列。 実行時に、各書式項目は、パラメーター リスト内の対応する引数の文字列形式に置き換えられます。 引数の値が場合`null`、書式指定項目が置き換え<xref:System.String.Empty?displayProperty=nameWithType>します。 たとえば、次の呼び出し、<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>メソッドには、次の 3 つの書式項目を含む書式指定文字列が含まれています。 {0}、 {1}、および{2}、および引数リストを 3 つの項目。  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>書式指定項目  
 書式指定項目では、この構文があります。  
  
```  
{index[,alignment][:formatString]}  
```  
 
 角かっこは省略可能な要素を表します。 開始タグと右中かっこが必要です。 (を含めることが、リテラルの開く、閉じる、書式指定文字列に中かっこを参照してください、[エスケープ中かっこ](~/docs/standard/base-types/composite-formatting.md#escaping-braces)セクション、[複合書式指定](~/docs/standard/base-types/composite-formatting.md)記事です)。  
  
 たとえば、次のように通貨値の書式設定の書式指定項目が表示されます。  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 書式指定項目には、次の要素があります。  
  
 *index*  
 文字列を表現する場合は、引数の 0 から始まるインデックス、文字列内のこの位置に含まれています。 場合、この引数は`null`、空の文字列は、文字列のこの位置で含まれるなります。  
  
 *alignment*  
 任意。 引数を挿入するかどうかは右揃え (正の整数) か、(負の整数) を左揃えのフィールドの長さの合計を示す符号付き整数。 省略した場合*配置*、先頭または末尾のスペースなしのフィールドに対応する引数の文字列表現が挿入されます。  
  
 場合の値*配置*が挿入される引数の長さより小さい*配置*は無視されます、引数の文字列表現の長さは、フィールドの幅として使用されます。  
  
 *formatString*  
 任意。 対応する引数の結果の文字列の形式を指定する文字列。 省略した場合*formatString*、対応する引数のパラメーターなし`ToString`文字列表現を生成するためにメソッドが呼び出されます。 指定した場合*formatString*、書式指定項目によって参照される引数を実装する必要があります、<xref:System.IFormattable>インターフェイス。 書式指定文字列をサポートする型は次のとおりです。  
  
-   すべての整数と浮動小数点型。 (を参照してください[標準数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)と[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md))。  
  
-   <xref:System.DateTime> および <xref:System.DateTimeOffset>。 (を参照してください[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)と[カスタム日付/時刻の書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md))。  
  
-   すべての列挙型。 (を参照してください[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md))。  
  
-   <xref:System.TimeSpan> 値。 (を参照してください[標準の TimeSpan 書式指定文字列](~/docs/standard/base-types/standard-timespan-format-strings.md)と[カスタム TimeSpan 書式指定文字列](~/docs/standard/base-types/custom-timespan-format-strings.md))。  
  
-   GUID。 (を参照してください、<xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType>メソッドです)。  
  
 ただし、任意のカスタム型を実装できることに注意してください<xref:System.IFormattable>既存の型の拡張または<xref:System.IFormattable>実装します。  
  
 次の例では、`alignment`と`formatString`引数を書式設定された出力を生成します。  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>引数の書式設定方法  
 書式項目は、文字列の先頭から順番に処理されます。 各書式指定項目には、メソッドの引数リスト内のオブジェクトに対応するインデックスがあります。 <xref:System.String.Format%2A>メソッドは引数を取得し、その文字列形式を次のように派生します。  
  
-   引数の場合`null`、挿入<xref:System.String.Empty?displayProperty=nameWithType>結果文字列にします。 処理を考慮する必要はありません、 <xref:System.NullReferenceException> null 引数。 
  
-   呼び出す場合、<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>オーバー ロードと`provider`オブジェクトの<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>実装は、null 以外の値を返します<xref:System.ICustomFormatter>の実装に渡される引数、その<xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッド。 書式指定項目が含まれている場合、 *formatString*引数として渡される最初の引数をメソッドにします。 場合、<xref:System.ICustomFormatter>実装があるし、null 以外の文字列引数の文字列表現として返される文字列が生成されます。 それ以外の場合、次の手順を実行します。  
  
-   引数が実装されている場合、<xref:System.IFormattable>インターフェイス、その<xref:System.IFormattable.ToString%2A?displayProperty=nameWithType>実装が呼び出されます。  
  
-   引数のパラメーターなし`ToString`オーバーライドまたは基底クラスの実装から継承、メソッドが呼び出されます。  
  
 呼び出しをインターセプトする例については、<xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType>メソッドを使用すると、どのような情報を参照してくださいと、<xref:System.String.Format%2A>メソッドが、複合書式指定文字列の各書式項目の書式指定メソッドに渡すを参照してください[例: 切片プロバイダーとローマ数字フォーマッタ](#Format7_Example)します。  

 詳細については、次を参照してください。、[処理順序](~/docs/standard/base-types/composite-formatting.md##processing-order)セクション、[複合書式指定](~/docs/standard/base-types/composite-formatting.md)記事。  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>インデックスが同じである書式指定項目  
 <xref:System.String.Format%2A>メソッドがスローされます、<xref:System.FormatException>インデックス項目のインデックスがより大きいか、引数リストの引数の値に等しい場合は例外です。 ただし、`format`同じインデックスを複数の書式項目がある限り、引数があるほど、多くの書式項目を含めることができます。 呼び出しで、<xref:System.String.Format%28System.String%2CSystem.Object%29>次の例では、引数リスト内のメソッドが 1 つの引数が書式指定文字列に 2 つの書式項目が含まれています: 10 進値、数値のいずれかが表示されますおよび他の 16 進値が表示されます。  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>書式とカルチャ  
 によって返される現在のカルチャの規則を使用して、引数リスト内のオブジェクトをその文字列表現に変換されます一般に、<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>プロパティ。 いずれかのオーバー ロードを呼び出すことによって、この動作を制御できます<xref:System.String.Format%2A>を含む、`provider`パラメーター。 `provider`パラメーターは、<xref:System.IFormatProvider>中程度の書式設定に使用されるカスタムおよびカルチャ固有の書式設定情報を提供する実装を処理します。  
  
 <xref:System.IFormatProvider>インターフェイスが 1 つのメンバー、 <xref:System.IFormatProvider.GetFormat%2A>、これは書式設定情報を提供するオブジェクトを取得する責任を負います。 .NET には 3 つ<xref:System.IFormatProvider>カルチャに固有の書式を提供する実装。  
  
-   <xref:System.Globalization.CultureInfo>。 その<xref:System.Globalization.CultureInfo.GetFormat%2A>メソッドは、特定のカルチャを返します<xref:System.Globalization.NumberFormatInfo>数値およびカルチャ固有の書式設定オブジェクト<xref:System.Globalization.DateTimeFormatInfo>の日付と時刻の値を書式設定オブジェクト。  
  
-   <xref:System.Globalization.DateTimeFormatInfo>、日付と時刻の値のカルチャに固有の書式設定に使用されます。 その<xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A>メソッドでは、それ自体を返します。  
  
-   <xref:System.Globalization.NumberFormatInfo>、数値のカルチャに固有の書式設定に使用されます。 その<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>プロパティには、それ自体を返します。 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>カスタムの書式設定操作  
 いずれかのオーバー ロードを呼び出すことができます、<xref:System.String.Format%2A>メソッドを持つ、`provider`型のパラメーター<xref:System.IFormatProvider>カスタムの書式設定操作を実行します。 たとえば、id 番号、または電話番号として整数をフォーマットする可能性があります。 カスタム書式設定を実行する、`provider`引数は、両方を実装する必要があります、<xref:System.IFormatProvider>と<xref:System.ICustomFormatter>インターフェイス。 ときに、<xref:System.String.Format%2A>メソッドに渡されます、<xref:System.ICustomFormatter>実装として、`provider`引数、<xref:System.String.Format%2A>メソッドの呼び出し、<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>実装型のオブジェクトを要求して<xref:System.ICustomFormatter>。 呼び出して、返された<xref:System.ICustomFormatter>オブジェクトの<xref:System.ICustomFormatter.Format%2A>する複合文字列の各書式項目の書式設定メソッドに渡されます。  
  
 カスタムの書式設定ソリューションを提供する詳細については、次を参照してください。[方法: 定義と使用のカスタム数値書式プロバイダー](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md)と<xref:System.ICustomFormatter>します。 カスタム番号の書式設定された整数に変換する例について、次を参照してください。[例: カスタムの書式設定操作](#Format6_Example)します。 符号なしバイトをローマ数字に変換する例について、次を参照してください。[例:、切片プロバイダーおよびフォーマッタのローマ数字](#Format7_Example)します。  
  
<a name="Format6_Example"></a>   
### <a name="example-a-custom-formatting-operation"></a>例: カスタム書式設定操作  
 この例では、フォーム x-xxxxx-xx で顧客アカウント番号として整数値を書式設定する書式プロバイダーを定義します。  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example"></a>   
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>例: 切片プロバイダーおよびフォーマッタのローマ数字  
 この例では、実装するカスタム書式プロバイダーを定義します。、<xref:System.ICustomFormatter>と<xref:System.IFormatProvider>インターフェイスを 2 つの操作を行います。  
  
-   渡されるパラメーターが表示されます、<xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType>実装します。 これにより、どのようなパラメーターを表示する動き、<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>メソッドは書式を設定しようとするオブジェクトごとにカスタムの書式設定の実装に渡します。 これは、アプリケーションをデバッグするときに役立ちます。  
  
-   書式設定するオブジェクトが"R"標準書式指定文字列を使用して書式設定される符号なしバイト値の場合は、カスタム フォーマッタ ローマ数字として、数値の書式設定します。  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>String.Format の Q & A  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>なぜ文字列補間を呼び出し、`String.Format`メソッドでしょうか。

文字列補間は。

- 柔軟です。 これは、複合書式指定をサポートするメソッドの呼び出しを必要とせず任意の文字列で使用できます。 呼び出す必要が、それ以外の場合、<xref:System.String.Format%2A>メソッドまたは別のメソッドなどの複合書式指定をサポートする<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>または<xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>します。 

- 読みやすくします。 式を文字列に挿入するには、引数リストではなく、挿入式が表示されたらため、補間文字列はコードとコードを読み取るにははるかに簡単です。 大きいの読みやすさのため挿入文字列は、複合書式指定メソッドを呼び出すだけでなくを置き換えることができますが、文字列連結操作で使用してより簡潔でわかりやすいコードを生成することができますもします。 

次の 2 つのコード例の比較では、文字列の連結と複合書式指定メソッドの呼び出しを挿入文字列の上の優位性を示しています。 次の例では、複数の文字列連結操作の使用には、冗長で読みハード コードが生成されます。

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

これに対し、次の例で挿入文字列の使用が文字列の連結ステートメントとへの呼び出しよりもはるかにわかりやすくより簡潔なコードを生成、<xref:System.String.Format%2A>前の例のメソッド。

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>書式指定項目で使用できる定義済み書式指定文字列の一覧はどこで確認できますか。  
  
-   すべての整数と浮動小数点型を参照してください。 [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md)と[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)します。  
  
-   日付と時刻の値を参照してください。 [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md)と[Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md)します。  
  
-   列挙値の場合は、次を参照してください。[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)します。  
  
-   <xref:System.TimeSpan>値を参照してください[標準 TimeSpan 書式指定文字列](~/docs/standard/base-types/standard-timespan-format-strings.md)と[カスタム TimeSpan 書式指定文字列](~/docs/standard/base-types/custom-timespan-format-strings.md)します。  
  
-   <xref:System.Guid> 、値の「解説」を参照してください、<xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType>リファレンス ページです。  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>書式項目を置換する結果文字列の配置を制御する方法は?  
 書式指定項目の一般的な構文です。  
  
```  
{index[,alignment][: formatString]}  
```  
  
 場所*配置*フィールドの幅を定義する符号付き整数します。 この値が負の場合は、フィールド内のテキストは左揃えです。 正の場合は、テキストは右揃えです。  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>小数点区切り文字の後の桁数が制御する方法  
 すべて[標準数値書式指定文字列](~/docs/standard/base-types/standard-numeric-format-strings.md)"D"(これは、整数のみを使用)、"G"、"R"を除くし、"X"は、結果の文字列の小数点以下桁数を定義する有効桁数指定子を許可します。 次の例では、標準数値書式指定文字列を使用して、結果の文字列の 10 進数字の数を制御します。  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 使用している場合、[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)結果の文字列で、次の例の 10 進数字の数を制御する、「0」書式指定子を使用します。  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>整数の桁の数を制御する方法は?  
 既定では、書式設定操作は 0 以外の整数の桁のみを表示します。 整数の書式を設定する場合は、以下の桁数を制御するため、精度指定子"D"と"X"標準書式指定文字列を使用できます。  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 「0」を使用して整数の桁の数を指定して結果の文字列を生成するために、整数または浮動小数点数に先行するゼロを埋め込む[カスタム数値書式指定子](~/docs/standard/base-types/custom-numeric-format-strings.md)、次の例に示すようにします。  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>形式の一覧で項目の数を含めることができますか。  
 事実上制限はありません。 2 番目のパラメーター、<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>メソッドがタグ付け、<xref:System.ParamArrayAttribute>属性には、コンマ区切りのリストか、形式のリストとしてオブジェクトの配列を含めることができます。  
  
<a name="braces"></a>
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>リテラル中かっこを含める方法 ("{"と"}")、結果の文字列のでしょうか。  
 たとえば、どのようにして、次のメソッド呼び出しからスロー、<xref:System.FormatException>例外でしょうか。  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 1 つの開始または右中かっこは、常に先頭または末尾の書式指定項目として解釈されます。 どおりに解釈するのにそれをエスケープする必要があります。 もう 1 つの中かっこを追加することで、かっこをエスケープする ("{{"と"}}"の代わりに"{"と"}")、次のメソッド呼び出しで。  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 ただし、さらにエスケープされた中かっこは簡単に誤ったです。 形式の一覧で中かっこを含めるし、書式項目を使用して、次の例のように、結果文字列に挿入することをお勧めします。  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>String.Format メソッドの呼び出しが、FormatException をスローする理由  
 例外の最も一般的な原因は、書式指定項目のインデックスが、[形式] リスト内のオブジェクトに対応していません。 通常を書式指定項目のインデックスを misnumbered したか、形式の一覧でオブジェクトを含める忘れてしまったことを示します。 文字をエスケープ解除されたの左または右中かっこを含めるしようとしてもがスローされます、<xref:System.FormatException>します。 場合によっては、例外は、入力ミス; の結果たとえば、よくある間違いはミスは"["(左角かっこ) の代わりに"{0}"(左中かっこ)。  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>場合 Format(System.IFormatProvider,System.String,System.Object[]) メソッドでは、理由は、コード例外をスロー配列を使用する場合、パラメーター配列をサポートしていますか。  
 たとえば、次のコードがスローされます、<xref:System.FormatException>例外。  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 これは、コンパイラのオーバー ロードの解決の問題です。 呼び出すために、1 つの引数として、整数の配列を扱いますが、コンパイラでは、整数の配列をオブジェクト配列に変換することはできません、ため、<xref:System.String.Format%28System.String%2CSystem.Object%29>メソッド。 4 つの書式項目が形式の一覧で 1 つの項目のみがあるために、例外がスローされます。  
  
 Visual Basic や c# のどちらで整数の配列をオブジェクト配列に変換できるため、呼び出す前に自分で変換を実行する必要がある、<xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>メソッド。 次の例では、1 つの実装を提供します。  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

呼び出すさまざまな例、<xref:System.String.Format%2A>メソッドが混在してから、[解説](#remarks)この記事のセクション。  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

完全なセットをダウンロードすることもできます`String.Format`例については、に含まれる、 [(C#) または .NET Core 2.0 プロジェクト](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip)と[Visual basic .NET Core 2.0 プロジェクト](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip)、から、 [dotnet/。サンプルの GitHub リポジトリ](https://github.com/dotnet/samples)します。

この記事の例の一部を次に示します。

### <a name="create-a-format-string"></a>書式指定文字列を作成します。

[文字列を挿入します。](#inserting-a-string)  
[書式指定項目](#the-format-item)  
[インデックスが同じである書式指定項目](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>書式設定された出力を制御します。

[書式設定を制御します。](#controlling-formatting)  
[間隔を制御します。](#controlling-spacing)  
[配置を制御します。](#controlling-alignment)  
[整数の桁の数を制御します。](#how-do-i-control-the-number-of-integral-digits)  
[小数点区切り文字の後の桁数を制御します。](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[結果の文字列にリテラル中かっこを含む](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>カルチャに依存する書式指定文字列を作成します。

[カルチャの書式設定](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>書式設定操作をカスタマイズします。

[カスタムの書式設定操作](#example-a-custom-formatting-operation)  
[切片プロバイダーおよびフォーマッタのローマ数字](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">書式指定するオブジェクト。</param>
        <summary>文字列の 1 つ以上の書式項目を、指定されたオブジェクトの文字列表記に置換します。</summary>
        <returns>書式項目が <paramref name="arg0" /> の文字列表記に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドを使用して、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)式の値を文字列表現に変換して、その表現を文字列に埋め込みます。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>例: 1 つの引数を書式設定  
 
 次の例では、<xref:System.String.Format%28System.String%2CSystem.Object%29>文字列の途中で、個人の年齢を埋め込む方法。  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> の書式指定項目が正しくありません。  
  
- または - 
書式項目のインデックスが 0 ではありません。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="args">0 個以上の書式設定対象オブジェクトを含んだオブジェクト配列。</param>
        <summary>指定した文字列の書式項目を、指定した配列内の対応するオブジェクトの文字列形式に置換します。</summary>
        <returns>書式項目が <paramref name="args" /> の対応するオブジェクトの文字列表記に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドを使用して、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)4 つまたは複数の式の値をその文字列表現に変換して、それらの表現を文字列に埋め込みます。 以降、`args`パラメーターをマークするが、<xref:System.ParamArrayAttribute?displayProperty=nameWithType>属性を渡すことができます、オブジェクト メソッドとして、または個々 の引数として、<xref:System.Object>配列。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>例: 複数の 3 つの引数を書式設定  
 
 この例では、特定の日の高値と安値の温度データを格納する文字列を作成します。 複合書式指定文字列には、c# の例の書式項目を 5 と 6 つの Visual Basic の例があります。 、、対応する値の文字列形式の幅を定義の書式項目を、2 つと最初の書式指定項目は、標準の日付と時刻の書式指定文字列も含まれます。  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 配列として書式設定オブジェクトを渡すこともなく、引数リスト。  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> または <paramref name="args" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が無効です。  
  
- または - 
書式項目のインデックスが 0 (ゼロ) 未満か、または <paramref name="args" /> 配列の長さ以上です。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">書式指定するオブジェクト。</param>
        <summary>指定した文字列の 1 つまたは複数の書式項目を、対応するオブジェクトの文字列形式に置換します。 パラメーターにより、カルチャに固有の書式情報が指定されます。</summary>
        <returns>書式項目が <paramref name="arg0" /> の文字列形式に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドを使用して、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)式の値を文字列表現に変換して、その表現を文字列に埋め込みます。 変換を実行するには、カルチャ依存した書式設定またはカスタム フォーマッタを使用します。 メソッドに変換します`arg0`呼び出すことによって文字列表現にその**ToString(IFormatProvider)** メソッド書式項目は、書式指定文字列を呼び出すことによって、オブジェクトの対応する場合や、その**ToString (String, IFormatProvider)** メソッド。 これらのメソッドが存在しない場合は、呼び出し、オブジェクトのパラメーターなし**ToString**メソッド。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が無効です。  
  
- または - 
書式項目のインデックスが 0 ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="args">0 個以上の書式設定対象オブジェクトを含んだオブジェクト配列。</param>
        <summary>文字列の書式項目を、指定した配列内の対応するオブジェクトの文字列表記に置換します。 パラメーターにより、カルチャに固有の書式情報が指定されます。</summary>
        <returns>書式項目が <paramref name="args" /> の対応するオブジェクトの文字列表記に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドを使用して、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)4 つまたは複数の式をその文字列表現に変換して、それらの表現を文字列に埋め込みます。 変換を実行するには、カルチャ依存した書式設定またはカスタム フォーマッタを使用します。 メソッドでは、それぞれに変換します<xref:System.Object>引数を文字列形式を呼び出してその**ToString(IFormatProvider)** メソッドまたは、書式指定項目がそのを呼び出すことによって、書式指定文字列を含む場合は、オブジェクトの対応する**ToString(String,IFormatProvider)** メソッド。 これらのメソッドが存在しない場合は、呼び出し、オブジェクトのパラメーターなし**ToString**メソッド。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a>例: カルチャに依存する書式設定  
 この例では、<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>いくつかの異なるカルチャを使用していくつかの日付と時刻の値と数値の文字列形式を表示するメソッド。  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> または <paramref name="args" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が無効です。  
  
- または - 
書式項目のインデックスが 0 (ゼロ) 未満か、または <paramref name="args" /> 配列の長さ以上です。</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <summary>文字列の書式項目を、指定した 2 つのオブジェクトの文字列形式に置換します。</summary>
        <returns>書式項目が <paramref name="arg0" /> と <paramref name="arg1" /> の文字列形式に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドを使用して、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)とそれらの表現を文字列に埋め込むには 2 つの式の値をその文字列表現に変換します。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>例: 2 つの引数を書式設定  
 
 この例では、<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29>ジェネリックに格納されている時間と温度データを表示するメソッドを<xref:System.Collections.Generic.Dictionary%602>オブジェクト。 書式設定する 2 つのオブジェクトは、書式指定文字列に 3 つの書式指定項目に注意してください。 これは (日付と時刻の値) の一覧の最初のオブジェクトが 2 つの書式指定項目によって使用されるためです。 時間、および 2 つ目は、日付を表示します。 最初の書式項目の表示。  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が無効です。  
  
- または - 
書式項目のインデックスが 0 でも 1 でもありません。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <summary>文字列の書式項目を、指定した 2 つのオブジェクトの文字列形式に置換します。 パラメーターにより、カルチャに固有の書式情報が指定されます。</summary>
        <returns>書式項目が <paramref name="arg0" /> と <paramref name="arg1" /> の文字列形式に置換された <paramref name="format" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドを使用して、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)とそれらの表現を文字列に埋め込むには 2 つの式をその文字列表現に変換します。 変換を実行するには、カルチャ依存した書式設定またはカスタム フォーマッタを使用します。 メソッドでは、それぞれに変換します<xref:System.Object>引数を文字列形式を呼び出してその**ToString(IFormatProvider)** メソッドまたは、書式指定項目がそのを呼び出すことによって、書式指定文字列を含む場合は、オブジェクトの対応する**ToString(String,IFormatProvider)** メソッド。 これらのメソッドが存在しない場合は、呼び出し、オブジェクトのパラメーターなし**ToString**メソッド。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が無効です。  
  
- または - 
書式項目のインデックスが 0 でも 1 でもありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <param name="arg2">3 番目に書式設定するオブジェクト。</param>
        <summary>文字列の書式項目を、指定した 3 つのオブジェクトの文字列形式に置換します。</summary>
        <returns>書式項目が <paramref name="format" />、<paramref name="arg0" />、および <paramref name="arg1" /> の文字列形式に置換された <paramref name="arg2" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドを使用して、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)3 つの式の値をその文字列表現に変換して、それらの表現を文字列に埋め込みます。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>例: 3 つの引数を書式設定  
 
 この例では、<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>ブール値の結果を示す文字列を作成するメソッドを`And`2 つの整数値を操作します。 各項目が 2 つの方法で書式設定されたために、書式指定文字列に 6 つの書式項目が含まれていますが、メソッドのパラメーター リストの 3 つだけの項目には注意してください。  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が無効です。  
  
- または - 
書式項目のインデックスが 0 より小さいか、または 2 より大きい値です。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">[複合書式設定文字列](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <param name="arg2">3 番目に書式設定するオブジェクト。</param>
        <summary>文字列の書式項目を、指定した 3 つのオブジェクトの文字列形式に置換します。 パラメーターにより、カルチャに固有の書式設定情報を指定します。</summary>
        <returns>書式項目が <paramref name="format" />、<paramref name="arg0" />、および <paramref name="arg1" /> の文字列形式に置換された <paramref name="arg2" /> のコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
このメソッドを使用して、[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)3 つの式をその文字列表現に変換して、それらの表現を文字列に埋め込みます。 変換を実行するには、カルチャ依存した書式設定またはカスタム フォーマッタを使用します。 メソッドでは、それぞれに変換します<xref:System.Object>引数を文字列形式を呼び出してその**ToString(IFormatProvider)** メソッドまたは、書式指定項目がそのを呼び出すことによって、書式指定文字列を含む場合は、オブジェクトの対応する**ToString(String,IFormatProvider)** メソッド。 これらのメソッドが存在しない場合は、呼び出し、オブジェクトのパラメーターなし**ToString**メソッド。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が無効です。  
  
- または - 
書式項目のインデックスが 0 より小さいか、または 2 より大きい値です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列に含まれる個々の文字を反復処理するオブジェクトを取得します。</summary>
        <returns>列挙子オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> 呼び出しではなく、<xref:System.String.GetEnumerator%2A>を取得するメソッド、<xref:System.CharEnumerator>オブジェクトから文字列を列挙するために使用することは、代わりに、言語のイテレーションの構成要素を使用する必要があります (c#、c++/cli、CLR と Visual Basic で)。 [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) c# で[各](/cpp/dotnet/for-each-in)c++/cli、CLR と[ごと](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)Visual Basic で)。
  
 このメソッドでは、文字列の個々 の文字を反復処理することができます。 たとえば、Visual Basic`For Each`と c#`foreach`ステートメントを返すには、このメソッドの呼び出しを<xref:System.CharEnumerator>この文字列インスタンス内の文字を読み取り専用のアクセスを提供できるオブジェクト。  
  
   
  
## Examples  
 次の例では、いくつかの文字列内の文字を反復処理し、個々 の文字に関する情報が表示されます。 呼び出しではなく、言語のイテレーションの構成要素を使用して、<xref:System.String.GetEnumerator%2A>メソッド。  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列のハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動作<xref:System.String.GetHashCode%2A>は別に、共通言語ランタイムの 1 つのバージョンから変わる可能性のある、その実装に依存します。 パフォーマンスを向上させるためになぜこのエラーが発生する理由は、<xref:System.String.GetHashCode%2A>します。  
  
> [!IMPORTANT]
>  2 つの文字列オブジェクトが等しい場合、<xref:System.String.GetHashCode%2A>メソッドと同じ値を返します。 ただし、一意の文字列値ごとに一意のハッシュ コード値はありません。 別の文字列には、同じハッシュ コードを返すことができます。  
>   
>  ハッシュ コード自体には、安定しているは限りません。 .NET 実装間で、.NET のバージョン間で、および .NET の 1 つのバージョン (32 ビットおよび 64 ビット) などの .NET プラットフォーム間で、同一文字列のハッシュ コードは異なることができます。 場合によっては、アプリケーション ドメインによっても異なることができます。 つまり、同じプログラムの 2 つの後続の実行が別のハッシュ コードを返す可能性があります。  
>   
>  ハッシュ コードで作成された、アプリケーション ドメインの外部で使用しないでください、結果として、コレクション内のキー フィールドとして使用する必要がありますしないと、永続化することはありません。  
>   
>  強力な暗号的ハッシュを作成する必要がある場合は、暗号化ハッシュ関数によって返される値ではなく、ハッシュ コードが最後に、使用しないでください。 暗号化ハッシュから派生したクラスを使用して、<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType>または<xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>クラス。  
>   
>  ハッシュ コードの詳細については、次を参照してください。<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>します。  
  
 デスクトップ アプリで使用することができます、 [ \<UseRandomizedStringHashAlgorithm > 要素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)一意のハッシュ コードを生成する、アプリケーション ドメインごと。 競合の数を削減でき挿入とハッシュ テーブルを使用する参照の全体的なパフォーマンスを向上できます。 次の例は、使用する方法を示します、 [ \<UseRandomizedStringHashAlgorithm > 要素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)します。 定義、一意のハッシュ コードを生成する、アプリケーション ドメインごと。 競合の数を削減でき挿入とハッシュ テーブルを使用する参照の全体的なパフォーマンスを向上できます。 次の例は、使用する方法を示します、します。 定義、`DisplayString`プライベート文字列定数を含むクラス`s`値が「、文字列です」。 また、メソッドを実行しているアプリケーション ドメインの名前と共に文字列値とハッシュ コードを表示する `ShowStringHashCode` メソッドも含まれています。  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 構成ファイルを指定せずにこの例を実行すると、次のような出力が表示されます。 文字列のハッシュ コードが 2 つアプリケーション ドメインで同じであることに注意してください。  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 ただし、例のディレクトリに次の構成ファイルを追加して例を実行すると、同じ文字列のハッシュ コードがアプリケーション ドメインによって異なります。  
  
```xml  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 構成ファイルが存在する場合、次の出力が表示されます。  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  ハッシュ コードは、挿入およびハッシュ テーブルからキーを持つオブジェクトを効率的に取得に使用されます。 ただし、ハッシュ コードは、文字列を一意に識別しません。 同一の文字列と同じハッシュ コードが共通言語ランタイムは同じハッシュ コードを別の文字列に割り当てることもできます。 さらに、ハッシュ コードでは、.NET のバージョン、1 つのバージョンでプラットフォームとアプリケーション ドメインを変更できます。 このためは、シリアル化したり、ハッシュ コードの値を保持しないでくださいもする必要がありますとして使用するハッシュ テーブルまたはディクショナリのキー。  
  
 ハッシュ コードの使用について、`GetHashCode`メソッドを参照してください<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>します。  
  
   
  
## Examples  
 次の例で、<xref:System.String.GetHashCode%2A>を使用してさまざまなメソッドは、文字列を入力します。  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>によって返される値<see cref="M:System.String.GetHashCode" />プラットフォームに依存します。 .NET Framework の 32 ビットおよび 64 ビット バージョンが異なります。 .NET Framework のバージョンと .NET Core の間で異なることもできます。</para>
        </block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt;要素</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.TypeCode" /> クラスには <see cref="T:System.String" /> を返します。</summary>
        <returns>列挙型定数 <see cref="F:System.TypeCode.String" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、表示、<xref:System.TypeCode>の列挙型の定数、<xref:System.String>型。  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンス内で最初に出現する指定 Unicode 文字または文字列の 0 から始まるインデックスをレポートします。 このインスタンス内で文字または文字列が見つからない場合、このメソッドは -1 を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <summary>指定した Unicode 文字がこの文字列内で最初に見つかった位置の 0 から始まるインデックスをレポートします。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックスでの位置。見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 から開始します。  
  
 このメソッドは、場所文字と見なされますを別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存する検索を実行するには、使用、<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>メソッド、場所、構成済みの文字を表す、合字「Æ」など (U + 00 C 6)、Unicode スカラー値可能性がありますに相当する文字の構成要素の出現、"AE"などのシーケンスを修正 (u+0041、u+0045)、カルチャによって異なります。  
  
   
  
## Examples  
 次の例では、検索する方法を示します、<xref:System.String>の文字を使用して、<xref:System.String.IndexOf%2A>メソッド。  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <summary>指定された文字列がこのインスタンス内で最初に見つかった位置の 0 から始まるインデックスをレポートします。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックスでの位置。見つからなかった場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は 0 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 から開始します。  
  
 このメソッドは、現在のカルチャを使用して単語 (大文字小文字を区別し、カルチャに依存する) 検索を実行します。 検索では、このインスタンスの最初の文字位置から開始し、最後の文字位置まで継続されます。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 場合`value`1 つまたは複数の無視できる文字のみで構成されて、<xref:System.String.IndexOf%28System.String%29>メソッドは常に現在のインスタンスの先頭に一致が見つかったことを示す、0 (ゼロ) を返します。 次の例では、<xref:System.String.IndexOf%28System.String%29>メソッドを使用して、2 つの文字列 (ソフト ハイフン (U + 00AD)、"n"の後にソフト ハイフンおよびソフト ハイフン、および"m") の 3 つの部分文字列を検索します。 文字列の 1 つのみにソフト ハイフンが含まれます。 例実行している場合、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]後で、各ケースでソフト ハイフンが、無視できる文字であるため、結果は、場合と同じにソフト ハイフンが含まれていない必要があるか`value`します。 ソフト ハイフンのみを検索するときに、文字列の先頭に一致が検出されたことを示す、0 (ゼロ) を返します。  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 次の例は、「動物」で"n"を検索します。 文字列のインデックスは、1 つではなく、0 から始まるため、<xref:System.String.IndexOf%28System.String%29>メソッドは、位置 1 で"n"があることを示します。  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 次の例では、<xref:System.String.IndexOf%2A>動物の名前の文の開始位置を決定する方法。 この位置を使用して、文に対象の動物を説明する形容詞を挿入します。  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>説明したよう[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)既定値を代入しを明示的に指定するパラメーターを必要とするメソッドを呼び出す代わりに文字列比較メソッドを呼び出さないようにすることをお勧めします。 文字列インスタンス内の部分文字列の最初のインデックスを検索するには、現在のカルチャの比較規則を使用して、呼び出して、<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />メソッドのオーバー ロードの値を持つ<see cref="F:System.StringComparison.CurrentCulture" />の`comparisonType`パラメーター。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <summary>指定した Unicode 文字がこの文字列内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は、指定した文字位置から開始されます。</summary>
        <returns>その文字が見つかった場合は、文字列の先頭からの、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合は、-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は、0 から始まります。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。 場合`startIndex`文字列インスタンスの長さと等しい、-1 が返されます。  
  
 検索の範囲は`startIndex`文字列の末尾にします。  
  
 このメソッドは、場所文字と見なされますを別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存する検索を実行するには、使用、<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>メソッド、場所、構成済みの文字を表す、合字「Æ」など (U + 00 C 6)、Unicode スカラー値可能性がありますに相当する文字の構成要素の出現、"AE"などのシーケンスを修正 (u+0041、u+0045)、カルチャによって異なります。  
  
   
  
## Examples  
 次の例で、<xref:System.String.IndexOf%2A>メソッド。  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が、0 (ゼロ) 未満か、または文字列の長さを超えています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">検索対象の文字。</param>
        <param name="comparisonType">検索の規則を指定する列挙値。</param>
        <summary>指定した Unicode 文字がこの文字列内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 指定した文字に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックスでの位置。見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

インデックス番号は 0 から開始します。  
  
`comparisonType`パラメーターは、<xref:System.StringComparison>列挙型のメンバーを指定するかどうかの検索、`value`引数が現在またはインバリアント カルチャを使用して、大文字や大文字と小文字は、または word または序数比較規則を使用します。
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <summary>指定された文字列がこのインスタンス内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は、指定した文字位置から開始されます。</summary>
        <returns>その文字列が見つかった場合は、現在のインスタンスの先頭からの、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合は、-1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は、0 から始まります。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。 場合`startIndex`文字列インスタンスの長さと等しい、-1 が返されます。  
  
 このメソッドは、現在のカルチャを使用して単語 (大文字小文字を区別し、カルチャに依存する) 検索を実行します。 検索を開始、`startIndex`のこのインスタンスの位置の文字し、最後の文字位置まで継続されます。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 場合`value`1 つまたは複数の無視できる文字のみで構成されて、<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>メソッドは常に返します`startIndex`、これは、検索の開始文字位置。 次の例では、 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> 2 つの文字列で"m"の後にソフト ハイフン (U + 00AD) の位置を検索するメソッドを使用します。 文字列の 1 つのみに必要な部分文字列が含まれます。 例実行している場合、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]後で、どちらの場合も、ソフト ハイフンが、無視できる文字であるため、メソッドのインデックスを返します、文字列内の"m"またはします。 "m" の後にソフト ハイフンが含まれる最初の文字列の場合、メソッドはソフト ハイフンのインデックスを返すことができず、代わりに "m" のインデックスを返すことに注意してください。  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 次の例は、対象の文字列内で指定された文字列のすべての出現箇所を検索します。  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が、0 未満か、またはこの文字列の長さを超えています。</exception>
        <block subset="none" type="usage">
          <para>説明したよう[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)既定値を代入しを明示的に指定するパラメーターを必要とするメソッドを呼び出す代わりに文字列比較メソッドを呼び出さないようにすることをお勧めします。 特定の文字位置の後に発生する部分文字列の最初のインデックスを検索するには、現在のカルチャの比較規則を使用して、呼び出して、<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />の値を持つメソッド オーバー ロード<see cref="F:System.StringComparison.CurrentCulture" />の`comparisonType`パラメーター。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 指定した文字列に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> パラメーターのインデックス位置。見つからなかった場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は 0 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 から開始します。  
  
 `comparisonType`を検索するパラメーターを指定します、`value`現在またはインバリアント カルチャを使用して、または区別しない検索を使用して、word または序数比較規則を使用してパラメーター。  
  
   
  
## Examples  
 次の例では、3 つのオーバー ロード、<xref:System.String.IndexOf%2A>のさまざまな値を使用して別の文字列内の文字列の最初の出現箇所を検索するメソッド、<xref:System.StringComparison>列挙体。  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="comparisonType" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 場合<paramref name="value" />1 つまたは複数の無視できる文字のみで構成されて、<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />メソッドは常に現在のインスタンスの先頭に一致が見つかったことを示す、0 (ゼロ) を返します。  
  
次の例では、<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />メソッドを使用して、2 つの文字列 (ソフト ハイフン (U + 00AD)、"n"の後にソフト ハイフンおよびソフト ハイフン、および"m") の 3 つの部分文字列を検索します。 文字列の 1 つのみにソフト ハイフンが含まれます。 例実行している場合、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]後、ソフト ハイフンが無視できる文字であるため、カルチャに依存する検索値を返します同じ検索文字列にソフト ハイフンが含まれていないかどうかを返すことができます。 ただし、序数に基づく検索は、正常に 1 つの文字列でソフト ハイフンを検索して、それが存在しないことを報告 2 番目の文字列から。  
  
[! コード csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [! コード vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>指定文字がこのインスタンス内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は指定した文字位置から開始され、指定した数の文字位置が検査されます。</summary>
        <returns>その文字が見つかった場合は、文字列の先頭からの、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合は、-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索が始まります`startIndex`し続けて`startIndex`  +  `count` -1。 ある文字`startIndex`  +  `count`検索には含まれません。  
  
 インデックス番号は 0 (ゼロ) から開始します。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。  
  
 このメソッドは、場所文字と見なされますを別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存する検索を実行するには、使用、<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>メソッド、場所、構成済みの文字を表す、合字「Æ」など (U + 00 C 6)、Unicode スカラー値可能性がありますに相当する文字の構成要素の出現、"AE"などのシーケンスを修正 (u+0041、u+0045)、カルチャによって異なります。  
  
   
  
## Examples  
 次の例で、<xref:System.String.IndexOf%2A>メソッド。  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
- または - 
 <paramref name="startIndex" /> がこの文字列の長さより大きいです。  
  
- または - 
 <paramref name="count" /> がこの文字列の長さ - <paramref name="startIndex" /> より大きいです。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>指定された文字列がこのインスタンス内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は指定した文字位置から開始され、指定した数の文字位置が検査されます。</summary>
        <returns>その文字列が見つかった場合は、現在のインスタンスの先頭からの、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合は、-1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 (ゼロ) から開始します。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。  
  
 このメソッドは、現在のカルチャを使用して単語 (大文字小文字を区別し、カルチャに依存する) 検索を実行します。 検索が始まります`startIndex`し続けて`startIndex`  +  `count` -1。 ある文字`startIndex`  +  `count`検索には含まれません。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 場合`value`1 つまたは複数の無視できる文字のみで構成されて、<xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>メソッドは常に返します`startIndex`、これは、検索の開始文字位置。 次の例では、 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> "m"で、3 番目の 2 つの文字列内の 6 番目の文字位置から開始後にソフト ハイフン (U + 00AD) の位置を検索するメソッドを使用します。 文字列の 1 つのみに必要な部分文字列が含まれます。 例実行している場合、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]または後で、どちらの場合も、ソフト ハイフンが、無視できる文字であるため、メソッドのインデックスを返します、文字列内の"m"、カルチャに依存した比較を実行するとき。 "m" の後にソフト ハイフンが含まれる最初の文字列の場合、メソッドはソフト ハイフンのインデックスを返すことができず、代わりに "m" のインデックスを返すことに注意してください。  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 次の例は、文字列のすべての出現箇所のインデックスを検索"he"別の文字列の部分文字列。 検索の反復ごとに検索する文字数を再計算する必要があることに注意してください。  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
- または - 
 <paramref name="startIndex" /> がこの文字列の長さより大きいです。  
  
- または - 
 <paramref name="count" /> がこの文字列の長さ - <paramref name="startIndex" /> より大きいです。</exception>
        <block subset="none" type="usage">
          <para>説明したよう[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)既定値を代入しを明示的に指定するパラメーターを必要とするメソッドを呼び出す代わりに文字列比較メソッドを呼び出さないようにすることをお勧めします。 現在のカルチャの比較規則を使用して、この操作を実行する、呼び出し、<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />メソッドのオーバー ロードの値を持つ<see cref="F:System.StringComparison.CurrentCulture" />の`comparisonType`パラメーター。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 現在の文字列内での検索の開始位置、および指定した文字列に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、現在のインスタンスの先頭からの、<paramref name="value" /> パラメーターの 0 から始まるインデックス位置。見つからなかった場合は、-1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は、0 から始まります。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。 場合`startIndex`文字列インスタンスの長さと等しい、-1 が返されます。  
  
 `comparisonType`を検索するパラメーターを指定します、`value`現在またはインバリアント カルチャを使用して、または区別しない検索を使用して、word または序数比較規則を使用してパラメーター。  
  
   
  
## Examples  
 次の exampledemonstrates 3 つのオーバー ロード、<xref:System.String.IndexOf%2A>のさまざまな値を使用して別の文字列内の文字列の最初の出現箇所を検索するメソッド、<xref:System.StringComparison>列挙体。  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が、0 未満か、またはこの文字列の長さを超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="comparisonType" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 場合<paramref name="value" />1 つまたは複数の無視できる文字のみで構成されて、<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />メソッドは常に返します<paramref name="startIndex" />、これは、検索の開始文字位置。  
  
次の例では、 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> "m"の 2 つの文字列の 3 番目の文字位置から開始後にソフト ハイフン (U + 00AD) の位置を検索するメソッドを使用します。 文字列の 1 つだけでは、必要な部分が含まれています。例実行している場合、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]または後で、どちらの場合も、ソフト ハイフンが、無視できる文字であるため、メソッドのインデックスを返します、文字列内の"m"、カルチャに依存した比較を実行するとき。 "m" の後にソフト ハイフンが含まれる最初の文字列の場合、メソッドはソフト ハイフンのインデックスを返すことができず、代わりに "m" のインデックスを返すことに注意してください。 このメソッドは、序数に基づく比較を実行したときのみ、最初の文字列に含まれるソフト ハイフンのインデックスを返します。  
  
[! コード csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [! コード vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="count">検査する文字位置の数。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最初に見つかった位置の 0 から始まるインデックスをレポートします。 現在の文字列での検索開始位置、現在の文字列で検索する文字の数、および指定した文字列に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、現在のインスタンスの先頭からの、<paramref name="value" /> パラメーターの 0 から始まるインデックス位置。見つからなかった場合は、-1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 (ゼロ) から開始します。 `startIndex` パラメーターには、0 から文字列インスタンスの長さまでの範囲の値を指定できます。  
  
 検索が始まります`startIndex`し続けて`startIndex`  +  `count` -1。 ある文字`startIndex`  +  `count`検索には含まれません。  
  
 `comparisonType`を検索するパラメーターを指定します、`value`現在またはインバリアント カルチャを使用して、または区別しない検索を使用して、word または序数比較規則を使用してパラメーター。  
  
   
  
## Examples  
 次の exampledemonstrates 3 つのオーバー ロード、<xref:System.String.IndexOf%2A>のさまざまな値を使用して別の文字列内の文字列の最初の出現箇所を検索するメソッド、<xref:System.StringComparison>列挙体。  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
- または - 
 <paramref name="startIndex" /> はこのインスタンスの長さを超えています。  
  
- または - 
 <paramref name="count" /> がこの文字列の長さ - <paramref name="startIndex" /> より大きいです。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="comparisonType" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 場合<paramref name="value" />1 つまたは複数の無視できる文字のみで構成されて、<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />メソッドは常に返します<paramref name="startIndex" />、これは、検索の開始文字位置。  
  
次の例では、 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> "m"で、3 番目の 2 つの文字列内の 6 番目の文字位置から開始後にソフト ハイフン (U + 00AD) の位置を検索するメソッドを使用します。 文字列の 1 つのみに必要な部分文字列が含まれます。 例実行している場合、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]または後で、どちらの場合も、ソフト ハイフンが、無視できる文字であるため、メソッドのインデックスを返します、文字列内の"m"、カルチャに依存した比較を実行するとき。 序数に基づく比較を実行するときに、部分文字列のみで見つけた最初の文字列。 最初の文字列は、"m"の後にソフト ハイフンが含まれている場合、メソッドはソフト ハイフンのインデックスを返すが失敗したが代わりに、カルチャに依存した比較を実行するときに、"m"のインデックスを返しますに注意してください。 このメソッドは、序数に基づく比較を実行したときのみ、最初の文字列に含まれるソフト ハイフンのインデックスを返します。  
  
[! コード csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [! コード vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Unicode 文字の指定した配列内にある文字がこのインスタンスで最初に見つかった位置のインデックスをレポートします。 このインスタンス内で配列内の文字が見つからない場合、このメソッドは -1 を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <summary>Unicode 文字の指定した配列内にある文字がこのインスタンスで最初に見つかった位置の 0 から始まるインデックスをレポートします。</summary>
        <returns>
          <paramref name="anyOf" /> 内の文字がこのインスタンスで最初に見つかった場所の 0 から始まるインデックスでの位置。<paramref name="anyOf" /> 内に文字が見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 から開始します。  
  
 検索`anyOf`小文字が区別されます。 場合`anyOf`は空の配列、文字列の先頭に一致するメソッドの検索 (つまり、インデックス 0)。  
  
 このメソッドは、場所文字と見なされますを別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存する検索を実行するには、使用、<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>メソッド、場所、構成済みの文字を表す、合字「Æ」など (U + 00 C 6)、Unicode スカラー値可能性がありますに相当する文字の構成要素の出現、"AE"などのシーケンスを修正 (u+0041、u+0045)、カルチャによって異なります。  
  
   
  
## Examples  
 次の例は、文字列内の最初の母音を検索します。  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <summary>Unicode 文字の指定した配列内にある文字がこのインスタンスで最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は、指定した文字位置から開始されます。</summary>
        <returns>
          <paramref name="anyOf" /> 内の文字がこのインスタンスで最初に見つかった場所の 0 から始まるインデックスでの位置。<paramref name="anyOf" /> 内に文字が見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 から開始します。 `startIndex`パラメーターは 0 から 1 文字列インスタンスの長さよりも少ない数までです。  
  
 検索の範囲は`startIndex`文字列の末尾にします。  
  
 検索`anyOf`小文字が区別されます。  
  
 このメソッドは、場所文字と見なされますを別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存する検索を実行するには、使用、<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>メソッド、場所、構成済みの文字を表す、合字「Æ」など (U + 00 C 6)、Unicode スカラー値可能性がありますに相当する文字の構成要素の出現、"AE"などのシーケンスを修正 (u+0041、u+0045)、カルチャによって異なります。  
  
   
  
## Examples  
 次の例では、別の文字列の部分文字列内で、"is"を文字列の任意の文字の見つかった位置のインデックスを検索します。  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が負の値です。  
  
- または - 
 <paramref name="startIndex" /> が、このインスタンス中の文字数を超えています。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <param name="startIndex">検索が開始される位置。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>Unicode 文字の指定した配列内にある文字がこのインスタンスで最初に見つかった位置の 0 から始まるインデックスをレポートします。 検索は指定した文字位置から開始され、指定した数の文字位置が検査されます。</summary>
        <returns>
          <paramref name="anyOf" /> 内の文字がこのインスタンスで最初に見つかった場所の 0 から始まるインデックスでの位置。<paramref name="anyOf" /> 内に文字が見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 検索が始まります`startIndex`し続けて`startIndex`  +  `count` -1。 ある文字`startIndex`  +  `count`検索には含まれません。  
  
 インデックス番号は 0 から開始します。 `startIndex`パラメーターは 0 から 1 文字列インスタンスの長さよりも少ない数までです。  
  
 検索`anyOf`小文字が区別されます。  
  
 このメソッドは、場所文字と見なされますを別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存する検索を実行するには、使用、<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>メソッド、場所、構成済みの文字を表す、合字「Æ」など (U + 00 C 6)、Unicode スカラー値可能性がありますに相当する文字の構成要素の出現、"AE"などのシーケンスを修正 (u+0041、u+0045)、カルチャによって異なります。  
  
   
  
## Examples  
 次の例では、別の文字列の部分文字列内で任意の文字の文字列「ヘルパー」に見つかった位置のインデックスを検索します。  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
- または - 
 <paramref name="count" /> + <paramref name="startIndex" /> が、このインスタンス中の文字数を超えています。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">挿入した箇所で 0 から始まるインデックス位置。</param>
        <param name="value">挿入する文字列。</param>
        <summary>このインスタンス内の指定したインデックス位置に指定した文字列を挿入した、新しい文字列を返します。</summary>
        <returns>このインスタンスと等価で、<paramref name="startIndex" /> の位置に <paramref name="value" /> が挿入された新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`startIndex`は、このインスタンスの長さと等しく`value`がこのインスタンスの末尾に追加されます。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、これで新しい文字列を返します`value`現在のインスタンスに挿入されます。  
  
 戻り値など、 `"abc".Insert(2, "XYZ")` "abXYZc"です。  
  
   
  
## Examples  
 次の例では、文字列の 4 番目の文字位置 (インデックス 3 文字) で、空白文字を挿入します。  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 次のコンソール アプリケーションでは、2 つの動物を記述する 1 つまたは複数の形容詞を入力するように求められます。 呼び出して、<xref:System.String.Insert%2A>を文字列に、ユーザーが入力したテキストを挿入するメソッド。  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が負の数値か、またはこのインスタンスの長さを超えています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">インターン プールから検索する文字列。</param>
        <summary>指定した <see cref="T:System.String" /> へのシステム参照を取得します。</summary>
        <returns>
          <paramref name="str" /> がインターン プールに存在する場合は、それに対するシステム参照。それ以外の場合は、値が <paramref name="str" /> の文字列への新しい参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 共通言語ランタイムは、インターン プールから、各一意のリテラル文字列宣言またはプログラムで、プログラムを作成する 1 つの参照を含んでいると呼ばれる、テーブルを維持することにより、文字列ストレージを節約できます。 その結果、特定の値を表すリテラル文字列のインスタンスのみ、システムに 1 回存在します。  
  
 たとえばにいくつかの変数を同じリテラル文字列を割り当てる場合、ランタイムはインターン プールからのリテラル文字列に同じ参照を取得し、各変数に割り当てます。  
  
 <xref:System.String.Intern%2A>メソッドを使用してインターン プールから検索の値に等しい文字列`str`します。 このような文字列が存在する場合は、インターン プール内の参照が返されます。 文字列が存在しないかどうかへの参照を`str`その参照が返されます、インターン プールに追加されます。  
  
 次の例では、プログラム内のリテラルである文字列 s1 では、"MyTest"の値を持つが既に隔離します。 <xref:System.Text.StringBuilder?displayProperty=nameWithType>クラスを s1 と同じ値を持つ新しい文字列オブジェクトが生成されます。 その文字列への参照は、s2 に割り当てられます。 <xref:System.String.Intern%2A>メソッドを s2 と同じ値を持つ文字列を検索します。 このような文字列が存在するため、メソッドは、s1 に割り当てられているものと同じ参照を返します。 S3 には、その参照が割り当てられます。 参照の s1 および s2 等しくないものと別のオブジェクトを参照しているため参照 s1 および s3 は、同じ文字列を参照しているため、等しくない比較します。  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 このメソッドを比較、<xref:System.String.IsInterned%2A>メソッド。  
  
## <a name="version-considerations"></a>バージョンの考慮事項  
 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]、<xref:System.String.Intern%2A>メソッドは、.NET Framework 1.0 および 1.1 に関して、空の文字列のインターンの動作に戻ります。 次の例では、変数`str1`への参照が割り当てられている<xref:System.String.Empty>、し、変数`str2`への参照が割り当てられている<xref:System.String.Empty>呼び出しによって返される、<xref:System.String.Intern%2A>変換して、からメソッド<xref:System.Text.StringBuilder>オブジェクトの値が<xref:System.String.Empty>文字列にします。 含まれる参照し、`str1`と`str2`が等しいかどうか比較します。  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]、 [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]、および[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]、`str1`と`str2`が等しい。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]と[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]、`str1`と`str2`が等しくないです。  
  
## <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 メモリの総量を削減しようとしている場合、アプリケーションの割り当て、文字列のインターンを 2 つの望ましくない副作用を持つことに留意してください。 インターンを最初に、メモリに割り当てられた<xref:System.String>オブジェクトが共通言語ランタイム (CLR) が終了するまでにリリースされる可能性があります。 その理由は、インターンへの参照を CLR の<xref:System.String>オブジェクトは、アプリケーション、またはアプリケーション ドメインも後になることができます、終了します。 次に、文字列をインターン プールには、文字列を最初に作成する必要があります。 によって使用されるメモリ、<xref:System.String>オブジェクトする必要がありますも割り当てられると、メモリはガベージ コレクションが、いずれもします。  
  
 .NET Framework version 2.0 では、<xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType>列挙型のメンバー。 <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning>メンバーは、リテラル文字列インターンを必要としないとしてアセンブリをマークします。 適用できる<xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning>を使用してアセンブリを<xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute>属性。 また、使用、 [Ngen.exe (ネイティブ イメージ ジェネレーター)](~/docs/framework/tools/ngen-exe-native-image-generator.md)モジュール間でインターンいない文字列を実行時の前にアセンブリをコンパイルします。  
  
   
  
## Examples  
 次のコードの例では、3 つの文字列は、文字列を新しく作成されたかどうかを決定する値に等しいとインターンの文字列が等しい。  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">インターン プールから検索する文字列。</param>
        <summary>指定した <see cref="T:System.String" /> への参照を取得します。</summary>
        <returns>
          <paramref name="str" /> が共通言語ランタイムのインターン プール内にある場合は、それへの参照。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 共通言語ランタイムの一意のインスタンスと同様に、プログラムで宣言されている各リテラルの一意の文字列定数の 1 つのインスタンスを含むインターン プールと呼ばれる、テーブルを自動的に維持する<xref:System.String>プログラムで呼び出すことによって追加します。<xref:System.String.Intern%2A>メソッド。  
  
 インターン プールからは、文字列ストレージを節約できます。 いくつかの変数にリテラル文字列定数を割り当てると、各変数は設定のいくつかの異なるインスタンスを参照する代わりに、インターン プール内の同じ定数を参照する<xref:System.String>同一の値があります。  
  
 このメソッドを検索`str`インターン プールから。 場合`str`が既にがそのインスタンスへの参照が返されます。 それ以外の場合、`null`が返されます。  
  
 このメソッドを比較、<xref:System.String.Intern%2A>メソッド。  
  
 このメソッドは、ブール値を返しません。 特定の文字列がインターン プールに存在するかどうかを示すブール値の目的であるため、メソッドを呼び出す場合、次のコードを使用できます。  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  以降、.NET Framework version 2.0 では、オーバーライドできますインターン プールからの使用を使用する場合、 [Ngen.exe (ネイティブ イメージ ジェネレーター)](~/docs/framework/tools/ngen-exe-native-image-generator.md)ローカル コンピューター上のネイティブ イメージ キャッシュにアセンブリをインストールします。 詳細については、パフォーマンスに関する考慮事項は、「解説」を参照してください、<xref:System.String.Intern%2A>プロパティ。  
  
   
  
## Examples  
 次の例では、リテラル文字列がコンパイラによって自動的に隔離されてことを示します。  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列が、特定の Unicode 正規形であるかどうかを示します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列が、Unicode 正規形 C であるかどうかを示します。</summary>
        <returns>この文字列が正規形 C である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部の Unicode 文字の組み合わせで構成される同等の複数のバイナリ表現があるや複合の Unicode 文字。 1 つの文字の複数の表現が存在するには、検索、並べ替え、照合、およびその他の操作が複雑になります。  
  
 標準の Unicode 文字のバイナリ表現のいずれかが指定されると 1 つのバイナリ表現を返します正規化と呼ばれるプロセスを定義します。 別の規則に従う、正規化形式と呼ばれる複数のアルゴリズムでは、正規化を実行できます。 .NET では、正規化フォーム C、D、KC、および KD がサポートされています。  
  
 サポートされている Unicode 正規化フォームの説明は、次を参照してください。<xref:System.Text.NormalizationForm?displayProperty=nameWithType>します。  
  
   
  
## Examples  
 次の例では、さまざまな正規形に文字列が正常に正規化されたかどうかを判断します。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のインスタンスに、正しくない Unicode 文字が含まれています。</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" />メソッドを返します。<see langword="false" />文字列の最初の正規化されていない文字が発生するとすぐにします。 したがって、文字列には、後に無効な Unicode 文字を正規化されていない文字が含まれている場合、<see cref="Overload:System.String.Normalize" />メソッドがスローされます、<see cref="T:System.ArgumentException" />が<see cref="Overload:System.String.IsNormalized" />を返します<see langword="false" />。</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Unicode 正規形。</param>
        <summary>この文字列が、指定された Unicode 正規形であるかどうかを示します。</summary>
        <returns>この文字列が <paramref name="normalizationForm" /> パラメーターで指定された正規形である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部の Unicode 文字の組み合わせで構成される同等の複数のバイナリ表現があるや複合の Unicode 文字。 1 つの文字の複数の表現が存在するには、検索、並べ替え、照合、およびその他の操作が複雑になります。  
  
 標準の Unicode 文字のバイナリ表現のいずれかが指定されると 1 つのバイナリ表現を返します正規化と呼ばれるプロセスを定義します。 別の規則に従う、正規化形式と呼ばれる複数のアルゴリズムでは、正規化を実行できます。 .NET では、正規化フォーム C、D、KC、および KD がサポートされています。  
  
 サポートされている Unicode 正規化フォームの説明は、次を参照してください。<xref:System.Text.NormalizationForm?displayProperty=nameWithType>します。  
  
   
  
## Examples  
 次の例で、<xref:System.String.IsNormalized%2A>と<xref:System.String.Normalize%2A>メソッド。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のインスタンスに、正しくない Unicode 文字が含まれています。</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" />メソッドを返します。<see langword="false" />文字列の最初の正規化されていない文字が発生するとすぐにします。 したがって、文字列には、後に無効な Unicode 文字を正規化されていない文字が含まれている場合、<see cref="Overload:System.String.Normalize" />メソッドがスローされます、<see cref="T:System.ArgumentException" />が<see cref="Overload:System.String.IsNormalized" />を返します<see langword="false" />。</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">テストする文字列。</param>
        <summary>指定された文字列が <see langword="null" /> または空の文字列 ("") であるかどうかを示します。</summary>
        <returns>
          <see langword="true" /> パラメーターが <paramref name="value" /> または空の文字列 ("") の場合は <see langword="null" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A> 同時にテストすることができる便利なメソッドは、かどうかを<xref:System.String>は`null`またはその値が<xref:System.String.Empty?displayProperty=nameWithType>します。 これは、次のコードに相当します。  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 使用することができます、<xref:System.String.IsNullOrWhiteSpace%2A>文字列があるかどうかをテストするメソッド`null`、その値は<xref:System.String.Empty?displayProperty=nameWithType>、またはの空白文字だけで構成されます。  
  
## <a name="what-is-a-null-string"></a>Null 文字列とは何ですか。

文字列が`null`(C++ および Visual Basic) の値を割り当てられていない場合、または値の割り当てられて明示的に`null`します。 ただし、[複合書式指定](~/docs/standard/base-types/composite-formatting.md)機能は次の例は、そのメンバーがスローされた場合は、いずれかを呼び出しますしようと null 文字列では、適切に処理を<xref:System.NullReferenceException>します。  
  
[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>空の文字列とは何ですか。  

文字列が空の文字列を明示的に割り当てられている場合は空 ("") または<xref:System.String.Empty?displayProperty=nameWithType>します。 空の文字列が、 <xref:System.String.Length%2A> 0 です。  次の例では、空の文字列を作成し、その値とその長さが表示されます。  
  
[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
## Examples  
 次の例は、3 つの文字列を検査し、各文字列の値を持つ、空の文字列、されるかを決定`null`します。  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">テストする文字列。</param>
        <summary>指定された文字列が <see langword="null" /> または空であるか、空白文字だけで構成されているかどうかを示します。</summary>
        <returns>
          <see langword="true" /> パラメーターが <paramref name="value" /> または <see langword="null" /> であるか、<see cref="F:System.String.Empty" /> が空白文字だけで構成されている場合は <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A> 優れたパフォーマンスを提供する点を除いて、次のコードでは、次のような便利なメソッドを示します。  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 空白文字は、Unicode 規格によって定義されます。 <xref:System.String.IsNullOrWhiteSpace%2A>メソッドの値を返す任意の文字は解釈`true`に渡されると、<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>空白文字としてのメソッド。  
  
   
  
## Examples  
 次の例は、文字列の配列を作成し、次に、配列の各要素に渡します、<xref:System.String.IsNullOrWhiteSpace%2A>メソッド。  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した配列の要素またはコレクションのメンバーを連結します。各要素の間には、指定した区切り記号が挿入されます。</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字列。<paramref name="separator" /> が返される文字列に含まれるのは、<paramref name="values" /> が 2 つ以上の要素を含む場合に限られます。</param>
        <param name="values">連結する文字列を格納しているコレクション。</param>
        <summary>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 型の構築された <see cref="T:System.String" /> コレクションのメンバーを連結します。各メンバーの間には、指定した区切り記号が挿入されます。</summary>
        <returns>
          <paramref name="values" /> のメンバーからなる、<paramref name="separator" /> 文字列で区切られた文字列。 <paramref name="values" /> にメンバーがない場合、メソッドは <see cref="F:System.String.Empty" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`separator`は`null`、空の文字列 (<xref:System.String.Empty?displayProperty=nameWithType>) 代わりに使用されます。 場合のメンバーはすべて`values`は`null`、空の文字列が代わりに使用されます。  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 便利なメソッド内の各要素を連結することができますが、`IEnumerable(Of String)`文字列配列に要素を変換しなくてもコレクション。 統合言語クエリ (LINQ) のクエリ式で特に便利です。 次の例では、`List(Of String)`と等しいか (つまり、例では、"M")、特定の文字を超える文字を選択するラムダ式にアルファベットの大文字または小文字の文字を含むオブジェクト。 `IEnumerable(Of String)`によって返されるコレクション、<xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>にメソッドが渡される、<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>メソッドを 1 つの文字列として結果を表示します。  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 次の例では、エラトステネスの篩というアルゴリズムを使用して、100 小さい素数を計算します。 結果を割り当てます、<xref:System.Collections.Generic.List%601>型のオブジェクト<xref:System.String>、しに渡されます、<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>メソッド。  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字列。 <paramref name="values" /> が 2 つ以上の要素を含む場合のみ、<paramref name="separator" /> が返される文字列に含まれます。</param>
        <param name="values">連結する要素を格納している配列。</param>
        <summary>オブジェクト配列の要素を連結します。各要素の間には、指定した区切り記号が挿入されます。</summary>
        <returns>
          <paramref name="values" /> の要素からなる、<paramref name="separator" /> 文字列で区切られた文字列。 <paramref name="values" /> が空の配列の場合、メソッドは <see cref="F:System.String.Empty" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`separator`は`null`場合、または任意の要素の`values`以外の最初の要素は`null`、空の文字列 (<xref:System.String.Empty?displayProperty=nameWithType>) 代わりに使用されます。 場合は、呼び出し元のセクションのノートを参照して、最初の要素の`values`は`null`。  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> 文字列をその要素を明示的に変換しなくてもオブジェクト配列内の各要素を連結することができます便利な方法です。 配列内の各オブジェクトの文字列表現を呼び出して、そのオブジェクトの派生`ToString`メソッド。  
  
   
  
## Examples  
 次の例では、エラトステネスの篩というアルゴリズムを使用して、100 小さい素数を計算します。 結果を次に、渡します、整数の配列に代入、<xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29>メソッド。  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>場合の最初の要素<paramref name="values" />は<see langword="null" />、<see cref="M:System.String.Join(System.String,System.Object[])" />メソッドが内の要素を連結しない<paramref name="values" />代わりに返されますが、<see cref="F:System.String.Empty" />します。 この問題の回避策数を利用できます。 値を割り当てるには、最も簡単な<see cref="F:System.String.Empty" />配列の最初の要素を次の例として示します。  
  
[! コード csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [! コード vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para>
        </block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字列。 <paramref name="value" /> が 2 つ以上の要素を含む場合のみ、<paramref name="separator" /> が返される文字列に含まれます。</param>
        <param name="value">連結する要素を格納している配列。</param>
        <summary>文字列配列のすべての要素を連結します。各要素の間には、指定した区切り記号が挿入されます。</summary>
        <returns>
          <paramref name="value" /> 内の要素からなる、<paramref name="separator" /> 文字列で区切られた文字列。 <paramref name="value" /> が空の配列の場合、メソッドは <see cref="F:System.String.Empty" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば場合、`separator`は「,」の要素が`value`は、"apple"、「オレンジ」、"grape"および"pear" `Join(separator, value)` 「apple、orange、grape、pear」を返します。  
  
 場合`separator`は`null`、空の文字列 (<xref:System.String.Empty?displayProperty=nameWithType>) 代わりに使用されます。 場合の任意の要素`value`は`null`、空の文字列が代わりに使用されます。  
  
   
  
## Examples  
 次の例で、<xref:System.String.Join%2A>メソッド。  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字列。 <paramref name="value" /> が 2 つ以上の要素を含む場合のみ、<paramref name="separator" /> が返される文字列に含まれます。</param>
        <param name="value">連結する要素を格納している配列。</param>
        <param name="startIndex">使用する <paramref name="value" /> の最初の要素。</param>
        <param name="count">使用する <paramref name="value" /> の要素の数。</param>
        <summary>文字列配列の指定した要素を連結します。各要素の間には、指定した区切り記号が挿入されます。</summary>
        <returns>
          <paramref name="value" /> 内の文字列からなる、<paramref name="separator" /> 文字列で区切られた文字列。  
  
または 
 <see cref="F:System.String.Empty" /> が 0 である場合、または <paramref name="count" /> に要素がない場合、または <paramref name="value" /> と <paramref name="separator" /> のすべての要素が <paramref name="value" /> である場合、<see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば場合、`separator`は「,」の要素が`value`は、"apple"、「オレンジ」、"grape"および"pear"`Join(separator, value, 1, 2)`を返します「オレンジ、grape」。  
  
 場合`separator`は`null`、空の文字列 (<xref:System.String.Empty?displayProperty=nameWithType>) 代わりに使用されます。 場合の任意の要素`value`は`null`、空の文字列が代わりに使用されます。  
  
   
  
## Examples  
 次の例では、果物の名前の配列から 2 つの要素を連結します。  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="count" /> が 0 未満です。  
  
- または - 
 <paramref name="startIndex" /> と <paramref name="count" /> を加算すると、<paramref name="value" /> にある要素の数を超えます。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しています。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <paramref name="values" /> のメンバーの型。</typeparam>
        <param name="separator">区切り記号として使用する文字列。<paramref name="separator" /> が返される文字列に含まれるのは、<paramref name="values" /> が 2 つ以上の要素を含む場合に限られます。</param>
        <param name="values">連結するオブジェクトを格納しているコレクション。</param>
        <summary>コレクションのメンバーを連結します。各メンバーの間には、指定した区切り記号が挿入されます。</summary>
        <returns>
          <paramref name="values" /> のメンバーからなる、<paramref name="separator" /> 文字列で区切られた文字列。 <paramref name="values" /> にメンバーがない場合、メソッドは <see cref="F:System.String.Empty" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`separator`は`null`、空の文字列 (<xref:System.String.Empty?displayProperty=nameWithType>) 代わりに使用されます。 場合のメンバーはすべて`values`は`null`、空の文字列が代わりに使用されます。  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 便利なメソッドの各メンバーを連結することができますが、<xref:System.Collections.Generic.IEnumerable%601>最初を文字列に変換することがなくコレクション。 内の各オブジェクトの文字列表現、<xref:System.Collections.Generic.IEnumerable%601>呼び出して、そのオブジェクトのコレクションは派生`ToString`メソッド。  
  
 このメソッドは、特定統合言語クエリ (LINQ) クエリ式で便利です。 たとえば、次のコードは非常に単純な定義`Animal`animal クラスとが所属する順序の名前を表すクラス。 定義し、<xref:System.Collections.Generic.List%601>オブジェクトの数を含む`Animal`オブジェクト。 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>を抽出する拡張メソッドが呼び出される、`Animal`オブジェクト`Order`プロパティが「げっ歯類」に等しい。 結果に渡される、<xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッド。  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 次の例では、エラトステネスの篩というアルゴリズムを使用して、100 小さい素数を計算します。 結果を割り当てます、<xref:System.Collections.Generic.List%601>しに渡されます整数型のオブジェクト、<xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>メソッド。  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンス内で最後に出現する指定 Unicode 文字または文字列の 0 から始まるインデックス位置をレポートします。 このインスタンス内で文字または文字列が見つからない場合、このメソッドは -1 を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <summary>このインスタンス内で最後に出現する指定 Unicode 文字の 0 から始まるインデックス位置をレポートします。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックスでの位置。見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 から開始します。 つまり、インデックス 0 の文字列の最初の文字は、最後が、 <xref:System.String.Length%2A> - 1。  
  
 このメソッドは、このインスタンスの最後の文字位置から検索を開始し、されるまで、先頭に向かって逆`value`が見つかるまたは最初の文字位置が検査されています。 検索は大文字小文字が区別されます。  
  
 このメソッドは、場所文字と見なされますを別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存する検索を実行するには、使用、<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>メソッド、場所、構成済みの文字を表す、合字「Æ」など (U + 00 C 6)、Unicode スカラー値可能性がありますに相当する文字の構成要素の出現、"AE"などのシーケンスを修正 (u+0041、u+0045)、カルチャによって異なります。  
  
   
  
## Examples  
 次の例では、定義、`ExtractFilename`メソッドを使用する、<xref:System.String.LastIndexOf%28System.Char%29>メソッド、文字列内の最後のディレクトリの区切り記号を検索し、文字列のファイル名を抽出します。 ファイルが存在する場合は、パスを除いたファイル名を返します。  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <summary>指定された文字列がこのインスタンス内で最後に見つかった 0 から始まるインデックス位置をレポートします。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> の 0 から始まる開始インデックス位置。見つからなかった場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値はこのインスタンスの最後のインデックス位置です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 から開始します。 つまり、インデックス 0 の文字列の最初の文字は、最後が、 <xref:System.String.Length%2A> - 1。  
  
 検索は、このインスタンスの最後の文字位置から開始し、されるまで、先頭に向かって逆`value`が見つかるまたは最初の文字位置が検査されています。  
  
 このメソッドは、現在のカルチャを使用して単語 (大文字小文字を区別し、カルチャに依存する) 検索を実行します。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 場合`value`1 つまたは複数の無視できる文字のみで構成されて、<xref:System.String.LastIndexOf%28System.String%29>メソッドは常に返します<xref:System.String.Length%2A?displayProperty=nameWithType>– 1 で、現在のインスタンス内の最後のインデックス位置を表します。 次の例では、<xref:System.String.LastIndexOf%28System.String%29>メソッドを使用して、2 つの文字列 (ソフト ハイフン (U + 00AD)、"n"の後にソフト ハイフンおよびソフト ハイフン、および"m") の 3 つの部分文字列を検索します。 文字列の 1 つのみにソフト ハイフンが含まれます。 例実行している場合、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]後で、各ケースでソフト ハイフンが、無視できる文字であるため、結果は、場合と同じにソフト ハイフンが含まれていない必要があるか`value`します。 ソフト ハイフンのみを検索する場合、メソッドは、6、5 を返します。 これらの値は、2 つの文字列の最後の文字のインデックスに対応します。  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 次の例では、タグと終了タグで開始する場合、文字列および文字列の末尾から HTML タグを削除します。 場合は、文字列で終わる終了角かっこ文字 (">")、例では、<xref:System.String.LastIndexOf%2A>終了タグの開始を検索するメソッド。  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>説明したよう[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)既定値を代入しを明示的に指定するパラメーターを必要とするメソッドを呼び出す代わりに文字列比較メソッドを呼び出さないようにすることをお勧めします。 文字列インスタンス内の部分文字列の最後のインデックスを検索するには、現在のカルチャの比較規則を使用して、呼び出して、<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />メソッドのオーバー ロードの値を持つ<see cref="F:System.StringComparison.CurrentCulture" />の<paramref name="comparisonType" />パラメーター。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <param name="startIndex">検索の開始位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <summary>このインスタンス内で最後に出現する指定 Unicode 文字の 0 から始まるインデックス位置をレポートします。 検索は、指定された文字位置から開始され、文字列の先頭に向かって逆方向に進みます。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 から開始します。 つまり、インデックス 0 の文字列の最初の文字は、最後が、 <xref:System.String.Length%2A> -1. このメソッドの開始に検索、`startIndex`文字位置のこのインスタンスと処理されるまで、現在のインスタンスの先頭に向かって後方の進行状況`value`が見つかるまたは最初の文字位置が検査されています。 たとえば場合、`startIndex`は<xref:System.String.Length%2A>- 1、メソッドは、先頭に文字列の最後の文字からのすべての文字を検索します。 検索は大文字小文字が区別されます。  
  
 このメソッドは、場所文字と見なされますを別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存する検索を実行するには、使用、<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>メソッド、場所、構成済みの文字を表す、合字「Æ」など (U + 00 C 6)、Unicode スカラー値可能性がありますに相当する文字の構成要素の出現、"AE"などのシーケンスを修正 (u+0041、u+0045)、カルチャによって異なります。  
  
   
  
## Examples  
 次の例では、文字列、文字列の先頭に、文字列の末尾から作業に出現するすべての文字のインデックスを検索します。  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が 0 未満であるか、このインスタンスの長さ以上です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <summary>指定された文字列がこのインスタンス内で最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は、指定された文字位置から開始され、文字列の先頭に向かって逆方向に進みます。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> の 0 から始まる開始インデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> かこのインスタンスの最後のインデックス位置のいずれか小さい方です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 から開始します。 つまり、インデックス 0 の文字列の最初の文字は、最後が、 <xref:System.String.Length%2A> - 1。  
  
 検索を開始、`startIndex`文字位置のこのインスタンスと処理が進行するまで先頭に向かって後方`value`が見つかるまたは最初の文字位置が検査されています。 たとえば場合、`startIndex`は<xref:System.String.Length%2A>- 1、メソッドは、先頭に文字列の最後の文字からのすべての文字を検索します。  
  
 このメソッドは、現在のカルチャを使用して単語 (大文字小文字を区別し、カルチャに依存する) 検索を実行します。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 場合`value`1 つまたは複数の無視できる文字のみで構成されて、<xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29>メソッドは常に返します`startIndex`、これは、検索の開始文字位置。 次の例では、<xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29>ソフト ハイフン (U + 00AD) が含まれ、前または最後の"m"を文字列に含まれます部分文字列を検索するメソッドを使用します。 例実行している場合、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]または後で、検索文字列にソフト ハイフンが無視されるため、substrin を探すための呼び出しはソフト ハイフンと"m"で構成される部分文字列では、"m"の位置を返します、文字列内を検索するメソッドの呼び出しソフト ハイフンと"n"で構成される g では、"n"の位置を返します。 メソッドが、"m"の値を表すのインデックスを返します、検索文字列には、ソフト ハイフンのみが含まれている、`startIndex`します。  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 次の例では、ターゲット文字列の先頭に、ターゲット文字列の末尾からの操作のターゲット文字列の文字列のすべての出現箇所のインデックスを検索します。  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が 0 未満であるか、または現在のインスタンスの長さを超えています。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="startIndex" /> が -1 未満であるか、または 0 を超えています。</exception>
        <block subset="none" type="usage">
          <para>説明したよう[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)既定値を代入しを明示的に指定するパラメーターを必要とするメソッドを呼び出す代わりに文字列比較メソッドを呼び出さないようにすることをお勧めします。 現在のカルチャの比較規則を使用して特定の文字位置の前の部分文字列のインデックスを検索するには、呼び出し、<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />メソッドのオーバー ロードの値を持つ<see cref="F:System.StringComparison.CurrentCulture" />の<paramref name="comparisonType" />パラメーター。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最後に見つかった 0 から始まる位置のインデックスをレポートします。 指定した文字列に使用する検索の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> パラメーターの 0 から始まる開始インデックス位置。見つからなかった場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値はこのインスタンスの最後のインデックス位置です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 から開始します。 つまり、インデックス 0 の文字列の最初の文字は、最後が、 <xref:System.String.Length%2A> - 1。  
  
 `comparisonType`を検索するパラメーターを指定します、`value`現在またはインバリアント カルチャを使用して、または区別しない検索を使用して、word または序数比較規則を使用してパラメーター。  
  
 検索は、このインスタンスの最後の文字位置から開始し、されるまで、先頭に向かって逆`value`が見つかるまたは最初の文字位置が検査されています。  
  
   
  
## Examples  
 次の exampledemonstrates 3 つのオーバー ロード、<xref:System.String.LastIndexOf%2A>のさまざまな値を使用して別の文字列内の文字列の最後の出現箇所を検索するメソッド、<xref:System.StringComparison>列挙体。  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="options" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 場合<paramref name="value" />1 つまたは複数の無視できる文字のみで構成されて、<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />メソッドは常に返します<see cref="P:System.String.Length" />– 1 で、現在のインスタンス内の最後のインデックス位置を表します。  
  
次の例では、<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />メソッドを使用して、2 つの文字列 (ソフト ハイフン (U + 00AD)、"n"の後にソフト ハイフンおよびソフト ハイフン、および"m") の 3 つの部分文字列を検索します。 文字列の 1 つのみにソフト ハイフンが含まれます。 例実行している場合、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]後、ソフト ハイフンが無視できる文字であるため、カルチャに依存する検索値を返します同じ検索文字列にソフト ハイフンが含まれていないかどうかを返すことができます。 ただし、序数に基づく検索は、正常に 1 つの文字列でソフト ハイフンを検索して、それが存在しないことを報告 2 番目の文字列から。  
  
[! コード csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [! コード vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする Unicode 文字。</param>
        <param name="startIndex">検索の開始位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>このインスタンス内の部分文字列で最後に出現する指定 Unicode 文字の 0 から始まるインデックス位置をレポートします。 検索は指定された文字位置から開始し、文字列の開始に向かって後方に移動し、文字位置の指定された数だけ行われます。</summary>
        <returns>その文字が見つかった場合は、<paramref name="value" /> の 0 から始まるインデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 から開始します。 つまり、インデックス 0 の文字列の最初の文字は、最後が、 <xref:System.String.Length%2A> - 1。  
  
 このメソッドでの検索を開始、`startIndex`文字位置が続行されるまで、このインスタンスの先頭に向かって後方`value`が見つかるまたは`count`文字位置します。 たとえば場合、`startIndex`は<xref:System.String.Length%2A>- 1、メソッドは逆方向に検索`count`文字、文字列の最後の文字から。 検索は大文字小文字が区別されます。  
  
 このメソッドは、場所文字と見なされますを別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存する検索を実行するには、使用、<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>メソッド、場所、構成済みの文字を表す、合字「Æ」など (U + 00 C 6)、Unicode スカラー値可能性がありますに相当する文字の構成要素の出現、"AE"などのシーケンスを修正 (u+0041、u+0045)、カルチャによって異なります。  
  
   
  
## Examples  
 次の例では、部分文字列の先頭に、部分文字列の末尾から作業の部分文字列内で出現するすべての文字のインデックスを検索します。  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が 0 未満であるか、このインスタンスの長さ以上です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> - <paramref name="count" /> + 1 が 0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>指定された文字列がこのインスタンス内で最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は指定された文字位置から開始し、文字列の開始に向かって後方に移動し、文字位置の指定された数だけ行われます。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> の 0 から始まる開始インデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> かこのインスタンスの最後のインデックス位置のいずれか小さい方です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 から開始します。 つまり、インデックス 0 の文字列の最初の文字は、最後が、 <xref:System.String.Length%2A> - 1。  
  
 検索を開始、`startIndex`文字位置のこのインスタンスと処理が進行するまで先頭に向かって後方`value`が見つかるまたは`count`文字位置します。 たとえば場合、`startIndex`は<xref:System.String.Length%2A>- 1、メソッドは逆方向に検索`count`文字、文字列の最後の文字から。  
  
 このメソッドは、現在のカルチャを使用して単語 (大文字小文字を区別し、カルチャに依存する) 検索を実行します。  
  
 文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存した検索では、`value` に無視できる文字が含まれている場合、その文字を削除して検索した場合と同じ結果になります。 場合`value`1 つまたは複数の無視できる文字のみで構成されて、<xref:System.String.LastIndexOf%2A>メソッドは常に返します`startIndex`、これは、検索の開始文字位置。 次の例では、<xref:System.String.LastIndexOf%2A>メソッドを使用して、2 つの文字の 2 つの文字列の最後の"m"の前にソフト ハイフン (U + 00AD) の位置を調べます。 文字列の 1 つのみに必要な部分文字列が含まれます。 例実行している場合、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]または後で、どちらの場合も、ソフト ハイフンが、無視できる文字であるため、メソッドのインデックスを返します、文字列内の"m"、カルチャに依存した比較を実行するとき。 "m" の後にソフト ハイフンが含まれる最初の文字列の場合、メソッドはソフト ハイフンのインデックスを返すことができず、代わりに "m" のインデックスを返すことに注意してください。  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 次の例では、部分文字列を部分文字列の先頭に、部分文字列の末尾からの操作で、文字列のすべての出現箇所のインデックスを検索します。  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が負の値です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が負の値です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> がこのインスタンスの長さより大きいです。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> - <paramref name="count" /> + 1 した値がこのインスタンス内にはない位置を指定しています。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="start" /> が -1 より小さいか 0 より大きいです。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="count" /> が 1 より大きいです。</exception>
        <block subset="none" type="usage">
          <para>説明したよう[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)既定値を代入しを明示的に指定するパラメーターを必要とするメソッドを呼び出す代わりに文字列比較メソッドを呼び出さないようにすることをお勧めします。 現在のカルチャの比較規則を使用して、この操作を実行する、<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />メソッドのオーバー ロードの値を持つ<see cref="F:System.StringComparison.CurrentCulture" />の<paramref name="comparisonType" />パラメーター。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定した文字列が現在の <see cref="T:System.String" /> オブジェクト内で最後に見つかった 0 から始まる位置のインデックスをレポートします。 検索は、指定された文字位置から開始され、文字列の先頭に向かって逆方向に進みます。 指定した文字列を検索するときに実行する比較の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> パラメーターの 0 から始まる開始インデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> かこのインスタンスの最後のインデックス位置のいずれか小さい方です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 から開始します。 つまり、インデックス 0 の文字列の最初の文字は、最後が、 <xref:System.String.Length%2A> - 1。  
  
 検索を開始、`startIndex`文字の位置および処理されるまで、旧バージョンとの進行状況`value`が見つかるまたは最初の文字位置が検査されています。 たとえば場合、`startIndex`は<xref:System.String.Length%2A>- 1、メソッドは、先頭に文字列の最後の文字からのすべての文字を検索します。  
  
 `comparisonType`を検索するパラメーターを指定します、`value`現在またはインバリアント カルチャを使用して、または区別しない検索を使用して、word または序数比較規則を使用してパラメーター。  
  
   
  
## Examples  
 次の exampledemonstrates 3 つのオーバー ロード、<xref:System.String.LastIndexOf%2A>のさまざまな値を使用して別の文字列内の文字列の最後の出現箇所を検索するメソッド、<xref:System.StringComparison>列挙体。  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が 0 未満であるか、または現在のインスタンスの長さを超えています。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="startIndex" /> が -1 未満であるか、または 0 を超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="comparisonType" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 場合<paramref name="value" />1 つまたは複数の無視できる文字のみで構成されて、<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />メソッドは常に返します<paramref name="startIndex" />、これは、検索の開始文字位置。  
  
次の例では、 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> "m"、"m"の 2 つの文字列の最後の開始後にソフト ハイフン (U + 00AD) の位置を検索するメソッドを使用します。 文字列の 1 つのみに必要な部分文字列が含まれます。 例実行している場合、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]または後で、どちらの場合も、ソフト ハイフンが、無視できる文字であるため、メソッドのインデックスを返します、文字列内の"m"、カルチャに依存した比較を実行するとき。 "m" の後にソフト ハイフンが含まれる最初の文字列の場合、メソッドはソフト ハイフンのインデックスを返すことができず、代わりに "m" のインデックスを返すことに注意してください。 このメソッドは、序数に基づく比較を実行したときのみ、最初の文字列に含まれるソフト ハイフンのインデックスを返します。  
  
[! コード csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [! コード vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">シークする文字列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <param name="count">検査する文字位置の数。</param>
        <param name="comparisonType">検索の規則を指定する列挙値の 1 つ。</param>
        <summary>指定された文字列がこのインスタンス内で最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は指定された文字位置から開始し、文字列の開始に向かって後方に移動し、文字位置の指定された数だけ行われます。 指定した文字列を検索するときに実行する比較の種類をパラメーターで指定します。</summary>
        <returns>その文字列が見つかった場合は、<paramref name="value" /> パラメーターの 0 から始まる開始インデックス位置。見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。 <paramref name="value" /> が <see cref="F:System.String.Empty" /> の場合、戻り値は <paramref name="startIndex" /> かこのインスタンスの最後のインデックス位置のいずれか小さい方です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 から開始します。 つまり、インデックス 0 の文字列の最初の文字は、最後が、 <xref:System.String.Length%2A> - 1。  
  
 検索を開始、`startIndex`文字の位置および処理されるまで、旧バージョンとの進行状況`value`が見つかるまたは`count`文字位置します。 たとえば場合、`startIndex`は<xref:System.String.Length%2A>- 1、メソッドは逆方向に検索`count`文字、文字列の最後の文字から。  
  
 `comparisonType`を検索するパラメーターを指定します、`value`現在またはインバリアント カルチャを使用して、または区別しない検索を使用して、word または序数比較規則を使用してパラメーター。  
  
   
  
## Examples  
 次の exampledemonstrates 3 つのオーバー ロード、<xref:System.String.LastIndexOf%2A>のさまざまな値を使用して別の文字列内の文字列の最後の出現箇所を検索するメソッド、<xref:System.StringComparison>列挙体。  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が負の値です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> が負の値です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> がこのインスタンスの長さより大きいです。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> + 1 - <paramref name="count" /> した値がこのインスタンス内にはない位置を指定しています。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="start" /> が -1 より小さいか 0 より大きいです。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しく、<paramref name="count" /> が 1 より大きいです。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> は有効な <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <block subset="none" type="usage">
          <para>文字セットには無視できる文字が含まれています。これらの文字は、言語またはカルチャに依存した比較を実行する際には考慮されません。 カルチャに依存する検索の場合 (つまり、<paramref name="comparisonType" /> が <see cref="F:System.StringComparison.Ordinal" /> または <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> でない場合)、<paramref name="value" /> に無視できる文字が含まれていると、その文字を削除して検索した場合と同じ結果になります。 場合<paramref name="value" />1 つまたは複数の無視できる文字のみで構成されて、<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />メソッドは常に返します<paramref name="startIndex" />、これは、検索の開始文字位置。  
  
次の例では、<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />メソッドを使用して、2 つの文字列で、その後にすべての"m"ソフト ハイフン (U + 00AD) の位置が最後の"m"の前に、最初の文字位置を検索します。 文字列の 1 つのみに必要な部分文字列が含まれます。 例実行している場合、[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]または後で、どちらの場合も、ソフト ハイフンが、無視できる文字であるため、メソッドのインデックスを返します、文字列内の"m"、カルチャに依存した比較を実行するとき。 序数に基づく比較を実行するときに、部分文字列のみで見つけた最初の文字列。 最初の文字列は、"m"の後にソフト ハイフンが含まれている場合、メソッドはソフト ハイフンのインデックスを返すが失敗したが代わりに、カルチャに依存した比較を実行するときに、"m"のインデックスを返しますに注意してください。 このメソッドは、序数に基づく比較を実行したときのみ、最初の文字列に含まれるソフト ハイフンのインデックスを返します。  
  
[! コード csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [! コード vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Unicode 配列内の指定した 1 つ以上の文字がこのインスタンスで最後に見つかった 0 から始まるインデックス位置をレポートします。 このインスタンス内で配列内の文字が見つからない場合、このメソッドは -1 を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <summary>Unicode 配列内の指定した 1 つ以上の文字がこのインスタンスで最後に見つかった 0 から始まるインデックス位置をレポートします。</summary>
        <returns>
          <paramref name="anyOf" /> 内の文字がこのインスタンスで最後に見つかった場所のインデックス位置。<paramref name="anyOf" /> 内の文字が見つからなかった場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 から開始します。  
  
 このメソッドは、このインスタンスの最後の文字位置から検索を開始し、内の文字までの先頭に向かって逆`anyOf`が見つかるまたは最初の文字位置が検査されています。 検索は大文字小文字が区別されます。  
  
 このメソッドは、場所文字と見なされますを別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存する検索を実行するには、使用、<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>メソッド、場所、構成済みの文字を表す、合字「Æ」など (U + 00 C 6)、Unicode スカラー値可能性がありますに相当する文字の構成要素の出現、"AE"などのシーケンスを修正 (u+0041、u+0045)、カルチャによって異なります。  
  
   
  
## Examples  
 次の例では、別の文字列内で、"is"を最後に見つかった文字列内の任意の文字のインデックスを検索します。  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <summary>Unicode 配列内の指定した 1 つ以上の文字がこのインスタンスで最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は、指定された文字位置から開始され、文字列の先頭に向かって逆方向に進みます。</summary>
        <returns>
          <paramref name="anyOf" /> 内の文字がこのインスタンスで最後に見つかった場所のインデックス位置。<paramref name="anyOf" /> 内の文字が見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 から開始します。  
  
 このメソッドでの検索を開始、`startIndex`文字位置のこのインスタンスと処理の進行状況ページ内の文字までの先頭に向かって後方`anyOf`が見つかるまたは最初の文字位置が検査されています。 検索は大文字小文字が区別されます。  
  
 このメソッドは、場所文字と見なされますを別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存する検索を実行するには、使用、<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>メソッド、場所、構成済みの文字を表す、合字「Æ」など (U + 00 C 6)、Unicode スカラー値可能性がありますに相当する文字の構成要素の出現、"AE"などのシーケンスを修正 (u+0041、u+0045)、カルチャによって異なります。  
  
   
  
## Examples  
 次の例では、別の文字列の部分文字列内で、"is"を最後に見つかった文字列内の任意の文字のインデックスを検索します。  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> がこのインスタンス内にはない位置を指定しています。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">シークする 1 つ以上の文字を格納している、Unicode 文字の配列。</param>
        <param name="startIndex">検索が開始される位置。 検索は、このインスタンスの先頭に向かって <paramref name="startIndex" /> から開始されます。</param>
        <param name="count">検査する文字位置の数。</param>
        <summary>Unicode 配列内の指定した 1 つ以上の文字がこのインスタンスで最後に見つかった 0 から始まるインデックス位置をレポートします。 検索は指定された文字位置から開始し、文字列の開始に向かって後方に移動し、文字位置の指定された数だけ行われます。</summary>
        <returns>
          <paramref name="anyOf" /> 内の文字がこのインスタンスで最後に見つかった場所のインデックス位置。<paramref name="anyOf" /> 内の文字が見つからなかった場合、または現在のインスタンスが <see cref="F:System.String.Empty" /> と等しい場合は -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インデックス番号は 0 から開始します。  
  
 このメソッドでの検索を開始、`startIndex`文字位置のこのインスタンスと処理の進行状況ページ内の文字までの先頭に向かって後方`anyOf`が見つかるまたは`count`文字位置します。 検索は大文字小文字が区別されます。  
  
 このメソッドは、場所文字と見なされますを別の文字と等価の Unicode スカラー値が同じ場合にのみ、序数 (カルチャに依存しない) 検索を実行します。 カルチャに依存する検索を実行するには、使用、<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>メソッド、場所、構成済みの文字を表す、合字「Æ」など (U + 00 C 6)、Unicode スカラー値可能性がありますに相当する文字の構成要素の出現、"AE"などのシーケンスを修正 (u+0041、u+0045)、カルチャによって異なります。  
  
   
  
## Examples  
 次の例では、別の文字列の部分文字列「ヘルパー」という文字列の文字の最後に見つかった位置のインデックスを検索します。  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="count" /> または <paramref name="startIndex" /> が負の値です。  
  
- または - 
現在のインスタンスが <see cref="F:System.String.Empty" /> と等しくなく、<paramref name="startIndex" /> - <paramref name="count" /> + 1 が 0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクト内の文字数を取得します。</summary>
        <value>現在の文字列の文字数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Length%2A>プロパティの数を返します<xref:System.Char>このインスタンス内のオブジェクト、Unicode 文字数ではありません。 理由は、1 つ以上で Unicode 文字を表す場合があります、<xref:System.Char>します。 使用して、<xref:System.Globalization.StringInfo?displayProperty=nameWithType>ごとではなく各 Unicode 文字を使用するクラス<xref:System.Char>します。  
  
 C や C++ など、一部の言語では、null 文字は、文字列の末尾を示します。 .NET では、文字列の null 文字を埋め込むことができます。 文字列には、1 つまたは複数の null 文字が含まれている場合は、合計の文字列の長さに含まれます。 たとえば、次の文字列では、"abc"と"def"が、null 文字で区切られた部分文字列で。 <xref:System.String.Length%2A>プロパティは 6 つのアルファベット文字と null 文字含まれていることを示します 7 を返します。  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 次の例で、<xref:System.String.Length%2A>プロパティ。  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バイナリ表現が特定の Unicode 正規形である新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列と同じテキスト値を持ち、なおかつ、バイナリ表現が Unicode 正規形 C である新しい文字列を返します。</summary>
        <returns>この文字列と同じテキスト値を持ち、なおかつ、バイナリ表現が正規形 C である新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部の Unicode 文字の組み合わせで構成される同等の複数のバイナリ表現があるや複合の Unicode 文字。 たとえば、次のコード ポイントのいずれか「いずれも」文字を表すことができます。  
  
-   U+1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 1 つの文字の複数の表現が存在するには、検索、並べ替え、照合、およびその他の操作が複雑になります。  
  
 標準の Unicode 文字のバイナリ表現のいずれかが指定されると 1 つのバイナリ表現を返します正規化と呼ばれるプロセスを定義します。 別の規則に従う、正規化形式と呼ばれる複数のアルゴリズムでは、正規化を実行できます。 .NET には、次の 4 つの正規化フォーム (C、D、KC、および KD) の中、Unicode 規格によって定義されているがサポートされています。 2 つの文字列が同じ正規形で示される場合は、序数に基づく比較を使用して比較できます。  
  
 正規化を 2 つの文字列の比較は、次の操作を行います。  
  
1.  ファイルやユーザー入力デバイスなどの入力ソースから比較する文字列を取得します。  
  
2.  呼び出す、<xref:System.String.Normalize>正規形 C に文字列を正規化する方法  
  
3.  2 つの文字列を比較するなど、文字列の順序比較をサポートするメソッドを呼び出す、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>メソッドの値を指定して<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>または<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>として、<xref:System.StringComparison>引数。 正規化された文字列の配列を並べ替えるには、渡す、 `comparer` @property<xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType>または<xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType>の適切なオーバー ロードに<xref:System.Array.Sort%2A?displayProperty=nameWithType>します。  
  
4.  前の手順で示された順序に基づいて並べ替えられる出力内の文字列を出力します。  
  
 サポートされている Unicode 正規化フォームの説明は、次を参照してください。<xref:System.Text.NormalizationForm?displayProperty=nameWithType>します。  
  
   
  
## Examples  
 次の例では、それぞれの 4 つの正規化形式の文字列を正規化を文字列に、指定された正規形では、正規化された、正規化された文字列内のコード ポイントの一覧を確認します。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のインスタンスに、正しくない Unicode 文字が含まれています。</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" />メソッドを返します。<see langword="false" />文字列の最初の正規化されていない文字が発生するとすぐにします。 したがって、文字列には、後に無効な Unicode 文字を正規化されていない文字が含まれている場合、<see cref="Overload:System.String.Normalize" />メソッドがスローされます、<see cref="T:System.ArgumentException" />が<see cref="Overload:System.String.IsNormalized" />を返します<see langword="false" />。</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Unicode 正規形。</param>
        <summary>この文字列と同じテキスト値を持ち、なおかつ、バイナリ表現が、指定された Unicode 正規形である新しい文字列を返します。</summary>
        <returns>この文字列と同じテキスト値を持ち、なおかつ、バイナリ表現が、<paramref name="normalizationForm" /> パラメーターで指定された正規形である新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部の Unicode 文字の組み合わせで構成される同等の複数のバイナリ表現があるや複合の Unicode 文字。 1 つの文字の複数の表現が存在するには、検索、並べ替え、照合、およびその他の操作が複雑になります。  
  
 標準の Unicode 文字のバイナリ表現のいずれかが指定されると 1 つのバイナリ表現を返します正規化と呼ばれるプロセスを定義します。 別の規則に従う、正規化形式と呼ばれる複数のアルゴリズムでは、正規化を実行できます。 .NET には、次の 4 つの正規化フォーム (C、D、KC、および KD) の中、Unicode 規格によって定義されているがサポートされています。 2 つの文字列が同じ正規形で示される場合は、序数に基づく比較を使用して比較できます。  
  
 正規化を 2 つの文字列の比較は、次の操作を行います。  
  
1.  ファイルやユーザー入力デバイスなどの入力ソースから比較する文字列を取得します。  
  
2.  呼び出す、<xref:System.String.Normalize%28System.Text.NormalizationForm%29>メソッドを指定した正規形に文字列を正規化します。  
  
3.  2 つの文字列を比較するなど、文字列の順序比較をサポートするメソッドを呼び出す、<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>メソッドの値を指定して<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>または<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>として、<xref:System.StringComparison>引数。 正規化された文字列の配列を並べ替えるには、渡す、 `comparer` @property<xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType>または<xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType>の適切なオーバー ロードに<xref:System.Array.Sort%2A?displayProperty=nameWithType>します。  
  
4.  前の手順で示された順序に基づいて並べ替えられる出力内の文字列を出力します。  
  
 サポートされている Unicode 正規化フォームの説明は、次を参照してください。<xref:System.Text.NormalizationForm?displayProperty=nameWithType>します。  
  
   
  
## Examples  
 次の例では、それぞれの 4 つの正規化形式の文字列を正規化を文字列に、指定された正規形では、正規化された、正規化された文字列内のコード ポイントの一覧を確認します。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のインスタンスに、正しくない Unicode 文字が含まれています。</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" />メソッドを返します。<see langword="false" />文字列の最初の正規化されていない文字が発生するとすぐにします。 したがって、文字列には、後に無効な Unicode 文字を正規化されていない文字が含まれている場合、<see cref="Overload:System.String.Normalize" />メソッドがスローする可能性が、<see cref="T:System.ArgumentException" />が<see cref="Overload:System.String.IsNormalized" />を返します<see langword="false" />。</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">比較する最初の文字列または <see langword="null" />。</param>
        <param name="b">比較する 2 番目の文字列または <see langword="null" />。</param>
        <summary>指定した 2 つの文字列の値が同一かどうかを判断します。</summary>
        <returns>
          <paramref name="a" /> の値が <paramref name="b" /> の値と同じ場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.op_Equality%2A>メソッド定義の等値演算子の操作、<xref:System.String>クラス。 「使用例に示すように示すようなコードができるようにします。 演算子をさらに、静的なを呼び出す<xref:System.String.Equals%28System.String%2CSystem.String%29>メソッドで、序数に基づく (大文字と小文字およびカルチャに依存しない) 比較を実行します。  
  
> [!NOTE]
>  Visual Basic コンパイラでも、等値演算子の呼び出しとして解決しない、<xref:System.String.op_Equality%2A>メソッド。 等値演算子がへの呼び出しをラップする代わりに、<xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType>メソッド。  
  
   
  
## Examples  
 次の例では、等値演算子を示します。  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">比較する最初の文字列または <see langword="null" />。</param>
        <param name="b">比較する 2 番目の文字列または <see langword="null" />。</param>
        <summary>指定した 2 つの文字列の値が異なるかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> の値が <paramref name="a" /> の値と異なる場合は <paramref name="b" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.op_Inequality%2A>メソッドの非等値演算子の動作を定義する、<xref:System.String>クラス。   「例」に示すように示すようなコードができるようにします。  
  
 <xref:System.String.op_Inequality%2A>演算子を呼び出し、静的な<xref:System.String.Equals%28System.String%2CSystem.String%29>メソッドで、序数に基づく (大文字と小文字およびカルチャに依存しない) 比較を実行します。  
  
> [!NOTE]
>  Visual Basic コンパイラでも、非等値演算子の呼び出しとして解決しない、<xref:System.String.op_Inequality%2A>メソッド。 非等値演算子がへの呼び出しをラップする代わりに、<xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType>メソッド。  
  
   
  
## Examples  
 次の例では、非等値演算子を示します。  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の文字列の先頭に空白または指定された Unicode 文字が埋め込まれた指定された長さの新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">結果として生成される文字列の文字数。これは、元の文字数と、埋め込み文字がある場合はその数を加えた数に等しくなります。</param>
        <summary>指定された文字数になるまで左側に空白を埋め込むことで、このインスタンス内の文字を右寄せした新しい文字列を返します。</summary>
        <returns>このインスタンスと等価な新しい文字列。ただし右揃えであり、<paramref name="totalWidth" /> の長さになるまで左側に空白が埋め込まれています。 ただし、<paramref name="totalWidth" /> がこのインスタンスの長さより短い場合、メソッドは既存のインスタンスへの参照を返します。 <paramref name="totalWidth" /> がこのインスタンスの長さと等しい場合、メソッドはこのインスタンスと同一の新しい文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unicode の領域は、0x0020 の 16 進数として定義されます。  
  
 <xref:System.String.PadLeft%28System.Int32%29>返される文字列の先頭が埋め込まれます。 これは、右から左の言語で使用すると、文字列の右側の部分が埋められることを意味します。  
  
> [!NOTE]
>  場合、<xref:System.String.PadLeft%2A>現在のインスタンスの空白文字が埋め込まれます、このメソッドは、現在のインスタンスの値を変更しません。 代わりに、その合計の長さが実行されるように先頭の空白文字を埋め込みは、新しい文字列を返します`totalWidth`文字。  
  
   
  
## Examples  
 次の例で、<xref:System.String.PadLeft%2A>メソッド。  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> が 0 未満です。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">結果として生成される文字列の文字数。これは、元の文字数と、埋め込み文字がある場合はその数を加えた数に等しくなります。</param>
        <param name="paddingChar">Unicode 埋め込み文字。</param>
        <summary>指定された文字数になるまで左側に指定された Unicode 文字を埋め込むことで、このインスタンス内の文字を右寄せした新しい文字列を返します。</summary>
        <returns>このインスタンスと等価な新しい文字列。ただし右揃えであり、<paramref name="totalWidth" /> の長さになるまで左側に <paramref name="paddingChar" /> の文字が埋め込まれています。 ただし、<paramref name="totalWidth" /> がこのインスタンスの長さより短い場合、メソッドは既存のインスタンスへの参照を返します。 <paramref name="totalWidth" /> がこのインスタンスの長さと等しい場合、メソッドはこのインスタンスと同一の新しい文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29>返される文字列の先頭が埋め込まれます。 これは、右から左の言語で使用すると、文字列の右側の部分が埋められることを意味します。  
  
> [!NOTE]
>  場合、<xref:System.String.PadLeft%2A>現在のインスタンスの空白文字が埋め込まれます、このメソッドは、現在のインスタンスの値を変更しません。 代わりに、先頭に埋め込みは、新しい文字列を返します`paddingChar`文字がその合計の長さがように`totalWidth`文字。  
  
   
  
## Examples  
 次の例で、<xref:System.String.PadLeft%2A>メソッド。  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> が 0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の文字列の末尾に空白または指定された Unicode 文字が埋め込まれた指定された長さの新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">結果として生成される文字列の文字数。これは、元の文字数と、埋め込み文字がある場合はその数を加えた数に等しくなります。</param>
        <summary>指定された文字数になるまで右側に空白を埋め込むことで、この文字列内の文字を左寄せした新しい文字列を返します。</summary>
        <returns>このインスタンスと等価な新しい文字列。ただし左揃えであり、<paramref name="totalWidth" /> の長さになるまで右側に空白が埋め込まれています。 ただし、<paramref name="totalWidth" /> がこのインスタンスの長さより短い場合、メソッドは既存のインスタンスへの参照を返します。 <paramref name="totalWidth" /> がこのインスタンスの長さと等しい場合、メソッドはこのインスタンスと同一の新しい文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unicode の領域は、0x0020 の 16 進数として定義されます。  
  
 <xref:System.String.PadRight%28System.Int32%29>返される文字列の末尾が埋め込まれます。 これは、右から左の言語で使用すると、文字列の左側の部分が埋められることを意味します。  
  
> [!NOTE]
>  場合、<xref:System.String.PadRight%2A>現在のインスタンスの空白文字が埋め込まれます、このメソッドは、現在のインスタンスの値を変更しません。 代わりに、その合計の長さが実行されるように、後続の空白で埋められますな新しい文字列を返します`totalWidth`文字。  
  
   
  
## Examples  
 次の例で、<xref:System.String.PadRight%2A>メソッド。  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> が 0 未満です。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">結果として生成される文字列の文字数。これは、元の文字数と、埋め込み文字がある場合はその数を加えた数に等しくなります。</param>
        <param name="paddingChar">Unicode 埋め込み文字。</param>
        <summary>指定された文字数になるまで右側に指定された Unicode 文字を埋め込むことで、この文字列内の文字を左寄せした新しい文字列を返します。</summary>
        <returns>このインスタンスと等価な新しい文字列。ただし左揃えであり、<paramref name="totalWidth" /> の長さになるまで右側に <paramref name="paddingChar" /> の文字が埋め込まれています。 ただし、<paramref name="totalWidth" /> がこのインスタンスの長さより短い場合、メソッドは既存のインスタンスへの参照を返します。 <paramref name="totalWidth" /> がこのインスタンスの長さと等しい場合、メソッドはこのインスタンスと同一の新しい文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29>返される文字列の末尾が埋め込まれます。 これは、右から左の言語で使用すると、文字列の左側の部分が埋められることを意味します。  
  
> [!NOTE]
>  場合、<xref:System.String.PadRight%2A>現在のインスタンスの空白文字が埋め込まれます、このメソッドは、現在のインスタンスの値を変更しません。 代わりに、末尾に埋め込みは、新しい文字列を返します`paddingChar`文字がその合計の長さがように`totalWidth`文字。  
  
   
  
## Examples  
 次の例で、<xref:System.String.PadRight%2A>メソッド。  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> が 0 未満です。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の文字列から指定された文字数を削除した新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">文字を削除する際の 0 から始まる開始位置。</param>
        <summary>現在のインスタンスの指定した位置から指定した最後の位置までの全文字が削除された新しい文字列を返します。</summary>
        <returns>この文字列から対象となる文字を取り除いた新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]文字列は 0 から始まります。 値、`startIndex`パラメーターの範囲は 0 から文字列インスタンスの長さより 1 少ない数にします。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、その新しい文字列を返すすべての文字の位置から`startIndex`元の文字列の末尾までが削除されました。  
  
   
  
## Examples  
 次の例で、<xref:System.String.Remove%2A>メソッド。 [次へ]、最後のケースでは、文字列の末尾から指定したインデックスから始まるすべてのテキストを削除します。 最後の場合は、指定したインデックスから始まる次の 3 つの文字を削除します。  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が 0 未満です。  
  
- または - 
 <paramref name="startIndex" /> が、この文字列内にはない位置を指定しています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">文字を削除する際の 0 から始まる開始位置。</param>
        <param name="count">削除する文字数。</param>
        <summary>現在のインスタンス内の指定した位置から指定した文字数が削除された新しい文字列を返します。</summary>
        <returns>このインスタンスから対象となる文字を取り除いた新しい文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]文字列は 0 から始まります。 値、`startIndex`パラメーターの範囲は 0 から文字列インスタンスの長さより 1 少ない数にします。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、文字の数がで指定されている新しい文字列を返します、`count`パラメーターが削除されました。 指定された位置にある、文字を削除する`startIndex`します。  
  
   
  
## Examples  
 次の例では、完全な名前をミドル ネームを削除する方法を示します。  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="count" /> のいずれかが 0 より小さい値です。  
  
- または - 
 <paramref name="startIndex" /> に <paramref name="count" /> を加えたものが、このインスタンスの外部の位置を指定しています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の文字列に出現する指定した Unicode 文字または <see cref="T:System.String" /> をすべて、別の指定した Unicode 文字または <see cref="T:System.String" /> に置換した新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">置換する Unicode 文字。</param>
        <param name="newChar">出現するすべての <paramref name="oldChar" /> を置換する Unicode 文字。</param>
        <summary>このインスタンスに出現する指定された Unicode 文字をすべて、別の指定された Unicode 文字に置換した新しい文字列を返します。</summary>
        <returns>
          <paramref name="oldChar" /> のすべてのインスタンスが <paramref name="newChar" /> で置換されることを除いて、このインスタンスと等価な文字列。 <paramref name="oldChar" /> が現在のインスタンス内に見つからない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを検索する序数に基づく (大文字と小文字およびカルチャに依存しない) 検索を実行`oldChar`します。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、すべての出現箇所で新しい文字列を返します`oldChar`は置き換えられます`newChar`します。  
  
 このメソッドは、変更後の文字列を返すため、連結を連続して呼び出す、<xref:System.String.Replace%2A>元の文字列に対して複数の置換を実行するメソッド。 メソッドの呼び出しは、左から右に実行されます。 具体的な例を次に示します。  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 次の例では、一連の数字の間にある空白をコンマに置き換えることで、コンマ区切り値リストを作成します。  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">置換される文字列。</param>
        <param name="newValue">出現するすべての <paramref name="oldValue" /> を置換する文字列。</param>
        <summary>現在のインスタンスに出現する指定した文字列をすべて、別に指定した文字列に置換した新しい文字列を返します。</summary>
        <returns>
          <paramref name="oldValue" /> のすべてのインスタンスが <paramref name="newValue" /> で置き換えられることを除いて、現在の文字列と等価な文字列。 <paramref name="oldValue" /> が現在のインスタンス内に見つからない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`newValue`は`null`、出現するすべての`oldValue`が削除されます。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、すべての出現箇所で新しい文字列を返します`oldValue`は置き換えられます`newValue`します。  
  
 このメソッドを検索する序数に基づく (大文字と小文字およびカルチャに依存しない) 検索を実行`oldValue`します。  
  
 このメソッドは、変更後の文字列を返すため、連結を連続して呼び出す、<xref:System.String.Replace%2A>元の文字列に対して複数の置換を実行するメソッド。 メソッドの呼び出しは、左から右に実行されます。 具体的な例を次に示します。  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 次の例を使用する方法、<xref:System.String.Replace%2A>スペル ミスを修正する方法。  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> が空の文字列 ("") です。</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンス内の、指定された文字列または Unicode 文字の配列の要素で区切られた部分文字列を格納する文字列配列を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A> 区切られた文字列を部分文字列に分割に使用されます。 0、1、または複数の区切り文字を指定する文字配列を使用することができます (、<xref:System.String.Split%28System.Char%5B%5D%29>メソッド)、または 0、1、または複数の区切り記号文字列を指定する文字配列を使用することができます。 オーバー ロード、<xref:System.String.Split%2A>メソッドを使用するメソッドによって返される部分文字列の数を制限できます (、<xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29>メソッド)、空の文字列が返される部分文字列に含まれるかどうかを判断する (、<xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29>と<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29>メソッド、または両方を処理する (、<xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29>と<xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29>メソッド)。  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

### <a name="alternatives-to-stringsplit"></a>String.Split に代わる方法

 <xref:System.String.Split%2A>常に区切られた文字列を部分文字列に分割する最善の方法がメソッドではありません。 区切られた文字列の部分文字列のすべてを展開したくない場合、または区切り文字のセットではなくパターンに基づいて文字列を解析する場合は、次の代替策を検討してください。  
  
### <a name="regular-expressions"></a>正規表現  
 文字列は、一定のパターンに準拠している場合、は、抽出して、要素を処理する正規表現を使用できます。 たとえば、次の文字列形式になります"*数**オペランド**数*"を使用することができます、[正規](~/docs/standard/base-types/regular-expressions.md)を抽出し、処理、文字列の要素。 次に例を示します。  
  
 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 正規表現パターン`(\d+)\s+([-+*/])\s+(\d+)`次のように定義されます。  
  
|パターン|説明|  
|-------------|-----------------|  
|`(\d+)`|1 個以上の 10 進数と一致します。 これが最初のキャプチャ グループです。|  
|`\s+`|1 つ以上の空白文字と一致します。|  
|`([-+*/])`|一致、算術演算子の符号 (+、-、*、または/)。 これが 2 番目のキャプチャ グループです。|  
|`\s+`|1 つ以上の空白文字と一致します。|  
|`(\d+)`|1 個以上の 10 進数と一致します。 これが 3 番目のキャプチャ グループです。|  
  
 文字の固定セットではなく、パターンに基づく文字列から部分文字列を抽出するのに正規表現を使用することもできます。 これは、これらの条件のいずれかが発生したときの一般的なシナリオです。  
  
-   1 つ以上の区切り文字が常を処理しないで区切り記号として、<xref:System.String>インスタンス。  
  
-   区切り記号文字の数と順序が変数または不明です。  
  
 たとえば、<xref:System.String.Split%2A>次の文字列を分割するメソッドを使用できませんの数`\n`(で C# の場合) または`vbCrLf`(Visual Basic) で文字は、変数、および区切り記号として使用され、常にはありません。  
  
```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
```  
  
 正規表現では、簡単に、次の例はこの文字列を分割できます。  
  
 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 正規表現パターン`\[([^\[\]]+)\]`次のように定義されます。  
  
|パターン|説明|  
|-------------|-----------------|  
|`\[`|始め角かっこと一致します。|  
|`([^\[\]]+)`|開始または右角かっこを 1 回以上の任意の文字と一致します。 これが最初のキャプチャ グループです。|  
|`\]`|右角かっこと一致します。|  
  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>メソッドとほぼ同じ<xref:System.String.Split%2A?displayProperty=nameWithType>、固定された文字セットではなく正規表現パターンに基づく文字列を分割する点が異なります。 たとえば、次の例を使用して、<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>ハイフン、およびその他の文字のさまざまな組み合わせで区切られた部分文字列を格納する文字列を分割します。  
  
 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 正規表現パターン`\s-\s?[+*]?\s?-\s`次のように定義されます。  
  
|パターン|説明|  
|-------------|-----------------|  
|`\s-`|ハイフンの後に空白文字と一致します。|  
|`\s?`|0 個または 1 個の空白文字と一致します。|  
|`[+*]?`|0 個または 1 つのいずれかに一致、+ または * の文字。|  
|`\s?`|0 個または 1 個の空白文字と一致します。|  
|`-\s`|空白文字が続くハイフンと一致します。|  
  
### <a name="search-methods-and-the-substring-method"></a>検索方法と Substring メソッド  
 文字列から部分文字列のすべてに興味はない場合、一致が開始されるインデックスを返す文字列比較メソッドのいずれかを使用することもできます。 呼び出して、<xref:System.String.Substring%2A>メソッドを使用する部分文字列を抽出します。 文字列比較メソッドは、次のとおりです。  
  
-   <xref:System.String.IndexOf%2A>、文字列インスタンスで最初に出現する文字または文字列の 0 から始まるインデックスが返されます。  
  
-   <xref:System.String.IndexOfAny%2A>、0 から始まるインデックスを最初に出現する文字配列の任意の文字の現在の文字列インスタンスで返されます。  
  
-   <xref:System.String.LastIndexOf%2A>、文字列インスタンスで最後に出現する文字または文字列の 0 から始まるインデックスが返されます。  
  
-   <xref:System.String.LastIndexOfAny%2A>、0 から始まるインデックスを最後に出現する文字配列の任意の文字の現在の文字列インスタンスで返されます。  
  
 次の例では、<xref:System.String.IndexOf%2A>メソッドを文字列内の期間を検索します。 次を使用して、<xref:System.String.Substring%2A>完全な文を返します。  
  
 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字配列、区切り文字が含まれていない空の配列、または <see langword="null" />。</param>
        <summary>配列内の文字に基づいて文字列を部分文字列に分割します。</summary>
        <returns>このインスタンスを <paramref name="separator" /> の 1 つ以上の文字で区切った部分文字列を要素に格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文字列は、既知の一連の文字で区切られた、ときに使用できます、<xref:System.String.Split%28System.Char%5B%5D%29>メソッドを部分文字列に分割します。   
  
### <a name="return-value-details"></a>戻り値の詳細  
 返される配列の要素では、区切り記号の文字は含まれません。 たとえば、区切り記号の配列に文字が含まれています"-"と、現在の文字列インスタンスの値は"aa、bb、cc"、3 つの要素を含む配列を返します:"aa"、"bb"、"cc"。  
  
 このインスタンスに文字が含まれていないかどうかは`separator`、返される配列は、このインスタンスを含む 1 つの要素で構成されています。  
  
 各要素`separator`別の区切り記号を定義します。 返される配列に対応する要素に含まれる 2 つの区切り記号は、隣接するセル、または区切り記号が先頭またはこのインスタンスの末尾に見つかった、<xref:System.String.Empty>します。 次にいくつかの例を示します。  
  
|文字列値|区切り記号|返される配列|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|新しい文字の {','、' '} (C#)<br /><br /> Char() = {「,」c""c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|新しい文字の {'. '} (C#)<br /><br /> Char() = {0}"."c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|"Banana"|新しい文字の {'. '} (C#)<br /><br /> Char() = {0}"."c} (Visual Basic)|{"Banana"}|  
|"Darb\nSmarba"(c#)<br /><br /> "Darb"& vbLf"Smarba"(Visual Basic)|新しいを Char {} (C#)<br /><br /> Char() = {} (Visual Basic)|{"Darb"、"Smarba"}|  
|"Darb\nSmarba"(c#)<br /><br /> "Darb"& vbLf"Smarba"(Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Darb"、"Smarba"}|  
  
### <a name="the-separator-array"></a>区切り記号の配列  
 区切り記号の各要素は、単一の文字で構成されている別の区切り記号を定義します。 場合、`separator`引数が`null`文字が含まれていない、またはメソッドの空白文字を区切り記号として扱われます。 空白文字が Unicode 標準; で定義されています。返される`true`に渡された場合、<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>メソッド。  
  
### <a name="stringsplitchar-and-compiler-overload-resolution"></a>String.Split(Char[]) コンパイラ オーバー ロードの解決  
 このオーバー ロードの 1 つのパラメーター<xref:System.String.Split%2A?displayProperty=nameWithType>文字配列では、次の例として、単一の文字を呼び出すことができます。  
  
 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 `separator`でパラメーターが修飾されて、<xref:System.ParamArrayAttribute>属性に、コンパイラでは、1 つの要素の文字配列として単一の文字が解釈されます。 これは他のケースではありません<xref:System.String.Split%2A?displayProperty=nameWithType>含むオーバー ロードを`separator`; パラメーターを渡す必要があります明示的にこれらのオーバー ロードとして文字配列、`separator`引数。  
  
### <a name="comparison-details"></a>比較の詳細  
 <xref:System.String.Split%28System.Char%5B%5D%29>メソッドが 1 つ以上の文字で区切られた、この文字列の部分文字列を抽出し、`separator`配列、および配列の要素としてそれらの部分文字列を返します。  
  
 <xref:System.String.Split%28System.Char%5B%5D%29>メソッドが大文字の序数の並べ替え規則を使用する比較を実行することでは区切り記号を検索します。 単語、文字列、および序数の並べ替えの詳細については、次を参照してください。、<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列挙体。  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 <xref:System.String.Split%2A>メソッドが返される配列オブジェクトのメモリを割り当てると、<xref:System.String>配列の各要素のオブジェクト。 アプリケーションに最適なパフォーマンスを必要な場合、またはメモリの割り当てを管理するは、アプリケーションで重要な場合は、使用を検討して、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>メソッド。 使用するオプションもある、<xref:System.String.Compare%2A>文字列内の部分文字列を検索するメソッド。  
  
 区切り記号文字の文字列を分割するには、使用、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>文字列の区切り記号の文字を検索するメソッド。 文字列に区切り記号文字列を分割するには、使用、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>区切り記号の文字列の最初の文字を検索するメソッド。 使用して、<xref:System.String.Compare%2A>その最初の文字の後に文字が区切り記号の文字列の残りの文字に等しいかどうかを判断するメソッド。  
  
 さらに、同じ設定する場合の文字が使用で複数の文字列を分割する<xref:System.String.Split%2A>メソッドの呼び出しが 1 つの配列を作成して、各メソッド呼び出しで参照することを検討してください。 これには、各メソッド呼び出しのオーバーヘッドが大幅に削減されます。  
  
## Examples  
 次の例では、空白や句読点を区切り記号として扱うことにより、テキストのブロックから個々 の単語を抽出する方法を示します。 渡された文字の配列、`separator`のパラメーター、<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>メソッドは、空白文字とと共に一部の一般的な区切り記号のタブ文字で構成されます。  
  
 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]以前のバージョンでは場合、<see cref="M:System.String.Split(System.Char[])" />メソッドに渡されます、<paramref name="separator" />は<see langword="null" />文字が含まれていない、またはメソッドは若干異なる一連の文字を使用してよりも文字列を分割する、<see cref="M:System.String.Trim(System.Char[])" />メソッドには文字列を切り捨てます。 以降、.NET Framework 4 では、どちらの方法は、同一 Unicode の空白文字のセットを使用します。</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字配列、区切り文字が含まれていない空の配列、または <see langword="null" />。</param>
        <param name="count">返される最大の部分文字列数。</param>
        <summary>配列内の文字に基づいて文字列を最大数の部分文字列に分割します。 返される部分文字列の最大数を指定します。</summary>
        <returns>このインスタンスを、<paramref name="separator" /> 配列のいずれかまたは複数の要素 (文字) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返される配列の要素では、区切り記号の文字は含まれません。  
  
 このインスタンスに文字が含まれていないかどうかは`separator`、返される配列は、このインスタンスを含む 1 つの要素で構成されています。 場合`count`0 の場合は、空の配列が返されます。  
  
 場合、`separator`パラメーターが`null`文字が含まれていない、または空白文字が区切り記号と見なされます。 空白文字が Unicode 標準および戻り値によって定義されます`true`に渡された場合、<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>メソッド。  
  
 各要素`separator`別の区切り記号を定義します。 配列の対応する要素を含む 2 つの区切り記号は、隣接するセル、または区切り記号が先頭またはこのインスタンスの末尾に見つかった、<xref:System.String.Empty>します。  
  
 ある場合は、複数の`count`、このインスタンス内の部分文字列最初`count`マイナス 1 の部分文字列が最初に返されます`count`-1、戻り値のこのインスタンスの残りの文字が最後に返されます戻り値の要素。  
  
 場合`count`数より大きい、部分文字列の使用可能な部分文字列が返され、例外はスローされません。  
  
 次の表では、例を示します。  
  
|文字列値|区切り記号|カウント|返される配列|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|新しい文字の {','、' '} (C#)<br /><br /> Char() = {「,」c""c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|新しい文字の {'. '} (C#)<br /><br /> Char() = {0}"."c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|"Banana"|新しい文字の {'. '} (C#)<br /><br /> Char() = {0}"."c} (Visual Basic)|2|{"Banana"}|  
|"Darb\nSmarba"(c#)<br /><br /> "Darb"& vbLf"Smarba"(Visual Basic)|新しいを Char {} (C#)<br /><br /> Char() = {} (Visual Basic)|1|{"Darb\nSmarba"}(C#)<br /><br /> "Darb"& vbLf"Smarba"(Visual Basic)|  
|"Darb\nSmarba"(c#)<br /><br /> "Darb"& vbLf"Smarba"(Visual Basic)|null の新しい char[] (C#)<br /><br /> Char() = Nothing|2|{"Darb"、"Smarba"}|  
|"Darb\nSmarba"(c#)<br /><br /> "Darb"& vbLf"Smarba"(Visual Basic)|null の新しい char[] (C#)<br /><br /> Char() = Nothing|100|{"Darb"、"Smarba"}|  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 <xref:System.String.Split%2A>メソッドが返される配列オブジェクトのメモリを割り当てると、<xref:System.String>配列の各要素のオブジェクト。 アプリケーションに最適なパフォーマンスを必要な場合、またはメモリの割り当てを管理するは、アプリケーションで重要な場合は、使用を検討して、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>メソッド、および必要に応じて、<xref:System.String.Compare%2A>メソッドは、文字列内の部分文字列を検索します。  
  
 区切り記号文字の文字列を分割する場合は、使用、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>文字列の区切り記号の文字を検索するメソッド。 文字列に区切り記号文字列を分割する場合は、使用、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>区切り記号の文字列の最初の文字を検索するメソッド。 使用して、<xref:System.String.Compare%2A>その最初の文字の後に文字が区切り記号の文字列の残りの文字に等しいかどうかを判断するメソッド。  
  
 さらに、同じ設定する場合の文字が使用で複数の文字列を分割する<xref:System.String.Split%2A>メソッドの呼び出しが 1 つの配列を作成して、各メソッド呼び出しで参照することを検討してください。 これには、各メソッド呼び出しのオーバーヘッドが大幅に削減されます。  
  
   
  
## Examples  
 次の例でどのように`count`によって返される文字列の数に影響を与えます<xref:System.String.Split%2A>します。  
  
 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が負の値です。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]以前のバージョンでは場合、<see cref="M:System.String.Split(System.Char[])" />メソッドに渡されます、<paramref name="separator" />は<see langword="null" />文字が含まれていない、またはメソッドは若干異なる一連の文字を使用してよりも文字列を分割する、<see cref="M:System.String.Trim(System.Char[])" />メソッドには文字列を切り捨てます。 以降、.NET Framework 4 では、どちらの方法は、同一 Unicode の空白文字のセットを使用します。</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字配列、区切り文字が含まれていない空の配列、または <see langword="null" />。</param>
        <param name="options">返される配列から空の配列要素を省略する場合は <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />。返される配列に空の配列要素も含める場合は <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>配列内の文字に基づいて文字列を部分文字列に分割します。 部分文字列が空の配列の要素を含めるかどうかを指定することができます。</summary>
        <returns>この文字列を、<paramref name="separator" /> 配列のいずれかまたは複数の要素 (文字) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>戻り値の詳細  
 区切り記号文字 (文字、`separator`配列) は、返される配列の要素に含まれません。 たとえば場合、`separator`配列には、文字が含まれています。"-"と現在の文字列インスタンスの値は"aa、bb、cc"、3 つの要素を含む配列を返します:"aa"、"bb"、"cc"。  
  
 このインスタンスに文字が含まれていないかどうかは`separator`、返される配列は、このインスタンスを含む 1 つの要素で構成されています。  
  
 場合、`options`パラメーターが<xref:System.StringSplitOptions.RemoveEmptyEntries>とこのインスタンスの長さがゼロ、空の配列を返します。  
  
 各要素`separator`単一の文字で構成されている別の区切り記号を定義します。 場合、`options`引数が<xref:System.StringSplitOptions.None>、2 つの区切り記号は隣接して、または配列の対応する要素を含む、先頭または、このインスタンスの末尾に、区切り記号が見つかった<xref:System.String.Empty?displayProperty=nameWithType>します。 たとえば場合、 `separator` 2 つの要素が含まれています"-"と"\_"、文字列インスタンスの値が"-\_aa -\_"の値、`options`引数が<xref:System.StringSplitOptions.None>メソッドの文字列配列を返します次の 5 つの要素。  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>を前にある空の文字列を表す、"-"インデックス 0 位置にある文字。  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>、間の空の文字列を表す、"-"インデックス 0 と 1 のインデックス位置にある文字「_」にある文字。  
  
3.  "aa"など  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>を表すインデックス 4 文字「_」に続く空の文字列。  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>、次の空の文字列を表す、"-"文字のインデックスを 5 にします。  
  
### <a name="the-separator-array"></a>区切り記号の配列  
 場合、`separator`パラメーターが`null`文字が含まれていない、または空白文字が区切り記号と見なされます。 空白文字が Unicode 標準および戻り値によって定義されます`true`に渡された場合、<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>メソッド。  
  
 場合、`separator`このメソッドのオーバー ロードの呼び出しでパラメーターが`null`コンパイラのオーバー ロードの解決は失敗します。 呼び出されたメソッドを明確に識別するコードがの型を示す必要があります、`null`します。 次の例では、このオーバー ロードを明確に識別するためにいくつかの方法を示します。  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
### <a name="comparison-details"></a>比較の詳細  
 <xref:System.String.Split%2A>メソッドが 1 つ以上の文字で区切られた、この文字列の部分文字列を抽出し、`separator`パラメーター、配列の要素としてそれらの部分文字列を返します。  
  
 <xref:System.String.Split%2A>メソッドが大文字の序数の並べ替え規則を使用する比較を実行することでは区切り記号を検索します。 単語、文字列、および序数の並べ替えの詳細については、次を参照してください。、<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列挙体。  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 <xref:System.String.Split%2A>メソッドが返される配列オブジェクトのメモリを割り当てると、<xref:System.String>配列の各要素のオブジェクト。 アプリケーションに最適なパフォーマンスを必要な場合、またはメモリの割り当てを管理するは、アプリケーションで重要な場合は、使用を検討して、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>メソッド、および必要に応じて、<xref:System.String.Compare%2A>メソッドは、文字列内の部分文字列を検索します。  
  
 区切り記号文字の文字列を分割する場合は、使用、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>文字列の区切り記号の文字を検索するメソッド。 文字列に区切り記号文字列を分割する場合は、使用、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>区切り記号の文字列の最初の文字を検索するメソッド。 使用して、<xref:System.String.Compare%2A>その最初の文字の後に文字が区切り記号の文字列の残りの文字に等しいかどうかを判断するメソッド。  
  
 さらに、同じ設定する場合の文字が使用で複数の文字列を分割する<xref:System.String.Split%2A>メソッドの呼び出しが 1 つの配列を作成して、各メソッド呼び出しで参照することを検討してください。 これには、各メソッド呼び出しのオーバーヘッドが大幅に削減されます。  
  
   
  
## Examples  
 次の例では、<xref:System.StringSplitOptions>列挙体によって生成された部分文字列を含めたり除外したり、<xref:System.String.Split%2A>メソッド。  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> は <see cref="T:System.StringSplitOptions" /> 値のいずれでもありません。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]以前のバージョンでは場合、<see cref="M:System.String.Split(System.Char[])" />メソッドに渡されます、<paramref name="separator" />は<see langword="null" />文字が含まれていない、またはメソッドは若干異なる一連の文字を使用してよりも文字列を分割する、<see cref="M:System.String.Trim(System.Char[])" />メソッドには文字列を切り捨てます。 以降、.NET Framework 4 では、どちらの方法は、同一 Unicode の空白文字のセットを使用します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字列配列。区切り文字が含まれていない空の配列。または <see langword="null" />。</param>
        <param name="options">返される配列から空の配列要素を省略する場合は <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />。返される配列に空の配列要素も含める場合は <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>配列内の文字列に基づいて文字列を部分文字列に分割します。 部分文字列が空の配列の要素を含めるかどうかを指定することができます。</summary>
        <returns>この文字列を、<paramref name="separator" /> 配列のいずれかまたは複数の要素 (文字列) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文字列は、既知の一連の文字列で区切られた、ときに使用できます、<xref:System.String.Split%2A>メソッドを部分文字列に分割します。  
  
### <a name="return-value-details"></a>戻り値の詳細  
 区切り記号の文字列は、返される配列の要素には含まれません。 たとえば場合、`separator`配列には、文字列が含まれています。"-"と現在の文字列インスタンスの値は"aa--bb cc"、3 つの要素を含む配列を返します:"aa"、"bb"、"cc"。  
  
 このインスタンスに内の文字列が含まれていないかどうかは`separator`、返される配列は、このインスタンスを含む 1 つの要素で構成されています。  
  
 場合、`options`パラメーターが<xref:System.StringSplitOptions.RemoveEmptyEntries>とこのインスタンスの長さがゼロ、空の配列を返します。  
  
 各要素`separator`1 つまたは複数の文字で構成されている別の区切り記号を定義します。 場合、`options`引数が<xref:System.StringSplitOptions.None>、2 つの区切り記号は隣接して、または配列の対応する要素を含む、先頭または、このインスタンスの末尾に、区切り記号が見つかった<xref:System.String.Empty?displayProperty=nameWithType>します。 たとえば場合、 `separator` 2 つの要素が含まれています"-"「_」文字列インスタンスの値は"- _aa -\_"との値、`options`引数が<xref:System.StringSplitOptions.None>メソッドは、次の 5 つの要素を持つ文字列配列を返します。  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>を前にある空の文字列を表す、"-"インデックス 0 位置にある部分文字列。  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>、間の空の文字列を表す、"-"インデックスが 0 と 1 のインデックス位置にある「_」の部分文字列に部分文字列。  
  
3.  "aa"など  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>を表すインデックス 4「_」の部分文字列を次の空の文字列。  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>、次の空の文字列を表す、"-"のインデックスを 5 にある部分文字列。  
  
### <a name="the-separator-array"></a>区切り記号の配列  
 内の要素のいずれか`separator`は、複数の文字の部分文字列全体は、区切り記号と見なされます。 たとえば、1 つの要素の`separator`は「10」、"This10is10a10string。"という文字列を分割しようとしています。 次の 4 つの要素の配列を返します: {"This"、"is"、"a"、「文字列」。 }.  
  
 場合、`separator`パラメーターが`null`文字が含まれていない、または空白文字が区切り記号と見なされます。 空白文字が Unicode 標準および戻り値によって定義されます`true`に渡された場合、<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>メソッド。  
  
 場合、`separator`このメソッドのオーバー ロードの呼び出しでパラメーターが`null`コンパイラのオーバー ロードの解決は失敗します。 呼び出されたメソッドを明確に識別するコードがの型を示す必要があります、`null`します。 次の例では、このオーバー ロードを明確に識別するためにいくつかの方法を示します。  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
### <a name="comparison-details"></a>比較の詳細  
 <xref:System.String.Split%2A>メソッドが 1 つ以上の内の文字列で区切られた、この文字列の部分文字列を抽出し、`separator`パラメーター、配列の要素としてそれらの部分文字列を返します。  
  
 <xref:System.String.Split%2A>メソッドが大文字の序数の並べ替え規則を使用する比較を実行することでは区切り記号を検索します。 単語、文字列、および序数の並べ替えの詳細については、次を参照してください。、<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列挙体。  
  
 <xref:System.String.Split%2A>メソッドは任意の要素を無視`separator`値が`null`または空の文字列 ("")。  
  
 あいまいな結果を回避するときにで文字列`separator`共通の文字がある、<xref:System.String.Split%2A>操作は、インスタンスの値の末尾に、先頭から開始されの最初の要素と一致する`separator`内の区切り記号と等しい、インスタンス。 部分文字列が、インスタンスで発生した順序で要素の順序よりも優先`separator`します。  
  
 たとえば、値を持つ"abcdef"のインスタンスがあるとします。 場合の最初の要素`separator`"ef"と 2 番目の要素が"bcde"に、split 操作の結果は 2 つの要素を格納する文字列配列になりますが、"a"および"f"です。 これは、"bcde"、インスタンス内の部分文字列が検出され、内の要素と一致するため`separator`前に、"f"の部分文字列が発生しました。  
  
 ただし場合の最初の要素`separator`"bcd"と 2 番目の要素が"bc"に、split 操作の結果は 2 つの要素を格納する文字列配列になりますが、"a"と"ef"。 これは最初の区切り記号が"bcd"`separator`インスタンス内の区切り記号に一致します。 "Bcd"に、2 番目の要素が、結果は 2 つの要素を格納する文字列配列になりますので、最初の要素は"bc"区切り記号の順序が取り消された場合、"a"と"def"。  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 <xref:System.String.Split%2A>メソッドが返される配列オブジェクトのメモリを割り当てると、<xref:System.String>配列の各要素のオブジェクト。 アプリケーションに最適なパフォーマンスを必要な場合、またはメモリの割り当てを管理するは、アプリケーションで重要な場合は、使用を検討して、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>メソッド、および必要に応じて、<xref:System.String.Compare%2A>メソッドは、文字列内の部分文字列を検索します。  
  
 区切り記号文字の文字列を分割する場合は、使用、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>文字列の区切り記号の文字を検索するメソッド。 文字列に区切り記号文字列を分割する場合は、使用、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>区切り記号の文字列の最初の文字を検索するメソッド。 使用して、<xref:System.String.Compare%2A>その最初の文字の後に文字が区切り記号の文字列の残りの文字に等しいかどうかを判断するメソッド。  
  
 さらに、同じ設定する場合の文字が使用で複数の文字列を分割する<xref:System.String.Split%2A>メソッドの呼び出しが 1 つの配列を作成して、各メソッド呼び出しで参照することを検討してください。 これには、各メソッド呼び出しのオーバーヘッドが大幅に削減されます。  
  
   
  
## Examples  
 次の例は、文字列を呼び出すことによって返された配列の違いを示しています。<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType>メソッドをその`options`パラメーターと等しい<xref:System.StringSplitOptions.None?displayProperty=nameWithType>と<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>します。  
  
 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 次の例では、区切り記号および空白文字を含む区切り記号の配列を定義します。 この配列の値と共に渡す<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>を<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29>メソッドは、文字列から個々 の単語で構成される配列を返します。  
  
 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 メソッドが呼び出されたメモ、`options`引数に設定<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>します。 これにより、返される配列を含む<xref:System.String.Empty?displayProperty=nameWithType>区切り記号と空白文字の間の空の部分文字列の一致を表す値。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> は <see cref="T:System.StringSplitOptions" /> 値のいずれでもありません。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]以前のバージョンでは場合、<see cref="M:System.String.Split(System.Char[])" />メソッドに渡されます、<paramref name="separator" />は<see langword="null" />文字が含まれていない、またはメソッドは若干異なる一連の文字を使用してよりも文字列を分割する、<see cref="M:System.String.Trim(System.Char[])" />メソッドには文字列を切り捨てます。 以降、.NET Framework 4 では、どちらの方法は、同一 Unicode の空白文字のセットを使用します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字配列、区切り文字が含まれていない空の配列、または <see langword="null" />。</param>
        <param name="count">返される最大の部分文字列数。</param>
        <param name="options">返される配列から空の配列要素を省略する場合は <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />。返される配列に空の配列要素も含める場合は <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>配列内の文字に基づいて文字列を最大数の部分文字列に分割します。</summary>
        <returns>この文字列を、<paramref name="separator" /> 配列のいずれかまたは複数の要素 (文字) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返される配列の要素では、区切り記号の文字は含まれません。  
  
 このインスタンスに文字が含まれていないかどうかは`separator`、または`count`パラメーターが 1 の場合、返される配列は、このインスタンスを含む 1 つの要素で構成されています。 場合、`separator`パラメーターが`null`文字が含まれていない、または空白文字が区切り記号と見なされます。 空白文字が Unicode 標準および戻り値によって定義されます`true`に渡された場合、<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>メソッド。 ただし場合、`separator`このメソッドのオーバー ロードの呼び出しでパラメーターが`null`コンパイラのオーバー ロードの解決は失敗します。 呼び出されたメソッドを明確に識別するには、コードは、null の種類を指定する必要があります。 次の例では、このオーバー ロードを明確に識別するためにいくつかの方法を示します。  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 場合、`count`パラメーターが 0、または`options`パラメーターが<xref:System.StringSplitOptions.RemoveEmptyEntries>し、このインスタンスの長さが 0、空の配列が返されます。  
  
 各要素`separator`別の区切り記号を定義します。 場合、`options`パラメーターが<xref:System.StringSplitOptions.None>、2 つの区切り記号は隣接して、または配列の対応する要素を含む、先頭または、このインスタンスの末尾に、区切り記号が見つかった<xref:System.String.Empty>します。  
  
 ある場合は、複数の`count`、このインスタンス内の部分文字列最初`count`マイナス 1 の部分文字列が最初に返されます`count`-1、戻り値のこのインスタンスの残りの文字が最後に返されます戻り値の要素。  
  
 場合`count`数より大きい、部分文字列の使用可能な部分文字列が返され、例外はスローされません。  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 <xref:System.String.Split%2A>メソッドが返される配列オブジェクトのメモリを割り当てると、<xref:System.String>配列の各要素のオブジェクト。 アプリケーションに最適なパフォーマンスを必要な場合、またはメモリの割り当てを管理するは、アプリケーションで重要な場合は、使用を検討して、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>メソッド、および必要に応じて、<xref:System.String.Compare%2A>メソッドは、文字列内の部分文字列を検索します。  
  
 区切り記号文字の文字列を分割する場合は、使用、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>文字列の区切り記号の文字を検索するメソッド。 文字列に区切り記号文字列を分割する場合は、使用、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>区切り記号の文字列の最初の文字を検索するメソッド。 使用して、<xref:System.String.Compare%2A>その最初の文字の後に文字が区切り記号の文字列の残りの文字に等しいかどうかを判断するメソッド。  
  
 さらに、同じ設定する場合の文字が使用で複数の文字列を分割する<xref:System.String.Split%2A>メソッドの呼び出しが 1 つの配列を作成して、各メソッド呼び出しで参照することを検討してください。 これには、各メソッド呼び出しのオーバーヘッドが大幅に削減されます。  
  
   
  
## Examples  
 次の例では、<xref:System.StringSplitOptions>列挙体によって生成された部分文字列を含めたり除外したり、<xref:System.String.Split%2A>メソッド。  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が負の値です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> は <see cref="T:System.StringSplitOptions" /> 値のいずれでもありません。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]以前のバージョンでは場合、<see cref="M:System.String.Split(System.Char[])" />メソッドに渡されます、<paramref name="separator" />は<see langword="null" />文字が含まれていない、またはメソッドは若干異なる一連の文字を使用してよりも文字列を分割する、<see cref="M:System.String.Trim(System.Char[])" />メソッドには文字列を切り捨てます。 以降、.NET Framework 4 では、どちらの方法は、同一 Unicode の空白文字のセットを使用します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">この文字列から部分文字列を取り出すために区切り文字として使用する文字列配列。区切り文字が含まれていない空の配列。または <see langword="null" />。</param>
        <param name="count">返される最大の部分文字列数。</param>
        <param name="options">返される配列から空の配列要素を省略する場合は <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />。返される配列に空の配列要素も含める場合は <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>配列内の文字列に基づいて文字列を最大数の部分文字列に分割します。 部分文字列が空の配列の要素を含めるかどうかを指定することができます。</summary>
        <returns>この文字列を、<paramref name="separator" /> 配列のいずれかまたは複数の要素 (文字列) で区切ることによって取り出された部分文字列を格納する配列。 詳細については、「解説」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>戻り値の詳細  
 区切り記号の文字列は、返される配列の要素には含まれません。  
  
 このインスタンスに内の文字列が含まれていないかどうかは`separator`、または`count`パラメーターが 1 の場合、返される配列は、このインスタンスを含む 1 つの要素で構成されています。 場合、`separator`パラメーターが`null`文字が含まれていない、または空白文字が区切り記号と見なされます。 空白文字が Unicode 標準および戻り値によって定義されます`true`に渡された場合、<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>メソッド。 ただし場合、`separator`このメソッドのオーバー ロードの呼び出しでパラメーターが`null`コンパイラのオーバー ロードの解決は失敗します。 呼び出されたメソッドを明確に識別するコードがの型を示す必要があります、`null`します。 次の例では、このオーバー ロードを明確に識別するためにいくつかの方法を示します。  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 場合、`count`パラメーターが 0、または`options`パラメーターが<xref:System.StringSplitOptions.RemoveEmptyEntries>し、このインスタンスの長さが 0、空の配列が返されます。  
  
 各要素`separator`1 つまたは複数の文字で構成されている別の区切り記号を定義します。 場合、`options`パラメーターが<xref:System.StringSplitOptions.None>、2 つの区切り記号は隣接して、または配列の対応する要素を含む、先頭または、このインスタンスの末尾に、区切り記号が見つかった<xref:System.String.Empty>します。  
  
 ある場合は、複数の`count`、このインスタンス内の部分文字列最初`count`マイナス 1 の部分文字列が最初に返されます`count`-1、戻り値のこのインスタンスの残りの文字が最後に返されます戻り値の要素。  
  
 場合`count`数より大きい、部分文字列の使用可能な部分文字列が返され、例外はスローされません。  
  
### <a name="the-separator-array"></a>区切り記号の配列  
 内の要素のいずれか`separator`は、複数の文字の部分文字列全体は、区切り記号と見なされます。 たとえば、1 つの要素の`separator`は「10」、"This10is10a10string。"という文字列を分割しようとしています。 この 4 つの要素の配列を返します: {"This"、"is"、"a"、「文字列」。 }.  
  
### <a name="comparison-details"></a>比較の詳細  
 <xref:System.String.Split%2A>メソッドが 1 つ以上の内の文字列で区切られた、この文字列の部分文字列を抽出し、`separator`パラメーター、配列の要素としてそれらの部分文字列を返します。  
  
 <xref:System.String.Split%2A>メソッドが大文字の序数の並べ替え規則を使用する比較を実行することでは区切り記号を検索します。 単語、文字列、および序数の並べ替えの詳細については、次を参照してください。、<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列挙体。  
  
 <xref:System.String.Split%2A>メソッドは任意の要素を無視`separator`値が`null`または空の文字列 ("")。  
  
 あいまいな結果を回避するときにで文字列`separator`共通の文字がある、<xref:System.String.Split%2A>メソッドは、インスタンスの値の末尾に、先頭から開始されの最初の要素と一致する`separator`内の区切り記号と等しい、インスタンス。 部分文字列が、インスタンスで発生した順序で要素の順序よりも優先`separator`します。  
  
 たとえば、値を持つ"abcdef"のインスタンスがあるとします。 場合の最初の要素`separator`"bcde"を"ef"と 2 番目の要素が、split 操作の結果になりますが、"a"および"f"です。 これは、"bcde"、インスタンス内の部分文字列が検出され、内の要素と一致するため`separator`前に、"f"の部分文字列が発生しました。  
  
 ただし場合の最初の要素`separator`"bc"を"bcd"と 2 番目の要素が、split 操作の結果になりますが、"a"と"ef"。 これは最初の区切り記号が"bcd"`separator`インスタンス内の区切り記号に一致します。 "Bcd"に、2 番目の要素が、結果になりますので、最初の要素は"bc"区切り記号の順序が取り消された場合、"a"と"def"。  
  
### <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 <xref:System.String.Split%2A>メソッドが返される配列オブジェクトのメモリを割り当てると、<xref:System.String>配列の各要素のオブジェクト。 アプリケーションに最適なパフォーマンスを必要な場合、またはメモリの割り当てを管理するは、アプリケーションで重要な場合は、使用を検討して、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>メソッド、および必要に応じて、<xref:System.String.Compare%2A>メソッドは、文字列内の部分文字列を検索します。  
  
 区切り記号文字の文字列を分割する場合は、使用、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>文字列の区切り記号の文字を検索するメソッド。 文字列に区切り記号文字列を分割する場合は、使用、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOfAny%2A>区切り記号の文字列の最初の文字を検索するメソッド。 使用して、<xref:System.String.Compare%2A>その最初の文字の後に文字が区切り記号の文字列の残りの文字に等しいかどうかを判断するメソッド。  
  
 さらに、同じ設定する場合の文字が使用で複数の文字列を分割する<xref:System.String.Split%2A>メソッドの呼び出しが 1 つの配列を作成して、各メソッド呼び出しで参照することを検討してください。 これには、各メソッド呼び出しのオーバーヘッドが大幅に削減されます。  
  
   
  
## Examples  
 次の例では、<xref:System.StringSplitOptions>列挙体によって生成された部分文字列を含めたり除外したり、<xref:System.String.Split%2A>メソッド。  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が負の値です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> は <see cref="T:System.StringSplitOptions" /> 値のいずれでもありません。</exception>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]以前のバージョンでは場合、<see cref="M:System.String.Split(System.Char[])" />メソッドに渡されます、<paramref name="separator" />は<see langword="null" />文字が含まれていない、またはメソッドは若干異なる一連の文字を使用してよりも文字列を分割する、<see cref="M:System.String.Trim(System.Char[])" />メソッドには文字列を切り捨てます。 以降、.NET Framework 4 では、どちらの方法は、同一 Unicode の空白文字のセットを使用します。</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列インスタンスの先頭が、指定した文字列と一致するかどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">比較対象の文字列。</param>
        <summary>この文字列インスタンスの先頭が、指定した文字列と一致するかどうかを判断します。</summary>
        <returns>この文字列の先頭が <paramref name="value" /> と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは比較`value`のこのインスタンスと同じ長さである先頭の部分文字列`value`、それらが等しいかどうか示す値を返します。 等しいもの`value`空の文字列を指定する必要があります (<xref:System.String.Empty?displayProperty=nameWithType>)、この同じインスタンスへの参照があります。 または、このインスタンスの先頭に一致する必要があります。  
  
 このメソッドは、現在のカルチャを使用して、単語 (大文字小文字を区別し、カルチャに依存) 比較を実行します。  
  
   
  
## Examples  
 次の例では、定義、`StripStartTags`メソッドを使用する、 <xref:System.String.StartsWith%28System.String%29> HTML を削除する方法は、文字列の先頭からタグを起動します。 なお、`StripStartTags`メソッドには、行の先頭に複数の HTML 開始タグが削除されるようにするには、再帰的には呼び出されます。 例では、文字列に埋め込まれた HTML タグは削除されません。  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>説明したよう[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)既定値を代入しを明示的に指定するパラメーターを必要とするメソッドを呼び出す代わりに文字列比較メソッドを呼び出さないようにすることをお勧めします。 文字列が現在のカルチャの文字列比較の規則を使用して、特定の部分文字列で始まるかどうかを確認するのには、呼び出し、<see cref="M:System.String.StartsWith(System.String,System.StringComparison)" />メソッドのオーバー ロードの値を持つ<see cref="F:System.StringComparison.CurrentCulture" />の<paramref name="comparisonType" />パラメーター。</para>
        </block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">比較対象の文字列。</param>
        <param name="comparisonType">この文字列と <paramref name="value" /> との比較方法を決定する列挙値の 1 つ。</param>
        <summary>指定された比較オプションを使って比較した場合に、この文字列インスタンスの先頭が、指定された文字列と一致するかどうかを判断します。</summary>
        <returns>インスタンスが <see langword="true" /> で開始する場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.StartsWith%2A>メソッドの比較、`value`この文字列の先頭の部分文字列のパラメーターが等しいかどうかを示す値を返します。 等しく、`value`この同じ文字列への参照である必要があります、空の文字列にする必要があります ("")、またはこの文字列の先頭に一致する必要があります。 によって実行される比較の種類、<xref:System.String.StartsWith%2A>メソッドの値によって異なります、`comparisonType`パラメーター。 比較は、現在のカルチャの規則を使用できます (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>と<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) またはインバリアント カルチャ (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>と<xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>)、またはコード ポイントの文字の比較で構成されていることができます (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>または<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). この比較は大文字小文字を区別も指定できます (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>、 <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>、または<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>)、または大文字小文字を区別できます (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>、 <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>、 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>)。  
  
   
  
## Examples  
 次の例では、文字列を検索する単語で始まる長い文字列の先頭に「、」「、」。 例への呼び出しからの出力として、<xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29>カルチャに依存しないが、大文字の比較を実行するメソッドは、文字列を文字列に一致するカルチャおよび大文字小文字 insensitive の比較を実行するための呼び出し中に一致するように失敗します。  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 次の例では、文字列が特定の部分文字列で始まるかどうかを判断します。 これには、2 次元の文字列配列を初期化します。 2 番目の次元の最初の要素には、文字列が含まれていて、2 番目の要素には、最初の文字列の先頭で検索する文字列が含まれています。 結果は、カルチャ、ケースが無視されるかどうか、および序数の比較を実行するかどうかの選択肢の影響を受けます。 文字列のインスタンスにする合字が含まれている場合、連続する文字を含むカルチャに依存した比較が正常に一致することを注意してください。  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> が <see cref="T:System.StringComparison" /> 値ではありません。</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">比較対象の文字列。</param>
        <param name="ignoreCase">比較時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="culture">この文字列と <paramref name="value" /> との比較方法を決定するカルチャ情報。 <paramref name="culture" /> が <see langword="null" /> の場合は、現在のカルチャが使用されます。</param>
        <summary>指定されたカルチャを使って比較した場合に、この文字列インスタンスの先頭が、指定された文字列と一致するかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> パラメーターがこの文字列の先頭と一致する場合は <paramref name="value" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは比較、`value`パラメーターと同じ長さであるこの文字列の先頭の部分文字列を`value`、し、それらが等しいかどうかを示す値を返します。 等しいもの`value`空の文字列を指定する必要があります (<xref:System.String.Empty?displayProperty=nameWithType>)、この同じインスタンスへの参照があります。 または、このインスタンスの先頭に一致する必要があります。  
  
 このメソッドは、指定した大文字小文字の区別とカルチャを使用して、比較を実行します。  
  
   
  
## Examples  
 次の例では、別の文字列の先頭に文字列が発生したかどうかを判断します。 <xref:System.String.StartsWith%2A>大文字小文字の区別、大文字小文字の区別、および検索の結果に影響する異なるカルチャを使用していくつかのメソッドが呼び出されます。  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>インスタンスから部分文字列を取得します。  
  
このメンバーはオーバーロードされます。 構文、使用方法、例など、このメンバーの詳細については、オーバーロード リストで名前をクリックしてください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">このインスタンス内の部分文字列の 0 から始まる開始文字位置。</param>
        <summary>インスタンスから部分文字列を取得します。 部分文字列は、文字列中の指定した文字の位置で開始し、文字列の末尾まで続きます。</summary>
        <returns>このインスタンスの <paramref name="startIndex" /> で始まる部分文字列と等価な文字列。または、<paramref name="startIndex" /> がこのインスタンスの長さと等しい場合は <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.String.Substring%28System.Int32%29>メソッドを指定した文字位置から開始し、文字列の末尾で終了する文字列から部分文字列を抽出します。 開始文字の位置は 0 から始まるです。つまり、文字列の最初の文字は、インデックス 0、インデックス 1 ではありませんが。 指定した文字位置から開始し、文字列の末尾の前に終了する部分文字列を抽出する呼び出し、<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>メソッド。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりで始まる新しい文字列を返します、`startIndex`現在の文字列内の位置。  
  
 に特定の文字または文字のシーケンスで始まる部分文字列を抽出するためにメソッドを呼び出すよう<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOf%2A>の値を取得する`startIndex`します。 2 番目の例を示しています。「=」文字の後に 1 つの文字位置を開始するキー値を抽出します。  
  
 場合`startIndex`は 0、元の文字列をそのまま返されます。  
   
  
## Examples  
 次の例では、文字列から部分文字列の取得を示します。  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 次の例では、<xref:System.String.Substring%2A>は等号で区切られたキーと値のペアを区切るためのメソッド (「=」) 文字。  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A>メソッドを使用して、文字列に等しい文字の位置を取得します。 呼び出し、<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>メソッドの抽出、文字列の最初の文字から開始しへの呼び出しによって返される文字数を拡張するキーの名前、<xref:System.String.IndexOf%2A>メソッド。 呼び出し、<xref:System.String.Substring%28System.Int32%29>メソッドは、キーに割り当てられている値を抽出します。 Equals の文字を超えるの 1 つの文字位置から開始し、文字列の末尾に拡張します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">このインスタンス内の部分文字列の 0 から始まる開始文字位置。</param>
        <param name="length">部分文字列の文字数。</param>
        <summary>インスタンスから部分文字列を取得します。 この部分文字列は、指定した文字位置から開始し、指定した文字数の文字列です。</summary>
        <returns>このインスタンスの <paramref name="startIndex" /> から始まる長さ <paramref name="length" /> の部分文字列と等価な文字列。または、<paramref name="startIndex" /> がこのインスタンスの長さと等しく、<paramref name="length" /> がゼロの場合は <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>メソッドを指定した文字位置から開始し、文字列の末尾の前に終了する文字列から部分文字列を抽出します。 開始文字の位置は 0 から始まるです。つまり、文字列の最初の文字は、インデックス 0、インデックス 1 ではありませんが。 指定した文字位置から開始し、文字列の末尾に部分文字列を抽出する呼び出し、<xref:System.String.Substring%28System.Int32%29>メソッド。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりを持つ新しい文字列を返します`length`から文字、`startIndex`現在の文字列内の位置。  
  
 `length`パラメーターが文字列の現在のインスタンスから抽出する文字の合計数を表します。 これにより、インデックスにある先頭の文字が含まれます。`startIndex`します。  つまり、<xref:System.String.Substring%2A>メソッドが、インデックスから文字を抽出しようとしています。`startIndex`インデックスに`startIndex`  +  `length` - 1。  
  
 に特定の文字または文字のシーケンスで始まる部分文字列を抽出するためにメソッドを呼び出すよう<xref:System.String.IndexOf%2A>または<xref:System.String.LastIndexOf%2A>の値を取得する`startIndex`します。  
  
 部分文字列の場合`startIndex`、指定された文字シーケンスにするメソッドを呼び出すよう<xref:System.String.IndexOf%2A>または<xref:System.String.LastIndexOf%2A>終了文字または文字のシーケンスのインデックスを取得します。  文字列内のインデックス位置に、次のように、その値をし、変換できます。  
  
-   部分文字列の終わりをマークする単一の文字を検索する場合、`length`パラメーターと等しい`endIndex`  -  `startIndex` + 1、場所`endIndex`の戻り値は、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOf%2A>メソッド。 次の例では、文字列から文字"b"の継続的なブロックを抽出します。  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   部分文字列の終わりをマークする複数の文字を検索する場合、`length`パラメーターと等しい`endIndex`  +  `endMatchLength`  - `startIndex`ここで、 `endIndex` の戻り値は、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOf%2A>メソッドをおよび`endMatchLength`部分文字列の末尾を示す文字のシーケンスの長さです。 次の例は、XML を格納したテキストのブロックを抽出`<definition>`要素。  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   文字または文字シーケンスが含まれていない場合、部分文字列の末尾、`length`パラメーターと等しい`endIndex`  - `startIndex`ここで、`endIndex`の戻り値は、<xref:System.String.IndexOf%2A>または<xref:System.String.IndexOf%2A>メソッド。  
  
 場合`startIndex`が 0 と等しい、メソッド、現在の文字列の長さが変更されていない元の文字列を返します。  
  
   
  
## Examples  
 次の例では、シンプルな呼び出しを<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>6 番目の文字位置から始まる文字列から 2 つの文字を抽出する方法 (つまり、インデックス 5)。  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 次の例では、<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>メソッドで、次の 3 つの場合、文字列内の部分文字列を分離します。 2 つのケースで部分文字列を使用して、比較、され、無効なパラメーターが指定されているため、3 番目のケースで、例外がスローされます。  
  
-   1 つの文字と、3 番目の位置 (インデックス 2) の文字列を抽出し、"c"と比較します。 この比較を返します`true`します。  
  
-   (インデックス 3) の文字列内の 4 番目の位置にあるゼロ文字を抽出し、それを<xref:System.String.IsNullOrEmpty%2A>メソッド。 これは true を返しますのでへの呼び出し、<xref:System.String.Substring%2A>メソッドを返します。<xref:System.String.Empty?displayProperty=nameWithType>します。  
  
-   文字列の 4 番目の位置以降にある 1 つの文字を抽出しようとします。 その位置にある文字がないため、メソッドの呼び出しがスローされます、<xref:System.ArgumentOutOfRangeException>例外。  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 次の例では、<xref:System.String.Substring%2A>は等号で区切られたキーと値のペアを区切るためのメソッド (「=」) 文字。  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A>メソッドを使用して、文字列に等しい文字の位置を取得します。 呼び出し、<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>メソッドの抽出、文字列の最初の文字から開始しへの呼び出しによって返される文字数を拡張するキーの名前、<xref:System.String.IndexOf%2A>メソッド。 呼び出し、<xref:System.String.Substring%28System.Int32%29>メソッドは、キーに割り当てられている値を抽出します。 Equals の文字を超えるの 1 つの文字位置から開始し、文字列の末尾に拡張します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> に<paramref name="length" /> を加算した値はこのインスタンスの範囲外である位置を示します。  
  
- または - 
 <paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクトを反復処理する列挙子を返します。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトを反復処理するために使用できる、厳密に型指定された列挙子。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 使用できる場合にのみ、<xref:System.String>インスタンスにキャスト、<xref:System.Collections.Generic.IEnumerable%601>インターフェイス オブジェクト。 詳細については、<xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> メソッドを参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクトを反復処理する列挙子を返します。</summary>
        <returns>現在の文字列を反復処理するために使用できる列挙子。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.Collections.IEnumerable> インターフェイスにキャストされる場合にのみ、使用できます。 詳細については、<xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> メソッドを参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の文字列の値が <see cref="F:System.Boolean.TrueString" /> の場合は <see langword="true" />。現在の文字列の値が <see cref="F:System.Boolean.FalseString" /> の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段は、<xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の文字列の値が <see cref="F:System.Boolean.TrueString" /> または <see cref="F:System.Boolean.FalseString" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段は、<xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.Byte.MaxValue" /> より大きいか <see cref="F:System.Byte.MinValue" /> より小さいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトのインデックス 0 位置にある文字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段は、<xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段は、<xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段は、<xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.Decimal.MinValue" /> 未満か、<see cref="F:System.Decimal.MaxValue" /> より大きい数です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段は、<xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.Double.MinValue" /> 未満か、<see cref="F:System.Double.MaxValue" /> より大きい数です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段は、<xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.Int16.MaxValue" /> より大きいか <see cref="F:System.Int16.MinValue" /> より小さいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段は、<xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段は、<xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段は、<xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.SByte.MaxValue" /> より大きいか <see cref="F:System.SByte.MinValue" /> より小さいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段は、<xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">取得するオブジェクトの型。</param>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段は、<xref:System.Convert.ChangeType%2A>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidCastException">現在の <see cref="T:System.String" /> オブジェクトの値を、<paramref name="type" /> パラメーターで指定された型に変換できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段は、<xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.UInt16.MaxValue" /> より大きいか <see cref="F:System.UInt16.MinValue" /> より小さいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段は、<xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">現在の <see cref="T:System.String" /> オブジェクトの値を解析できません。</exception>
        <exception cref="T:System.OverflowException">現在の <see cref="T:System.String" /> オブジェクトの値は、<see cref="F:System.UInt32.MaxValue" /> より大きい数か、<see cref="F:System.UInt32.MinValue" /> 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>現在の <see cref="T:System.String" /> オブジェクトの変換後の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.String> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 推奨される代替手段は、<xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスの文字を Unicode 文字配列へコピーします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスの文字を Unicode 文字配列へコピーします。</summary>
        <returns>このインスタンスの各文字を要素とする Unicode 文字配列。 このインスタンスが空の文字列である場合、返される配列は空で、長さは 0 になります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、各文字をコピー (つまり、各<xref:System.Char>オブジェクト) を文字配列への文字列にします。 は、返される文字配列のインデックスは 0 からコピーされる最初の文字は、します。コピーする最後の文字インデックス位置にある<xref:System.Array.Length%2A?displayProperty=nameWithType>– 1。  
  
 文字配列内の文字から文字列を作成するには、呼び出し、<xref:System.String.%23ctor%28System.Char%5B%5D%29>コンス トラクター。  
  
 文字列でエンコードされた文字を含むバイト配列を作成する、適切なインスタンス化<xref:System.Text.Encoding>オブジェクトと呼び出しの<xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType>メソッド。 .NET で使用できる標準エンコーディングの一部を以下に示します。  
  
|エンコード|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 詳細については、次を参照してください。 [.NET における文字エンコーディング](~/docs/standard/base-types/character-encoding.md)します。  
  
   
  
## Examples  
 次の例では、<xref:System.String.ToCharArray%2A>文字配列への文字列に文字を抽出するメソッド。 配列の元の文字列と要素が表示されます。  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 次の例では、区切られた文字列内の区切り記号として機能する文字を含む文字列を定義します。 呼び出して、<xref:System.String.ToCharArray%2A>メソッドに渡すことができる文字の配列を作成する、<xref:System.String.Split%28System.Char%5B%5D%29>その個々 の部分文字列に区切られた文字列を区切るためのメソッド。  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">このインスタンス内の部分文字列の開始位置。</param>
        <param name="length">このインスタンス内の部分文字列の長さ。</param>
        <summary>このインスタンスの指定した部分文字列の文字を Unicode 文字配列へコピーします。</summary>
        <returns>文字位置 <paramref name="startIndex" /> から始まる、このインスタンス内の文字の <paramref name="length" /> 数を要素とする Unicode 文字配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、文字列の一部で、文字配列に文字をコピーします。 文字列文字配列内の文字の範囲からを作成するには、呼び出し、<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>コンス トラクター。  
  
 `startIndex`パラメーターは 0 から始まります。 つまり、文字列インスタンスの最初の文字のインデックスは 0 です。  
  
 場合`length`0 の場合は、返される配列が空で、長さは 0。 このインスタンスが場合`null`または空の文字列 ("")、返される配列が空で、長さは 0。  
  
 文字列の一部でエンコードされた文字を含むバイト配列を作成する、適切なインスタンス化<xref:System.Text.Encoding>オブジェクトと呼び出しの<xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29>メソッド。 .NET で使用できる標準エンコーディングのとおりです。  
  
|エンコード|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 詳細については、次を参照してください。 [.NET における文字エンコーディング](~/docs/standard/base-types/character-encoding.md)します。  
  
   
  
## Examples  
 次の例は文字列内の部分文字列を文字の配列に変換を列挙し、配列の要素が表示されます。  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。  
  
- または - 
 <paramref name="startIndex" /> に <paramref name="length" /> を加算した値がこのインスタンスの長さを超えています。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列のコピーを小文字に変換して返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列のコピーを小文字に変換して返します。</summary>
        <returns>小文字の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、現在のカルチャの大文字小文字の規則が考慮されます。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、現在のインスタンス内のすべての文字が小文字に変換する新しい文字列を返します。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 大文字と小文字の操作呼び出しに起因する、<xref:System.String.ToLower>メソッドは、現在のカルチャのケース表記規則が考慮されます。 名前付きパイプ、またはレジストリ キーの使用をファイル名など、オペレーティング システムの識別子の大文字か小文字のバージョンが必要な場合、<xref:System.String.ToLowerInvariant%2A>または<xref:System.String.ToUpperInvariant%2A>メソッド。 すべてのカルチャで同じ結果が生成されます (とは異なり、<xref:System.String.ToLower>メソッド) より効率的に実行します。  
  
   
  
## Examples  
 次の例では、いくつかの混合大文字と小文字の文字列を小文字に変換します。  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>説明したよう[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)既定値を代入しを明示的に指定するパラメーターを必要とするメソッドを呼び出す代わりに文字列の大文字小文字の区別メソッドを呼び出さないようにすることをお勧めします。 現在のカルチャの大文字と小文字の規則を使用して小文字の文字を変換するを呼び出して、<see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />メソッドのオーバー ロードの値を持つ<see cref="P:System.Globalization.CultureInfo.CurrentCulture" />の<paramref name="culture" />パラメーター。</para>
        </block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">カルチャ固有の大文字と小文字の規則を提供するオブジェクト。</param>
        <summary>指定されたカルチャの大文字と小文字の規則を使用して、この文字列のコピーを小文字に変換して返します。</summary>
        <returns>現在の文字列を小文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定されたカルチャの大文字小文字の規則、`culture`パラメーターを変更する方法、文字列の大文字と小文字を決定します。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、現在のインスタンス内のすべての文字が小文字に変換する新しい文字列を返します。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 渡す場合、<xref:System.String.ToLower%28System.Globalization.CultureInfo%29>メソッド、<xref:System.Globalization.CultureInfo>オブジェクト以外の<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>、大文字と小文字の操作がカルチャに固有のルールが考慮します。 名前付きパイプ、またはレジストリ キーの使用をファイル名など、オペレーティング システムの識別子の大文字か小文字のバージョンが必要な場合、<xref:System.String.ToLowerInvariant%2A>または<xref:System.String.ToUpperInvariant%2A>メソッド。 これにより、すべてのカルチャで同じ結果になりより効率的に実行します。  
  
   
  
## Examples  
 次の例では、2 つの文字列の大文字の文字を英語 (米国)、トルコ語、トルコのカルチャを使用して文字を小文字に変換し、小文字の文字列を比較します。 大文字の文字列は、LATIN CAPITAL LETTER I にドットの上、Unicode LATIN CAPITAL LETTER I で 1 つの文字列のうち、その他の文字列に含まれる点を除いて同じです。  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>インバリアント カルチャの大文字と小文字の規則を使用して、この <see cref="T:System.String" /> オブジェクトのコピーを小文字に変換して返します。</summary>
        <returns>現在の文字列を小文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インバリアント カルチャでは、カルチャに依存しないられるカルチャを表します。 関連付けられている英語の言語が特定の国または地域を使用できません。 詳細については、<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> プロパティを参照してください。  
  
 使用して、現在のカルチャによって影響を受けるある予測可能な方法で変更する文字列の場合に、アプリケーションが依存する場合、<xref:System.String.ToLowerInvariant%2A>メソッド。 <xref:System.String.ToLowerInvariant%2A>メソッドは`ToLower(CultureInfo.InvariantCulture)`します。 文字列のコレクションは、ユーザー インターフェイス コントロールでの予測可能な順序で表示する必要があるときに、メソッドの使用をお勧めします。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、現在のインスタンス内のすべての文字が小文字に変換する新しい文字列を返します。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 名前付きパイプ、またはレジストリ キーの使用をファイル名など、オペレーティング システムの識別子の大文字か小文字のバージョンが必要な場合、<xref:System.String.ToLowerInvariant%2A>または<xref:System.String.ToUpperInvariant%2A>メソッド。  
  
   
  
## Examples  
 次の例では、さまざまな言語で 1 つの単語を含む文字列配列を定義します。 <xref:System.String.ToLowerInvariant%2A>メソッドは、各単語の大文字バージョンと並列配列の要素の設定に使用されます。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>メソッドは言語に関係なく同じ順序で要素が表示されるように小文字の配列内の要素の順序に基づいて区別配列の並べ替えに使用します。  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスの値を <see cref="T:System.String" /> に変換します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.String" /> のこのインスタンスを返します。実際の変換処理は実行されません。</summary>
        <returns>現在の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが単に変更されていない、現在の文字列を返すために、これを直接呼び出す必要はありません。 複合操作の例のように、書式指定では、暗黙的にそのという通常は。  
  
   
  
## Examples  
 次の例で、<xref:System.String.ToString%2A>メソッド。例が明示的に呼び出していないこと、<xref:System.String.ToString%2A>メソッド。 代わりに、メソッドがによって暗黙的に呼び出されます、[複合書式指定](~/docs/standard/base-types/composite-formatting.md)機能します。  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(予約済み) カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>
          <see cref="T:System.String" /> のこのインスタンスを返します。実際の変換処理は実行されません。</summary>
        <returns>現在の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` 予約されていると、この操作に現在参加していません。  
  
 このメソッドが単に変更されていない、現在の文字列を返すために、これを直接呼び出す必要はありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この文字列のコピーを大文字に変換して返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この文字列のコピーを大文字に変換して返します。</summary>
        <returns>現在の文字列を大文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のインスタンス内の各文字を等価な大文字に変換するのに、現在のカルチャの大文字小文字の規則を使用します。 文字が大文字の対応を持たない場合が含まれる、返される文字列では変更されません。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、現在のインスタンス内のすべての文字が大文字に変換する新しい文字列を返します。  
  
 <xref:System.String.ToUpper%2A>メソッドは大文字と小文字のために使用できるように、文字列を大文字に変換するよく使用されます。 大文字と小文字を実行する方を持つ文字列比較メソッドを呼び出すが、<xref:System.StringComparison>パラメーターを設定する値を持つ<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>カルチャ、大文字の比較。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 大文字と小文字の操作呼び出しに起因する、<xref:System.String.ToUpper>メソッドは、現在のカルチャのケース表記規則が考慮されます。 名前付きパイプ、またはレジストリ キーの使用をファイル名など、オペレーティング システムの識別子の大文字か小文字のバージョンが必要な場合、<xref:System.String.ToLowerInvariant%2A>または<xref:System.String.ToUpperInvariant%2A>メソッド。 すべてのカルチャで同じ結果が生成されます (とは異なり、<xref:System.String.ToUpper>メソッド) より効率的に実行します。  
  
   
  
## Examples  
 次の例では、<xref:System.String.ToUpper%2A>一連の基本的なラテン語、ラテン 1 補足、およびラテン文字拡張 A 文字セット内の各文字が含まれている 1 つの文字の文字列に変換します。 大文字の文字が小文字の文字からさまざまな各文字列が表示されます。  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>説明したよう[文字列を使用するためのベスト プラクティス](~/docs/standard/base-types/best-practices-strings.md)既定値を代入しを明示的に指定するパラメーターを必要とするメソッドを呼び出す代わりに文字列の大文字小文字の区別メソッドを呼び出さないようにすることをお勧めします。 文字列を現在のカルチャの大文字と小文字の規則を使用して大文字に変換するには、呼び出し、<see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" />メソッドのオーバー ロードの値を持つ<see cref="P:System.Globalization.CultureInfo.CurrentCulture" />の<paramref name="culture" />パラメーター。</para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">カルチャ固有の大文字と小文字の規則を提供するオブジェクト。</param>
        <summary>指定されたカルチャの大文字と小文字の規則を使用して、この文字列のコピーを大文字に変換して返します。</summary>
        <returns>現在の文字列を大文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定されたカルチャの大文字小文字の規則、`culture`パラメーターを変更する方法、文字列の大文字と小文字を決定します。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、現在のインスタンス内のすべての文字が大文字に変換する新しい文字列を返します。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 渡す場合、<xref:System.String.ToUpper%28System.Globalization.CultureInfo%29>メソッド、<xref:System.Globalization.CultureInfo>オブジェクト以外の<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>、大文字と小文字の操作がカルチャに固有のルールが考慮します。 名前付きパイプ、またはレジストリ キーの使用をファイル名など、オペレーティング システムの識別子の大文字か小文字のバージョンが必要な場合、<xref:System.String.ToLowerInvariant%2A>または<xref:System.String.ToUpperInvariant%2A>メソッド。 これにより、すべてのカルチャで同じ結果になりより効率的に実行します。  
  
   
  
## Examples  
 次の例では、英語 (米国) カルチャとトルコ語、トルコのカルチャを使用して、大文字の 2 つの文字列の小文字の文字列に変換し、大文字の文字列を比較します。 大文字の文字列は、LATIN CAPITAL LETTER I にドットの上、Unicode LATIN CAPITAL LETTER I で 1 つの文字列のうち、その他の文字列に含まれる点を除いて同じです。  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>インバリアント カルチャの大文字と小文字の規則を使用して、この <see cref="T:System.String" /> オブジェクトのコピーを大文字に変換して返します。</summary>
        <returns>現在の文字列を大文字にしたもの。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インバリアント カルチャでは、カルチャに依存しないられるカルチャを表します。 関連付けられている英語の言語が特定の国または地域を使用できません。 詳細については、<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> プロパティを参照してください。  
  
 使用して、現在のカルチャによって影響を受けるある予測可能な方法で変更する文字列の場合に、アプリケーションが依存する場合、<xref:System.String.ToUpperInvariant%2A>メソッド。 <xref:System.String.ToUpperInvariant%2A>メソッドは`ToUpper(CultureInfo.InvariantCulture)`します。 文字列のコレクションは、ユーザー インターフェイス コントロールでの予測可能な順序で表示する必要があるときに、メソッドの使用をお勧めします。  
  
> [!NOTE]
>  このメソッドは、現在のインスタンスの値を変更できません。 代わりに、現在のインスタンス内のすべての文字が大文字に変換する新しい文字列を返します。  
  
## <a name="security-considerations"></a>セキュリティの考慮事項  
 名前付きパイプ、またはレジストリ キーの使用をファイル名など、オペレーティング システムの識別子の大文字か小文字のバージョンが必要な場合、<xref:System.String.ToLowerInvariant%2A>または<xref:System.String.ToUpperInvariant%2A>メソッド。  
  
   
  
## Examples  
 次の例では、さまざまな言語で 1 つの単語を含む文字列配列を定義します。 <xref:System.String.ToUpperInvariant%2A>メソッドは、各単語の大文字バージョンと並列配列の要素の設定に使用されます。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>メソッドは言語に関係なく同じ順序で要素が表示されることを確認する大文字の配列の要素の順序に基づいて区別配列の並べ替えに使用します。  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクトの先頭および末尾から、指定した文字セットをすべて削除した新しい文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.String" /> オブジェクトの先頭および末尾にある空白文字をすべて削除します。</summary>
        <returns>現在の文字列の先頭および末尾から空白文字をすべて削除した後に残った文字列。 現在のインスタンスから文字をトリムできない場合は、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Trim%2A>メソッドは、現在の文字列から先頭および末尾の空白文字がすべて削除します。 各先頭および末尾のトリム操作は、空白以外の文字が検出されたときに停止します。 たとえば、現在の文字列が"abc xyz"の場合、<xref:System.String.Trim%2A>メソッドは"abc xyz"を返します。 文字列内の単語の間の空白文字を削除する使用[.NET の正規](~/docs/standard/base-types/regular-expressions.md)します。  
  
> [!NOTE]
>  場合、<xref:System.String.Trim%2A>メソッドは、現在のインスタンスから任意の文字を削除、このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンスで検出されたすべての先頭および末尾の空白文字を削除する新しい文字列を返します。  
  
 現在の文字列が等しい場合<xref:System.String.Empty>メソッドを返します、現在のインスタンスのすべての文字は、空白文字で構成されている、または<xref:System.String.Empty>します。  
  
 空白文字は、Unicode 規格によって定義されます。 <xref:System.String.Trim>メソッドの戻り値を生成する先頭および末尾の文字を削除`true`に渡されるときに、<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>メソッド。  
  
   
  
## Examples  
 次の例では、<xref:System.String.Trim?displayProperty=nameWithType>それらを連結する前に、ユーザーが入力した文字列から余分な空白を削除する方法。  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]および以前のバージョンがこのメソッドをトリミングする空白文字の内部リストを管理します。 以降では、 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]、メソッドは、すべての Unicode の空白文字をトリミング (つまり、文字が生成する、<see langword="true" />に渡されるときに値を返す、<see cref="M:System.Char.IsWhiteSpace(System.Char)" />メソッド)。 この変更により、<see cref="M:System.String.Trim" />メソッド、[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]し、以前のバージョンは、ゼロ幅の容量 (U + 200B) またはゼロ幅の非分割領域 (U+FEFF) を 2 つの文字を削除する、<see cref="M:System.String.Trim" />メソッド、[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以降のバージョンは、削除されません。 さらに、<see cref="M:System.String.Trim" />メソッドで、[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]と以前のバージョンは次の 3 つの Unicode の空白文字を除去しません: モンゴル文字の母音区切り記号 (U + 180E)、幅の狭い非分割領域 (U + 202F)、および中規模の数学的な領域 (U + 205F)。</para>
        </block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">削除する Unicode 文字の配列、または <see langword="null" />。</param>
        <summary>現在の <see cref="T:System.String" /> オブジェクトの先頭および末尾から、配列で指定された文字セットをすべて削除します。</summary>
        <returns>現在の文字列の先頭および末尾から、<paramref name="trimChars" /> パラメーターの文字をすべて削除した後に残った文字列。 <paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合は、代わりに空白文字が削除されます。 現在のインスタンスから文字をトリミングできない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Trim%2A>メソッドが現在の文字列からではすべての先頭および末尾の文字を削除、`trimChars`パラメーター。 それぞれの先頭と末尾の操作が停止されていない文字をトリミング`trimChars`が発生しました。 たとえば、現在の文字列が"123abc456xyz789"と`trimChars`から「9」、「1」、桁の数字が含まれています、 <xref:System.String.Trim%2A> "abc456xyz"を返します。  
  
> [!NOTE]
>  場合、<xref:System.String.Trim%2A>メソッドは、現在のインスタンスから任意の文字を削除、このメソッドは、現在のインスタンスの値を変更しません。 代わりに、すべての新しい文字列を返します先頭と末尾の`trimChars`現在のインスタンスで検出された文字が削除されます。  
  
 現在の文字列が等しい場合<xref:System.String.Empty>または現在のインスタンスのすべての文字内の文字から成る、`trimChars`配列を返します<xref:System.String.Empty>します。  
  
 場合`trimChars`は`null`または空の配列に、このメソッドは、メソッドの返されると、先頭または末尾の文字を削除します`true`に渡されるときに、<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>メソッド  
  
   
  
## Examples  
 次の例では、<xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType>領域、アスタリスク (*)、およびアポストロフィ (') 文字を文字列から削除する方法。  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]以前のバージョンは、このメソッドはトリム場合の空白文字の内部の一覧を管理および<paramref name="trimChars" />は<see langword="null" />または空の配列。 以降では、[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]場合は、<paramref name="trimChars" />は<see langword="null" />、空の配列、メソッドがすべての Unicode の空白文字をトリミングまたは (つまり、文字が生成する、<see langword="true" />に渡されるときに値を返す、<see cref="M:System.Char.IsWhiteSpace(System.Char)" />メソッド)。 この変更により、<see cref="M:System.String.Trim" />メソッド、[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]し、以前のバージョンは、ゼロ幅の容量 (U + 200B) またはゼロ幅の非分割領域 (U+FEFF) を 2 つの文字を削除する、<see cref="M:System.String.Trim" />メソッド、[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以降のバージョンは、削除されません。 さらに、<see cref="M:System.String.Trim" />メソッドで、[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]と以前のバージョンは次の 3 つの Unicode の空白文字を除去しません: モンゴル文字の母音区切り記号 (U + 180E)、幅の狭い非分割領域 (U + 202F)、および中規模の数学的な領域 (U + 205F)。</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">削除する Unicode 文字の配列、または <see langword="null" />。</param>
        <summary>現在の <see cref="T:System.String" /> オブジェクトの末尾から、配列で指定された文字セットをすべて削除します。</summary>
        <returns>現在の文字列の末尾から、<paramref name="trimChars" /> パラメーターの文字をすべて削除した後に残った文字列。 <paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合は、代わりに Unicode の空白文字が削除されます。 現在のインスタンスから文字をトリミングできない場合、メソッドは現在のインスタンスを変更せずに返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.TrimEnd%2A>メソッドが現在の文字列から内にあるすべての文字を削除、`trimChars`パラメーター。 場合の最初の文字にトリム操作が停止する`trimChars`は、文字列の終わりが発生しました。 たとえば、現在の文字列が"123abc456xyz789"と`trimChars`から「9」、「1」、桁の数字が含まれています、 <xref:System.String.TrimEnd%2A> "123abc456xyz"を返します。  
  
> [!NOTE]
>  場合、<xref:System.String.TrimEnd%2A>メソッドは、現在のインスタンスから任意の文字を削除、このメソッドは、現在のインスタンスの値を変更しません。 代わりに、どので検出されたすべての末尾の文字で、新しい文字列を返します`trimChars`現在の文字列から削除されます。  
  
   
  
## Examples  
 次の例を使用する方法、<xref:System.String.TrimEnd%28System.Char%5B%5D%29>空白文字または文字列の末尾から句読点をトリムするメソッド。  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]以前のバージョンは、このメソッドはトリム場合の空白文字の内部の一覧を管理および<paramref name="trimChars" />は<see langword="null" />または空の配列。 以降では、[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]場合は、<paramref name="trimChars" />は<see langword="null" />、空の配列、メソッドがすべての Unicode の空白文字をトリミングまたは (つまり、文字が生成する、<see langword="true" />に渡されるときに値を返す、<see cref="M:System.Char.IsWhiteSpace(System.Char)" />メソッド)。 この変更により、<see cref="M:System.String.Trim" />メソッド、[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]し、以前のバージョンは、ゼロ幅の容量 (U + 200B) またはゼロ幅の非分割領域 (U+FEFF) を 2 つの文字を削除する、<see cref="M:System.String.Trim" />メソッド、[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以降のバージョンは、削除されません。 さらに、<see cref="M:System.String.Trim" />メソッドで、[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]と以前のバージョンは次の 3 つの Unicode の空白文字を除去しません: モンゴル文字の母音区切り記号 (U + 180E)、幅の狭い非分割領域 (U + 202F)、および中規模の数学的な領域 (U + 205F)。</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">削除する Unicode 文字の配列、または <see langword="null" />。</param>
        <summary>現在の <see cref="T:System.String" /> オブジェクトの先頭から、配列で指定された文字セットをすべて削除します。</summary>
        <returns>現在の文字列の先頭から、<paramref name="trimChars" /> パラメーターの文字をすべて削除した後に残った文字列。 <paramref name="trimChars" /> が <see langword="null" /> または空の配列の場合は、代わりに空白文字が削除されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.TrimStart%2A>メソッドが現在の文字列から内にあるすべての先頭文字を削除、`trimChars`パラメーター。 ではない文字にトリム操作が停止`trimChars`が発生しました。 たとえば、現在の文字列が"123abc456xyz789"と`trimChars`から「9」、「1」、桁の数字が含まれています、 <xref:System.String.TrimStart%2A> "abc456xyz789"を返します。  
  
> [!NOTE]
>  場合、<xref:System.String.TrimStart%2A>メソッドは、現在のインスタンスから任意の文字を削除、このメソッドは、現在のインスタンスの値を変更しません。 代わりに、現在のインスタンスにある先頭の空白文字はすべてを削除する新しい文字列を返します。  
  
   
  
## Examples  
 次の例での基本的な機能、<xref:System.String.TrimStart%2A>メソッド。

 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]

 次の例では、<xref:System.String.TrimStart%2A>空白と行のソース コードからコメント文字をトリミングするメソッド。 `StripComments`メソッドへの呼び出しをラップする<xref:System.String.TrimStart%2A>し、それを Visual Basic および c# では、スラッシュ (/) で、スペース、アポストロフィ (') は、このコメント文字を含む文字配列を渡します。 <xref:System.String.TrimStart%2A>メソッドは、文字列がコメントであるかどうかを評価するときに、先頭の空白文字を削除するとも呼ばれます。  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 `StripComments` メソッドを呼び出す例を次に示します。  
  
 [!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
 [!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]以前のバージョンは、このメソッドはトリム場合の空白文字の内部の一覧を管理および<paramref name="trimChars" />は<see langword="null" />または空の配列。 以降では、[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]場合は、<paramref name="trimChars" />は<see langword="null" />、空の配列、メソッドがすべての Unicode の空白文字をトリミングまたは (つまり、文字が生成する、<see langword="true" />に渡されるときに値を返す、<see cref="M:System.Char.IsWhiteSpace(System.Char)" />メソッド)。 この変更により、<see cref="M:System.String.Trim" />メソッド、[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]し、以前のバージョンは、ゼロ幅の容量 (U + 200B) またはゼロ幅の非分割領域 (U+FEFF) を 2 つの文字を削除する、<see cref="M:System.String.Trim" />メソッド、[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以降のバージョンは、削除されません。 さらに、<see cref="M:System.String.Trim" />メソッドで、[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]と以前のバージョンは次の 3 つの Unicode の空白文字を除去しません: モンゴル文字の母音区切り記号 (U + 180E)、幅の狭い非分割領域 (U + 202F)、および中規模の数学的な領域 (U + 205F)。</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>