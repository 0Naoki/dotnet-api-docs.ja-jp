<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="GC.xml" source-language="en-US" target-language="ja-JP">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-567ae5a" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3cf4df88-236b-4f49-aebe-6184303eadc311996d97bef6121bce982a8368bef5e8197c8a44.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">11996d97bef6121bce982a8368bef5e8197c8a44</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1465f1a9bce3970cd9e95769eaa641b92a0a22d5</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/18/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Controls the system garbage collector, a service that automatically reclaims unused memory.</source>
          <target state="translated">未使用メモリを自動的に収集するサービスであるシステム ガベージ コレクターを制御します。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector is a common language runtime component that controls the allocation and release of managed memory.</source>
          <target state="translated">ガベージ コレクターは、割り当てとマネージ メモリの解放を制御する共通言語ランタイム コンポーネントです。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released.</source>
          <target state="translated">このクラスのメソッドは、オブジェクトとオブジェクトによって割り当てられたリソースが解放されるときに、ガベージ コレクションが実行されるときに影響します。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</source>
          <target state="translated">このクラスのプロパティは、システムおよび年齢のカテゴリ、またはオブジェクトに割り当てられたメモリの生成で使用可能なメモリの合計量に関する情報を提供します。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector tracks and reclaims objects allocated in managed memory.</source>
          <target state="translated">ガベージ コレクターは、追跡し、マネージ メモリに割り当てられたオブジェクトを解放します。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references.</source>
          <target state="translated">定期的に、ガベージ コレクターは、対象の有効な参照がないオブジェクトに割り当てられたメモリを解放するガベージ コレクションを実行します。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory.</source>
          <target state="translated">ガベージ コレクションは、利用可能なメモリを使用してメモリの要求を満たすできないときに自動的に行われます。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Alternatively, an application can force garbage collection using the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">また、アプリケーションが使用してガベージ コレクションを強制することができます、<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Garbage collection consists of the following steps:</source>
          <target state="translated">ガベージ コレクションは、次の手順で構成されます。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector searches for managed objects that are referenced in managed code.</source>
          <target state="translated">ガベージ コレクターはマネージ コードで参照されている管理対象のオブジェクトを検索します。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector tries to finalize objects that are not referenced.</source>
          <target state="translated">ガベージ コレクターが参照されていないオブジェクトの終了しようとするとします。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector frees objects that are not referenced and reclaims their memory.</source>
          <target state="translated">ガベージ コレクターは、参照されていないオブジェクトを解放し、自らのメモリを解放します。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>This topic includes the following sections:</source>
          <target state="translated">このトピックには、次のセクションがあります。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source><bpt id="p1">[</bpt>The garbage collector and unmanaged resources<ept id="p1">](#unmanaged)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>ガベージ コレクターとアンマネージ リソース<ept id="p1">](#unmanaged)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source><bpt id="p1">[</bpt>Object aging and generations<ept id="p1">](#generations)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>オブジェクトのエージング機能と生成結果<ept id="p1">](#generations)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source><bpt id="p1">[</bpt>Disallowing garbage collection<ept id="p1">](#NoGCRegion)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>ガベージ コレクションを禁止します。<ept id="p1">](#NoGCRegion)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector and unmanaged resources</source>
          <target state="translated">ガベージ コレクターとアンマネージ リソース</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code.</source>
          <target state="translated">コレクション中に、ガベージ コレクターはオブジェクトを解放しませんマネージ コードで、オブジェクトへの 1 つまたは複数の参照を検出した場合。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so.</source>
          <target state="translated">ただし、ガベージ コレクターは、アンマネージ コードからオブジェクトへの参照では認識されませんし、これから明示的に禁止場合を除き、アンマネージ コードに排他的に使用されているオブジェクトを解放することがあります。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph>メソッドは、ガベージ コレクターがアンマネージ コードでまだ使用されているオブジェクトを収集することを防止する機構を提供します。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections.</source>
          <target state="translated">別に、マネージ メモリの割り当て、ガベージ コレクターの実装は、ファイル ハンドルやデータベース接続などのオブジェクトによって保持されているリソースに関する情報を保持しています。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</source>
          <target state="translated">型は、その型のインスタンスがクリアされる前に解放する必要がありますのあるアンマネージ リソースを使用しているときに、型はファイナライザーを実装できます。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In most cases, finalizers are implemented by overriding the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <ph id="ph2">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">ほとんどの場合、ファイナライザーはオーバーライドすることで、<ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>メソッドです。 ただし、デストラクター、のオーバーライドを有効にするコンパイラの実装 (C#) または C++ で記述された型<ph id="ph2">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object.</source>
          <target state="translated">ほとんどの場合、オブジェクトに、ファイナライザーがある場合、ガベージ コレクターでそのオブジェクトを解放する前に、</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>However, the garbage collector is not required to call finalizers in all situations; for example, the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method explicitly prevents an object's finalizer from being called.</source>
          <target state="translated">ただし、ガベージ コレクターはすべての状況でファイナライザーを呼び出す必要はありません。たとえば、<ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>メソッドが呼び出されることを明示的にオブジェクトのファイナライザーを防止します。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</source>
          <target state="translated">また、ガベージ コレクターを特定のスレッドを使用して、オブジェクトの終了またはファイナライザーが相互に参照が、ガベージ コレクション用に使用できるオブジェクトに対して呼び出される順序を保証する必要はありません。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In scenarios where resources must be released at a specific time, classes can implement the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface, which contains the <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> method that performs resource management and cleanup tasks.</source>
          <target state="translated">クラスに実装できる特定の時刻にリソースを解放する必要がありますのシナリオで、<ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>インターフェイスが含まれています、<ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph>リソースの管理およびクリーンアップのタスクを実行するメソッド。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Classes that implement <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> must specify, as part of their class contract, if and when class consumers call the method to clean up the object.</source>
          <target state="translated">実装するクラス<ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>必要がありますを指定、クラス コントラクトの一部としてクラスのコンシューマーが、オブジェクトをクリーンアップするメソッドを呼び出す場合。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector does not, by default, call the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method; however, implementations of the <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method can call methods in the <ph id="ph3">&lt;xref:System.GC&gt;</ph> class to customize the finalization behavior of the garbage collector.</source>
          <target state="translated">ガベージ コレクターは、既定では、呼び出しません、<ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>メソッドです。 ただし、の実装、<ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>メソッド メソッドを呼び出すことができます、<ph id="ph3">&lt;xref:System.GC&gt;</ph>ガベージ コレクターの終了処理動作をカスタマイズするクラス。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>For more information on object finalization and the dispose pattern, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">オブジェクトの終了処理し、dispose パターンの詳細については、次を参照してください。<bpt id="p1">[</bpt>アンマネージ リソースのクリーンアップ<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Object aging and generations</source>
          <target state="translated">オブジェクトのエージング機能と生成結果</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector in the common language runtime supports object aging using generations.</source>
          <target state="translated">共通言語ランタイムのガベージ コレクターには、世代を使用してオブジェクトの世代がサポートしています。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>A generation is a unit of measure of the relative age of objects in memory.</source>
          <target state="translated">生成結果は、メモリ内のオブジェクトの相対的な有効期間の測定単位です。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The generation number, or age, of an object indicates the generation to which an object belongs.</source>
          <target state="translated">世代番号、またはオブジェクトの経過期間は、オブジェクトが所属する生成を示します。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle.</source>
          <target state="translated">最近作成されたオブジェクトは新しいジェネレーションの一部であるいてオブジェクトの既に作成したアプリケーション ライフ サイクルよりも小さいジェネレーション番号になります。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Objects in the most recent generation are in generation 0.</source>
          <target state="translated">最も新しいジェネレーションのオブジェクトでは、ジェネレーション 0 にします。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2.</source>
          <target state="translated">ガベージ コレクターのこの実装では、オブジェクトの 3 つの世代、ジェネレーション 0、1、および 2 をサポートします。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum generation number supported by the system.</source>
          <target state="translated">値を取得することができます、<ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph>プロパティをシステムでサポートされている最大のジェネレーション番号を決定します。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.</source>
          <target state="translated">オブジェクトの世代は、ガベージ コレクターがすべてのジェネレーションを評価するを必要とするのではなく、ジェネレーションの特定のセットでアプリケーションを対象のガベージ コレクションをできます。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Overloads of the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method that include a <ph id="ph2">`generation`</ph> parameter allow you to specify the oldest generation to be garbage collected.</source>
          <target state="translated">オーバー ロードが、<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>メソッドを含む、<ph id="ph2">`generation`</ph>パラメーターを使用する最も古いジェネレーションのガベージ コレクション実行を指定します。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Disallowing garbage collection</source>
          <target state="translated">ガベージ コレクションを禁止します。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance.</source>
          <target state="translated">以降で、 <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>、ガベージ コレクターは、GC 領域の無待機モードでガベージ コレクションによって低下アプリのパフォーマンスのクリティカル パスの実行中に使用できるをサポートしています。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector.</source>
          <target state="translated">GC 領域の無待機モードは、干渉なし、ガベージ コレクターから割り当て可能なメモリの量を指定することが必要です。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.</source>
          <target state="translated">場合は、ランタイムは、そのメモリを割り当てることができます、ランタイムはない実行ガベージ コレクションのクリティカル パスにコードが実行中にします。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You define the beginning of the critical path of the no GC region by calling one of the overloads of the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>.</source>
          <target state="translated">オーバー ロードのいずれかを呼び出していない GC 領域のクリティカル パスの先頭を定義する、<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You specify the end of its critical path by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">呼び出して、クリティカル パスの末尾を指定する、<ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">呼び出しをネストすることはできません、<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>メソッド、およびするのみを呼び出す、<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>メソッドの場合は、ランタイムが GC 領域の無待機モードになっています。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">つまり、呼び出す必要はありません<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>複数回 (最初のメソッド呼び出しの後に後続の呼び出しは成功しません)、呼び出しをすることはありませんし<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>を最初の呼び出しからといってを成功させる<ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>に成功しました。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The following example uses several GC methods to get generation and memory information about a block of unused objects and print it to the console.</source>
          <target state="translated">次の例では、いくつかの GC メソッドを使用して、生成と使用されていないオブジェクトのブロックのメモリ情報を取得し、コンソールに出力します。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The unused objects are then collected, and the resulting memory totals are displayed.</source>
          <target state="translated">使用されていないオブジェクトを収集し、され、結果として得られるメモリの合計が表示されます。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>The incremental amount of unmanaged memory that has been allocated.</source>
          <target state="translated">割り当てられたアンマネージ メモリの増加量。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</source>
          <target state="translated">アンマネージ メモリが大規模に割り当てられたため、ガベージ コレクションをスケジュールするときに考慮する必要があることが、ランタイムに通知されます。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</source>
          <target state="translated">ガベージ コレクションのスケジュールを設定する時期を判断するには、ランタイムは考慮マネージ メモリの量が割り当てられます。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</source>
          <target state="translated">小規模のマネージ オブジェクトがアンマネージ メモリの消費量を割り当てる場合、ランタイムはマネージ メモリのみを考慮し、したがってガベージ コレクションのスケジュールの緊急度を過小評価します。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method informs the runtime of this additional pressure on system memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph>メソッドをシステム メモリの不足しているこの追加のランタイムに通知します。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the <ph id="ph1">`Dispose`</ph> or <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">パターンでは、最も簡単な使用方法、マネージ オブジェクト コンス トラクターで、アンマネージ メモリの割り当てし、解放で、<ph id="ph1">`Dispose`</ph>または<ph id="ph2">`Finalize`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method after allocating the unmanaged memory, and call the <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method after releasing it.</source>
          <target state="translated">呼び出す、 <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> 、アンマネージ メモリの割り当て後にメソッドを呼び出すと、<ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph>解放するとメソッド。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> methods to communicate these incremental changes to the runtime.</source>
          <target state="translated">呼び出すことができますをアンマネージ メモリの割り当てが変更された大幅にマネージ オブジェクトの有効期間中より複雑なシナリオで、<ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph>ランタイムに増分変更を通知するメソッド。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>You must ensure that you remove exactly the amount of pressure you add.</source>
          <target state="translated">追加する負荷の量だけを削除することを確認する必要があります。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</source>
          <target state="translated">これに失敗すると、長期間にわたって実行されるアプリケーションでは、システムのパフォーマンスが低下することができます。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is less than or equal to 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> が 0 以下です。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>On a 32-bit computer, <ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is larger than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">32 ビットのコンピューターで、<ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> の値が <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> の値を超えています。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>for the ability to call unmanaged code when manipulating garbage-collection priority.</source>
          <target state="translated">ガベージ コレクションの優先順位を操作するときに、アンマネージ コードを呼び出す必要なアクセス許可。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">関連する列挙。 <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.GC.CancelFullGCNotification">
          <source>Cancels the registration of a garbage collection notification.</source>
          <target state="translated">ガベージ コレクションの通知の登録をキャンセルします。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This method cancels a garbage collection notification that was registered by using the <ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">このメソッドは、使用して登録されたガベージ コレクションの通知をキャンセル、<ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">後続の呼び出しでパラメーター値のしきい値を調整する前にこのメソッドを呼び出すしなくても、<ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>The following example cancels a garbage collection registration.</source>
          <target state="translated">次の例では、ガベージ コレクションの登録をキャンセルします。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This example is part of a larger example provided for the <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">この例に示されている例の一部である、<bpt id="p1">[</bpt>ガベージ コレクションの通知<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>トピックです。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.GC.CancelFullGCNotification">
          <source>This member is not available when concurrent garbage collection is enabled.</source>
          <target state="translated">同時実行ガベージ コレクションが有効の場合、このメンバーは使用できません。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.GC.CancelFullGCNotification">
          <source>See the <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>gcConcurrent<ph id="ph2">&amp;gt;</ph><ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)</ept> runtime setting for information about how to disable concurrent garbage collection.</source>
          <target state="translated">同時実行ガベージ コレクションを無効にする方法については、<bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>gcConcurrent<ph id="ph2">&amp;gt;</ph><ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)</ept> 実行時設定をご覧ください。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているコードから使用することはできません。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Forces garbage collection.</source>
          <target state="translated">強制的にガベージ コレクションを行います。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.GC.Collect">
          <source>Forces an immediate garbage collection of all generations.</source>
          <target state="translated">すべてのジェネレーションのガベージ コレクションを直ちに強制実行します。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>Use this method to try to reclaim all memory that is inaccessible.</source>
          <target state="translated">このメソッドを使用して、アクセスできなくなっているすべてのメモリを解放しようとしてください。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>It performs a blocking garbage collection of all generations.</source>
          <target state="translated">すべてのジェネレーションのブロッキング ガベージ コレクションを実行します。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected.</source>
          <target state="translated">どのくらいの時間が長かった、メモリ内に関係なく、すべてのオブジェクトがコレクションの対象します。ただし、マネージ コードで参照されるオブジェクトが収集されません。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>Use this method to force the system to try to reclaim the maximum amount of available memory.</source>
          <target state="translated">このメソッドを使用して、強制的に使用可能なメモリの最大量を解放しようとしてください。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>, you can compact the large object heap (LOH) by setting the <ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property to <ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> before calling the <ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph> method, as the following example illustrates.</source>
          <target state="translated">以降で、<ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>を設定して、大きなオブジェクト ヒープ (LOH) を圧縮することができます、<ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph>プロパティを<ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph>呼び出す前に、<ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph>メソッドでは、次の例として示します。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to perform a collection on all generations of memory.</source>
          <target state="translated">次の例で使用する方法、<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>メモリのすべてのジェネレーションのコレクションを実行するメソッド。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>The code generates a number of unused objects, and then calls the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to clean them from memory.</source>
          <target state="translated">コードは、使用されていないオブジェクトの数を生成しを呼び出して、<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>メモリから消去します。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">ガベージ コレクションを行うべき最も古いジェネレーションの番号。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32)">
          <source>Forces an immediate garbage collection from generation 0 through a specified generation.</source>
          <target state="translated">ジェネレーション 0 から指定ジェネレーションまでのガベージ コレクションを直ちに強制実行します。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>Use this method to try to reclaim memory that is inaccessible.</source>
          <target state="translated">このメソッドを使用して、アクセスできるメモリの解放を試みます。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</source>
          <target state="translated">ただし、このメソッドを使用していないわけでは、指定したジェネレーション内のすべてのアクセスできないメモリが解放されることです。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation.</source>
          <target state="translated">世代番号のオブジェクトは、ガベージ コレクターによって収集されませんオブジェクトの世代が実装されている場合は、指定したジェネレーションよりも高い。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</source>
          <target state="translated">オブジェクトの世代が実装されていない場合、ガベージ コレクターは、ガベージ コレクション中にすべてのオブジェクトを考慮します。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum valid value of the <ph id="ph2">`generation`</ph> parameter.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph>の最大有効値を決定するプロパティ、<ph id="ph2">`generation`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</source>
          <target state="translated">すべてのオブジェクトの世代に関係なく、ガベージ コレクターには、このパラメーターをとらないメソッドのバージョンを使用します。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>To have the garbage collector reclaim objects based on a <ph id="ph1">&lt;xref:System.GCCollectionMode&gt;</ph> setting, use the <ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">に基づいてオブジェクトの再利用、ガベージ コレクターを使用して、<ph id="ph1">&lt;xref:System.GCCollectionMode&gt;</ph>設定を使用して、<ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to perform a collection on individual layers of memory.</source>
          <target state="translated">次の例で使用する方法、<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>メモリの個々 のレイヤーのコレクションを実行するメソッド。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>The code generates a number of unused objects, and then calls the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to clean them from memory.</source>
          <target state="translated">コードは、使用されていないオブジェクトの数を生成しを呼び出して、<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>メモリから消去します。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> が無効です。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">ガベージ コレクションを行うべき最も古いジェネレーションの番号。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>An enumeration value that specifies whether the garbage collection is forced (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) or optimized (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</source>
          <target state="translated">ガベージ コレクションが強制実行になっている (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> または <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) か、最適化になっている (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>) かを示す列挙値。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> 値によって指定したタイミングで、ジェネレーション 0 から指定ジェネレーションまでのガベージ コレクションを強制的に実行します。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Use the <ph id="ph1">`mode`</ph> parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects.</source>
          <target state="translated">使用して、<ph id="ph1">`mode`</ph>パラメーターを指定するかどうかガベージ コレクションを実行するのみか、すぐに、時間はオブジェクトの再利用するのに最適です。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</source>
          <target state="translated">このメソッドを使用しても、指定したジェネレーション内のすべてのアクセスできないメモリが解放されることとは限りません。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>To adjust the intrusiveness of garbage collection during critical periods in your application, set the <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LatencyMode%2A&gt;</ph> property.</source>
          <target state="translated">アプリケーションで重要な期間中にガベージ コレクションの割り込みの動作を調整するには<ph id="ph1">&lt;xref:System.Runtime.GCSettings.LatencyMode%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>The garbage collector does not collect objects with a generation number higher than specified by the <ph id="ph1">`generation`</ph> parameter.</source>
          <target state="translated">ガベージ コレクターはジェネレーションの番号で指定されたよりも高いのオブジェクトを収集しません、<ph id="ph1">`generation`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Use the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum valid value of <ph id="ph2">`generation`</ph>.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph>の最大有効値を決定するプロパティ<ph id="ph2">`generation`</ph>です。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</source>
          <target state="translated">すべてのオブジェクトの世代に関係なく、ガベージ コレクターには、このパラメーターをとらないメソッドのバージョンを使用します。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>To have the garbage collector reclaim objects up to a specified generation of objects, use the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">オブジェクトの指定ジェネレーションまでのオブジェクトの再利用を使用して、ガベージ コレクターを使用して、<ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>When you specify the maximum generation, all objects are collected.</source>
          <target state="translated">Generation の最大値を指定する場合は、すべてのオブジェクトが収集されます。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>The following example forces a garbage collection for generation 2 objects with the <ph id="ph1">&lt;xref:System.GCCollectionMode.Optimized&gt;</ph> setting.</source>
          <target state="translated">次の例には、第 2 世代のオブジェクトをガベージ コレクションが強制実行、<ph id="ph1">&lt;xref:System.GCCollectionMode.Optimized&gt;</ph>設定します。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> が無効です。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> は <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> 値のいずれでもありません。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">ガベージ コレクションを行うべき最も古いジェネレーションの番号。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>An enumeration value that specifies whether the garbage collection is forced (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) or optimized (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</source>
          <target state="translated">ガベージ コレクションが強制実行になっている (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> または <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) か、最適化になっている (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>) かを示す列挙値。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a blocking garbage collection; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a background garbage collection where possible.</source>
          <target state="translated">ブロッキング ガベージ コレクションを実行する場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。可能な限りバックグラウンド ガベージ コレクションを実行する場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> value, with a value specifying whether the collection should be blocking.</source>
          <target state="translated">ジェネレーション 0 から指定ジェネレーションまでのガベージ コレクションを、 <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> 値で指定したタイミングで強制実行します。コレクションをブロックする必要があるかどうかを指定する値を指定します。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The following table summarizes the interaction of the <ph id="ph1">`mode`</ph> and <ph id="ph2">`blocking`</ph> parameters:</source>
          <target state="translated">次の表の相互作用をまとめたもの、<ph id="ph1">`mode`</ph>と<ph id="ph2">`blocking`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">`blocking`</ph> is <ph id="ph2">`true`</ph></source>
          <target state="translated"><ph id="ph1">`blocking`</ph> は <ph id="ph2">`true`</ph> です</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">`blocking`</ph> is <ph id="ph2">`false`</ph></source>
          <target state="translated"><ph id="ph1">`blocking`</ph> は <ph id="ph2">`false`</ph> です</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.GCCollectionMode.Forced&gt;</ph> or <ph id="ph2">&lt;xref:System.GCCollectionMode.Default&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GCCollectionMode.Forced&gt;</ph> または <ph id="ph2">&lt;xref:System.GCCollectionMode.Default&gt;</ph></target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A blocking collection is performed as soon as possible.</source>
          <target state="translated">ブロッキング コレクションはできるだけ早く実行されます。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is in progress and <ph id="ph1">`generation`</ph> is 0 or 1, the <ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method immediately triggers a blocking collection and returns when the collection is finished.</source>
          <target state="translated">バック グラウンド コレクションが実行中である場合と<ph id="ph1">`generation`</ph>が 0 または 1 の場合、<ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph>メソッドは直ちにブロッキング コレクションをトリガーし、コレクションが完了したらを返します。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is in progress and <ph id="ph1">`generation`</ph> is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</source>
          <target state="translated">バック グラウンド コレクションが実行中である場合と<ph id="ph1">`generation`</ph>は、2、バック グラウンド コレクションが終了して、ジェネレーション 2 のブロッキング コレクションをトリガーし、返されるまで、メソッドを待機します。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A collection is performed as soon as possible.</source>
          <target state="translated">コレクションはできるだけ早く実行されます。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> メソッドはバックグラウンド コレクションを要求しますが、それは保証されず、状況によってはブロッキング コレクションが実行される場合もあります。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is already in progress, the method returns immediately.</source>
          <target state="translated">バックグラウンド コレクションが既に実行中の場合、メソッドはすぐに制御を返します。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A blocking collection may be performed, depending on the state of the garbage collector and the <ph id="ph1">`generation`</ph> parameter.</source>
          <target state="translated">ガベージ コレクターおよび <ph id="ph1">`generation`</ph> パラメーターの状態によっては、ブロッキング コレクションが実行される場合があります。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The garbage collector tries to provide optimal performance.</source>
          <target state="translated">ガベージ コレクターは最適なパフォーマンスを提供しようとします。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A collection may be performed, depending on the state of the garbage collector.</source>
          <target state="translated">ガベージ コレクターの状態によっては、コレクションが実行される場合があります。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> メソッドはバックグラウンド コレクションを要求しますが、それは保証されず、状況によってはブロッキング コレクションが実行される場合もあります。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The garbage collector tries to provide optimal performance.</source>
          <target state="translated">ガベージ コレクターは最適なパフォーマンスを提供しようとします。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is already in progress, the method returns immediately.</source>
          <target state="translated">バックグラウンド コレクションが既に実行中の場合、メソッドはすぐに制御を返します。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a call to the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property to <ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> before calling the <ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">呼び出し、<ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph>メソッドがフル ブロッキング ガベージ コレクションを実行、設定して、大きなオブジェクト ヒープを圧縮することもできます、<ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph>プロパティを<ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph>呼び出す前に、<ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> が無効です。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> は <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> 値のいずれでもありません。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">ガベージ コレクションを行うべき最も古いジェネレーションの番号。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>An enumeration value that specifies whether the garbage collection is forced (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) or optimized (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</source>
          <target state="translated">ガベージ コレクションが強制実行になっている (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> または <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) か、最適化になっている (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>) かを示す列挙値。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a blocking garbage collection; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a background garbage collection where possible.</source>
          <target state="translated">ブロッキング ガベージ コレクションを実行する場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。可能な限りバックグラウンド ガベージ コレクションを実行する場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to compact the small object heap; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to sweep only.</source>
          <target state="translated">小さなオブジェクト ヒープの圧縮を行う場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>、スイープのみ行う場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> value, with values that specify whether the collection should be blocking and compacting.</source>
          <target state="translated">ジェネレーション 0 から指定ジェネレーションまでのガベージ コレクションを、 <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> 値で指定したタイミングで強制実行します。コレクションをブロックおよび圧縮する必要があるかどうかを指定する値を指定します。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`blocking`</ph> is <ph id="ph2">`false`</ph>, the GC decides whether to perform a background or a blocking garbage collection.</source>
          <target state="translated">場合<ph id="ph1">`blocking`</ph>は<ph id="ph2">`false`</ph>GC は、バック グラウンドまたはブロッキング ガベージ コレクションを実行するかどうかを決定します。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`compacting`</ph> is <ph id="ph2">`true`</ph>, it performs a blocking garbage collection.</source>
          <target state="translated">場合<ph id="ph1">`compacting`</ph>は<ph id="ph2">`true`</ph>、ブロッキング ガベージ コレクションを実行します。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`compacting`</ph> is <ph id="ph2">`true`</ph>, the runtime compacts the small object heap (SOH).</source>
          <target state="translated">場合<ph id="ph1">`compacting`</ph>は<ph id="ph2">`true`</ph>ランタイムは、小さなオブジェクト ヒープ (SOH) を圧縮します。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>The large object heap (LOH) is not compacted unless the <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property is set to <ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">しない限り、大きなオブジェクト ヒープ (LOH) は圧縮されません、<ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph>プロパティに設定されている<ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Note that this includes all blocking garbage collections, not just full blocking garbage collections.</source>
          <target state="translated">すべてブロッキング ガベージ コレクション、いないだけフル ブロッキング ガベージ コレクションを含むことに注意してください。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>You can call the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.</source>
          <target state="translated">呼び出すことができます、<ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>次のコード フラグメントに示すように、最小サイズできるにマネージ ヒープを減らすための方法です。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Specifying <ph id="ph1">`true`</ph> for the <ph id="ph2">`compacting`</ph> argument guarantees a compacting, full blocking garbage collection.</source>
          <target state="translated">指定する<ph id="ph1">`true`</ph>の<ph id="ph2">`compacting`</ph>引数は、圧縮、フル ブロッキング ガベージ コレクションを保証します。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Setting the <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property to <ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> ensures that both the LOH and SOH are compacted.</source>
          <target state="translated">設定、<ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph>プロパティを<ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph>LOH と SOH の両方が圧縮されていることを確認します。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>The generation of objects for which the garbage collection count is to be determined.</source>
          <target state="translated">ガベージ コレクションの回数を確認するオブジェクトのジェネレーション。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>Returns the number of times garbage collection has occurred for the specified generation of objects.</source>
          <target state="translated">指定したジェネレーションのオブジェクトに対するガベージ コレクションの発生回数を返します。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>The number of times garbage collection has occurred for the specified generation since the process was started.</source>
          <target state="translated">プロセスの起動後に、指定したジェネレーションに対して発生したガベージ コレクションの回数。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>If you implement your own resource management, you might need to force garbage collection periodically by calling the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">独自のリソース管理を実装する場合は、定期的に呼び出すことによってガベージ コレクションを強制的が必要、<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently.</source>
          <target state="translated">これはコストのかかる操作であるため、ガベージ コレクションが最近発生したときに呼び出しをスキップしてパフォーマンスを向上できます。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>Save the value returned by <ph id="ph1">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> immediately after calling <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph>.</source>
          <target state="translated">によって返される値を保存する<ph id="ph1">&lt;xref:System.GC.CollectionCount%2A&gt;</ph>呼び出し直後後<ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>The next time you need to call <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>, compare the current value returned by <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> to the saved value.</source>
          <target state="translated">次に呼び出す必要があるとき<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>、によって返される現在の値を比較<ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph>保存されている値にします。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>If the two values are equal, no collection has occurred in the interim and it is reasonable to call <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> again.</source>
          <target state="translated">2 つの値が等しい場合は、その前にコレクションが発生していないしそのを呼び出す<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>もう一度です。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>Ends the no GC region latency mode.</source>
          <target state="translated">GC 領域の無待機モードを終了します。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> if the garbage collector is not in no GC region latency mode.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>メソッドがスローされます、<ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph>ガベージ コレクターが GC 領域の無待機モードにない場合。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>This occurs under any of the following conditions:</source>
          <target state="translated">これは、次の条件のいずれかで発生します。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method was not called previously.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>メソッドが以前に呼び出されませんでした。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The call to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method returned <ph id="ph2">`false`</ph>.</source>
          <target state="translated">呼び出し、<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>メソッドが返される<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The call to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method threw an exception.</source>
          <target state="translated">呼び出し、<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>メソッドが例外をスローしました。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>You can prevent an exception for any of these reasons by using code such as the following:</source>
          <target state="translated">次のようなコードを使用して、これらの理由のいずれかの例外を回避できます。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>The garbage collector is not in no GC region latency mode.</source>
          <target state="translated">ガベージ コレクターが、GC 領域の無待機モードではありません。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>The no GC region latency mode was ended previously because a garbage collection was induced.</source>
          <target state="translated">ガベージ コレクションが発生したために、GC 領域の無待機モードは前に終了されました。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>A memory allocation exceeded the amount specified in the call to the <ph id="ph1">&lt;see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /&gt;</ph> method.</source>
          <target state="translated">メモリ割り当てが、<ph id="ph1">&lt;see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /&gt;</ph> メソッドの呼び出しで指定された量を超えています。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Returns the current generation number of an object.</source>
          <target state="translated">オブジェクトの現在のジェネレーション番号を返します。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The object that generation information is retrieved for.</source>
          <target state="translated">ジェネレーションの情報を検索する対象のオブジェクト。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.Object)">
          <source>Returns the current generation number of the specified object.</source>
          <target state="translated">指定したオブジェクトの現在のジェネレーション番号を返します。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The current generation number of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> の現在のジェネレーション番号。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>Use this method to determine the age of an object, and then use that information with the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to force the garbage collector to collect objects in the same generation.</source>
          <target state="translated">このメソッドを使用して、オブジェクトの有効期間を特定しでその情報を使用して、<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>同じ世代のオブジェクトをガベージ コレクターが収集を強制する方法です。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.</source>
          <target state="translated">たとえば、一連のオブジェクトをグループとして作成されると同時にアクセスできなくなることがある場合は、このメソッドを使用します。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph> method to determine the age of an object.</source>
          <target state="translated">次の例で使用する方法、<ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph>オブジェクトの期間を確認するメソッド。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The example then performs garbage collections to clean up memory and compare the pre and post collection memory totals in the console.</source>
          <target state="translated">この例は、メモリをクリーンアップして、事前の比較をコンソールでメモリの合計をコレクションに投稿するガベージ コレクションを実行します。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>A <ph id="ph1">&lt;see cref="T:System.WeakReference" /&gt;</ph> that refers to the target object whose generation number is to be determined.</source>
          <target state="translated">ジェネレーション番号を確認する対象のオブジェクトを参照する <ph id="ph1">&lt;see cref="T:System.WeakReference" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>Returns the current generation number of the target of a specified weak reference.</source>
          <target state="translated">指定した弱い参照の対象となる現在のジェネレーション番号を返します。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>The current generation number of the target of <ph id="ph1">&lt;paramref name="wo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="wo" /&gt;</ph> の対象となる現在のジェネレーション番号。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph> method to determine the age of a weak reference object.</source>
          <target state="translated">次の例での使用、<ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph>弱参照オブジェクトの古さを調べます。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>Garbage collection has already been performed on <ph id="ph1">&lt;paramref name="wo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="wo" /&gt;</ph> に対して既にガベージ コレクションが実行されています。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">ガベージ コレクションの発生を待ってから制御を戻す場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>Retrieves the number of bytes currently thought to be allocated.</source>
          <target state="translated">現在割り当てられていると思われるバイト数を取得します。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</source>
          <target state="translated">パラメーターは、このメソッドが制御を戻す前に短い時間だけ待機して、システムがガベージ コレクションを行い、オブジェクトの終了操作を実行できるようにするかどうかを示します。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>A number that is the best available approximation of the number of bytes currently allocated in managed memory.</source>
          <target state="translated">マネージ メモリに現在割り当てられているバイト数の最もよい近似値となる数値。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>If the <ph id="ph1">`forceFullCollection`</ph> parameter is <ph id="ph2">`true`</ph>, this method waits a short interval before returning while the system collects garbage and finalizes objects.</source>
          <target state="translated">場合、<ph id="ph1">`forceFullCollection`</ph>パラメーターは<ph id="ph2">`true`</ph>、このメソッドは、システムがガベージを収集し、オブジェクトを終了させるときに返す前に、短い間隔を待機します。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles.</source>
          <target state="translated">間隔の時間は、完了したガベージ コレクション サイクルの数によって決定されます、内部的に指定された制限とサイクル間で回復メモリ量の変化です。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>The garbage collector does not guarantee that all inaccessible memory is collected.</source>
          <target state="translated">ガベージ コレクターでは、すべてのアクセスできないメモリを収集することは保証されません。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.GetTotalMemory%2A&gt;</ph> method to get and display the number of bytes currently allocated in managed memory.</source>
          <target state="translated">次の例で使用する方法、<ph id="ph1">&lt;xref:System.GC.GetTotalMemory%2A&gt;</ph>メソッドを取得し、マネージ メモリに現在割り当てられているバイト数を表示します。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The object to reference.</source>
          <target state="translated">参照するオブジェクト。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.GC.KeepAlive(System.Object)">
          <source>References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</source>
          <target state="translated">指定したオブジェクトを参照することにより、現在のルーチンの開始時からこのメソッドが呼び出される時点までの間、そのオブジェクトをガベージ コレクションの対象から外します。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The purpose of the <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.</source>
          <target state="translated">目的、<ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph>メソッドは、ガベージ コレクターによって解放される処理の途中での危険にさらされるオブジェクトへの参照の有無を確認することです。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.</source>
          <target state="translated">これが発生する一般的なシナリオは、マネージ コードまたはデータ、オブジェクトへの参照はありませんが、オブジェクトがアンマネージ Dll の場合、Win32 Api などのアンマネージ コードでは使用されている場合、または COM を使用する方法</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>This method references the <ph id="ph1">`obj`</ph> parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called.</source>
          <target state="translated">このメソッドは参照、<ph id="ph1">`obj`</ph>パラメーター、そのオブジェクトのガベージ コレクションの対象から外しますから行うルーチンの開始実行順にポイントにこのメソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>Code this method at the end, not the beginning, of the range of instructions where <ph id="ph1">`obj`</ph> must be available.</source>
          <target state="translated">最初ではなく命令の範囲の最後に、このメソッドのコードで<ph id="ph1">`obj`</ph>できる必要があります。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph>メソッドが操作を実行しないとは、パラメーターとして渡されたオブジェクトの有効期間を拡張する以外の副作用がします。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The following code example creates an object at the beginning of its <ph id="ph1">`Main`</ph> method and does not refer to the object again until the end, when the <ph id="ph2">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method is called.</source>
          <target state="translated">次のコード例の先頭にオブジェクトを作成するその<ph id="ph1">`Main`</ph>メソッドし、最後に、まで、オブジェクトを参照しないときに、<ph id="ph2">&lt;xref:System.GC.KeepAlive%2A&gt;</ph>メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The object persists for the 30-second duration of the <ph id="ph1">`Main`</ph> method, despite calls to the <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> methods.</source>
          <target state="translated">オブジェクトは、30 秒間のみが引き続き発生する、<ph id="ph1">`Main`</ph>への呼び出しに関係なく、メソッド、<ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph>と<ph id="ph3">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="P:System.GC.MaxGeneration">
          <source>Gets the maximum number of generations that the system currently supports.</source>
          <target state="translated">システムが現在サポートしている最大のジェネレーション番号を取得します。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>A value that ranges from zero to the maximum number of supported generations.</source>
          <target state="translated">0 からサポートされるジェネレーションの最大番号までの値。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan.</source>
          <target state="translated">世代番号、またはオブジェクトの経過期間は、オブジェクトの有効期間の実装定義の相対尺度です。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property.</source>
          <target state="translated">最近作成されたオブジェクトは、ジェネレーション 0 で、最も古いオブジェクトによって返される生成小さいジェネレーションで、<ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory.</source>
          <target state="translated">ガベージ コレクターは、新しいメモリがより古いメモリ ガベージ コレクションの対象とする方があることを前提とします。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property value can grow over time.</source>
          <target state="translated">そのため、ガベージ コレクターがジェネレーションの番号のたびに、メモリを解放することを調整することによって、パフォーマンスが向上し、<ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph>プロパティの値が時間の経過と共に成長ことができます。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>If object aging is implemented, the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property returns the maximum generation number used by the system; otherwise, this property returns zero.</source>
          <target state="translated">オブジェクトの世代が実装されている場合、<ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph>プロパティは、システムによって使用される最大のジェネレーション番号を返します。 それ以外の場合、このプロパティは 0 を返します。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The following example demonstrates how to use the MaxGeneration property to display the largest generation number currently in use.</source>
          <target state="translated">次の例では、MaxGeneration プロパティを使用して、現在使用中で最大のジェネレーション番号を表示する方法を示します。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>For this implementation, the value returned by the <ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph> property is guaranteed to remain constant for the lifetime of an executing application.</source>
          <target state="translated">この実装によって返される値、<ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph>プロパティは実行中のアプリケーションの有効期間が一定に保たを保証します。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>Use the <ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph> property to determine the maximum value you can specify when calling the <ph id="ph2">&lt;see cref="M:System.GC.Collect(System.Int32)" /&gt;</ph> method that takes a generation parameter.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph>を呼び出すときに指定できる最大値を決定するプロパティ、<ph id="ph2">&lt;see cref="M:System.GC.Collect(System.Int32)" /&gt;</ph>生成パラメーターを受け取るメソッド。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</source>
          <target state="translated">ジェネレーション 2 に割り当てられたオブジェクト数に基づいて通知を発行するタイミングを指定する、1 ～ 99 の数値。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</source>
          <target state="translated">大きなオブジェクトのヒープに割り当てられたオブジェクト数に基づいて通知を発行するタイミングを指定する、1 ～ 99 の数値。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</source>
          <target state="translated">フル ガベージ コレクションの可能性が高い状態のとき、およびガベージ コレクションが完了したときに、ガベージ コレクションの通知を発行する必要があることを指定します。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For each generation, the garbage collector sets a threshold for allocations into that generation.</source>
          <target state="translated">各ジェネレーションは、ガベージ コレクターは、そのジェネレーションに割り当てのしきい値を設定します。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation.</source>
          <target state="translated">割り当てのサイズがこのしきい値を超えたときに、そのジェネレーションで、ガベージ コレクションがトリガーされます。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For example, if generation 2’s threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection.</source>
          <target state="translated">例では、ジェネレーション 2 のしきい値は 20 MB (20 MB のジェネレーション 1 のコレクションで回収されなかったし、ジェネレーション 2 に昇格されたことを意味します)、20 MB を超える場合は、第 1 世代が存続したジェネレーション 2 にメッセージが表示されます、ジェネレーション 2 のコレクションとして次のガベージ コレクションが試行されます。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).</source>
          <target state="translated">同様に、大きなオブジェクト ヒープ (LOH) の場合のしきい値は 20 MB と 20 MB 以上のラージ オブジェクトの割り当て済みのアプリが、次回のガベージ コレクションも試みますジェネレーション 2 のコレクションとして (ため LOH は gen2 ガベージ コレクションでのみ収集されます)。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The <ph id="ph1">`maxGenerationThreshold`</ph> and <ph id="ph2">`largeObjectHeapThreshold`</ph> thresholds control how much in advance you are notified before a full garbage collection occurs.</source>
          <target state="translated"><ph id="ph1">`maxGenerationThreshold`</ph>と<ph id="ph2">`largeObjectHeapThreshold`</ph>しきい値を制御を事前にどの程度フル ガベージ コレクションが発生する前に通知されます。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.</source>
          <target state="translated">しきい値よりも大きいが、割り当て通知と次の完全なガベージ コレクションの間に発生することができます。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method) when conditions are still favorable.</source>
          <target state="translated">ランタイムが完全なガベージ コレクションを行い、そのコレクションを自分でコレクションを発生させることで回避するときに通知する求められる場合は、アプリケーションのパフォーマンスは、共通言語ランタイムによるフル ガベージ コレクションに悪影響を及ぼす場合がある場合は、(を使用して、<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>メソッド) の条件がまだ有効な場合です。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:</source>
          <target state="translated">ガベージ コレクションのスケジュールを自分で変更だけでなくフル GC 通知は、次のシナリオに便利です。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries).</source>
          <target state="translated">フル ガベージ コレクションのアプローチを監視して、(たとえば、いくつかのキャッシュ エントリを解放する) をライブ データのサイズを小さく 1 つに近づいていることを確認するメッセージが表示されたら、します。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>As a result, when the garbage collection occurs, it is able to reclaim more memory.</source>
          <target state="translated">その結果、ガベージ コレクションが発生するより多くのメモリを解放できないです。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>You monitor for the completion of a full garbage collection so that you can collect some statistics.</source>
          <target state="translated">監視するフル ガベージ コレクションが完了できるように、いくつかの統計を収集することができます。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For example, you might want to measure the size of the heap at GC completion so that you know the size of live data.</source>
          <target state="translated">たとえば、ライブ データのサイズがわかるように、GC の終了時にヒープのサイズを測定することができます。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>(After a full GC, the heap is at its smallest size.)</source>
          <target state="translated">(フル GC では、後に、ヒープの最小サイズで)。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For more information about what represents a full garbage collection, see <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>.</source>
          <target state="translated">詳細については、フル ガベージ コレクションが何を表す、次を参照してください。<bpt id="p1">[</bpt>ガベージ コレクションの通知<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed.</source>
          <target state="translated">ガベージ コレクションの通知を登録するときにフル ガベージ コレクションが近づいているとき、およびが完了を通知できます。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This pattern resembles how the operating system monitors for low memory notifications.</source>
          <target state="translated">このパターンでは、オペレーティング システムがメモリ不足の通知を監視する方法に似ています。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>Use the following guidelines for specifying the <ph id="ph1">`maxGenerationThreshold`</ph> and <ph id="ph2">`largeObjectHeapThreshold`</ph> parameters:</source>
          <target state="translated">指定するため、次のガイドラインを使用して、<ph id="ph1">`maxGenerationThreshold`</ph>と<ph id="ph2">`largeObjectHeapThreshold`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.</source>
          <target state="translated">しきい値の値が大きいほど、通知とフル ガベージ コレクションの間で複数の割り当てが発生します。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>A larger threshold value provides more opportunities for the runtime to check for an approaching collection.</source>
          <target state="translated">しきい値より大きい値では、コレクションが近づいているを確認するランタイムの機会を提供します。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This increases the likelihood that you will be notified.</source>
          <target state="translated">これには、通知する可能性が高くなります。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.</source>
          <target state="translated">ただし、ランタイムは、次のコレクションを発生させる前に複数の割り当てになるために、ありません高すぎるしきい値を設定してください。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.</source>
          <target state="translated">強制的に実行するコレクション自分で上限しきい値の値を使用して通知時に、ときに、ランタイムの次のコレクションで解放されるよりも少数のオブジェクトが再利用されます。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.</source>
          <target state="translated">しきい値の値が小さいほど、通知とフル ガベージ コレクションの割り当てが少ない。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The following example shows how to register a garbage collection notification and start a thread to monitor the status of the garbage collection notification.</source>
          <target state="translated">次の例では、ガベージ コレクションの通知を登録し、ガベージ コレクションの通知の状態を監視するスレッドを開始する方法を示します。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This code example is part of a larger example provided for <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">このコード例に示されている例の一部である<bpt id="p1">[</bpt>ガベージ コレクションの通知<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>トピックです。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maxGenerationThreshold" /&gt;</ph> or <ph id="ph2">&lt;paramref name="largeObjectHeapThreshold" /&gt;</ph> is not between 1 and 99.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxGenerationThreshold" /&gt;</ph> または <ph id="ph2">&lt;paramref name="largeObjectHeapThreshold" /&gt;</ph> は 1 ～ 99 の範囲外です。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているコードから使用することはできません。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>The amount of unmanaged memory that has been released.</source>
          <target state="translated">解放されたアンマネージ メモリの量。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</source>
          <target state="translated">アンマネージ メモリが解放され、ガベージ コレクションのスケジュールにこのメモリを考慮する必要がなくなったことをランタイムに通知します。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</source>
          <target state="translated">ガベージ コレクションのスケジュールを設定する時期を判断するには、ランタイムは考慮マネージ メモリの量が割り当てられます。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</source>
          <target state="translated">小規模のマネージ オブジェクトがアンマネージ メモリの消費量を割り当てる場合、ランタイムはマネージ メモリのみを考慮し、したがってガベージ コレクションのスケジュールの緊急度を過小評価します。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method informs the runtime of this additional pressure on system memory, and the <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method informs the runtime that the additional pressure has been released.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph>メソッドをシステム メモリの不足しているこの追加のランタイムに通知し、<ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph>メソッドは、追加の負荷が解放されたことをランタイムに通知します。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the <ph id="ph1">`Dispose`</ph> or <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">パターンでは、最も簡単な使用方法、マネージ オブジェクト コンス トラクターで、アンマネージ メモリの割り当てし、解放で、<ph id="ph1">`Dispose`</ph>または<ph id="ph2">`Finalize`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method after allocating the unmanaged memory, and call the <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method after releasing it.</source>
          <target state="translated">呼び出す、 <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> 、アンマネージ メモリの割り当て後にメソッドを呼び出すと、<ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph>解放するとメソッド。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> methods to communicate these incremental changes to the runtime.</source>
          <target state="translated">呼び出すことができますをアンマネージ メモリの割り当てが変更された大幅にマネージ オブジェクトの有効期間中より複雑なシナリオで、<ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph>ランタイムに増分変更を通知するメソッド。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>You must ensure that you remove exactly the amount of pressure you add.</source>
          <target state="translated">追加する負荷の量だけを削除することを確認する必要があります。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</source>
          <target state="translated">これに失敗すると、長期間にわたって実行されるアプリケーションでは、システムのパフォーマンスが低下することができます。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is less than or equal to 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> が 0 以下です。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>On a 32-bit computer, <ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is larger than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">32 ビットのコンピューターで、<ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> の値が <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> の値を超えています。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>for the ability to call unmanaged code when manipulating garbage-collection priority.</source>
          <target state="translated">ガベージ コレクションの優先順位を操作するときに、アンマネージ コードを呼び出す必要なアクセス許可。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">関連する列挙。 <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The object that a finalizer must be called for.</source>
          <target state="translated">ファイナライザーの呼び出しが必要なオブジェクト。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>Requests that the system call the finalizer for the specified object for which <ph id="ph1">&lt;see cref="M:System.GC.SuppressFinalize(System.Object)" /&gt;</ph> has previously been called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.GC.SuppressFinalize(System.Object)" /&gt;</ph> が事前に呼び出されている指定オブジェクトに対して、ファイナライザーを呼び出すことをシステムに要求します。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> method adds the <ph id="ph2">`obj`</ph> parameter to the list of objects that request finalization before the garbage collector frees the object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph>メソッドを追加、<ph id="ph2">`obj`</ph>ガベージ コレクターがオブジェクトを解放する前に、終了処理を要求するオブジェクトの一覧へのパラメーターです。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The <ph id="ph1">`obj`</ph> parameter must be the caller of this method.</source>
          <target state="translated"><ph id="ph1">`obj`</ph>パラメーターはこのメソッドの呼び出し元である必要があります。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> method does not guarantee that the garbage collector will call an object's finalizer.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph>メソッドは、ガベージ コレクターがオブジェクトのファイナライザーを呼び出すことを保証しません。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method.</source>
          <target state="translated">既定では、ファイナライザーを実装するすべてのオブジェクトが終了操作を必要とするオブジェクトの一覧に追加されます。ただし、オブジェクトの可能性がありますが既に終了されているまたは可能性がありますが無効になっているファイナライズを呼び出して、<ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>A finalizer can use this method to resurrect itself or an object that it references.</source>
          <target state="translated">ファイナライザーは、そのリング自体またはそれが参照するオブジェクトを再生するのにこのメソッドを使用できます。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The following example demonstrates how to use the ReRegisterForFinalize method to finalize an object a second time after garbage collection.</source>
          <target state="translated">次の例では、ReRegisterForFinalize メソッドを 2 回目のオブジェクトの最終処理を使用してガベージ コレクションの後に時間。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>The object whose finalizer must not be executed.</source>
          <target state="translated">実行すべきではないファイナライザーを持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>Requests that the common language runtime not call the finalizer for the specified object.</source>
          <target state="translated">指定したオブジェクトに対してファイナライザーを呼び出さないことを共通言語ランタイムに要求します。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>This method sets a bit in the object header of <ph id="ph1">`obj`</ph>, which the runtime checks when calling finalizers.</source>
          <target state="translated">このメソッドは、ビットのオブジェクトのヘッダーを設定<ph id="ph1">`obj`</ph>ランタイムがファイナライザーを呼び出すときに照合します。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>A finalizer, which is represented by the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method, is used to release unmanaged resources before an object is garbage-collected.</source>
          <target state="translated">によって表される、ファイナライザー、<ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>オブジェクトがガベージ コレクトされる前に、アンマネージ リソースを解放するメソッドを使用します。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>If <ph id="ph1">`obj`</ph> does not have a finalizer, the call to the <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method has no effect.</source>
          <target state="translated">場合<ph id="ph1">`obj`</ph>への呼び出し、ファイナライザーを持たない、<ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>メソッドも何も起こりません。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>Objects that implement the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface can call this method from the object's <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation to prevent the garbage collector from calling <ph id="ph3">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> on an object that does not require it.</source>
          <target state="translated">実装するオブジェクト、<ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>インターフェイスは、オブジェクトからこのメソッドを呼び出すことができます<ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph>を呼び出して、ガベージ コレクターを防ぐために実装<ph id="ph3">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>できる必要のないオブジェクトにします。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation.</source>
          <target state="translated">ファイナライザーがによって既に解放されているアンマネージ リソースを解放するを防ぐためにこれは、通常、<ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph>実装します。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method in a resource class to prevent a redundant garbage collection from being called.</source>
          <target state="translated">次の例で使用する方法、<ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>冗長なガベージ コレクションが呼び出されるようにリソース クラスのメソッドです。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>The example uses the <bpt id="p1">[</bpt>dispose pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> to free both managed resources (that is, objects that implement <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>) and unmanaged resources.</source>
          <target state="translated">この例では、 <bpt id="p1">[</bpt>dispose パターン<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>両方を解放するマネージ リソース (を実装するには、オブジェクト<ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>) リソースとアンマネージ リソース。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Attempts to disallow garbage collection during the execution of a critical path.</source>
          <target state="translated">クリティカル パスの実行中はガベージ コレクションが行われないよう、試行します。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">呼び出しをネストすることはできません、<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>メソッド、およびするのみを呼び出す、<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>メソッドの場合は、ランタイムが GC 領域の無待機モードになっています。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">つまり、呼び出す必要はありません<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>複数回 (最初のメソッド呼び出しの後に後続の呼び出しは成功しません)、呼び出しをすることはありませんし<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>を最初の呼び出しからといってを成功させる<ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>に成功しました。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">ガベージ コレクションをトリガーすることなく割り当てるメモリの量 (バイト) を指定します。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>It must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated">短期セグメントのサイズ以下でなければなりません。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">短期セグメントのサイズの詳細については、「<bpt id="p1">[</bpt>ガベージ コレクションの基礎<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept>」記事の "短期のジェネレーションとセグメント" セクションを参照してください。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</source>
          <target state="translated">指定した量のメモリを使用可能な場合、クリティカル パスの実行中にガベージ コレクションが行われないよう、試行します。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">ランタイムが、必要な量のメモリをコミットできたため、ガベージ コレクターが GC 領域の無待機モードに入ることができる場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%29&gt;</ph>メソッドは、ガベージ コレクターに GC 領域の無待機モード、によってコードの重要な領域をアプリが実行中にガベージ コレクションを禁止されている配置しようとしています。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</source>
          <target state="translated">ランタイムは、最初に要求したメモリ量を割り当てることができませんが、ガベージ コレクターで追加メモリを解放するためにフル ブロッキング ガベージ コレクションを実行します。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * <ph id="ph1">`totalSize`</ph> bytes (it attempts to allocate <ph id="ph2">`totalSize`</ph> bytes for the small object heap and <ph id="ph3">`totalSize`</ph> bytes for the large object heap).</source>
          <target state="translated">ガベージ コレクターには GC 領域の無待機モードがない場合は、必要なメモリの量、ここでは実際には 2 を割り当てることができません *<ph id="ph1">`totalSize`</ph>バイト (割り当てしよう<ph id="ph2">`totalSize`</ph>小さなオブジェクト ヒープのバイト数と<ph id="ph3">`totalSize`</ph>大きなオブジェクト ヒープのバイト数)。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source><ph id="ph1">`totalSize`</ph> must be large enough to handle all memory allocations that occur in the critical path.</source>
          <target state="translated"><ph id="ph1">`totalSize`</ph> クリティカル パスで発生したすべてのメモリ割り当てを処理するのに十分な大きさである必要があります。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">これには、アプリケーションによって割り当てだけでなく、ランタイムは、アプリの代わりに、割り当てが含まれます。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">呼び出しをネストすることはできません、<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>メソッド、およびするのみを呼び出す、<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>メソッドの場合は、ランタイムが GC 領域の無待機モードになっています。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">つまり、呼び出す必要はありません<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>複数回 (最初のメソッド呼び出しの後に後続の呼び出しは成功しません)、呼び出しをすることはありませんし<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>を最初の呼び出しからといってを成功させる<ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>に成功しました。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">呼び出して、GC 領域の無待機モードを終了する、<ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> は、短期セグメント サイズを超えています。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">プロセスは既に、非 GC 領域待機時間モードになっています。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">ガベージ コレクションをトリガーすることなく割り当てるメモリの量 (バイト) を指定します。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>It must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated">短期セグメントのサイズ以下でなければなりません。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">短期セグメントのサイズの詳細については、「<bpt id="p1">[</bpt>ガベージ コレクションの基礎<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept>」記事の "短期のジェネレーションとセグメント" セクションを参照してください。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> bytes; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">ガベージ コレクターが最初に <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> バイトを割り当てられなかったときにフル ブロッキング ガベージ コレクションを省略する場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</source>
          <target state="translated">指定した量のメモリを使用可能な場合は、クリティカル パスの実行中にガベージ コレクションが行われないよう、試行します。また、最初に十分な量のメモリを使用できない場合に、ガベージ コレクターがフル ブロッキング ガベージ コレクションを実行するかどうかを制御します。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">ランタイムが、必要な量のメモリをコミットできたため、ガベージ コレクターが GC 領域の無待機モードに入ることができる場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29&gt;</ph>メソッドは、ガベージ コレクターに GC 領域の無待機モード、によってコードの重要な領域をアプリが実行中にガベージ コレクションを禁止されている配置しようとしています。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>If the runtime is unable to initially allocate the requested amount of memory and the <ph id="ph1">`disallowFullBlockingGC`</ph> argument is <ph id="ph2">`false`</ph>, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">かどうか、ランタイムは最初に要求したメモリ量を割り当てることはおよび<ph id="ph1">`disallowFullBlockingGC`</ph>引数は<ph id="ph2">`false`</ph>、追加のメモリを解放しようとすると、ガベージ コレクターがフル ブロッキング ガベージ コレクションを実行以外の場合はそれ以外の場合、割り当ては失敗し、メソッドを返します<ph id="ph3">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * <ph id="ph1">`totalSize`</ph> (it attempts to allocate <ph id="ph2">`totalSize`</ph> for the small object heap and <ph id="ph3">`totalSize`</ph> for the large object heap).</source>
          <target state="translated">ガベージ コレクターには GC 領域の無待機モードがない場合は、必要なメモリの量、ここでは実際には 2 を割り当てることができません * <ph id="ph1">`totalSize`</ph> (割り当てるしよう<ph id="ph2">`totalSize`</ph>小さなオブジェクト ヒープと<ph id="ph3">`totalSize`</ph>大きなオブジェクト ヒープ) です。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">`totalSize`</ph> must be large enough to handle all memory allocations that occur in the critical path.</source>
          <target state="translated"><ph id="ph1">`totalSize`</ph> クリティカル パスで発生したすべてのメモリ割り当てを処理するのに十分な大きさである必要があります。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">これには、アプリケーションによって割り当てだけでなく、ランタイムは、アプリの代わりに、割り当てが含まれます。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>Setting <ph id="ph1">`disallowFullBlockingGC`</ph> to <ph id="ph2">`true`</ph> to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns <ph id="ph3">`true`</ph>, and have the load balancer redirect requests to other systems if it returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">設定<ph id="ph1">`disallowFullBlockingGC`</ph>に<ph id="ph2">`true`</ph>をフル ブロッキング ガベージを回避するのに十分なメモリが最初に利用可能な場合は、コレクションが負荷分散のシナリオで最も役に立つ: 1 つのシステムがこのメソッドを呼び出すし、報告して返された場合は、要求を受け入れる準備ができて<ph id="ph3">`true`</ph>、返された場合、その他のシステムに要求をリダイレクトするロード バランサーがあると<ph id="ph4">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>It can then do a full blocking garbage collection when it's not handling requests by calling the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">これを実行できますフル ブロッキング ガベージ コレクションを呼び出して要求は処理されません。 ときに、<ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">呼び出しをネストすることはできません、<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>メソッド、およびするのみを呼び出す、<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>メソッドの場合は、ランタイムが GC 領域の無待機モードになっています。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">つまり、呼び出す必要はありません<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>複数回 (最初のメソッド呼び出しの後に後続の呼び出しは成功しません)、呼び出しをすることはありませんし<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>を最初の呼び出しからといってを成功させる<ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>に成功しました。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">呼び出して、GC 領域の無待機モードを終了する、<ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> は、短期セグメント サイズを超えています。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">プロセスは既に、非 GC 領域待機時間モードになっています。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">ガベージ コレクションをトリガーすることなく割り当てるメモリの量 (バイト) を指定します。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> –<bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> – <bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> は短期セグメントのサイズ以下でなければなりません。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">短期セグメントのサイズの詳細については、「<bpt id="p1">[</bpt>ガベージ コレクションの基礎<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept>」記事の "短期のジェネレーションとセグメント" セクションを参照してください。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The number of bytes in <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> to use for large object heap (LOH) allocations.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> のうち、大きなオブジェクト ヒープ (LOH) の割り当てに使用するバイト数。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</source>
          <target state="translated">大きなオブジェクト ヒープおよび小さなオブジェクト ヒープに対して、指定した量のメモリを使用可能な場合、クリティカル パスの実行中にガベージ コレクションが行われないよう、試行します。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">ランタイムが、必要な量のメモリをコミットできたため、ガベージ コレクターが GC 領域の無待機モードに入ることができる場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29&gt;</ph>メソッドは、ガベージ コレクターに GC 領域の無待機モード、によってコードの重要な領域をアプリが実行中にガベージ コレクションを禁止されている配置しようとしています。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</source>
          <target state="translated">ランタイムは、最初に要求したメモリ量を割り当てることができませんが、ガベージ コレクターで追加メモリを解放するためにフル ブロッキング ガベージ コレクションを実行します。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate <ph id="ph1">`lohSize`</ph> for the LOH and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> for the small object heap (SOH).</source>
          <target state="translated">ガベージ コレクターが入るありません GC 領域の無待機モードに割り当てられない場合<ph id="ph1">`lohSize`</ph>LOH のおよび<ph id="ph2">`totalSize`</ph>–<ph id="ph3">`lohSize`</ph>小さなオブジェクト ヒープ (SOH)。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><ph id="ph1">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the LOH, and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the SOH.</source>
          <target state="translated"><ph id="ph1">`lohSize`</ph> LOH のクリティカル パスで発生したすべてのメモリ割り当てを処理するのに十分な大きさである必要がありますと<ph id="ph2">`totalSize`</ph>– <ph id="ph3">`lohSize`</ph> SOH のクリティカル パスで発生したすべてのメモリ割り当てを処理するのに十分な大きさである必要があります。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">これには、アプリケーションによって割り当てだけでなく、ランタイムは、アプリの代わりに、割り当てが含まれます。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">呼び出しをネストすることはできません、<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>メソッド、およびするのみを呼び出す、<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>メソッドの場合は、ランタイムが GC 領域の無待機モードになっています。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">つまり、呼び出す必要はありません<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>複数回 (最初のメソッド呼び出しの後に後続の呼び出しは成功しません)、呼び出しをすることはありませんし<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>を最初の呼び出しからといってを成功させる<ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>に成功しました。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">呼び出して、GC 領域の無待機モードを終了する、<ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> は、短期セグメント サイズを超えています。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">プロセスは既に、非 GC 領域待機時間モードになっています。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">ガベージ コレクションをトリガーすることなく割り当てるメモリの量 (バイト) を指定します。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> –<bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> – <bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> は短期セグメントのサイズ以下でなければなりません。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">短期セグメントのサイズの詳細については、「<bpt id="p1">[</bpt>ガベージ コレクションの基礎<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept>」記事の "短期のジェネレーションとセグメント" セクションを参照してください。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The number of bytes in <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> to use for large object heap (LOH) allocations.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> のうち、大きなオブジェクト ヒープ (LOH) の割り当てに使用するバイト数。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">ガベージ コレクターが指定されたメモリを最初に小さなオブジェクト ヒープ (SOH) および LOH に割り当てられないときにフル ブロッキング ガベージ コレクションを省略する場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</source>
          <target state="translated">大きなオブジェクト ヒープおよび小さなオブジェクト ヒープに対して、指定した量のメモリを使用可能な場合は、クリティカル パスの実行中にガベージ コレクションが行われないよう、試行します。また、最初に十分な量のメモリを使用できない場合に、ガベージ コレクターがフル ブロッキング ガベージ コレクションを実行するかどうかを制御します。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">ランタイムが、必要な量のメモリをコミットできたため、ガベージ コレクターが GC 領域の無待機モードに入ることができる場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29&gt;</ph>メソッドは、ガベージ コレクターに GC 領域の無待機モード、によってコードの重要な領域をアプリが実行中にガベージ コレクションを禁止されている配置しようとしています。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>If the runtime is unable to initially allocate the requested amount of memory and the <ph id="ph1">`disallowFullBlockingGC`</ph> argument is <ph id="ph2">`false`</ph>, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">かどうか、ランタイムは最初に要求したメモリ量を割り当てることはおよび<ph id="ph1">`disallowFullBlockingGC`</ph>引数は<ph id="ph2">`false`</ph>、追加のメモリを解放しようとすると、ガベージ コレクターがフル ブロッキング ガベージ コレクションを実行以外の場合はそれ以外の場合、割り当ては失敗し、メソッドを返します<ph id="ph3">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate <ph id="ph1">`lohSize`</ph> for the LOH and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> for the small object heap (SOH).</source>
          <target state="translated">ガベージ コレクターが入るありません GC 領域の無待機モードに割り当てられない場合<ph id="ph1">`lohSize`</ph>LOH のおよび<ph id="ph2">`totalSize`</ph>–<ph id="ph3">`lohSize`</ph>小さなオブジェクト ヒープ (SOH)。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the LOH, and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the SOH.</source>
          <target state="translated"><ph id="ph1">`lohSize`</ph> LOH のクリティカル パスで発生したすべてのメモリ割り当てを処理するのに十分な大きさである必要がありますと<ph id="ph2">`totalSize`</ph>– <ph id="ph3">`lohSize`</ph> SOH のクリティカル パスで発生したすべてのメモリ割り当てを処理するのに十分な大きさである必要があります。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">これには、アプリケーションによって割り当てだけでなく、ランタイムは、アプリの代わりに、割り当てが含まれます。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>Setting <ph id="ph1">`disallowFullBlockingGC`</ph> to <ph id="ph2">`true`</ph> to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns <ph id="ph3">`true`</ph>, and have the load balancer redirect requests to other systems if it returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">設定<ph id="ph1">`disallowFullBlockingGC`</ph>に<ph id="ph2">`true`</ph>をフル ブロッキング ガベージを回避するのに十分なメモリが最初に利用可能な場合は、コレクションが負荷分散のシナリオで最も役に立つ: 1 つのシステムがこのメソッドを呼び出すし、報告して返された場合は、要求を受け入れる準備ができて<ph id="ph3">`true`</ph>、返された場合、その他のシステムに要求をリダイレクトするロード バランサーがあると<ph id="ph4">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>It can then do a full blocking garbage collection when it's not handling requests by calling the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">これを実行できますフル ブロッキング ガベージ コレクションを呼び出して要求は処理されません。 ときに、<ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">呼び出しをネストすることはできません、<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>メソッド、およびするのみを呼び出す、<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>メソッドの場合は、ランタイムが GC 領域の無待機モードになっています。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">つまり、呼び出す必要はありません<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>複数回 (最初のメソッド呼び出しの後に後続の呼び出しは成功しません)、呼び出しをすることはありませんし<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>を最初の呼び出しからといってを成功させる<ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>に成功しました。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">呼び出して、GC 領域の無待機モードを終了する、<ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> は、短期セグメント サイズを超えています。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">プロセスは既に、非 GC 領域待機時間モードになっています。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</source>
          <target state="translated">共通言語ランタイムによるフル ブロッキング ガベージ コレクションが近づいているかどうかを確認するための、登録済みの通知の状態を返します。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</source>
          <target state="translated">共通言語ランタイムによるフル ブロッキング ガベージ コレクションが近づいているかどうかを確認するための、登録済みの通知の状態を返します。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">登録済みのガベージ コレクションの通知の状態。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph>列挙体を使用して登録されている現在のガベージ コレクションの通知の状態を判断するには、このメソッドによって返される、<ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to determine whether the full garbage collection has completed.</source>
          <target state="translated">使用することも、<ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph>フル ガベージ コレクションが完了したかどうかを調べます。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">列挙体が返されるときに<ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>、割り当てられていると、コレクションを強制しないで、自分で追加のオブジェクトを妨げてなどのタスクを行うことができます、<ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</source>
          <target state="translated">通知が保証されません、フル ガベージ コレクションが発生する、条件の完全なガベージ コレクションが発生する高いしきい値に達したことのみに注意してください。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This method waits indefinitely for a garbage collection notification to be obtained.</source>
          <target state="translated">このメソッドは、ガベージ コレクションの通知を取得するための無期限に待機します。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">通知を取得できないかどうかを返すメソッドのタイムアウト期間を指定する場合を使用して、<ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>If you call this method without specifying a time-out, you can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method if you are waiting longer than preferred.</source>
          <target state="translated">タイムアウトを指定せずにこのメソッドを呼び出す場合は、呼び出す、<ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph>メソッド優先よりも長い時間を待機している場合。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>You should follow this method with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">このメソッドを呼び出してを従う必要があります、<ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph>フル ガベージ コレクションがあることを確認するメソッド。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Calling this method alone causes indeterminate results.</source>
          <target state="translated">このメソッドを呼び出すだけで、不確定な結果が発生します。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>The following example shows how to use this method to determine whether a full, blocking garbage collection is approaching.</source>
          <target state="translated">次の例では、このメソッドを使用してフル ブロッキング ガベージ コレクションが近づいているかどうかを判断する方法を示します。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Whenever the status of the notification is <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, the user method <ph id="ph2">`OnFullGCApproachNotify`</ph> is called to perform actions in response to the approaching collection.</source>
          <target state="translated">通知の状態のときに<ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>、ユーザー メソッド<ph id="ph2">`OnFullGCApproachNotify`</ph>コレクションが近づいているへの応答アクションを実行すると呼びます。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This code example is part of a larger example provided for <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">このコード例に示されている例の一部である<bpt id="p1">[</bpt>ガベージ コレクションの通知<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>トピックです。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているコードから使用することはできません。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>The length of time to wait before a notification status can be obtained.</source>
          <target state="translated">通知の状態が取得されるまで待機する時間。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Specify -1 to wait indefinitely.</source>
          <target state="translated">無期限に待機するには -1 を指定します。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</source>
          <target state="translated">共通言語ランタイムによるフル ブロッキング ガベージ コレクションが近づいているかどうかを確認するための登録済みの通知の状態を、指定したタイムアウト時間で返します。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">登録済みのガベージ コレクションの通知の状態。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph>列挙体を使用して登録されている現在のガベージ コレクションの通知の状態を判断するには、このメソッドによって返される、<ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to determine whether the full garbage collection has completed.</source>
          <target state="translated">使用することも、<ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph>フル ガベージ コレクションが完了したかどうかを調べます。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by <ph id="ph1">`millisecondsTimeout`</ph>.</source>
          <target state="translated">指定された値に関係なく、ガベージ コレクションの通知の状態を取得するときにすぐに、このメソッドが戻る注<ph id="ph1">`millisecondsTimeout`</ph>です。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>If a garbage collection notification status is not obtained before <ph id="ph1">`millisecondsTimeout`</ph> times out, this method returns <ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>.</source>
          <target state="translated">前にガベージ コレクションの通知の状態が取得されていないかどうかは<ph id="ph1">`millisecondsTimeout`</ph>回、このメソッドが戻る<ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">列挙体が返されるときに<ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>、割り当てられていると、コレクションを強制しないで、自分で追加のオブジェクトを妨げてなどのタスクを行うことができます、<ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</source>
          <target state="translated">通知が保証されません、フル ガベージ コレクションが発生する、条件の完全なガベージ コレクションが発生する高いしきい値に達したことのみに注意してください。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>You can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method when you cannot wait for the time-out period to elapse.</source>
          <target state="translated">呼び出すことができます、<ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph>メソッドと、タイムアウト期間に対して、経過時間を待機することはできません。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>You should follow this method with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">このメソッドを呼び出してを従う必要があります、<ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph>フル ガベージ コレクションがあることを確認するメソッド。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Calling this method alone causes indeterminate results.</source>
          <target state="translated">このメソッドを呼び出すだけで、不確定な結果が発生します。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> must be either non-negative or less than or equal to <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> or -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> は負でない数値、<ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> 以下の数値、または -1 であることが必要です。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているコードから使用することはできません。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</source>
          <target state="translated">共通言語ランタイムによるフル ブロッキング ガベージ コレクションが完了したかどうかを確認するための、登録済みの通知の状態を返します。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</source>
          <target state="translated">共通言語ランタイムによるフル ブロッキング ガベージ コレクションが完了したかどうかを確認するための、登録済みの通知の状態を返します。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">登録済みのガベージ コレクションの通知の状態。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph>列挙体を使用して登録されている現在のガベージ コレクションの通知の状態を判断するには、このメソッドによって返される、<ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to determine whether a full garbage collection is imminent.</source>
          <target state="translated">使用することも、<ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph>フル ガベージ コレクションが近づいているかどうかを調べます。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as resuming work and obtaining a collection count with the <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> property.</source>
          <target state="translated">列挙体が返されるときに<ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>、作業を再開して、コレクションの数を取得するなどのタスクを行うことができます、<ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This method waits indefinitely for a garbage collection notification to be obtained.</source>
          <target state="translated">このメソッドは、ガベージ コレクションの通知を取得するための無期限に待機します。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">通知を取得できないかどうかを返すメソッドのタイムアウト期間を指定する場合を使用して、<ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>If you call this method without specifying a time-out, you can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method if you are waiting longer than preferred.</source>
          <target state="translated">タイムアウトを指定せずにこのメソッドを呼び出す場合は、呼び出す、<ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph>メソッド優先よりも長い時間を待機している場合。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This method call should be preceded with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">呼び出しに先行されなければなりません。 このメソッドの呼び出し、<ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph>フル ガベージ コレクションがあることを確認するメソッド。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>Calling this method alone can produce indeterminate results.</source>
          <target state="translated">このメソッドを呼び出すだけで不確定な結果を生成できます。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>The following example shows how to use this method to determine whether a full garbage collection has completed.</source>
          <target state="translated">次の例では、このメソッドを使用して、フル ガベージ コレクションが完了したかどうかを判断する方法を示します。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>Whenever the status of the notification is <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, the user method <ph id="ph2">`OnFullGCCompletedNotify`</ph> is called to perform actions in response to the completed collection.</source>
          <target state="translated">通知の状態のときに<ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>、ユーザー メソッド<ph id="ph2">`OnFullGCCompletedNotify`</ph>完了したコレクションへの応答アクションを実行すると呼びます。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This code example is part of a larger example provided for <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">このコード例に示されている例の一部である<bpt id="p1">[</bpt>ガベージ コレクションの通知<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>トピックです。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているコードから使用することはできません。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>The length of time to wait before a notification status can be obtained.</source>
          <target state="translated">通知の状態が取得されるまで待機する時間。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Specify -1 to wait indefinitely.</source>
          <target state="translated">無期限に待機するには -1 を指定します。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</source>
          <target state="translated">共通言語ランタイムによるフル ブロッキング ガベージ コレクションが完了したかどうかを確認するための登録済みの通知の状態を、指定したタイムアウト時間で返します。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">登録済みのガベージ コレクションの通知の状態。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph>列挙体を使用して登録されている現在のガベージ コレクションの通知の状態を判断するには、このメソッドによって返される、<ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to determine whether a full garbage collection is imminent.</source>
          <target state="translated">使用することも、<ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph>フル ガベージ コレクションが近づいているかどうかを調べます。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by <ph id="ph1">`millisecondsTimeout`</ph>.</source>
          <target state="translated">指定された値に関係なく、ガベージ コレクションの通知の状態を取得するときにすぐに、このメソッドが戻る注<ph id="ph1">`millisecondsTimeout`</ph>です。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>If a garbage collection notification status is not obtained before <ph id="ph1">`millisecondsTimeout`</ph> times out, this method returns <ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>.</source>
          <target state="translated">前にガベージ コレクションの通知の状態が取得されていないかどうかは<ph id="ph1">`millisecondsTimeout`</ph>回、このメソッドが戻る<ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as resuming work and obtaining a collection count with the <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> property.</source>
          <target state="translated">列挙体が返されるときに<ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>、作業を再開して、コレクションの数を取得するなどのタスクを行うことができます、<ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>You can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method when you cannot wait for the time-out period to elapse.</source>
          <target state="translated">呼び出すことができます、<ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph>メソッドと、タイムアウト期間に対して、経過時間を待機することはできません。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>This method call should be preceded with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">呼び出しに先行されなければなりません。 このメソッドの呼び出し、<ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph>フル ガベージ コレクションがあることを確認するメソッド。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Calling this method alone can produce indeterminate results.</source>
          <target state="translated">このメソッドを呼び出すだけで不確定な結果を生成できます。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> must be either non-negative or less than or equal to <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> or -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> は負でない数値、<ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> 以下の数値、または -1 であることが必要です。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているコードから使用することはできません。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForPendingFinalizers">
          <source>Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</source>
          <target state="translated">ファイナライザーのキューを処理するスレッドがそのキューを空にするまで、現在のスレッドを中断します。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements.</source>
          <target state="translated">ガベージ コレクターは、再利用できるオブジェクトを検出すると、オブジェクトの終了処理の要件を決定するには、各オブジェクトを確認します。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>If an object implements a finalizer and has not disabled finalization by calling <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>, the object is placed in a list of objects that are marked as ready for finalization.</source>
          <target state="translated">オブジェクトがファイナライザーを実装しを無効に呼び出すことによってかどうか<ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>、終了処理の準備完了としてマークされているオブジェクトの一覧で、オブジェクトが配置されます。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>The garbage collector calls the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> methods for the objects in this list and removes the entries from the list.</source>
          <target state="translated">ガベージ コレクターの呼び出し、<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>このリストし、削除、一覧からエントリ内のオブジェクトのメソッドです。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>This method blocks until all finalizers have run to completion.</source>
          <target state="translated">このメソッドはブロックされるまでのすべてのファイナライザーの実行が終了します。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate.</source>
          <target state="translated">このメソッドが終了されるという保証はありません、ファイナライザーが実行されるスレッドは指定しません。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>However, this thread can be interrupted by another thread while the <ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> method is in progress.</source>
          <target state="translated">このスレッドを中断しているときに別のスレッドによってただし、<ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph>メソッドが進行中です。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.</source>
          <target state="translated">たとえば、一定の時間まで待機し、このスレッドがまだ中断されている場合、このスレッドを中断する別のスレッドを開始できます。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> method to suspend the current thread until finalization of all the collected objects is complete.</source>
          <target state="translated">次の例で使用する方法、<ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph>収集されたすべてのオブジェクトの最終処理が完了するまで、現在のスレッドを中断するメソッド。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>