<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="OutOfMemoryException.xml" source-language="en-US" target-language="ja-JP">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5910934c01288ec01071b99b363ba0c0e473ede08.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">910934c01288ec01071b99b363ba0c0e473ede08</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.OutOfMemoryException">
          <source>The exception that is thrown when there is not enough memory to continue the execution of a program.</source>
          <target state="translated">プログラムの実行を継続するためのメモリが不足している場合にスローされる例外。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>An <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception has two major causes:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>例外が 2 つの主要な原因。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>You are attempting to expand a <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object beyond the length defined by its <ph id="ph2">&lt;xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">展開しようとしている、<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>オブジェクトによって定義された長さを超えるその<ph id="ph2">&lt;xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The common language runtime cannot allocate enough contiguous memory to successfully perform an operation.</source>
          <target state="translated">共通言語ランタイムには、操作を正常に実行するための十分な連続するメモリを割り当てることができません。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>This exception can be thrown by any property assignment or method call that requires a memory allocation.</source>
          <target state="translated">メモリの割り当てを必要とするプロパティ割り当てまたはメソッド呼び出しによってこの例外をスローできます。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>For more information on the cause of the <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception, see <bpt id="p1">[</bpt>"Out of Memory" Does Not Refer to Physical Memory<ept id="p1">](http://blogs.msdn.com/b/ericlippert/archive/2009/06/08/out-of-memory-does-not-refer-to-physical-memory.aspx)</ept>.</source>
          <target state="translated">原因の詳細については、 <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> 、例外を参照してください<bpt id="p1">[</bpt>物理メモリを「メモリ不足の」が参照しない<ept id="p1">](http://blogs.msdn.com/b/ericlippert/archive/2009/06/08/out-of-memory-does-not-refer-to-physical-memory.aspx)</ept>です。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>This type of <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception represents a catastrophic failure.</source>
          <target state="translated">この種類の<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>例外は重大なエラーを表します。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>If you choose to handle the exception, you should include a <ph id="ph1">`catch`</ph> block that calls the <ph id="ph2">&lt;xref:System.Environment.FailFast%2A?displayProperty=nameWithType&gt;</ph> method to terminate your app and add an entry to the system event log, as the following example does.</source>
          <target state="translated">例外を処理する場合を含めるように、<ph id="ph1">`catch`</ph>ブロックを呼び出す、<ph id="ph2">&lt;xref:System.Environment.FailFast%2A?displayProperty=nameWithType&gt;</ph>アプリを終了し、次の例のように、システム イベント ログにエントリを追加します。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Some of the conditions under which the exception is thrown and the actions you can take to eliminate it include the following:</source>
          <target state="translated">例外がスローされ、除去するために行える操作が、次の条件の一部。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>You are calling the <ph id="ph1">&lt;xref:System.Text.StringBuilder.Insert%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">呼び出しには、<ph id="ph1">&lt;xref:System.Text.StringBuilder.Insert%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>You are attempting to increase the length of a <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object beyond the size specified by its <ph id="ph2">&lt;xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">長さを拡張しようとして、<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>オブジェクトで指定されたサイズを超えるその<ph id="ph2">&lt;xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception thrown by a call to the <ph id="ph2">&lt;xref:System.Text.StringBuilder.Insert%28System.Int32%2CSystem.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method when the example tries to insert a string that would cause the object's <ph id="ph3">&lt;xref:System.Text.StringBuilder.Length%2A&gt;</ph> property to exceed its maximum capacity.</source>
          <target state="translated">次の例を示しています、<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>への呼び出しによってスローされた例外、<ph id="ph2">&lt;xref:System.Text.StringBuilder.Insert%28System.Int32%2CSystem.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph>メソッドの例では、オブジェクトの原因となる文字列を挿入しようとしました。<ph id="ph3">&lt;xref:System.Text.StringBuilder.Length%2A&gt;</ph>処理能力の上限を超えるプロパティです。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>You can do either of the following to address the error:</source>
          <target state="translated">エラーを解決するには、次のいずれかの操作を行うことができます。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Replace the call to the <ph id="ph1">&lt;xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> constructor with a call any other <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> constructor overload.</source>
          <target state="translated">呼び出しを置き換える、<ph id="ph1">&lt;xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph>コンス トラクターの呼び出しで、他の<ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph>コンス トラクター オーバー ロードします。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The maximum capacity of your <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object will be set to its default value, which is <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">最大容量、<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>オブジェクトは、これは既定値に設定する<ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Call the <ph id="ph1">&lt;xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> constructor with a <ph id="ph2">`maxCapacity`</ph> value that is large enough to accommodate any expansions to the <ph id="ph3">&lt;xref:System.Text.StringBuilder&gt;</ph> object.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph>を持つコンス トラクター、<ph id="ph2">`maxCapacity`</ph>任意の拡張に合わせて十分な大きさの値、<ph id="ph3">&lt;xref:System.Text.StringBuilder&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Your app runs as a 32-bit process.</source>
          <target state="translated">アプリは、32 ビット プロセスとして実行されます。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>32-bit processes can allocate a maximum of 2GB of virtual user-mode memory on 32-bit systems, and 4GB of virtual user-mode memory on 64-bit systems.</source>
          <target state="translated">32 ビット プロセスでは、最大 2 GB の 32 ビット システムでユーザー モード仮想メモリと 4 GB の 64 ビット システムでユーザー モード仮想メモリを割り当てることができます。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>This can make it more difficult for the common language runtime to allocate sufficient contiguous memory when a large allocation is needed.</source>
          <target state="translated">これは、ため、共通言語ランタイム、大規模に割り当てが必要なときに十分な連続するメモリを割り当てることが難しく、ことができます。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>In contrast, 64-bit processes can allocate up to 8TB of virtual memory.</source>
          <target state="translated">これに対し、64 ビット プロセスでは、最大 8 TB の仮想メモリを割り当てることができます。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>To address this exception, recompile your app to target a 64-bit platform.</source>
          <target state="translated">この例外に対処するには、64 ビット プラットフォームを対象とするアプリを再コンパイルします。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>For information on targeting specific platforms in Visual Studio, see <bpt id="p1">[</bpt>How to: Configure Projects to Target Platforms<ept id="p1">](http://msdn.microsoft.com/library/845302fc-273d-4f81-820a-7296ce91bd76)</ept>.</source>
          <target state="translated">Visual Studio での特定のプラットフォームを対象とする方法の詳細については、次を参照してください。<bpt id="p1">[</bpt>する方法: プロジェクトのターゲット プラットフォームを構成<ept id="p1">](http://msdn.microsoft.com/library/845302fc-273d-4f81-820a-7296ce91bd76)</ept>です。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Your app is leaking unmanaged resources</source>
          <target state="translated">アプリは、アンマネージ リソースをリークします。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Although the garbage collector is able to free memory allocated to managed types, it does not manage memory allocated to unmanaged resources such as operating system handles (including handles to files, memory-mapped files, pipes, registry keys, and wait handles) and memory blocks allocated directly by Windows API calls or by calls to memory allocation functions such as <ph id="ph1">`malloc`</ph>.</source>
          <target state="translated">オペレーティング システム ハンドル (待機ハンドルおよびファイル、メモリ マップ ファイル、パイプ、レジストリ キーへのハンドルを含む) などのアンマネージ リソースに割り当てられたメモリとなど、Windows API の呼び出しによって直接、またはメモリ割り当て関数への呼び出しによって割り当てられたメモリ ブロックは管理しません。 ガベージ コレクターはマネージ型に割り当てられたメモリを解放できませんが、<ph id="ph1">`malloc`</ph>です。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Types that consume unmanaged resources implement the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">アンマネージ リソースを消費する型を実装、<ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>インターフェイスです。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>If you are consuming a type that uses unmanaged resources, you should be sure to call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> method when you have finished using it.</source>
          <target state="translated">アンマネージ リソースを使用する型を使用している、する必要がありますを呼び出してその<ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph>メソッドの使用を終了するときにします。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>(Some types also implement a <ph id="ph1">`Close`</ph> method that is identical in function to a <ph id="ph2">`Dispose`</ph> method.) For more information, see the <bpt id="p1">[</bpt>Using Objects That Implement IDisposable<ept id="p1">](~/docs/standard/garbage-collection/using-objects.md)</ept> topic.</source>
          <target state="translated">(一部の型が実装も、<ph id="ph1">`Close`</ph>を関数と同じであるメソッド、<ph id="ph2">`Dispose`</ph>メソッドです)。詳細については、次を参照してください。、<bpt id="p1">[</bpt>オブジェクトを実装する IDisposable のを使用して<ept id="p1">](~/docs/standard/garbage-collection/using-objects.md)</ept>トピックです。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>If you have created a type that uses unmanaged resources, make sure that you have implemented the Dispose pattern and, if necessary, supplied a finalizer.</source>
          <target state="translated">アンマネージ リソースを使用する型を作成した場合は、Dispose パターンを実装している、必要に応じて、指定のファイナライザーを確認します。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>For more information, see the <bpt id="p1">[</bpt>Dispose Pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>, <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>, and <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> topics.</source>
          <target state="translated">詳細については、次を参照してください。、 <bpt id="p1">[</bpt>Dispose パターン<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>、 <bpt id="p2">[</bpt>Dispose メソッドの実装<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>、および<ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>トピックです。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>You are attempting to create a large array in a 64-bit process.</source>
          <target state="translated">64 ビット プロセスでは大きな配列を作成しようとするとします。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>By default, the common language runtime does not allow single objects whose size exceeds 2GB.</source>
          <target state="translated">既定では、共通言語ランタイムにそのサイズは、2 GB を超えています。 1 つのオブジェクトはできません。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>To override this default, you can use the  configuration file setting to enable arrays whose total size exceeds 2 GB.</source>
          <target state="translated">この既定の設定を上書きするには、合計サイズが 2 GB を超える配列を有効にするのに構成ファイルの設定を使用できます。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>You are working with very large sets of data (such as arrays, collections, or database data sets) in memory.</source>
          <target state="translated">メモリ内データ (配列、コレクション、またはデータベースのデータ セット) などの非常に大きなセットを使用しています。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>When data structures or data sets that reside in memory become so large that the common language runtime is unable to allocate enough contiguous memory for them, an <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception results.</source>
          <target state="translated">メモリ内に存在するデータ セットまたはデータ構造が非常に大きいので、共通言語ランタイムが、それらの連続するのに十分なメモリを割り当てることはできないことになったときに、<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>例外が発生します。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>To prevent the <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exceptions, you must modify your application so that less data is resident in memory, or the data is divided into segments that require smaller memory allocations.</source>
          <target state="translated">防ぐために、<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>例外の低いデータは、メモリに常駐しているか、データは、小さいメモリ割り当てを必要とするセグメントに分割できるようにアプリケーションを変更する必要があります。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>For example:</source>
          <target state="translated">例:</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>If you are retrieving all of the data from a database and then filtering it in your app to minimize trips to the server, you should modify your queries to return only the subset of data that your app needs.</source>
          <target state="translated">データベースからのすべてのデータを取得して、フィルター処理することで、アプリ サーバーとのやり取りを最小限に抑えるには場合、は、アプリが必要なデータのサブセットのみを返すクエリを変更する必要があります。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>When working with large tables, multiple queries are almost always more efficient than retrieving all of the data in a single table and then manipulating it.</source>
          <target state="translated">大きなテーブルを使用するときに複数のクエリはほとんど常にすべての単一のテーブルにデータを取得し、それを操作するよりも効率的です。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>If you are executing queries that users create dynamically, you should ensure that the number of records returned by the query is limited.</source>
          <target state="translated">ユーザーを動的に作成するクエリを実行している場合は、クエリによって返されるレコードの数が制限されていることを確認する必要があります。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>If you are using large arrays or other collection objects whose size results in an <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception, you should modify your application to work the data in subsets rather than to work with it all at once.</source>
          <target state="translated">大きな配列を使用しているかどうか、またはその他のコレクション オブジェクトのサイズの結果が、<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>の例外を除き、すべて一度に使用するのではなく、データをサブセットとして動作するアプリケーションを変更する必要があります。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The following example gets a array that consists of 200 million floating-point values and then calculates their mean.</source>
          <target state="translated">次の例では、200, 000 の浮動小数点値で構成され、平均を計算する配列を取得します。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The output from the example shows that, because the example stores the entire array in memory before it calculates the mean, an <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is is thrown.</source>
          <target state="translated">出力の例を示していますの例では、平均を計算する前にメモリ内で配列全体を格納するため、<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The following example eliminates the <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception by processing the incoming data without storing the entire data set in memory, serializing the data to a file if necessary to permit further processing (these lines are commented out in the example, since in this case they produce a file whose size is greater than 1GB), and returning the calculated mean and the number of cases to the calling routine.</source>
          <target state="translated">次の例を排除、<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>さらに処理を許可するように必要な場合は、ファイルにデータをシリアル化する、メモリ内データ セット全体を格納することがなく、受信データを処理することで例外 (これらの行をコメント アウト例では、ここではサイズが 1 GB より大きいファイルが生成されるため)、呼び出し元のルーチンに計算される平均およびケースの数を返すとします。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>You are repeatedly concatenating large strings.</source>
          <target state="translated">大きな文字列を連結する繰り返しです。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Because strings are immutable, each string concatenation operation creates a new string.</source>
          <target state="translated">文字列は変更できないために、各文字列連結操作は、新しい文字列を作成します。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The impact for small strings, or for a small number of concatenation operations, is negligible.</source>
          <target state="translated">小さな文字列の場合、または連結操作の数が少ないの影響はごくわずかです。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>But for large strings or a very large number of concatenation operations, string concatenation can lead to a large number of memory allocations and memory fragmentation, poor performance, and possibly <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exceptions.</source>
          <target state="translated">大きな文字列または大量の連結操作の数は、文字列の連結は、大量のメモリの割り当てやメモリの断片化、パフォーマンスの低下を招く可能性と、場合によって<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>例外。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>When concatenating large strings or performing a large number of concatenation operations, you should use the <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> class instead of the <ph id="ph2">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated">大きな文字列を連結することや、連結操作の数が多いの実行を使用する際、<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>クラスの代わりに、<ph id="ph2">&lt;xref:System.String&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>When you have finished manipulating the string, convert the <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> instance to a string by calling the <ph id="ph2">&lt;xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">文字列の操作が完了したら、変換、<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>インスタンスを呼び出すことによって文字列、<ph id="ph2">&lt;xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>You pin a large number of objects in memory.</source>
          <target state="translated">メモリ内オブジェクトの数が多いをピン留めします。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Pinning a large number of objects in memory for long periods can make it difficult for the garbage collector to allocate contiguous blocks of memory.</source>
          <target state="translated">長期にわたってメモリ内の多数のオブジェクトをピン留めと、ガベージ コレクターが連続するメモリ ブロックを割り当てる困難ことができます。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>If you've pinned a large number of objects in memory, for example by using the <ph id="ph1">`fixed`</ph> statement in C# or by calling the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType&gt;</ph> method with a handle type of <ph id="ph3">&lt;xref:System.Runtime.InteropServices.GCHandleType.Pinned?displayProperty=nameWithType&gt;</ph>, you can do the following to address the <ph id="ph4">&lt;xref:System.OutOfMemoryException&gt;</ph> exception.</source>
          <target state="translated">ピン留めしたオブジェクトの数が多いメモリ上で例を使用している場合、<ph id="ph1">`fixed`</ph>ステートメント (C#) または呼び出すことによって、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType&gt;</ph>のハンドル型を持つメソッド<ph id="ph3">&lt;xref:System.Runtime.InteropServices.GCHandleType.Pinned?displayProperty=nameWithType&gt;</ph>、アドレスには、次を行うことができます、<ph id="ph4">&lt;xref:System.OutOfMemoryException&gt;</ph>例外。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Evaluate whether each object really needs to be pinned,</source>
          <target state="translated">各オブジェクトは、ピン留めを本当に必要かどうかを評価します。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Ensure that each object is unpinned as soon as possible.</source>
          <target state="translated">ある各オブジェクトは固定されておらずできるだけ早くを確認します。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Make sure that each call to the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType&gt;</ph> method to pin memory has a corresponding call to the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.GCHandle.Free%2A?displayProperty=nameWithType&gt;</ph> method to unpin that memory.</source>
          <target state="translated">各呼び出しことを確認してください、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType&gt;</ph>暗証番号 (pin) のメモリへのメソッドに対応する呼び出しには、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.GCHandle.Free%2A?displayProperty=nameWithType&gt;</ph>そのメモリの固定を解除する方法です。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The following Microsoft intermediate (MSIL) instructions throw an <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception:</source>
          <target state="translated">次の Microsoft intermediate (MSIL) の命令をスロー、<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>例外。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source><bpt id="p1">[</bpt>box<ept id="p1">](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.box.aspx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>box<ept id="p1">](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.box.aspx)</ept></target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source><bpt id="p1">[</bpt>newarr<ept id="p1">](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.newarr.aspx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>newarr<ept id="p1">](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.newarr.aspx)</ept></target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source><bpt id="p1">[</bpt>newobj<ept id="p1">](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.newobj.aspx)</ept>newobj</source>
          <target state="translated"><bpt id="p1">[</bpt>newobj<ept id="p1">](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.newobj.aspx)</ept>newobj</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> uses the HRESULT <ph id="ph2">`COR_E_OUTOFMEMORY`</ph>, which has the value 0x8007000E.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> HRESULT を使用して<ph id="ph2">`COR_E_OUTOFMEMORY`</ph>0x8007000E 値を持ちます。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>For a list of initial property values for an instance of <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>, see the <ph id="ph2">&lt;xref:System.OutOfMemoryException.%23ctor%2A&gt;</ph> constructors.</source>
          <target state="translated">インスタンスの初期プロパティ値の一覧については<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>を参照してください、<ph id="ph2">&lt;xref:System.OutOfMemoryException.%23ctor%2A&gt;</ph>コンス トラクターです。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The value of the inherited <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> property is always <ph id="ph2">`null`</ph>.</source>
          <target state="translated">継承された値<ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph>プロパティは常に<ph id="ph2">`null`</ph>です。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="T:System.OutOfMemoryException">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> クラスの新しいインスタンスを初期化します。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> クラスの新しいインスタンスを初期化します。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor">
          <source>This constructor initializes the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property of the new instance to a system-supplied message that describes the error, such as "There was not enough memory to continue the execution of the program."</source>
          <target state="translated">このコンス トラクター、 <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> 「がないプログラムの実行を継続する十分なメモリです」などに、エラーを説明するシステム提供のメッセージの新しいインスタンスのプロパティ。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor">
          <source>This message takes into account the current system culture.</source>
          <target state="translated">このメッセージには、現在のシステムのカルチャが考慮されます。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> のインスタンスの初期プロパティ値を次の表に示します。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor">
          <source>Value</source>
          <target state="translated">[値]</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor">
          <source><ph id="ph1">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor">
          <source>The localized error message string.</source>
          <target state="translated">ローカライズされたエラー メッセージ文字列。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>The message that describes the error.</source>
          <target state="translated">エラーを説明するメッセージ。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> class with a specified error message.</source>
          <target state="translated">指定したエラー メッセージを使用して、<ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> クラスの新しいインスタンスを初期化します。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>The content of the <ph id="ph1">`message`</ph> parameter is intended to be understood by humans.</source>
          <target state="translated"><ph id="ph1">`message`</ph> パラメーターの内容は、ユーザーが理解できる内容にします。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>The caller of this constructor is required to ensure that this string has been localized for the current system culture.</source>
          <target state="translated">このコンストラクターの呼び出し元は、この文字列が現在のシステムのカルチャに合わせてローカライズ済みであることを確認しておく必要があります。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> のインスタンスの初期プロパティ値を次の表に示します。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>Value</source>
          <target state="translated">[値]</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic).</source>
          <target state="translated">null 参照 (Visual Basic の場合は <ph id="ph1">`Nothing`</ph>)。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>The error message string.</source>
          <target state="translated">エラー メッセージ文字列。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The object that holds the serialized object data.</source>
          <target state="translated">シリアル化されたオブジェクト データを保持するオブジェクト。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The contextual information about the source or destination.</source>
          <target state="translated">転送元または転送先に関するコンテキスト情報。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> class with serialized data.</source>
          <target state="translated">シリアル化したデータを使用して、<ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> クラスの新しいインスタンスを初期化します。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This constructor is called during deserialization to reconstitute the exception object transmitted over a stream.</source>
          <target state="translated">このコンストラクターは、逆シリアル化中に、ストリームで送信された例外オブジェクトを再構築するために呼び出されます。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>For more information, see <bpt id="p1">[</bpt>XML and SOAP Serialization<ept id="p1">](~/docs/standard/serialization/xml-and-soap-serialization.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>XML および SOAP シリアル化<ept id="p1">](~/docs/standard/serialization/xml-and-soap-serialization.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>The error message that explains the reason for the exception.</source>
          <target state="translated">例外の原因を説明するエラー メッセージ。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>The exception that is the cause of the current exception.</source>
          <target state="translated">現在の例外の原因となった例外。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>innerException<ept id="p1">&lt;/c&gt;</ept> parameter is not a null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), the current exception is raised in a <ph id="ph2">&lt;see langword="catch" /&gt;</ph> block that handles the inner exception.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>innerException<ept id="p1">&lt;/c&gt;</ept> パラメーターが null 参照 (Visual Basic の場合は <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>) でない場合は、内部例外を処理する <ph id="ph2">&lt;see langword="catch" /&gt;</ph> ブロックで現在の例外が発生します。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> class with a specified error message and a reference to the inner exception that is the cause of this exception.</source>
          <target state="translated">指定したエラー メッセージおよびこの例外の原因となった内部例外への参照を使用して、<ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> クラスの新しいインスタンスを初期化します。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>An exception that is thrown as a direct result of a previous exception can include a reference to the previous exception in the <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property.</source>
          <target state="translated">前の例外の直接の結果としてスローされる例外は、<ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> プロパティに前の例外への参照を含んでいる場合があります。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>The <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property returns the same value that is passed into the constructor, or a null reference (<ph id="ph2">`Nothing`</ph> in Visual Basic) if the <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property does not supply the inner exception value to the constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> プロパティは、コンストラクターに渡されたものと同じ値を返します。<ph id="ph2">`Nothing`</ph> プロパティによって内部例外値がコンストラクターに渡されなかった場合は、null 参照 (Visual Basic の場合は <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph>) を返します。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> のインスタンスの初期プロパティ値を次の表に示します。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>Property</source>
          <target state="translated">プロパティ</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>Value</source>
          <target state="translated">[値]</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>The inner exception reference.</source>
          <target state="translated">内部例外の参照。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>The error message string.</source>
          <target state="translated">エラー メッセージ文字列。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>