<Type Name="ValueTuple" FullName="System.ValueTuple">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2a27c330e07785ca16a044fd75268d7d67650899" /><Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="11/27/2018" /><Meta Name="ms.locfileid" Value="52368443" /></Metadata><TypeSignature Language="C#" Value="public struct ValueTuple : IComparable, IComparable&lt;ValueTuple&gt;, IEquatable&lt;ValueTuple&gt;, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit ValueTuple extends System.ValueType implements class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.IComparable, class System.IComparable`1&lt;valuetype System.ValueTuple&gt;, class System.IEquatable`1&lt;valuetype System.ValueTuple&gt;" />
  <TypeSignature Language="DocId" Value="T:System.ValueTuple" />
  <TypeSignature Language="VB.NET" Value="Public Structure ValueTuple&#xA;Implements IComparable, IComparable(Of ValueTuple), IEquatable(Of ValueTuple), IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public value class ValueTuple : IComparable, IComparable&lt;ValueTuple&gt;, IEquatable&lt;ValueTuple&gt;, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type ValueTuple = struct" />
  <AssemblyInfo>
    <AssemblyName>System.ValueTuple</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.ValueTuple&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.ValueTuple&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>値のタプルを作成するための静的メソッドを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
タプルとは、特定の数と要素のシーケンスを持つデータ構造です。 タプルの例は、最初の要素、3 番目の要素では、その年の 2 番目の要素と個人の収入における年のユーザーの名前などの識別子を格納するために使用する (3 タプル、すなわちトリプルと呼ばれます) 3 つの要素を含むデータ構造です。  
  
値のタプルがで導入されたタプル型、[!INCLUDE[net_v463](~/includes/net-v463-md.md)]のランタイム実装を提供する[内の組C#](~/docs/csharp/tuples.md)と構造体タプルでF#します。 など、組クラスから異なる<xref:System.Tuple%601>、<xref:System.Tuple%602>などに、次のとおりです。  
  
-   クラス (参照型) ではなく構造体 (値型) です。  
  
-   変更可能なよりも読み取り専用です。 つまり、タプル コンポーネントの値を変更できます。  
  
-   そのデータ メンバーなど`Item1`、`Item2`など、プロパティではなく、フィールドです。  
  
<xref:System.ValueTuple>構造が要素を持たないタプルを表します。 主にその静的メソッドを作成し、値のタプル型のインスタンスを比較できるため便利です。 そのヘルパー メソッドを使用して、各値のタプル コンポーネントの型を明示的に指定することがなく値のタプルをインスタンス化できます。 静的を呼び出すことによって<xref:System.ValueTuple.Create%2A>メソッド、0 から 8 つのコンポーネントを持つ値のタプルを作成することができます。 8 つ以上のコンポーネントでは、値のタプルの呼び出す必要がある、<xref:System.ValueTuple%608.%23ctor%2A>コンス トラクター。  

### <a name="serialization-and-value-tuples"></a>シリアル化と値の組

<xref:System.ValueTuple>型が .NET Core でシリアル化可能な 1.x または .NET Framework 4.7 と以前のバージョン。 さらに、.NET Standard, .NET Standard 2.0 を含む必須ではないのシリアル化<xref:System.ValueTuple>; のインスタンスかどうかを<xref:System.ValueTuple>インスタンスがシリアル化可能な個々 の .NET Standard の実装によって異なります。 確認するかどうかを<xref:System.ValueTuple>型は、特定の .NET 実装でシリアル化、取得、<xref:System.Type>を表すオブジェクトを<xref:System.ValueTuple>を入力しの値を取得、<xref:System.Type.IsSerializable%2A>プロパティ。 .NET Core と .NET Framework でシリアル化可能な型の一覧は、次を参照してください。[バイナリ シリアル化](~/docs/standard/serialization/binary-serialization.md)します。

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ValueTuple other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.ValueTuple other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.CompareTo(System.ValueTuple)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ValueTuple) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(ValueTuple other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : ValueTuple -&gt; int&#xA;override this.CompareTo : ValueTuple -&gt; int" Usage="valueTuple.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.ValueTuple" />
      </Parameters>
      <Docs>
        <param name="other">現在のインスタンスと比較するオブジェクト。</param>
        <summary>現在の <see cref="T:System.ValueTuple" /> インスタンスを指定した <see cref="T:System.ValueTuple" /> インスタンスと比較します。</summary>
        <returns>このメソッドは常に 0 を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
        Because a <xref:System.ValueTuple> instance has no elements, any two <xref:System.ValueTuple> instances are considered to be equivalent.
           ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="other" /> は <see cref="T:System.ValueTuple" /> インスタンスではありません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新しい値のタプル インスタンスを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static ValueTuple Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As ValueTuple" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple Create();" />
      <MemberSignature Language="F#" Value="static member Create : unit -&gt; ValueTuple" Usage="System.ValueTuple.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コンポーネントを持たない新しい値のタプルを作成します。</summary>
        <returns>コンポーネントを持たない新しい値のタプル。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T1&gt;">
      <MemberSignature Language="C#" Value="public static ValueTuple&lt;T1&gt; Create&lt;T1&gt; (T1 item1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`1&lt;!!T1&gt; Create&lt;T1&gt;(!!T1 item1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of T1) (item1 As T1) As ValueTuple(Of T1)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1&gt;&#xA; static ValueTuple&lt;T1&gt; Create(T1 item1);" />
      <MemberSignature Language="F#" Value="static member Create : 'T1 -&gt; ValueTuple&lt;'T1&gt;" Usage="System.ValueTuple.Create item1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T1&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
      </Parameters>
      <Docs>
        <typeparam name="T1">値のタプルの唯一のコンポーネントの型。</typeparam>
        <param name="item1">値のタプルの唯一のコンポーネントの値。</param>
        <summary>1 個のコンポーネント (シングルトン) を持つ新しい値のタプルを作成します。</summary>
        <returns>1 個のコンポーネントを持つ値のタプル。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ValueTuple.Create%2A> ヘルパー メソッドを明示的にそのコンポーネントの種類を指定しなくても 1 コンポーネントの値のタプルをインスタンス化を呼び出すことです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static ValueTuple&lt;T1,T2&gt; Create&lt;T1,T2&gt; (T1 item1, T2 item2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;!!T1, !!T2&gt; Create&lt;T1, T2&gt;(!!T1 item1, !!T2 item2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create``2(``0,``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of T1, T2) (item1 As T1, item2 As T2) As ValueTuple(Of T1, T2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2&gt;&#xA; static ValueTuple&lt;T1, T2&gt; Create(T1 item1, T2 item2);" />
      <MemberSignature Language="F#" Value="static member Create : 'T1 * 'T2 -&gt; ValueTuple&lt;'T1, 'T2&gt;" Usage="System.ValueTuple.Create (item1, item2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T1,T2&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
      </Parameters>
      <Docs>
        <typeparam name="T1">値のタプルの 1 番目のコンポーネントの型。</typeparam>
        <typeparam name="T2">値のタプルの 2 番目のコンポーネントの型。</typeparam>
        <param name="item1">値のタプルの 1 番目のコンポーネントの値。</param>
        <param name="item2">値のタプルの 2 番目のコンポーネントの値。</param>
        <summary>2 個のコンポーネント (ペア) を持つ新しい値のタプルを作成します。</summary>
        <returns>2 個のコンポーネントを持つ値のタプル。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ValueTuple.Create%2A> そのコンポーネントの型を明示的に指定することがなく、2 コンポーネントの値のタプルをインスタンス化を呼び出すことができるヘルパー メソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static ValueTuple&lt;T1,T2,T3&gt; Create&lt;T1,T2,T3&gt; (T1 item1, T2 item2, T3 item3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;!!T1, !!T2, !!T3&gt; Create&lt;T1, T2, T3&gt;(!!T1 item1, !!T2 item2, !!T3 item3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create``3(``0,``1,``2)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of T1, T2, T3) (item1 As T1, item2 As T2, item3 As T3) As ValueTuple(Of T1, T2, T3)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3&gt;&#xA; static ValueTuple&lt;T1, T2, T3&gt; Create(T1 item1, T2 item2, T3 item3);" />
      <MemberSignature Language="F#" Value="static member Create : 'T1 * 'T2 * 'T3 -&gt; ValueTuple&lt;'T1, 'T2, 'T3&gt;" Usage="System.ValueTuple.Create (item1, item2, item3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T1,T2,T3&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
      </Parameters>
      <Docs>
        <typeparam name="T1">値のタプルの 1 番目のコンポーネントの型。</typeparam>
        <typeparam name="T2">値のタプルの 2 番目のコンポーネントの型。</typeparam>
        <typeparam name="T3">値のタプルの 3 番目のコンポーネントの型。</typeparam>
        <param name="item1">値のタプルの 1 番目のコンポーネントの値。</param>
        <param name="item2">値のタプルの 2 番目のコンポーネントの値。</param>
        <param name="item3">値のタプルの 3 番目のコンポーネントの値。</param>
        <summary>3 個のコンポーネント (トリプル) を持つ新しい値のタプルを作成します。</summary>
        <returns>3 個のコンポーネントを持つ値のタプル。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ValueTuple.Create%2A> そのコンポーネントの型を明示的に指定することがなく、3 コンポーネントの値のタプルをインスタンス化を呼び出すことができるヘルパー メソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T1,T2,T3,T4&gt;">
      <MemberSignature Language="C#" Value="public static ValueTuple&lt;T1,T2,T3,T4&gt; Create&lt;T1,T2,T3,T4&gt; (T1 item1, T2 item2, T3 item3, T4 item4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`4&lt;!!T1, !!T2, !!T3, !!T4&gt; Create&lt;T1, T2, T3, T4&gt;(!!T1 item1, !!T2 item2, !!T3 item3, !!T4 item4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create``4(``0,``1,``2,``3)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of T1, T2, T3, T4) (item1 As T1, item2 As T2, item3 As T3, item4 As T4) As ValueTuple(Of T1, T2, T3, T4)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3, typename T4&gt;&#xA; static ValueTuple&lt;T1, T2, T3, T4&gt; Create(T1 item1, T2 item2, T3 item3, T4 item4);" />
      <MemberSignature Language="F#" Value="static member Create : 'T1 * 'T2 * 'T3 * 'T4 -&gt; ValueTuple&lt;'T1, 'T2, 'T3, 'T4&gt;" Usage="System.ValueTuple.Create (item1, item2, item3, item4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T1,T2,T3,T4&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
        <Parameter Name="item4" Type="T4" />
      </Parameters>
      <Docs>
        <typeparam name="T1">値のタプルの 1 番目のコンポーネントの型。</typeparam>
        <typeparam name="T2">値のタプルの 2 番目のコンポーネントの型。</typeparam>
        <typeparam name="T3">値のタプルの 3 番目のコンポーネントの型。</typeparam>
        <typeparam name="T4">値のタプルの 4 番目のコンポーネントの型。</typeparam>
        <param name="item1">値のタプルの 1 番目のコンポーネントの値。</param>
        <param name="item2">値のタプルの 2 番目のコンポーネントの値。</param>
        <param name="item3">値のタプルの 3 番目のコンポーネントの値。</param>
        <param name="item4">値のタプルの 4 番目のコンポーネントの値。</param>
        <summary>4 個のコンポーネント (クアドラプル) を持つ新しい値のタプルを作成します。</summary>
        <returns>4 個のコンポーネントを持つ値のタプル。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ValueTuple.Create%2A> そのコンポーネントの型を明示的に指定することがなく、4 コンポーネントの値のタプルをインスタンス化を呼び出すことができるヘルパー メソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T1,T2,T3,T4,T5&gt;">
      <MemberSignature Language="C#" Value="public static ValueTuple&lt;T1,T2,T3,T4,T5&gt; Create&lt;T1,T2,T3,T4,T5&gt; (T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`5&lt;!!T1, !!T2, !!T3, !!T4, !!T5&gt; Create&lt;T1, T2, T3, T4, T5&gt;(!!T1 item1, !!T2 item2, !!T3 item3, !!T4 item4, !!T5 item5) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create``5(``0,``1,``2,``3,``4)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of T1, T2, T3, T4, T5) (item1 As T1, item2 As T2, item3 As T3, item4 As T4, item5 As T5) As ValueTuple(Of T1, T2, T3, T4, T5)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3, typename T4, typename T5&gt;&#xA; static ValueTuple&lt;T1, T2, T3, T4, T5&gt; Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);" />
      <MemberSignature Language="F#" Value="static member Create : 'T1 * 'T2 * 'T3 * 'T4 * 'T5 -&gt; ValueTuple&lt;'T1, 'T2, 'T3, 'T4, 'T5&gt;" Usage="System.ValueTuple.Create (item1, item2, item3, item4, item5)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T1,T2,T3,T4,T5&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="T5" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
        <Parameter Name="item4" Type="T4" />
        <Parameter Name="item5" Type="T5" />
      </Parameters>
      <Docs>
        <typeparam name="T1">値のタプルの 1 番目のコンポーネントの型。</typeparam>
        <typeparam name="T2">値のタプルの 2 番目のコンポーネントの型。</typeparam>
        <typeparam name="T3">値のタプルの 3 番目のコンポーネントの型。</typeparam>
        <typeparam name="T4">値のタプルの 4 番目のコンポーネントの型。</typeparam>
        <typeparam name="T5">値のタプルの 5 番目のコンポーネントの型。</typeparam>
        <param name="item1">値のタプルの 1 番目のコンポーネントの値。</param>
        <param name="item2">値のタプルの 2 番目のコンポーネントの値。</param>
        <param name="item3">値のタプルの 3 番目のコンポーネントの値。</param>
        <param name="item4">値のタプルの 4 番目のコンポーネントの値。</param>
        <param name="item5">値のタプルの 5 番目のコンポーネントの値。</param>
        <summary>5 個のコンポーネント (クインタプル) を持つ新しい値のタプルを作成します。</summary>
        <returns>5 個のコンポーネントを持つ値のタプル。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ValueTuple.Create%2A> ヘルパー メソッドを明示的にそのコンポーネントの種類を指定しなくても 5 コンポーネントの値のタプルをインスタンス化を呼び出すことです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T1,T2,T3,T4,T5,T6&gt;">
      <MemberSignature Language="C#" Value="public static ValueTuple&lt;T1,T2,T3,T4,T5,T6&gt; Create&lt;T1,T2,T3,T4,T5,T6&gt; (T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`6&lt;!!T1, !!T2, !!T3, !!T4, !!T5, !!T6&gt; Create&lt;T1, T2, T3, T4, T5, T6&gt;(!!T1 item1, !!T2 item2, !!T3 item3, !!T4 item4, !!T5 item5, !!T6 item6) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create``6(``0,``1,``2,``3,``4,``5)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of T1, T2, T3, T4, T5, T6) (item1 As T1, item2 As T2, item3 As T3, item4 As T4, item5 As T5, item6 As T6) As ValueTuple(Of T1, T2, T3, T4, T5, T6)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3, typename T4, typename T5, typename T6&gt;&#xA; static ValueTuple&lt;T1, T2, T3, T4, T5, T6&gt; Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);" />
      <MemberSignature Language="F#" Value="static member Create : 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 -&gt; ValueTuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6&gt;" Usage="System.ValueTuple.Create (item1, item2, item3, item4, item5, item6)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T1,T2,T3,T4,T5,T6&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="T5" />
        <TypeParameter Name="T6" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
        <Parameter Name="item4" Type="T4" />
        <Parameter Name="item5" Type="T5" />
        <Parameter Name="item6" Type="T6" />
      </Parameters>
      <Docs>
        <typeparam name="T1">値のタプルの 1 番目のコンポーネントの型。</typeparam>
        <typeparam name="T2">値のタプルの 2 番目のコンポーネントの型。</typeparam>
        <typeparam name="T3">値のタプルの 3 番目のコンポーネントの型。</typeparam>
        <typeparam name="T4">値のタプルの 4 番目のコンポーネントの型。</typeparam>
        <typeparam name="T5">値のタプルの 5 番目のコンポーネントの型。</typeparam>
        <typeparam name="T6">値のタプルの 6 番目のコンポーネントの型。</typeparam>
        <param name="item1">値のタプルの 1 番目のコンポーネントの値。</param>
        <param name="item2">値のタプルの 2 番目のコンポーネントの値。</param>
        <param name="item3">値のタプルの 3 番目のコンポーネントの値。</param>
        <param name="item4">値のタプルの 4 番目のコンポーネントの値。</param>
        <param name="item5">値のタプルの 5 番目のコンポーネントの値。</param>
        <param name="item6">値のタプルの 6 番目のコンポーネントの値。</param>
        <summary>6 個のコンポーネント (セクスプル) を持つ新しい値のタプルを作成します。</summary>
        <returns>6 個のコンポーネントを持つ値のタプル。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ValueTuple.Create%2A> ヘルパー メソッドを明示的にそのコンポーネントの種類を指定しなくても 6 コンポーネントの値のタプルをインスタンス化を呼び出すことです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T1,T2,T3,T4,T5,T6,T7&gt;">
      <MemberSignature Language="C#" Value="public static ValueTuple&lt;T1,T2,T3,T4,T5,T6,T7&gt; Create&lt;T1,T2,T3,T4,T5,T6,T7&gt; (T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`7&lt;!!T1, !!T2, !!T3, !!T4, !!T5, !!T6, !!T7&gt; Create&lt;T1, T2, T3, T4, T5, T6, T7&gt;(!!T1 item1, !!T2 item2, !!T3 item3, !!T4 item4, !!T5 item5, !!T6 item6, !!T7 item7) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create``7(``0,``1,``2,``3,``4,``5,``6)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of T1, T2, T3, T4, T5, T6, T7) (item1 As T1, item2 As T2, item3 As T3, item4 As T4, item5 As T5, item6 As T6, item7 As T7) As ValueTuple(Of T1, T2, T3, T4, T5, T6, T7)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7&gt;&#xA; static ValueTuple&lt;T1, T2, T3, T4, T5, T6, T7&gt; Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);" />
      <MemberSignature Language="F#" Value="static member Create : 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 -&gt; ValueTuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7&gt;" Usage="System.ValueTuple.Create (item1, item2, item3, item4, item5, item6, item7)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T1,T2,T3,T4,T5,T6,T7&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="T5" />
        <TypeParameter Name="T6" />
        <TypeParameter Name="T7" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
        <Parameter Name="item4" Type="T4" />
        <Parameter Name="item5" Type="T5" />
        <Parameter Name="item6" Type="T6" />
        <Parameter Name="item7" Type="T7" />
      </Parameters>
      <Docs>
        <typeparam name="T1">値のタプルの 1 番目のコンポーネントの型。</typeparam>
        <typeparam name="T2">値のタプルの 2 番目のコンポーネントの型。</typeparam>
        <typeparam name="T3">値のタプルの 3 番目のコンポーネントの型。</typeparam>
        <typeparam name="T4">値のタプルの 4 番目のコンポーネントの型。</typeparam>
        <typeparam name="T5">値のタプルの 5 番目のコンポーネントの型。</typeparam>
        <typeparam name="T6">値のタプルの 6 番目のコンポーネントの型。</typeparam>
        <typeparam name="T7">値のタプルの 7 番目のコンポーネントの型。</typeparam>
        <param name="item1">値のタプルの 1 番目のコンポーネントの値。</param>
        <param name="item2">値のタプルの 2 番目のコンポーネントの値。</param>
        <param name="item3">値のタプルの 3 番目のコンポーネントの値。</param>
        <param name="item4">値のタプルの 4 番目のコンポーネントの値。</param>
        <param name="item5">値のタプルの 5 番目のコンポーネントの値。</param>
        <param name="item6">値のタプルの 6 番目のコンポーネントの値。</param>
        <param name="item7">値のタプルの 7 番目のコンポーネントの値。</param>
        <summary>7 個のコンポーネント (セプタプル) を持つ新しい値のタプルを作成します。</summary>
        <returns>7 個のコンポーネントを持つ値のタプル。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ValueTuple.Create%2A> そのコンポーネントの型を明示的に指定することがなく、7 コンポーネントの値のタプルをインスタンス化を呼び出すことができるヘルパー メソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;">
      <MemberSignature Language="C#" Value="public static ValueTuple&lt;T1,T2,T3,T4,T5,T6,T7,ValueTuple&lt;T8&gt;&gt; Create&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt; (T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`8&lt;!!T1, !!T2, !!T3, !!T4, !!T5, !!T6, !!T7, valuetype System.ValueTuple`1&lt;!!T8&gt;&gt; Create&lt;T1, T2, T3, T4, T5, T6, T7, T8&gt;(!!T1 item1, !!T2 item2, !!T3 item3, !!T4 item4, !!T5 item5, !!T6 item6, !!T7 item7, !!T8 item8) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create``8(``0,``1,``2,``3,``4,``5,``6,``7)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of T1, T2, T3, T4, T5, T6, T7, T8) (item1 As T1, item2 As T2, item3 As T3, item4 As T4, item5 As T5, item6 As T6, item7 As T7, item8 As T8) As ValueTuple(Of T1, T2, T3, T4, T5, T6, T7, ValueTuple(Of T8))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8&gt;&#xA; static ValueTuple&lt;T1, T2, T3, T4, T5, T6, T7, ValueTuple&lt;T8&gt;&gt; Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);" />
      <MemberSignature Language="F#" Value="static member Create : 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 -&gt; ValueTuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, ValueTuple&lt;'T8&gt;&gt;" Usage="System.ValueTuple.Create (item1, item2, item3, item4, item5, item6, item7, item8)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T1,T2,T3,T4,T5,T6,T7,System.ValueTuple&lt;T8&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="T5" />
        <TypeParameter Name="T6" />
        <TypeParameter Name="T7" />
        <TypeParameter Name="T8" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
        <Parameter Name="item4" Type="T4" />
        <Parameter Name="item5" Type="T5" />
        <Parameter Name="item6" Type="T6" />
        <Parameter Name="item7" Type="T7" />
        <Parameter Name="item8" Type="T8" />
      </Parameters>
      <Docs>
        <typeparam name="T1">値のタプルの 1 番目のコンポーネントの型。</typeparam>
        <typeparam name="T2">値のタプルの 2 番目のコンポーネントの型。</typeparam>
        <typeparam name="T3">値のタプルの 3 番目のコンポーネントの型。</typeparam>
        <typeparam name="T4">値のタプルの 4 番目のコンポーネントの型。</typeparam>
        <typeparam name="T5">値のタプルの 5 番目のコンポーネントの型。</typeparam>
        <typeparam name="T6">値のタプルの 6 番目のコンポーネントの型。</typeparam>
        <typeparam name="T7">値のタプルの 7 番目のコンポーネントの型。</typeparam>
        <typeparam name="T8">値のタプルの 8 番目のコンポーネントの型。</typeparam>
        <param name="item1">値のタプルの 1 番目のコンポーネントの値。</param>
        <param name="item2">値のタプルの 2 番目のコンポーネントの値。</param>
        <param name="item3">値のタプルの 3 番目のコンポーネントの値。</param>
        <param name="item4">値のタプルの 4 番目のコンポーネントの値。</param>
        <param name="item5">値のタプルの 5 番目のコンポーネントの値。</param>
        <param name="item6">値のタプルの 6 番目のコンポーネントの値。</param>
        <param name="item7">値のタプルの 7 番目のコンポーネントの値。</param>
        <param name="item8">値のタプルの 8 番目のコンポーネントの値。</param>
        <summary>8 個のコンポーネント (オクタプル) を持つ新しい値のタプルを作成します。</summary>
        <returns>8 個のコンポーネントを持つ値のタプル。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ValueTuple.Create%2A> そのコンポーネントの型を明示的に指定することがなく、8 コンポーネントの値のタプルをインスタンス化を呼び出すことができるヘルパー メソッド。  
  
> [!NOTE]
>  呼び出す必要があります、<xref:System.ValueTuple%608.%23ctor%2A>お使いの言語は、この目的に特別な構文を提供しない限り、9 つまたは複数のコンポーネントを持つタプルを作成するコンス トラクター。 静的メソッド、 <xref:System.ValueTuple> 9 つまたは複数のコンポーネントを持つタプルを作成する構造体を使用することはできません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.ValueTuple" /> インスタンスが、指定されたオブジェクトと等しいかどうかを示す値を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="valueTuple.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">現在のインスタンスと比較する対象のオブジェクト。</param>
        <summary>現在の <see cref="T:System.ValueTuple" /> インスタンスが、指定されたオブジェクトと等しいかどうかを示す値を返します。</summary>
        <returns><paramref name="obj" /> が <see cref="T:System.ValueTuple" /> インスタンスである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ValueTuple other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.ValueTuple other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Equals(System.ValueTuple)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ValueTuple) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(ValueTuple other);" />
      <MemberSignature Language="F#" Value="override this.Equals : ValueTuple -&gt; bool" Usage="valueTuple.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.ValueTuple" />
      </Parameters>
      <Docs>
        <param name="other">現在のインスタンスと比較する値のタプル。</param>
        <summary>2 つの <see cref="T:System.ValueTuple" /> インスタンスが等しいかどうかを判断します。 このメソッドは常に <see langword="true" /> を返します。</summary>
        <returns>このメソッドは常に <see langword="true" /> を返します。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="valueTuple.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.ValueTuple" /> インスタンスのハッシュ コードを返します。</summary>
        <returns>このメソッドは常に 0 を返します。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">現在のインスタンスと比較するオブジェクト。</param>
        <param name="comparer">比較用のカスタムの規則を提供するオブジェクト。 このパラメーターは無視されます。</param>
        <summary>現在の <see cref="T:System.ValueTuple" /> インスタンスを指定したオブジェクトと比較します。</summary>
        <returns><paramref name="other" /> が <see cref="T:System.ValueTuple" /> インスタンスである場合は 0、<paramref name="other" /> が<see langword="null" /> である場合は 1 を返します。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="other" /> は <see cref="T:System.ValueTuple" /> インスタンスではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">このインスタンスと比較するオブジェクト。</param>
        <param name="comparer">2 つのオブジェクトが等しいかどうかの評価に使用するメソッドを定義するオブジェクト。</param>
        <summary>指定した比較メソッドに基づいて、現在の <see cref="T:System.ValueTuple" /> インスタンスが、指定されたオブジェクトと等しいかどうかを示す値を返します。</summary>
        <returns>現在のインスタンスが指定したオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス実装です。 できますのみ際に使用される、 <xref:System.ValueTuple>t > インスタンスにキャスト、<xref:System.Collections.IStructuralEquatable>インターフェイス。 <xref:System.Collections.IEqualityComparer.Equals%2A?displayProperty=nameWithType>場合にのみ実装が呼び出されます`other`は`null`、正常にすることができるかどうか、キャスト、<xref:System.ValueTuple>オブジェクト。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">ハッシュ コードを計算する <see cref="M:System.Collections.IEqualityComparer.GetHashCode(System.Object)" /> メソッドのオブジェクト。 このパラメーターは無視されます。</param>
        <summary>この <see cref="T:System.ValueTuple" /> インスタンスのハッシュ コードを返します。</summary>
        <returns>この <see cref="T:System.ValueTuple" /> インスタンスのハッシュ コード。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ other) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="other">現在のインスタンスと比較するオブジェクト</param>
        <summary>指定したオブジェクトとこの <see cref="T:System.ValueTuple" /> インスタンスを比較し、これらの相対値を示す値を返します。</summary>
        <returns><paramref name="other" /> が <see cref="T:System.ValueTuple" /> インスタンスである場合は 0。それ以外の場合は、<paramref name="other" /> が <see langword="null" /> である場合は 1。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="other" /> は <see cref="T:System.ValueTuple" /> インスタンスではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.CompilerServices.ITuple.Item">
      <MemberSignature Language="C#" Value="object System.Runtime.CompilerServices.ITuple.Item[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Runtime.CompilerServices.ITuple.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Item(index As Integer) As Object Implements ITuple.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Runtime::CompilerServices::ITuple::Item[int] { System::Object ^ get(int index); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.CompilerServices.ITuple.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.CompilerServices.ITuple.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><paramref name="index" /> に使用できる値はありません。</param>
        <summary><see cref="T:System.IndexOutOfRangeException" /> を返します。 <see langword="ValueTuple" /> に要素が存在しません。</summary>
        <value><see cref="T:System.IndexOutOfRangeException" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> に使用できる値はありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.CompilerServices.ITuple.Length">
      <MemberSignature Language="C#" Value="int System.Runtime.CompilerServices.ITuple.Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Runtime.CompilerServices.ITuple.Length" />
      <MemberSignature Language="DocId" Value="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Length" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Length As Integer Implements ITuple.Length" />
      <MemberSignature Language="C++ CLI" Value="property int System::Runtime::CompilerServices::ITuple::Length { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.CompilerServices.ITuple.Length" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.CompilerServices.ITuple.Length</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see langword="ValueTuple" /> インスタンスの長さを取得しますが、常に 0 です。 <see langword="ValueTuple" /> に要素が存在しません。</summary>
        <value>この <see langword="ValueTuple" /> インスタンス内の要素の数、0。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="valueTuple.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.ValueTuple" /> オブジェクトの文字列表現を返します。</summary>
        <returns>このメソッドは常に "()" を返します。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>