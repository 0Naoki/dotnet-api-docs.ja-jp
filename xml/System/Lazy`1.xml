<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a193eefa8afa38666768441022aa43617f7556d1" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70663824" /></Metadata><TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Lazy`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Lazy(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Lazy" />
  <TypeSignature Language="F#" Value="type Lazy&lt;'T&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">遅延初期化されるオブジェクトの型。</typeparam>
    <summary>遅延初期化のサポートを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 遅延初期化を使用すると、大量またはリソースを消費するオブジェクトの作成や、リソースを集中的に使用するタスクの実行を遅らせることができます。特に、プログラムの有効期間中にこのような作成や実行が行われない場合があります。  
  
 遅延初期化を準備するには、の<xref:System.Lazy%601>インスタンスを作成します。 作成する<xref:System.Lazy%601>オブジェクトの型引数は、遅延を初期化するオブジェクトの型を指定します。 オブジェクトの<xref:System.Lazy%601>作成に使用するコンストラクターによって、初期化の特性が決まります。 遅延初期化は、<xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> プロパティへの初回のアクセス時に発生します。  
  
 ほとんどの場合、コンストラクターの選択は、次の2つの質問に対する回答に依存します。  
  
-   遅延初期化されたオブジェクトには、複数のスレッドからアクセスしますか。 その場合は、 <xref:System.Lazy%601>オブジェクトによって任意のスレッドで作成される可能性があります。 既定の動作がスレッドセーフ<xref:System.Lazy%601>オブジェクトを作成する単純なコンストラクターの1つを使用できます。これにより、遅延インスタンス化されたオブジェクトの1つのインスタンスだけが、そのオブジェクトにアクセスしようとするスレッドの数に関係なく作成されます。 スレッドセーフで<xref:System.Lazy%601>はないオブジェクトを作成するには、スレッドセーフを指定できないようにするコンストラクターを使用する必要があります。  
  
    > [!CAUTION]
    >  オブジェクトを<xref:System.Lazy%601>スレッドセーフにすると、遅延初期化オブジェクトは保護されません。 遅延初期化されたオブジェクトに複数のスレッドがアクセスできる場合は、そのプロパティとメソッドを、マルチスレッドアクセスに対して安全にする必要があります。  
  
-   遅延初期化には多数のコードが必要です。また、遅延初期化オブジェクトには、必要なすべての処理を行うパラメーターなしのコンストラクターがあり、例外はスローされません。 初期化コードを記述する必要がある場合、または例外を処理する必要がある場合は、ファクトリメソッドを受け取るコンストラクターのいずれかを使用します。 ファクトリメソッドに初期化コードを記述します。  
  
 次の表は、これらの2つの要因に基づいて、選択するコンストラクターを示しています。  
  
|オブジェクトにアクセスする|初期化コードが必要ない場合 (パラメーターなしのコンストラクター)、を使用します。|初期化コードが必要な場合は、を使用します。|  
|--------------------------------|------------------------------------------------------------------------|---------------------------------------------|  
|複数のスレッド|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|1つのスレッド|<xref:System.Lazy%601.%23ctor%28System.Boolean%29>が`isThreadSafe` に `false` 設定された。|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29>が`isThreadSafe` に `false` 設定された。|  
  
 ラムダ式を使用して、ファクトリメソッドを指定できます。 これにより、すべての初期化コードが1つの場所に保持されます。 ラムダ式は、遅延初期化オブジェクトのコンストラクターに渡す引数を含め、コンテキストをキャプチャします。  
  
 **例外のキャッシュ**ファクトリメソッドを使用すると、例外がキャッシュされます。 つまり、スレッドが最初に<xref:System.Lazy%601.Value%2A> <xref:System.Lazy%601>オブジェクトのプロパティにアクセスしようとしたときにファクトリメソッドが例外をスローした場合、それ以降のすべての試行で同じ例外がスローされます。 これにより、プロパティの<xref:System.Lazy%601.Value%2A>すべての呼び出しで同じ結果が生成されるため、異なるスレッドで異なる結果が得られる場合に発生する軽度のエラーを回避できます。 は<xref:System.Lazy%601> 、以前の時点で`T`初期化されている (通常はスタートアップ時に) 実際のを表します。 その前の時点でのエラーは、通常、致命的です。 回復可能なエラーが発生する可能性がある場合は、遅延初期化を使用していない場合と同様に、初期化ルーチン (この場合はファクトリメソッド) に再試行ロジックを作成することをお勧めします。  
  
 **ロックの代替手段**場合によっては、 <xref:System.Lazy%601>オブジェクトの既定のロック動作のオーバーヘッドを回避する必要があります。 まれに、デッドロックが発生する可能性があります。 このような場合<xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29>は、コンストラクターまたは<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>コンストラクターを使用してを指定<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>できます。 これにより<xref:System.Lazy%601> 、スレッドが同時にプロパティを<xref:System.Lazy%601.Value%2A>呼び出す場合に、オブジェクトは、複数のスレッドのそれぞれに、遅延初期化されたオブジェクトのコピーを作成できるようになります。 オブジェクト<xref:System.Lazy%601>は、すべてのスレッドが遅延初期化オブジェクトの同じインスタンスを使用し、使用されていないインスタンスを破棄することを保証します。 したがって、ロックのオーバーヘッドを減らすコストは、プログラムが高価なオブジェクトの余分なコピーを作成して破棄することがあります。 ほとんどの場合、このことはほとんどありません。 コンストラクター <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> と <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> コンストラクターの例では、この動作を示しています。  
  
> [!IMPORTANT]
>  を指定<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>すると、ファクトリメソッドを指定した場合でも、例外はキャッシュされません。  
  
 **同等のコンストラクター**<xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>および <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> コンストラクターは、の使用を有効にするだけでなく、他のコンストラクターの機能を複製することもできます。 次の表に、同等の動作を生成するパラメーター値を示します。  
  
|オブジェクトを<xref:System.Lazy%601>作成するには|パラメーターを持つ`LazyThreadSafetyMode`コンストラクターの場合、を`mode`に設定します。 `mode`|ブール型`isThreadSafe`パラメーターを持つコンストラクターの場合、 `isThreadSafe`をに設定します。|スレッドセーフパラメーターのないコンストラクターの場合|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|  
|完全なスレッドセーフはロックを使用して、1つのスレッドだけが値を初期化するようにします。|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|このようなコンストラクターはすべて、完全にスレッドセーフです。|  
|スレッドセーフではありません。|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|該当なし。|  
|完全なスレッドセーフ値を初期化するスレッドの競合。|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|該当なし。|該当なし。|  
  
 **その他の機能**スレッド静的フィールドでのの<xref:System.Lazy%601>使用、またはプロパティのバッキングストアとしてを使用する方法については、「[レイジー初期化](~/docs/framework/performance/lazy-initialization.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、 <xref:System.Lazy%601>クラスを使用して、複数のスレッドからのアクセスで遅延初期化を行う方法を示します。  
  
> [!NOTE]
>  この例では<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> 、コンストラクターを使用します。 また、 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29>コンストラクター (の場合`isThreadSafe`はを指定`true` ) と<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>コンストラクター ( <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>の場合`mode`はを指定) の使用方法も示します。 別のコンストラクターに切り替えるには、コメントアウトするコンストラクターを変更するだけです。  
>   
>  同じコンストラクターを使用した例外のキャッシュを示す例につい<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>ては、「コンストラクター」を参照してください。  
  
 この例では、複数あるスレッドのうちの 1 つによって遅れて初期化される `LargeObject` クラスを定義します。 コードの4つの主要なセクションでは、初期化子、ファクトリメソッド、実際の初期化、およびオブジェクトが作成さ`LargeObject`れたときにメッセージを表示するクラスのコンストラクターを作成する方法を示します。 `Main` メソッドの開始時に、この例では `LargeObject` のスレッドセーフな遅延初期化子が作成されます。  
  
 [!code-csharp[System.Lazy\`1#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 ファクトリメソッドは、さらに初期化するためのプレースホルダーを使用して、オブジェクトの作成を示します。  
  
 [!code-csharp[System.Lazy\`1#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 次に示すように、ラムダ関数を使用すると、最初の2つのコードセクションを組み合わせることができます。  
  
 [!code-csharp[System.Lazy\`1#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 この例では、遅延初期化が発生する前に、不確定な期間が経過する可能性があることを示すために一時停止します。 **Enter キーを**押すと、この例では3つのスレッドを作成して開始します。 3 `ThreadProc`つのすべてのスレッドで使用されるメソッド<xref:System.Lazy%601.Value%2A>は、プロパティを呼び出します。 これが初めて発生`LargeObject`したときに、インスタンスが作成されます。  
  
 [!code-csharp[System.Lazy\`1#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 コードの最後の`LargeObject`キーセクションを含むクラスのコンストラクターは、メッセージを表示し、初期化中のスレッドの id を記録します。 プログラムからの出力は、完全なコードリストの最後に表示されます。  
  
 [!code-csharp[System.Lazy\`1#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` (Visual Basic の `Shared`) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>既定では、 <see cref="T:System.Lazy`1" />クラスのパブリックメンバーとプロテクトメンバーはすべてスレッドセーフであり、複数のスレッドから同時に使用することができます。 これらのスレッドセーフの保証は、必要に応じて、型のコンストラクターへのパラメーターを使用して、インスタンスごとに削除することができます。</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
    <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。 遅延初期化が発生した場合、ターゲットの型のパラメーターなしのコンストラクターが使用されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターを使用して作成されたインスタンスは、複数のスレッドから同時に使用できます。  
  
 このコンストラクターで初期化され<xref:System.Lazy%601>たインスタンスのスレッドセーフモードは<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>です。 スレッドセーフモードでは、複数のスレッドが<xref:System.Lazy%601>インスタンスを初期化しようとしたときの動作が記述されます。  
  
 この<xref:System.Lazy%601>コンストラクターを使用して作成されたインスタンスは、例外をキャッシュしません。 詳細については、<xref:System.Lazy%601> クラスまたは <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 列挙体の解説を参照してください。  
  
   
  
## Examples  
 このコンストラクターの使用例を次に示します。 また、 <xref:System.Lazy%601.%23ctor%28System.Boolean%29>コンストラクター (では`isThreadSafe`を指定`true` ) と<xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29>コンストラクター ( <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>の場合`mode`はを指定) の使用方法も示しています。 別のコンストラクターに切り替えるには、コメントアウトするコンストラクターを変更するだけです。  
  
 この例では、複数あるスレッドのうちの 1 つによって遅れて初期化される `LargeObject` クラスを定義します。 この例の2つの重要なコード行は、初期化子と実際の初期化を作成することです。 `Main` メソッドの開始時に、この例では `LargeObject` のスレッドセーフな遅延初期化子が作成されます。  
  
 [!code-csharp[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 この例では、 <xref:System.Threading.ManualResetEvent>オブジェクトでブロックされる3つのスレッドを作成して開始します。これにより、この例では、スレッドをすべて一度に解放できます。 3 `ThreadProc`つのすべてのスレッドで使用されるメソッド<xref:System.Lazy%601.Value%2A>は、プロパティを`LargeObject`呼び出してインスタンスを取得します。  
  
 [!code-csharp[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 クラス<xref:System.Lazy%601>は、1つのスレッドのみがインスタンスの`LargeObject`作成を許可されるように、ロックを提供します。 この例では、他のスレッドがすべて同じインスタンスを取得することを示しています。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` (Visual Basic の `Shared`) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctor#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; isThreadSafe" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe">このインスタンスを複数のスレッドで同時に使用できるようにする場合は <see langword="true" />。インスタンスを一度に 1 つのスレッドでしか使用できないようにする場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。 遅延初期化が発生した場合、ターゲットの型のパラメーターなしのコンストラクターと指定された初期化モードが使用されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターで初期化される<xref:System.Lazy%601>インスタンスのスレッドセーフモードは、が<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>の`isThreadSafe` `true`場合はです。それ以外の<xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>場合、モードはです。 スレッドセーフモードでは、複数のスレッドが<xref:System.Lazy%601>インスタンスを初期化しようとしたときの動作が記述されます。 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>モードを指定するに<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>は、コンストラクター <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29>またはコンストラクターを使用します。  
  
 この<xref:System.Lazy%601>コンストラクターを使用して作成されたインスタンスは、例外をキャッシュしません。 詳細については、<xref:System.Lazy%601> クラスまたは <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 列挙体の解説を参照してください。  
  
   
  
## Examples  
 次の例では、このコンストラクターを使用して、遅延初期化されたオブジェクトへのすべてのアクセスが同じスレッドで発生するシナリオについて、スレッドセーフではないレイジー初期化子を作成しています。 また、 <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29>コンストラクターの使用方法も示します ( <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>を`mode`指定します。 別のコンストラクターに切り替えるには、コメントアウトされているコンストラクターを変更するだけです。  
  
> [!NOTE]
>  このコンストラクターをマルチスレッドシナリオで使用する方法を示すコード ( `true`の`isThreadSafe`場合) につい<xref:System.Lazy%601.%23ctor>ては、コンストラクターの例を参照してください。  
  
 この例では`LargeObject` 、遅延して初期化されるクラスを定義します。 メソッドでは、インスタンスを<xref:System.Lazy%601>作成して一時停止します。 `Main` **Enter キーを**押すと、 <xref:System.Lazy%601.Value%2A> <xref:System.Lazy%601>インスタンスのプロパティにアクセスします。これにより、初期化が発生します。 `LargeObject`クラスのコンストラクターは、コンソールメッセージを表示します。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` (Visual Basic の `Shared`) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctorBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; valueFactory" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="valueFactory">必要時に遅延初期化される値を生成するために呼び出されるデリゲート。</param>
        <summary><see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。 遅延初期化が発生した場合、指定された初期化関数が使用されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターを使用して作成されたインスタンスは、複数のスレッドから同時に使用できます。  
  
 このコンストラクターで初期化され<xref:System.Lazy%601>たインスタンスのスレッドセーフモードは<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>です。 スレッドセーフモードでは、複数のスレッドが<xref:System.Lazy%601>インスタンスを初期化しようとしたときの動作が記述されます。  
  
 によって`valueFactory`スローされた例外はキャッシュされます。 詳細については、<xref:System.Lazy%601> クラスまたは <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 列挙体の解説を参照してください。  
  
   
  
## Examples  
 次の例では、このコンストラクターを使用して、例外キャッシュによるレイジー初期化を行う方法を示します。 また、 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29>コンストラクター (の場合`isThreadSafe`はを指定`true` ) と<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>コンストラクター ( <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>の場合`mode`はを指定) の使用方法も示します。 別のコンストラクターに切り替えるには、コメントアウトするコンストラクターを変更するだけです。  
  
 この例では、複数あるスレッドのうちの 1 つによって遅れて初期化される `LargeObject` クラスを定義します。 コードの3つの重要なセクションは、初期化子の作成、実際の初期化、および`LargeObject`クラスのコンストラクターの作成を示しています。これは、例外のキャッシュを示しています。 `Main` メソッドの開始時に、この例では `LargeObject` のスレッドセーフな遅延初期化子が作成されます。  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 この例では、3つのスレッドを作成して開始します。 3 `ThreadProc`つのすべてのスレッドで使用されるメソッド<xref:System.Lazy%601.Value%2A>は、プロパティを`LargeObject`呼び出してインスタンスを取得します。  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 `LargeObject`クラスのコンストラクターでは、コードの3番目のキーセクションが、 `LargeObject`インスタンスが最初に作成されたときに例外をスローしますが、その後インスタンスの作成が可能になります。  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 この例を実行すると、の`LargeObject`インスタンスを作成しようとする最初のスレッドが失敗し、例外がキャッチされます。 次のスレッドによってインスタンスが正常に作成されても<xref:System.Lazy%601> 、オブジェクトによって例外がキャッシュされていることが予想される場合があります。 このため、3つのすべてのスレッドが例外をスローします。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` (Visual Basic の `Shared`) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> は <see langword="null" />です。</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; mode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mode">スレッド セーフ モードを指定する列挙値の 1 つ。</param>
        <summary><paramref name="T" /> のパラメーターなしのコンストラクターと指定されたスレッド セーフ モードを使用する <see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Lazy%601>インスタンスのスレッドセーフモードでは、複数のスレッドが<xref:System.Lazy%601>インスタンスを初期化しようとしたときの動作が記述されます。  
  
 この<xref:System.Lazy%601>コンストラクターを使用して作成されたインスタンスは、例外をキャッシュしません。 詳細については、<xref:System.Lazy%601> クラスまたは <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 列挙体の解説を参照してください。  
  
   
  
## Examples  
 次の例では、このコンストラクターを使用して、複数のスレッドによるオブジェクトの作成を遅延させるレイジー初期化子を作成する方法を示します。 インスタンスの作成には複数のスレッドが成功することがありますが、すべてのスレッドは最初に作成されたインスタンスを使用します。  
  
> [!NOTE]
>  シングルスレッドシナリオ<xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> `mode`でこのコンストラクターを使用する方法を示す例については、「」を参照<xref:System.Lazy%601.%23ctor%28System.Boolean%29>してください。 このコンストラクターを使用してマルチスレッドシナリオ<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> `mode`で競合状態ではなくロックを提供する方法を示す例については<xref:System.Lazy%601.%23ctor> 、「」を参照してください。  
  
 この例では`LargeObject` 、複数のスレッドのいずれかによって遅延的に初期化されるクラスを定義します。 コードの3つの重要なセクションでは、初期化子の作成、実際の初期化、および`LargeObject`クラスのコンストラクターとファイナライザーを示します。 `Main`メソッドの先頭で、この例では、 `LargeObject`の<xref:System.Lazy%601>遅延初期化を実行するオブジェクトを作成します。  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 この例では、 <xref:System.Threading.ManualResetEvent>オブジェクトでブロックされる3つのスレッドを作成して開始します。これにより、この例では、スレッドをすべて一度に解放できます。 3つのすべてのスレッドで使用される<xref:System.Lazy%601.Value%2A> `LargeObject` メソッドで、プロパティを呼び出すと、インスタンスが作成 `ThreadProc` されます。  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 <xref:System.Lazy%601>インスタンスのコンストラクターが指定さ<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>れているため、3つのすべて`LargeObject`のスレッドでインスタンスを作成できます。 この例では、 `LargeObject`クラスのコンストラクターとファイナライザーにコンソールメッセージを表示することによって、これを示します。  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 ただし、オブジェクト<xref:System.Lazy%601>は、すべてのスレッドで使用されるインスタンスが1つだけであることを保証します。 この例の出力は、3つのすべてのスレッドが同じインスタンスを使用しており、他の2つのインスタンスがガベージコレクションによって再利用できることを示しています。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` (Visual Basic の `Shared`) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> に無効な値が含まれています。</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(T value);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : 'T -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">使用される、事前に初期化された値。</param>
        <summary>事前に初期化され、指定された値を使用する <see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
このコンストラクターを使用して作成されたインスタンスは、複数のスレッドが同時に使用できます。
]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, isThreadSafe)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="valueFactory">必要時に遅延初期化される値を生成するために呼び出されるデリゲート。</param>
        <param name="isThreadSafe">このインスタンスを複数のスレッドで同時に使用できるようにする場合は <see langword="true" />。このインスタンスを一度に 1 つのスレッドでしか使用できないようにする場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。 遅延初期化が発生した場合、指定された初期化関数および初期化モードが使用されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターで初期化される<xref:System.Lazy%601>インスタンスのスレッドセーフモードは、が<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>の`isThreadSafe` `true`場合はです。それ以外の<xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>場合、モードはです。 スレッドセーフモードでは、複数のスレッドが<xref:System.Lazy%601>インスタンスを初期化しようとしたときの動作が記述されます。  
  
 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>モードを指定するに<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>は、コンストラクター <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29>またはコンストラクターを使用します。  
  
 によって`valueFactory`スローされた例外はキャッシュされます。 詳細については、<xref:System.Lazy%601> クラスまたは <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 列挙体の解説を参照してください。  
  
   
  
## Examples  
 次の例では、単一のスレッドを使用するシナリオで、このコンストラクターを使用して、例外のキャッシュによるレイジー初期化を行う方法を示します。 また、 <xref:System.Lazy%601.%23ctor%2A>コンストラクターの使用方法についても示し`mode`ます (を指定<xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> )。 このコンストラクターに切り替えるには、コメントアウトされているコンストラクターを変更するだけです。  
  
> [!NOTE]
>  このコンストラクターをマルチスレッドシナリオで使用する方法を示すコード ( `true`の`isThreadSafe`場合) につい<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>ては、コンストラクターの例を参照してください。  
  
 この例では、複数あるスレッドのうちの 1 つによって遅れて初期化される `LargeObject` クラスを定義します。 コードの3つの重要なセクションは、初期化子の作成、実際の初期化、および`LargeObject`クラスのコンストラクターの作成を示しています。これは、例外のキャッシュを示しています。 `Main` メソッドの開始時に、この例では `LargeObject` のスレッドセーフな遅延初期化子が作成されます。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 コンストラクター `isThreadSafe`の呼び出しでは、パラメーターは`false`であるため<xref:System.Lazy%601> 、はスレッドセーフではありません。 この例では、スレッドセーフではないため<xref:System.Lazy%601.Value%2A> 、同じスレッドでプロパティを3回呼び出します。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 `LargeObject`クラスのコンストラクターでは、コードの3番目のキーセクションが、 `LargeObject`インスタンスが最初に作成されたときに例外をスローしますが、その後インスタンスの作成が可能になります。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 この例を実行すると、の`LargeObject`インスタンスを初めて作成しようとして失敗し、例外がキャッチされます。 次の試行は成功したと思われるかも<xref:System.Lazy%601>しれませんが、オブジェクトによって例外がキャッシュされています。 このため、3回すべての試行で例外がスローされます。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` (Visual Basic の `Shared`) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> が <see langword="null" /> です。</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="valueFactory">必要時に遅延初期化される値を生成するために呼び出されるデリゲート。</param>
        <param name="mode">スレッド セーフ モードを指定する列挙値の 1 つ。</param>
        <summary>指定された初期化関数とスレッド セーフ モードを使用する <see cref="T:System.Lazy`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Lazy%601>インスタンスのスレッドセーフモードでは、複数のスレッドが<xref:System.Lazy%601>インスタンスを初期化しようとしたときの動作が記述されます。  
  
 によって`valueFactory`スローされた例外は、 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>がの場合を除き`mode` 、キャッシュされます。 詳細については、<xref:System.Lazy%601> クラスまたは <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 列挙体の解説を参照してください。  
  
   
  
## Examples  
 次の例では、このコンストラクターを使用して、複数のスレッドによるオブジェクトの作成を遅延させるレイジー初期化子を作成する方法を示します。 インスタンスの作成には複数のスレッドが成功することがありますが、すべてのスレッドは最初に作成されたインスタンスを使用します。 また、この例では、指定<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>したときに例外がキャッシュされないことを示しています。これは、遅延作成型のパラメーターなしのコンストラクターではなく、関数によって初期化が実行される場合でも同様です。  
  
> [!NOTE]
>  シングルスレッドシナリオ<xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> `mode`でこのコンストラクターを使用する方法を示す例については、「」を参照<xref:System.Lazy%601.%23ctor%28System.Boolean%29>してください。 このコンストラクターを使用してマルチスレッドシナリオ<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> `mode`で競合状態ではなくロックを提供する方法を示す例については<xref:System.Lazy%601.%23ctor> 、「」を参照してください。  
  
 この例では`LargeObject` 、複数のスレッドのいずれかによって遅延的に初期化されるクラスを定義します。 コードの4つの主要なセクションでは、初期化子、実際の初期化、初期化関数、および`LargeObject`クラスのコンストラクターとファイナライザーの作成について説明します。 `Main`メソッドの先頭で、この例では、 `LargeObject`の<xref:System.Lazy%601>遅延初期化を実行するオブジェクトを作成します。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 レイジー初期化子は、関数を使用して初期化を実行します。 この場合、 `LargeObject`クラスのパラメーターなしのコンストラクターがないため、関数が必要です。  
  
 この例では、 <xref:System.Threading.ManualResetEvent>オブジェクトでブロックされる3つのスレッドを作成して開始します。これにより、この例では、スレッドをすべて一度に解放できます。 3つのすべてのスレッドで使用される<xref:System.Lazy%601.Value%2A> `LargeObject` メソッドで、プロパティを呼び出すと、インスタンスが作成 `ThreadProc` されます。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 コードの3番目のキーセクションでは、遅延初期化関数を呼び出して`LargeObject`インスタンスを作成します。 関数は、初めて呼び出されたときに例外をスローします。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 その他の<xref:System.Threading.LazyThreadSafetyMode>設定では、初期化関数でハンドルされない例外がキャッシュされます。 ただし、 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>は例外のキャッシュを抑制します。 この例の出力は、オブジェクトの初期化が成功したことを示しています。  
  
> [!NOTE]
>  通常、例外メッセージは、他のスレッドがオブジェクトを正常に初期化したことを示すメッセージの後に表示されます。 これは、例外のスローとキャッチによって発生する遅延に起因します。  
  
 <xref:System.Lazy%601>インスタンスのコンストラクターが指定さ<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>れているため、3つのすべて`LargeObject`のスレッドでインスタンスを作成できます。 この例では、 `LargeObject`クラスのコンストラクターとファイナライザーにコンソールメッセージを表示することによって、これを示します。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 オブジェクト<xref:System.Lazy%601>は、すべてのスレッドで使用されるインスタンスが1つだけであることを保証します (初期化関数が例外をスローするスレッドを除く)。 この例の出力はこれを示しています。  
  
> [!NOTE]
>  簡略化のために、この例では <xref:System.Lazy%601> のグローバル インスタンスを使用して、すべてのメソッドは `static` (Visual Basic の `Shared`) です。 これらは、遅延初期化を使用するための要件ではありません。  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> に無効な値が含まれています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> は <see langword="null" />です。</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueCreated : bool" Usage="System.Lazy&lt;'T&gt;.IsValueCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Lazy`1" /> インスタンスに対して値が作成されているかどうかを示す値を取得します。</summary>
        <value>この <see cref="T:System.Lazy`1" /> インスタンスに対して値が作成されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Lazy%601>インスタンスに対して遅延初期化が発生すると、値が作成されるか、例外がスローされます。 例外がスローされた場合、 <xref:System.Lazy%601>インスタンスの後続の動作は、例外キャッシュが有効になっているかどうかによって異なります。 初期化関数を指定していないコンストラクターを使用してインスタンスが作成された場合、例外キャッシュは有効になりません。 <xref:System.Lazy%601> 後続のの<xref:System.Lazy%601>初期化は成功する可能性があり、初期化が成功すると`true`、プロパティは<xref:System.Lazy%601.IsValueCreated%2A>を返します。 インスタンスが初期化関数 ( <xref:System.Lazy%601>コンストラクターの`valueFactory`パラメーターで指定) を使用して作成されている場合、例外キャッシュはスレッドセーフモードによって制御されます。 <xref:System.Lazy%601>  
  
-   モードが<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>または<xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>の場合、インスタンスを<xref:System.Lazy%601>初期化する機会はもうありません。 例外が発生し、初期化関数でハンドルされない場合、その例外はキャッシュされ、その後<xref:System.Lazy%601.Value%2A?displayProperty=nameWithType>のプロパティのアクセス時に再スローされます。 例外がスローされた場合は値が作成されない<xref:System.Lazy%601.IsValueCreated%2A>ため`false`、このような場合はが返されます。  
  
-   モードが<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>の場合、初期化関数 (またはパラメーターなしのコンストラクター) の実行に成功した最初のスレッドが、 <xref:System.Lazy%601>インスタンスの値を作成します。 初期化関数が1つのスレッドで例外をスローした場合でも、他の<xref:System.Lazy%601>スレッドはインスタンスの初期化を試みることができます。 値が作成されるまで、 <xref:System.Lazy%601.IsValueCreated%2A>プロパティは`false`を返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="lazy.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスの <see cref="P:System.Lazy`1.Value" /> プロパティの文字列形式を作成して返します。</summary>
        <returns>値が作成された (つまり、<see cref="M:System.Object.ToString" /> プロパティが <see langword="true" /> を返す) 場合は、このインスタンスの <see cref="P:System.Lazy`1.Value" /> プロパティに対して <see cref="P:System.Lazy`1.IsValueCreated" /> メソッドを呼び出した結果。 それ以外の場合は、値が作成されなかったことを示す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出すと、初期化は行われません。  
  
 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>、 <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> `valueFactory` `null` `null` 、また <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> はコンストラクターのパラメーターに指定されたファクトリメソッドがを返す場合、プロパティは遅延初期化の後に設定できます。 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><see cref="P:System.Lazy`1.Value" /> プロパティが <see langword="null" /> である。</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Value { T get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : 'T" Usage="System.Lazy&lt;'T&gt;.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Lazy`1" /> インスタンスの遅延初期化された値を取得します。</summary>
        <value>現在の <see cref="T:System.Lazy`1" /> インスタンスの遅延初期化された値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティがの場合`false`、プロパティに<xref:System.Lazy%601.Value%2A>アクセスすると、強制的に初期化されます。 <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType>  
  
 <xref:System.Lazy%601.Value%2A>このプロパティは、一覧表示されている例外に加えて、 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>、 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>、または<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29>の`valueFactory`パラメーターに渡されたファクトリメソッドによってスローされた未処理の例外をスローできます。コンストラクター.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><see cref="T:System.Lazy`1" /> インスタンスは、遅延初期化されている型のパラメーターなしのコンストラクターを使用して初期化されており、コンストラクターに対するアクセス許可がありません。</exception>
        <exception cref="T:System.MissingMemberException"><see cref="T:System.Lazy`1" /> インスタンスは、遅延初期化されている型のパラメーターなしのコンストラクターを使用して初期化されており、この型にはパブリックのパラメーターのないコンストラクターがありません。</exception>
        <exception cref="T:System.InvalidOperationException">初期化関数が、このインスタンスで <see cref="P:System.Lazy`1.Value" /> へのアクセスを試行します。</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">限定的な初期化</related>
      </Docs>
    </Member>
  </Members>
</Type>
