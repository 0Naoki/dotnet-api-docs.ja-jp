<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="308002d9ae24d643fad3d891656bd69b93f39794" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70405948" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>.NET クラス階層のすべてのクラスをサポートし、派生クラスに下位レベルのサービスを提供します。 これは、全 .NET クラスの基本クラスであり、型階層のルートです。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 継承は暗黙的に行わ<xref:System.Object>れるため、言語は通常、継承を宣言するクラスを必要としません。  
  
 .Net のすべてのクラスはから<xref:System.Object>派生しているため、 <xref:System.Object>クラスで定義されているすべてのメソッドは、システム内のすべてのオブジェクトで使用できます。 派生クラスは、次のようなメソッドの一部をオーバーライドできます。  
  
-   <xref:System.Object.Equals%2A>-オブジェクト間の比較をサポートします。  
  
-   <xref:System.Object.Finalize%2A>-オブジェクトが自動的に再利用される前にクリーンアップ操作を実行します。  
  
-   <xref:System.Object.GetHashCode%2A>-ハッシュテーブルの使用をサポートするために、オブジェクトの値に対応する番号を生成します。  
  
-   <xref:System.Object.ToString%2A>-クラスのインスタンスを記述する、人間が判読できるテキスト文字列を製造します。  
  
## <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 コレクションなど、任意の型のオブジェクトを処理する必要があるクラスをデザインする場合は、クラスの<xref:System.Object>インスタンスを受け入れるクラスメンバーを作成できます。 ただし、型のボックス化とボックス化解除のプロセスでは、パフォーマンスコストがかかります。 新しいクラスで特定の値型を頻繁に処理することがわかっている場合は、2つの戦術のいずれかを使用して、ボックス化のコストを最小限に抑えることができます。  
  
-   <xref:System.Object>型を受け入れる汎用メソッドと、クラスで頻繁に処理することが予想される各値型を受け入れる型固有のメソッドオーバーロードのセットを作成します。 呼び出し元のパラメーターの型を受け入れる型固有のメソッドが存在する場合は、ボックス化が行われず、型固有のメソッドが呼び出されます。 呼び出し元のパラメーターの型と一致するメソッド引数がない場合、パラメーターはボックス化され、一般メソッドが呼び出されます。  
  
-   ジェネリックを使用するように型とそのメンバーを設計します。 共通言語ランタイムは、クラスのインスタンスを作成し、ジェネリック型引数を指定するときに、クローズジェネリック型を作成します。 ジェネリックメソッドは型固有であり、呼び出し元のパラメーターをボックス化せずに呼び出すことができます。  
  
 型を受け入れて返す<xref:System.Object>汎用クラスを開発しなければならない場合もありますが、頻繁に使用される型を処理する型固有のクラスも用意することで、パフォーマンスを向上させることができます。 たとえば、ブール値の設定と取得に固有のクラスを指定すると、ブール値のボックス化とボックス化解除のコストが削減されます。  
  
   
  
## Examples  
 次の例では、 <xref:System.Object>クラスから派生した Point 型を定義し、 <xref:System.Object>クラスの多くの仮想メソッドをオーバーライドします。 また、この例では、 <xref:System.Object>クラスの静的メソッドとインスタンスメソッドの多くを呼び出す方法を示しています。  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>パブリック静的 (Visual Basic では<see langword="Shared" />) なこの型のメンバーはスレッド セーフです インスタンスメンバーは、スレッドセーフであるとは限りません。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Object" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターは、派生クラスのコンストラクターによって呼び出されますが、 <xref:System.Object>クラスのインスタンスを直接作成するために使用することもできます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>2 つのオブジェクト インスタンスが等しいかどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">現在のオブジェクトと比較するオブジェクト。</param>
        <summary>指定したオブジェクトが、現在のオブジェクトと等しいかどうかを判断します。</summary>
        <returns>指定したオブジェクトが現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在のインスタンスと`obj`パラメーターの比較の種類は、現在のインスタンスが参照型であるか値型であるかによって異なります。  
  
-   現在のインスタンスが参照型の場合、メソッド<xref:System.Object.Equals%28System.Object%29>は参照の等価性をテストし、メソッドの<xref:System.Object.Equals%28System.Object%29>呼び出しはメソッドの<xref:System.Object.ReferenceEquals%2A>呼び出しに相当します。 参照の等価性とは、比較されるオブジェクト変数が同じオブジェクトを参照することを意味します。 次の例は、このような比較の結果を示しています。 これは参照`Person`型であるクラスを定義し、 `Person`クラスコンストラクターを呼び出して、2つの`Person`新しいオブジェクト`person1a`と`person2`、同じ値を持つをインスタンス化します。 また、 `person1a` `person1b`別のオブジェクト変数にも割り当てられます。 この例の出力が示すように`person1a` 、 `person1b`とは同じオブジェクトを参照しているため、と同じです。 ただし、 `person2`との値が同じであっても、とは等しくありません。 `person1a`  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   現在のインスタンスが値型の場合、メソッド<xref:System.Object.Equals%28System.Object%29>は値が等しいかどうかをテストします。 値の等価性は、次のことを意味します。  
  
    -   2つのオブジェクトの型は同じです。 次の例に示すように<xref:System.Byte> 、値が12のオブジェクトは、値が 12 <xref:System.Int32>のオブジェクトとは異なります。これは、2つのオブジェクトの実行時の型が異なるためです。  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   2つのオブジェクトのパブリックフィールドとプライベートフィールドの値が等しい。 次の例では、値が等しいかどうかをテストします。 これは、 `Person`値型の構造体を定義し、 `Person`クラスコンストラクターを呼び出して、2つ`Person`の新しい`person1`オブジェクト`person2`と、同じ値を持つをインスタンス化します。 この例の出力はを示していますが、2つのオブジェクト変数は`person1`異なる`person2`オブジェクトを参照しますが、は、プライベート`personName`フィールドの値が同じであるため、同じです。  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 クラスは .NET Framework 内のすべての型の基底クラスであるため、 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッドは、他のすべての型に対して既定の等値比較を提供します。 <xref:System.Object> ただし、型は多くの<xref:System.Object.Equals%2A>場合、値の等価性を実装するためにメソッドをオーバーライドします。 詳細については、以下を参照してください。の呼び出し元とメモ継承先のセクションです。  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>のメモ[!INCLUDE[wrt](~/includes/wrt-md.md)]  
 の<xref:System.Object.Equals%28System.Object%29> <xref:System.Object.Equals%28System.Object%29>クラスでメソッドオーバーロードを呼び出すと、オーバーライドされないクラスの既定の動作が提供されます。 [!INCLUDE[wrt](~/includes/wrt-md.md)] これは、 [!INCLUDE[wrt](~/includes/wrt-md.md)] .NET Framework がに提供するサポートの一部です (「 [Windows ストアアプリと Windows ランタイムの .NET Framework サポート](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)」を参照してください)。 のクラスは[!INCLUDE[wrt](~/includes/wrt-md.md)]継承<xref:System.Object>されず、現在は<xref:System.Object.Equals%28System.Object%29>メソッドを実装していません。 ただし、これらのメソッドを<xref:System.Object.ToString%2A> C#また<xref:System.Object.Equals%28System.Object%29>は Visual Basic <xref:System.Object.GetHashCode%2A>コードで使用する場合は、、、およびの各メソッドがあるように見えます。 .NET Framework は、これらのメソッドの既定の動作を提供します。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]または Visual Basic にC#記述されたクラスは<xref:System.Object.Equals%28System.Object%29> 、メソッドのオーバーロードをオーバーライドできます。  
  
## <a name="notes-for-callers"></a>呼び出し元に関する注意事項  
 派生クラスは、値<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>の等価性を実装するためにメソッドをオーバーライドすることがよくあります。 また、型は、通常、 `Equals` <xref:System.IEquatable%601>インターフェイスを実装することによって、厳密に型指定されたオーバーロードをメソッドに提供します。 `Equals`メソッドを呼び出して等しいかどうかをテストする場合は、現在のインスタンスが<xref:System.Object.Equals%2A?displayProperty=nameWithType>をオーバーライドし、 `Equals`メソッドの特定の呼び出しがどのように解決されるかを把握しておく必要があります。 それ以外の場合は、意図したものとは異なる等しいかどうかのテストを実行し、メソッドが予期しない値を返す可能性があります。  
  
 具体的な例を次に示します。 同じ文字列を<xref:System.Text.StringBuilder>持つ3つのオブジェクトをインスタンス化してから`Equals` 、4つのメソッド呼び出しを行います。 最初のメソッド呼び出しは`true`を返し、残りの 3 `false`つの戻り値を返します。  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 最初のケースでは、厳密に<xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType>型指定されたメソッドオーバーロード (値が等しいかどうかをテストする) が呼び出されます。 2つ<xref:System.Text.StringBuilder>のオブジェクトに割り当てられた文字列は等しいため、 `true`メソッドはを返します。 ただし、 <xref:System.Text.StringBuilder>はをオーバーライド<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>しません。 この<xref:System.Text.StringBuilder>ため、オブジェクトが<xref:System.Object>に<xref:System.Text.StringBuilder>キャストされるときに、インスタンスが型<xref:System.Object> <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>の変数に割り当てられ、メソッドに2つ<xref:System.Text.StringBuilder>のオブジェクトが渡されたときに、既定で <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッドが呼び出されます。 は<xref:System.Text.StringBuilder>参照型であるため、これは2つ<xref:System.Text.StringBuilder>のオブジェクトを<xref:System.Object.ReferenceEquals%2A>メソッドに渡すことと同じです。 これら3つ<xref:System.Text.StringBuilder>のオブジェクトはすべて同一の文字列を含んでいますが、3つの異なるオブジェクトを参照します。 このため、この3つのメソッド呼び出し`false`はを返します。  
  
 <xref:System.Object.ReferenceEquals%2A>メソッドを呼び出すことにより、現在のオブジェクトを別のオブジェクトと比較して、参照の等価性を確認できます。 Visual Basic では、 `is`キーワード (など`If Me Is otherObject Then ...`) を使用することもできます。  
  
## <a name="notes-for-inheritors"></a>継承に関する注意事項  
 独自の型を定義すると、その型は基本型の`Equals`メソッドによって定義された機能を継承します。 次の表は、.NET Framework の型の`Equals`主なカテゴリに対するメソッドの既定の実装を示しています。  
  
|型のカテゴリ|等しいかどうかの定義|コメント|  
|-------------------|-------------------------|--------------|  
|から直接派生したクラス<xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|参照の等価性。の呼び出し<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>に相当します。|  
|構造体|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|値の等価性。リフレクションを使用して、バイト単位の比較またはフィールドごとの比較を直接行います。|  
|列挙|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|値の列挙型と基になる値が同じである必要があります。|  
|Delegate|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|デリゲートは、同じ型の呼び出しリストを持つ必要があります。|  
|Interface|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|参照の等価性。|  
  
 値型の場合は、リフレクションに依存<xref:System.Object.Equals%2A>する等しいかどうかのテストによってパフォーマンスが低下するため、常にをオーバーライドする必要があります。 参照型に対するの<xref:System.Object.Equals%2A>既定の実装をオーバーライドして、参照の等価性ではなく値の等価性をテストし、値の等価性の正確な意味を定義することもできます。 の<xref:System.Object.Equals%2A>このような`true`実装では、2つのオブジェクトが同じ値を持つ場合は、同じインスタンスではない場合でも、が返されます。 型の実装者は、オブジェクトの値を構成する対象を決定しますが、通常は、オブジェクトのインスタンス変数に格納されているデータの一部またはすべてを指定します。 たとえば、 <xref:System.String>オブジェクトの値は文字列の文字に基づいてい<xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType>ます。メソッドは、メソッドを<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>オーバーライドして、 `true`同じ文字を含む2つの文字列インスタンスが同じ順序で返されるようにします。  
  
 次の例は、 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッドをオーバーライドして値の等価性をテストする方法を示しています。 クラスのメソッド<xref:System.Object.Equals%2A>をオーバーライドします。 `Person` が`Person`その基底クラスの等価性の実装を`Person`受け入れた場合、2つのオブジェクトは、1つのオブジェクトを参照した場合にのみ等しくなります。 ただし、この場合、 `Person` `Person.Id`プロパティの値が同じである場合、2つのオブジェクトは等しいことになります。  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 をオーバーライド<xref:System.Object.Equals%2A>するだけでなく、厳密に<xref:System.IEquatable%601>型指定されたテストを等価性を提供するインターフェイスを実装することもできます。  
  
 次のステートメントは、 <xref:System.Object.Equals%28System.Object%29>メソッドのすべての実装に対して true である必要があります。 リスト`x`で `y` は、、、および`z`は、 **null**ではないオブジェクト参照を表します。  
  
-   `x.Equals(x)`浮動`true`小数点型が含まれている場合を除き、を返します。 「 [ISO/IEC/IEEE 60559:2011」、「情報技術-マイクロプロセッサシステム--浮動小数点演算」を](https://www.iso.org/standard/57469.html)参照してください。  
  
-   `x.Equals(y)` からは `y.Equals(x)` と同じ値が返されます。  
  
-   `x.Equals(y)`と`true`の両方`x` `y`がで `NaN` ある場合は、を返します。  
  
-   が`(x.Equals(y) && y.Equals(z))`を`true`返した`x.Equals(z)`場合`true`、はを返します。  
  
-   の連続し`x.Equals(y)`た呼び出しでは、および`y`によっ`x`て参照されるオブジェクトが変更されない限り、同じ値が返されます。  
  
-   `x.Equals(null)` は、`false` を返します。  
  
 の<xref:System.Object.Equals%2A>実装では、例外をスローすることはできません。常に値を返す必要があります。 たとえば、が`null`の`obj`場合、メソッド<xref:System.Object.Equals%2A>はをスロー `false` <xref:System.ArgumentNullException>するのではなく、を返す必要があります。  
  
 オーバーライド<xref:System.Object.Equals%28System.Object%29>する場合は、次のガイドラインに従ってください。  
  
-   を実装<xref:System.IComparable>する型は<xref:System.Object.Equals%28System.Object%29>、をオーバーライドする必要があります。  
  
-   オーバーライド<xref:System.Object.Equals%28System.Object%29>する型は、も<xref:System.Object.GetHashCode%2A>オーバーライドする必要があります。それ以外の場合、ハッシュテーブルが正しく機能しない可能性があります。  
  
-   厳密に型指定さ<xref:System.IEquatable%601>れたテストが等しいかどうかをサポートするには、インターフェイスを実装することを検討してください。 実装<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>では、と<xref:System.Object.Equals%2A>一致する結果を返す必要があります。  
  
-   プログラミング言語で演算子のオーバーロードがサポートされていて、特定の型の等値演算子をオーバーロード<xref:System.Object.Equals%28System.Object%29>する場合は、等値演算子と同じ結果を返すようにメソッドをオーバーライドする必要もあります。 これにより<xref:System.Object.Equals%2A> <xref:System.Collections.ArrayList> 、(や<xref:System.Collections.Hashtable>など) を使用するクラスライブラリコードが、アプリケーションコードで等値演算子が使用される方法と一貫性のある方法で動作するようになります。  
  
### <a name="guidelines-for-reference-types"></a>参照型のガイドライン  
 参照型のオーバーライド<xref:System.Object.Equals%28System.Object%29>には、次のガイドラインが適用されます。  
  
-   型の<xref:System.Object.Equals%2A>セマンティクスが、型がなんらかの値を表しているという事実に基づいているかどうかをオーバーライドすることを検討してください。  
  
-   ほとんどの参照型は、をオーバーライド<xref:System.Object.Equals%2A>する場合でも、等値演算子をオーバーロードすることはできません。 ただし、複素数型などの値のセマンティクスを持つ参照型を実装する場合は、等値演算子をオーバーライドする必要があります。  
  
-   変更可能な参照<xref:System.Object.Equals%2A>型ではオーバーライドしないでください。 これは、前<xref:System.Object.Equals%2A>のセクションで説明した<xref:System.Object.GetHashCode%2A>ように、をオーバーライドするには、メソッドもオーバーライドする必要があるためです。 これは、変更可能な参照型のインスタンスのハッシュコードがその有効期間中に変更される可能性があることを意味します。そのため、ハッシュテーブル内のオブジェクトが失われる可能性があります。  
  
### <a name="guidelines-for-value-types"></a>値型のガイドライン  
 値型のオーバーライド<xref:System.Object.Equals%28System.Object%29>には、次のガイドラインが適用されます。  
  
-   値が参照型である1つ以上のフィールドを含む値型を定義する場合は、を<xref:System.Object.Equals%28System.Object%29>オーバーライドする必要があります。 によっ <xref:System.ValueType> て提供される実装では、フィールドがすべての値型である値型のバイト単位の比較を実行しますが、リフレクションを使用して、参照型を含むフィールドを持つ値型のフィールドごとの比較を実行します。 <xref:System.Object.Equals%28System.Object%29>  
  
-   をオーバーライド<xref:System.Object.Equals%2A>し、開発言語で演算子のオーバーロードがサポートされている場合は、等値演算子をオーバーロードする必要があります。  
  
-   インターフェイスを<xref:System.IEquatable%601>実装する必要があります。 厳密に型指定<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>されたメソッド`obj`を呼び出すと、引数のボックス化が回避されます。  
  
   
  
## Examples  
 次の例は、 `Point` <xref:System.Object.Equals%2A>メソッドをオーバーライドして`Point3D`値の等価性を提供するクラスと、から`Point`派生したクラスを示しています。 は`Point`を<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>オーバーライドし <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> て値の等価性をテストするため、メソッドは呼び出されません。 ただし、 `Point3D.Equals`は、が<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>値の等価性を提供する方法でを実装するため`Point` 、を呼び出し`Point.Equals`ます。  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 メソッド`Point.Equals` **** は、引数が null でないこと、およびこのオブジェクトと同じ型のインスタンスを参照していることを確認します`obj` 。 いずれかのチェックが失敗した`false`場合、メソッドはを返します。  
  
 メソッドは、 <xref:System.Object.GetType%2A>メソッドを呼び出して、2つのオブジェクトの実行時の型が同一かどうかを確認します。 `Point.Equals` メソッドがC#または`TryCast(obj, Point)`の Visual Basic のフォーム`obj is Point`のチェックを使用した場合、 `obj`とで`true`は、 `obj`が派生クラス`Point`のインスタンスであっても、このチェックはを返します。現在のインスタンスの実行時の型が同じではありません。 両方のオブジェクトが同じ型であることを確認すると、 `obj`メソッドは`Point`を型にキャストし、2つのオブジェクトのインスタンスフィールドを比較した結果を返します。  
  
 で`Point3D.Equals`は、を`Point.Equals`オーバーライド<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>する継承されたメソッドが、他の処理が行われる前に呼び出されます。 は`Point3D` sealed クラス (`NotInheritable` Visual Basic) であるため、 `Point3D`がオブジェクトである`obj`ことをC#確認`TryCast(obj, Point)`するには、Visual Basic のまたはでフォーム`obj is Point`をチェックインすることをお勧めします。 オブジェクトの場合は、 `Point`オブジェクトにキャストされ、の基本クラスの<xref:System.Object.Equals%2A>実装に渡されます。 `Point3D` 継承`Point.Equals`されたメソッドが`true`を返す場合にのみ`z` 、メソッドは、派生クラスで導入されたインスタンスフィールドを比較します。  
  
 次の例では`Rectangle` 、四角形を2つ`Point`のオブジェクトとして内部で実装するクラスを定義しています。 クラス`Rectangle`は、値<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>の等価性を提供するようにもオーバーライドします。  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 や Visual Basic などのC#一部の言語では、演算子のオーバーロードがサポートされています。 型が等値演算子をオーバーロードする場合は、同じ機能<xref:System.Object.Equals%28System.Object%29>を提供するためにメソッドもオーバーライドする必要があります。 通常、これは、次の<xref:System.Object.Equals%28System.Object%29>例に示すように、オーバーロードされた等値演算子の観点からメソッドを記述することで実現されます。  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 は`Complex`値型であるため、から派生することはできません。  したがって、メソッドへ<xref:System.Object.Equals%28System.Object%29>のオーバーライドでは<xref:System.Object.GetType%2A> 、各オブジェクトの正確な実行時の型を判断するためにを呼び`is`出す必要C#はあり`TypeOf`ませんが、代わりにの演算子または Visual Basic の演算子を使用して、`obj`パラメーター。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">比較する最初のオブジェクト。</param>
        <param name="objB">比較する 2 番目のオブジェクト。</param>
        <summary>指定されたインスタンスが等しいかどうかを判断します。</summary>
        <returns>オブジェクトが等しいと見なされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 <paramref name="objA" /> と <paramref name="objB" /> の両方が **null** の場合、このメソッドは <see langword="true" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 静的<xref:System.Object.Equals%28System.Object%2CSystem.Object%29>メソッドは、 `objA`と`objB`の2つのオブジェクトが等しいかどうかを示します。 また、値が等しい場合に**null**を持つオブジェクトをテストすることもできます。 次の`objA`よう`objB`に、との等価性を比較します。  
  
-   2つのオブジェクトが同じオブジェクト参照を表しているかどうかを判断します。 指定されている場合、 `true`メソッドはを返します。 このテストは、 <xref:System.Object.ReferenceEquals%2A>メソッドを呼び出すことと同じです。 さらに`objA` 、と`objB`の両方が**null**の場合、メソッド`true`はを返します。  
  
-   `objA`または `objB` が**null**かどうかを判断します。 その場合は、を`false`返します。  
  
-   2つのオブジェクトが同じオブジェクト参照を表しておらず、どちらも**null**で`objA`ない`Equals`場合は、を呼び出します。(`objB`) とは、結果を返します。 これは、が`objA` <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッドをオーバーライドすると、このオーバーライドが呼び出されることを意味します。  
  
   
  
## Examples  
 次の例では<xref:System.Object.Equals%28System.Object%2CSystem.Object%29> 、メソッドを使用して<xref:System.Object.ReferenceEquals%2A>メソッドと比較しています。  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>オブジェクトが、ガベージ コレクションによって収集される前に、リソースの解放とその他のクリーンアップ操作の実行を試みることができるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.Finalize%2A>メソッドは、オブジェクトが破棄される前に、現在のオブジェクトによって保持されているアンマネージリソースに対してクリーンアップ操作を実行するために使用されます。 メソッドは保護されているため、このクラスまたは派生クラスを介してのみアクセスできます。  
  
 このセクションの内容:  
  
-   [終了処理のしくみ](#How)  
  
-   [実装に関する注意事項](#Notes)  
  
-   [SafeHandle 代替](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>終了処理のしくみ  
 クラス<xref:System.Object> <xref:System.Object.Finalize%2A>はメソッドの実装を提供しません。また、ガベージコレクターは、 <xref:System.Object.Finalize%2A>メソッドを<xref:System.Object>オーバーライドしない限り、から派生した型に、終了をマークしません。  
  
 型がメソッドを<xref:System.Object.Finalize%2A>オーバーライドする場合、ガベージコレクターは、その型の各インスタンスのエントリを、終了キューと呼ばれる内部構造体に追加します。 終了キューには、ガベージコレクターがメモリを再利用できるようにするために、終了コードを実行する必要があるマネージヒープ内のすべてのオブジェクトのエントリが含まれています。 次に、ガベージコレクターは<xref:System.Object.Finalize%2A> 、次の条件下でメソッドを自動的に呼び出します。  
  
-   オブジェクトがメソッドの<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>呼び出しによって終了から除外されていない限り、ガベージコレクターは、オブジェクトにアクセスできないことを検出しました。  
  
-   オブジェクトが終了処理から除外されている場合を除き、アプリケーションドメインのシャットダウン時に**のみ .NET Framework**。 シャットダウン中に、まだアクセス可能なオブジェクトであっても、終了します。  
  
 <xref:System.Object.Finalize%2A>は、特定のインスタンスで1回だけ自動的に呼び出されます。ただし、など<xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>の機構を使用してオブジェクトが再登録され、その後、メソッドが呼び出されていない場合は除きます。  
  
 <xref:System.Object.Finalize%2A>操作には次の制限があります。  
  
-   ファイナライザーが実行される正確な時間は未定義です。 クラスのインスタンスのリソースを確実に解放するには、メソッド`Close`を実装するか<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 、実装を提供します。  
  
-   2つのオブジェクトのファイナライザーは、一方のオブジェクトが他方を参照している場合でも、特定の順序で実行されることは保証されません。 つまり、オブジェクト A がオブジェクト B への参照を持ち、両方にファイナライザーがある場合、オブジェクト B は、オブジェクト A のファイナライザーが開始されたときに既に完了している可能性があります。  
  
-   ファイナライザーを実行するスレッドが指定されていません。  
  
 次<xref:System.Object.Finalize%2A>の例外的な状況下では、メソッドが完了しないか、まったく実行されない可能性があります。  
  
-   別のファイナライザーが無期限にブロックした場合 (無限ループに入る場合、は取得できないロックを取得しようとします)。 ランタイムはファイナライザーの実行を完了しようとするため、ファイナライザーが無期限にブロックした場合、他のファイナライザーが呼び出されないことがあります。  
  
-   ランタイムをクリーンアップする機会を与えずにプロセスを終了する場合は。 この場合、ランタイムのプロセス終了通知は、DLL_PROCESS_DETACH 通知です。  
  
 実行可能オブジェクトの数が減少し続けている間、シャットダウン中にも、ランタイムはオブジェクトの最終処理を継続します。  
  
 また<xref:System.Object.Finalize%2A>はの<xref:System.Object.Finalize%2A>オーバーライドによって例外がスローされ、ランタイムが既定のポリシーをオーバーライドするアプリケーションによってホストされていない場合`try` 、ランタイムはプロセスを終了し、アクティブな/ `finally`ブロックは終了しません。ファイナライザーが実行されます。 この動作により、ファイナライザーがリソースを解放または破棄できない場合に、プロセスの整合性が確保されます。  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Finalize メソッドのオーバーライド 
 ファイルハンドルや<xref:System.Object.Finalize%2A>データベース接続など、アンマネージリソースを使用するクラスをオーバーライドして、ガベージコレクション中にそれらを使用するマネージオブジェクトが破棄されるようにする必要があります。 マネージリソースは、 <xref:System.Object.Finalize%2A>ガベージコレクターによって自動的に解放されるので、マネージオブジェクトのメソッドを実装しないでください。  
  
> [!IMPORTANT]
>  アンマネージリソースをラップする<xref:System.Object.Finalize%2A>オブジェクトが使用可能な場合は、オーバーライドではなくセーフハンドルを使用して dispose パターンを実装することをお勧めします。 <xref:System.Runtime.InteropServices.SafeHandle> 詳細については、「 [SafeHandle の代替](#SafeHandle)」セクションを参照してください。  
  
 メソッド<xref:System.Object.Finalize%2A?displayProperty=nameWithType>は、既定では何も行いません<xref:System.Object.Finalize%2A>が、必要な場合にのみオーバーライドし、アンマネージリソースだけを解放する必要があります。 メモリの再利用は、終了操作を実行すると、少なくとも2つのガベージコレクションが必要になるため、かなり長くかかる傾向があります。 さらに、参照型に対し<xref:System.Object.Finalize%2A>てのみメソッドをオーバーライドする必要があります。 共通言語ランタイムは、参照型のみを終了します。 値型のファイナライザーは無視されます。  

<xref:System.Object.Finalize%2A?displayProperty=nameWithType>メソッドのスコープは`protected`です。 クラス内でこのメソッドをオーバーライドする場合は、このスコープの範囲を維持する必要があります。 メソッドを<xref:System.Object.Finalize%2A>保護することで、アプリケーションのユーザーがオブジェクトの<xref:System.Object.Finalize%2A>メソッドを直接呼び出すことを防ぐことができます。
  
 派生型の<xref:System.Object.Finalize%2A>のすべての実装は、の<xref:System.Object.Finalize%2A>基本型の実装を呼び出す必要があります。 これは、アプリケーションコードがを呼び出す<xref:System.Object.Finalize%2A>ことができる唯一のケースです。 オブジェクトの<xref:System.Object.Finalize%2A>メソッドは、基底クラスのオブジェクト以外のオブジェクトに対してメソッドを呼び出すことはできません。 これは、共通言語ランタイムがシャットダウンされる場合など、呼び出し元のオブジェクトと呼び出された別のオブジェクトが同時にガベージ コレクションされることがあるからです。 
  
> [!NOTE]
>  C#コンパイラでは、 <xref:System.Object.Finalize%2A>メソッドをオーバーライドすることはできません。 代わりに、クラスの[デストラクター](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)を実装することによってファイナライザーを提供します。 デストラクター C#は、基底クラスのデストラクターを自動的に呼び出します。  
>   
>  ビジュアルC++には、メソッドを<xref:System.Object.Finalize%2A>実装するための独自の構文も用意されています。 詳細については、「[方法: クラスと構造体を定義および使用する (C++/cli)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)」の「デストラクターとファイナライザー」を参照してください。  
  
 ガベージコレクションは非決定的であるため、ガベージコレクターが終了処理を実行するタイミングを正確に把握することはできません。 リソースをすぐに解放するには、 [dispose パターン](~/docs/standard/garbage-collection/implementing-dispose.md)と<xref:System.IDisposable>インターフェイスを実装することもできます。 実装<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>は、アンマネージリソースを解放するためにクラスのコンシューマーによって呼び出すことが<xref:System.Object.Finalize%2A>できます。メソッドが呼び出されない場合は<xref:System.IDisposable.Dispose%2A> 、メソッドを使用してアンマネージリソースを解放できます。  
  
 <xref:System.Object.Finalize%2A>は、ガベージコレクション中にクリーンアップされた後、オブジェクトの resurrecting (つまり、オブジェクトに再度アクセスできるようにする) など、ほぼすべてのアクションを実行できます。 ただし、オブジェクトを再生することはできません。<xref:System.Object.Finalize%2A>は、ガベージコレクション中に再生オブジェクトで呼び出すことはできません。
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>代替手段としての SafeHandle  
 アプリケーションの状態を想定することはできず、や<xref:System.OutOfMemoryException> <xref:System.StackOverflowException>などの未処理のシステム例外によってファイナライザーが終了するため、信頼性の高いファイナライザーを作成するのは難しいことがよくあります。 アンマネージリソースを解放するためにクラスのファイナライザーを実装する代わりに、 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>クラスから派生したオブジェクトを使用してアンマネージリソースをラップし、ファイナライザーを使用せずに dispose パターンを実装することができます。 .NET Framework には、から<xref:Microsoft.Win32?displayProperty=nameWithType> <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>派生した名前空間の次のクラスが用意されています。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>はファイルハンドルのラッパークラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>は、メモリマップトファイルハンドルのラッパークラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle>は、アンマネージメモリブロックへのポインターのラッパークラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>、 <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>、および<xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle>は、暗号化ハンドルのラッパークラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle>は、パイプハンドルのラッパークラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>は、レジストリキーへのハンドルのラッパークラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>は、待機ハンドルのラッパークラスです。  
  
 次の例では、メソッドを<xref:System.Object.Finalize%2A>オーバーライドする代わりに、セーフハンドルで[dispose パターン](~/docs/standard/garbage-collection/implementing-dispose.md)を使用します。 このクラスは`FileAssociation` 、特定のファイル拡張子を持つファイルを処理するアプリケーションに関するレジストリ情報をラップするクラスを定義します。 Windows regopenkeyex が関数呼び出しによっ`out`てパラメーターと[](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)して返される2つの<xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>レジストリハンドルは、コンストラクターに渡されます。 次に、型`Dispose`の protected メソッドは`SafeRegistryHandle.Dispose`メソッドを呼び出して、これらの2つのハンドルを解放します。  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 次の例では、 <xref:System.Object.Finalize%2A>をオーバーライド<xref:System.Object.Finalize%2A>するオブジェクトが破棄されたときに、メソッドが呼び出されることを確認します。 実稼働アプリケーションでは、オブジェクトに保持<xref:System.Object.Finalize%2A>されているアンマネージリソースを解放するためにメソッドがオーバーライドされることに注意してください。 また、このC#例では、メソッドを<xref:System.Object.Finalize%2A>オーバーライドするのではなく、デストラクターが提供されていることに注意してください。  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 <xref:System.Object.Finalize%2A>メソッドをオーバーライドするその他の例につい<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>ては、メソッドを参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>既定のハッシュ関数として機能します。</summary>
        <returns>現在のオブジェクトのハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハッシュコードは、クラス、 <xref:System.Collections.Generic.Dictionary%602> <xref:System.Collections.Hashtable>クラス、または<xref:System.Collections.DictionaryBase>クラスから派生した型など、ハッシュベースのコレクションにオブジェクトを挿入および識別するために使用される数値です。 メソッド<xref:System.Object.GetHashCode%2A>は、オブジェクトの等価性を簡単にチェックする必要があるアルゴリズムに対して、このハッシュコードを提供します。  
  
> [!NOTE]
>  ハッシュコードをハッシュテーブルで使用する方法と、追加のハッシュコードアルゴリズムの詳細については、Wikipedia の[Hash 関数](https://en.wikipedia.org/wiki/Hash_function)のエントリを参照してください。  
  
 等しい2つのオブジェクトが等しい場合は、そのハッシュコードが等しいことを示します。 ただし、逆は true ではありません。等値のハッシュコードでは、オブジェクトの等価性を意味しません。これは、異なる (等しくない) オブジェクトが同じハッシュコードを持つことができるためです。 さらに、.net では、 <xref:System.Object.GetHashCode%2A>メソッドの既定の実装は保証されません。また、このメソッドが返す値は、異なるバージョンの .NET Framework や .net Core などの .net 実装と、32ビットや64ビットプラットフォーム。 このような理由から、このメソッドの既定の実装をハッシュ用の一意のオブジェクト識別子として使用しないでください。 これには、次の2つの影響があります。  
  
-   等しいハッシュコードでは、オブジェクトの等価性を意味することを想定しないでください。  
  
-   同じオブジェクトがアプリケーションドメイン、プロセス、およびプラットフォーム間でハッシュされる可能性があるため、作成元のアプリケーションドメインの外部でハッシュコードを永続化したり、使用したりしないでください。  
  
> [!WARNING]
>  ハッシュコードは、ハッシュテーブルに基づくコレクション内での効率的な挿入と検索を目的としています。 ハッシュコードが永続的な値ではありません。 理由:  
>   
> -   ハッシュコード値をシリアル化したり、データベースに格納したりしないでください。  
> -   キーとしてハッシュコードを使用して、キー付きコレクションからオブジェクトを取得することは避けてください。  
> -   アプリケーションドメインまたはプロセス間でハッシュコードを送信しないでください。 場合によっては、プロセスごとまたはアプリケーションごとのドメインごとにハッシュコードを計算することがあります。  
> -   暗号ハッシュ関数によって返される値の代わりにハッシュコードを使用しないでください。暗号化に強力なハッシュが必要な場合に使用します。 暗号化ハッシュの場合<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType>は、クラスまたは<xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>クラスから派生したクラスを使用します。  
> -   2つのオブジェクトが等しいかどうかを判断するために、ハッシュコードが等しいかどうかをテストしないでください。 (等しくないオブジェクトは、同一のハッシュコードを持つことができます)。等しいかどう<xref:System.Object.ReferenceEquals%2A>かをテストするに<xref:System.Object.Equals%2A>は、メソッドまたはメソッドを呼び出します。  
  
 メソッド<xref:System.Object.GetHashCode%2A>は、派生型でオーバーライドできます。 が<xref:System.Object.GetHashCode%2A>オーバーライドされていない場合、参照型のハッシュコードは<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 、オブジェクトの参照に基づいてハッシュコードを計算する基底クラスのメソッドを呼び出すことによって<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>計算されます。詳細については、「」を参照してください。 言い換えると、メソッドが<xref:System.Object.ReferenceEquals%2A>返す`true` 2 つのオブジェクトのハッシュコードが同じであるということです。 値型がオーバーライド<xref:System.Object.GetHashCode%2A>されない場合、基本クラスのメソッドは<xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> 、リフレクションを使用して、型のフィールドの値に基づいてハッシュコードを計算します。 言い換えると、同じ値を持つフィールドを持つ値型には、同じハッシュコードが含まれます。 オーバーライド<xref:System.Object.GetHashCode%2A>の詳細については、「継承に関する注意事項」を参照してください。  
  
> [!WARNING]
>  <xref:System.Object.GetHashCode%2A>メソッドをオーバーライドする場合は、もオーバーライド<xref:System.Object.Equals%2A>する必要があります (その逆も同様)。 2つの<xref:System.Object.Equals%2A>オブジェクトが`true`等しいかどうかをテストするときに、 <xref:System.Object.GetHashCode%2A>オーバーライドされたメソッドがを返す場合、オーバーライドされたメソッドは2つのオブジェクトに対して同じ値を返す必要があります。  
  
 ハッシュテーブルのキーとして使用されているオブジェクトが、の<xref:System.Object.GetHashCode%2A>便利な実装を提供していない場合は、 <xref:System.Collections.Hashtable>クラスコンストラクターの<xref:System.Collections.IEqualityComparer>いずれかのオーバーロードに実装を指定することで、ハッシュコードプロバイダーを指定できます。  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>のメモ[!INCLUDE[wrt](~/includes/wrt-md.md)]  
 の<xref:System.Object.GetHashCode%2A> <xref:System.Object.GetHashCode%2A>クラスでメソッドを呼び出すと、オーバーライドされないクラスの既定の動作が提供されます。 [!INCLUDE[wrt](~/includes/wrt-md.md)] これは、 [!INCLUDE[wrt](~/includes/wrt-md.md)] .NET Framework がに提供するサポートの一部です (「 [Windows ストアアプリと Windows ランタイムの .NET Framework サポート](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)」を参照してください)。 のクラスは[!INCLUDE[wrt](~/includes/wrt-md.md)]継承<xref:System.Object>されず、現在はを<xref:System.Object.GetHashCode%2A>実装していません。 ただし、これらのメソッドを<xref:System.Object.ToString%2A> C#また<xref:System.Object.Equals%28System.Object%29>は Visual Basic <xref:System.Object.GetHashCode%2A>コードで使用する場合は、、、およびの各メソッドがあるように見えます。 .NET Framework は、これらのメソッドの既定の動作を提供します。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]または Visual Basic にC#記述されているクラス<xref:System.Object.GetHashCode%2A>は、メソッドをオーバーライドできます。  
  
   
  
## Examples  
 型と<xref:System.Int32>は異なる数値のハッシュコードを計算する最も簡単な方法の1つは、単にその値を返すことです。 次の例は、 `Number`構造体のこのような実装を示しています。  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 多くの場合、型にはハッシュコードの生成に参加できる複数のデータフィールドがあります。 ハッシュコードを生成する方法の1つは、次の例`XOR (eXclusive OR)`に示すように、操作を使用してこれらのフィールドを結合することです。  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 前の例では、(n1, n2) と (n2, n1) に対して同じハッシュコードが返されるため、望ましいよりも多くの衝突が発生する可能性があります。 これらのケースのハッシュコードが同一でないように、いくつかのソリューションを利用できます。 1つは、各フィールドの順序を`Tuple`反映するオブジェクトのハッシュコードを返すことです。 <xref:System.Tuple%602>クラスを使用する実装の例を次に示します。 ただし、 `Tuple`オブジェクトのインスタンス化のパフォーマンスオーバーヘッドが、ハッシュテーブルに多数のオブジェクトを格納するアプリケーションの全体的なパフォーマンスに大きな影響を与える可能性があることに注意してください。  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 2つ目の代替ソリューションでは、連続するフィールドのハッシュコードを2つ以上のビットで左にシフトすることで、個々のハッシュコードを重み付けします。 最適です。破棄するのではなく、ビット31を超えてシフトされたビットは、破棄されるのではなく、ラップする必要があります。 ビットは Visual Basic との両方C#の左シフト演算子によって破棄されるため、次のような左シフトアンドラップメソッドを作成する必要があります。  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 次の例では、この shift キーと wrap メソッドを使用して、前の`Point`例で使用した構造体のハッシュコードを計算します。  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>ハッシュ関数は、オブジェクトの値に対応する数値 (ハッシュコード) をすばやく生成するために使用されます。 通常、ハッシュ関数はそれぞれの型に固有であり、一意性を確保するには、少なくとも1つのインスタンスフィールドを入力として使用する必要があります。 ハッシュコードは、静的フィールドの値を使用して計算することはできません。  
  
から<see cref="T:System.Object" />派生したクラスの<see langword="GetHashCode" />場合、メソッドは、派生クラス<see cref="M:System.Object.GetHashCode" />が参照の等価性を定義する場合にのみ、基底クラスの実装にデリゲートできます。 参照型のの<see cref="M:System.Object.GetHashCode" />既定の実装では、 <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />メソッドによって返されるハッシュコードに相当するハッシュコードが返されます。 変更できない<see cref="M:System.Object.GetHashCode" />参照型については、をオーバーライドできます。 一般に、変更可能な参照型の場合は<see cref="M:System.Object.GetHashCode" /> 、次の場合にのみをオーバーライドする必要があります。 
-変更できないフィールドからハッシュコードを計算できます。もしくは 
-ハッシュコードに依存するコレクションにオブジェクトが含まれている間は、変更可能なオブジェクトのハッシュコードが変更されないようにすることができます。  
  
それ以外の場合は、変更可能なオブジェクトがハッシュテーブルで失われると考えられます。 変更可能な参照型を<see cref="M:System.Object.GetHashCode" />オーバーライドすることを選択した場合、ドキュメントでは、オブジェクトがハッシュテーブルに格納されている間、型のユーザーがオブジェクトの値を変更しないようにする必要があります。  
  
値型の場合<see cref="M:System.ValueType.GetHashCode" /> 、には、リフレクションを使用する既定のハッシュコードの実装が用意されています。 パフォーマンスを向上させるためにオーバーライドすることを検討してください。  
  
 <block subset="none" type="note"><para>  
 さまざまな方法でハッシュコードを計算する詳細と例については、「例」を参照してください。  
  
</para></block>  
  
 ハッシュ関数には、次のプロパティが必要です。 
-2 つのオブジェクトが等しいかどう<see cref="M:System.Object.GetHashCode" />かを比較する場合、各オブジェクトのメソッドは同じ値を返す必要があります。 ただし、2つのオブジェクトが等しいかどうかを<see cref="M:System.Object.GetHashCode" />比較しない場合、2つのオブジェクトのメソッドは異なる値を返す必要はありません。  
  
-オブジェクト<see cref="M:System.Object.GetHashCode" />のメソッドは、オブジェクトの system.object メソッドの戻り値を決定する[オブジェクトの状態](xref:System.Object.Equals*)に変更がない限り、常に同じハッシュコードを返す必要があります。 これはアプリケーションの現在の実行に対してのみ true であり、アプリケーションが再実行されると別のハッシュコードが返される可能性があることに注意してください。  
  
-最適なパフォーマンスを得るために、ハッシュ関数では、大量の入力 (大量のクラスター化された入力を含む) に対して均等な分布を生成する必要があります。 暗黙的には、オブジェクトの状態を変更すると、ハッシュテーブルのパフォーマンスが最適になるように、結果のハッシュコードが大幅に変更されることになります。  
  
-ハッシュ関数は、コンピューティングのコストを安くする必要があります。  
  
-メソッド<see cref="M:System.Object.GetHashCode" />は例外をスローしません。  
  
たとえば、 <see cref="T:System.String" />クラスによって提供<see cref="M:System.String.GetHashCode" />されるメソッドの実装は、同一の文字列値に対して同一のハッシュコードを返します。 したがって、 <see cref="T:System.String" /> 2 つのオブジェクトが同じ文字列値を表す場合は、同じハッシュコードを返します。 また、入力が特定の範囲内でクラスター化されている場合でも、メソッドは文字列内のすべての文字を使用して、適度にランダムに分散された出力を生成します。たとえば、多くのユーザーは、128の ASCII 文字のみを含む文字列を持つこともできます。文字列には、65535の Unicode 文字を含めることができます。  
  
クラスに適切なハッシュ関数を指定すると、それらのオブジェクトをハッシュテーブルに追加するときのパフォーマンスに大きく影響することがあります。 ハッシュ関数の適切な実装を提供するキーを持つハッシュテーブルでは、要素の検索には一定の時間がかかります (O (1) 操作など)。 ハッシュ関数が実装されていないハッシュテーブルでは、検索のパフォーマンスはハッシュテーブル内の項目の数によって異なります (たとえば、O (`n`) 操作など) `n` 。ここで、はハッシュテーブル内の項目の数です)。 悪意のあるユーザーがデータを入力すると、衝突の数が増えるため、次のような状況下で、ハッシュテーブルに依存するアプリケーションのパフォーマンスが大幅に低下する可能性があります。 
-ハッシュ関数が頻繁に衝突を生成する場合。  
  
-ハッシュテーブル内のオブジェクトの大部分が、互いに等しいまたはほぼ等しいハッシュコードを生成する場合。  
  
-ハッシュコードの計算元のデータをユーザーが入力した場合。  
  
をオーバーライド<see cref="M:System.Object.GetHashCode" />する派生クラスは、 <see cref="M:System.Object.Equals(System.Object)" />同じであると見なされる2つのオブジェクトが同じハッシュ<see cref="T:System.Collections.Hashtable" />コードを持つことを保証するためにもオーバーライドする必要があります。そうしないと、型が正しく機能しない可能性があります。</para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスの <see cref="T:System.Type" /> を取得します。</summary>
        <returns>現在のインスタンスの正確なランタイム型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 は<xref:System.Object?displayProperty=nameWithType> .net 型システムのすべての型の基底クラスであるため<xref:System.Object.GetType%2A> 、メソッドを使用して、 <xref:System.Type>すべての .net 型を表すオブジェクトを返すことができます。 .NET では、次の5種類のカテゴリが認識されます。  
  
-   クラスは、から<xref:System.Object?displayProperty=nameWithType>派生したものです。  
  
-   値型。から<xref:System.ValueType?displayProperty=nameWithType>派生します。  
  
-   .NET Framework 2.0 で始まるから<xref:System.Object?displayProperty=nameWithType>派生したインターフェイス。  
  
-   列挙型。から<xref:System.Enum?displayProperty=nameWithType>派生します。  
  
-   デリゲートは、から<xref:System.MulticastDelegate?displayProperty=nameWithType>派生します。  
  
 2つの`x`オブジェクト`y`のランタイム型が同一`Object.ReferenceEquals(x.GetType(),y.GetType())`で`true`ある場合、はを返します。 次の例では<xref:System.Object.GetType%2A> 、メソッドを<xref:System.Object.ReferenceEquals%2A>メソッドと共に使用して、1つの数値が他の2つの数値と同じ型であるかどうかを確認します。  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  オブジェクトが特定の型であるかどうかを判断するには、言語の型比較キーワードまたはコンストラクトを使用できます。 たとえば、Visual Basic `is`またはのキーワード`TypeOf…Is`で構成体を使用できC#ます。  
  
 メソッド<xref:System.Object.GetType%2A>は、から<xref:System.Object>派生するすべての型によって継承されます。 つまり、次の例に示すように、独自の言語の比較キーワードを使用する<xref:System.Object.GetType%2A>だけでなく、メソッドを使用して特定のオブジェクトの型を特定することもできます。  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 オブジェクト<xref:System.Type>は、現在<xref:System.Object>ののクラスに関連付けられているメタデータを公開します。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Object.GetType%2A>が現在のインスタンスのランタイム型を返すことを示しています。  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Object" /> の簡易コピーを作成します。</summary>
        <returns>現在の <see cref="T:System.Object" /> の簡易コピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Object.MemberwiseClone%2A>は、新しいオブジェクトを作成し、現在のオブジェクトの非静的フィールドを新しいオブジェクトにコピーすることによって、簡易コピーを作成します。 フィールドが値型の場合は、フィールドのビットごとのコピーが実行されます。 フィールドが参照型の場合、参照はコピーされますが、参照先のオブジェクトはコピーされません。したがって、元のオブジェクトとその複製は、同じオブジェクトを参照します。  
  
 たとえば、オブジェクト A と B を参照する X と呼ばれるオブジェクトについて考えてみます。オブジェクト B がオブジェクト C を参照しているとします。X の簡易コピーでは、オブジェクト A と B も参照する新しいオブジェクト X2 が作成されます。これに対し、X の詳細コピーでは新しいオブジェクト X2 が作成されます。これは、A と B のコピーである A2 と B2 の新しいオブジェクトを参照します。 B2 は、C のコピーである新しいオブジェクト C2 を参照します。この例では、簡易コピー操作と詳細コピー操作の違いについて説明します。  
  
 <xref:System.Object.MemberwiseClone%2A>メソッドによって実行されるシャローコピー操作がニーズを満たさない場合、詳細コピー操作を実装する方法は多数あります。 次に例を示します。  
  
-   コピーするオブジェクトのクラスコンストラクターを呼び出して、最初のオブジェクトから取得したプロパティ値を持つ2番目のオブジェクトを作成します。 これは、オブジェクトの値がクラスコンストラクターによって完全に定義されていることを前提としています。  
  
-   <xref:System.Object.MemberwiseClone%2A>メソッドを呼び出してオブジェクトの簡易コピーを作成し、元のオブジェクトと同じ値を持つ新しいオブジェクトを、値が参照型であるプロパティまたはフィールドに割り当てます。 この`DeepCopy`例のメソッドは、この方法を示しています。  
  
-   詳細にコピーされるようにオブジェクトをシリアル化し、シリアル化されたデータを別のオブジェクト変数に復元します。  
  
-   詳細コピー操作を実行するには、再帰と共にリフレクションを使用します。  
  
   
  
## Examples  
 次の例は、 <xref:System.Object.MemberwiseClone%2A>メソッドを示しています。 これは、 `ShallowCopy` `Person`オブジェクトに対して<xref:System.Object.MemberwiseClone%2A>簡易コピー操作を実行するメソッドを呼び出すメソッドを定義します。 また、 `Person`オブジェクトに`DeepCopy`対して詳細コピー操作を実行するメソッドを定義します。  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 この例では、 `Person.IdInfo`プロパティは`IdInfo`オブジェクトを返します。 この例の出力に`Person`示すように、 <xref:System.Object.MemberwiseClone%2A>メソッドを呼び出してオブジェクトを複製すると、複製`Person`されたオブジェクトは元のオブジェクトの独立したコピーになります`Person.IdInfo` 。ただし、同じオブジェクト参照を共有する点が異なります。 その結果、複製の`Person.IdInfo`プロパティを変更すると、元のオブジェクトの`Person.IdInfo`プロパティが変更されます。 一方、詳細コピー操作が実行された場合、複製`Person`されたオブジェクト ( `Person.IdInfo`プロパティを含む) は、元のオブジェクトに影響を与えることなく変更できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">比較する最初のオブジェクト。</param>
        <param name="objB">比較する 2 番目のオブジェクト。</param>
        <summary>指定した複数の <see cref="T:System.Object" /> インスタンスが同一インスタンスかどうかを判断します。</summary>
        <returns><paramref name="objA" /> が <paramref name="objB" /> と同一のインスタンスである場合、または両方のインスタンスが **null** の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドと等値演算子とは異なり<xref:System.Object.ReferenceEquals%2A> 、メソッドをオーバーライドすることはできません。 <xref:System.Object.Equals%2A> このため、2つのオブジェクト参照が等しいかどうかをテストし、 `Equals`メソッドの実装がわからない場合は、 <xref:System.Object.ReferenceEquals%2A>メソッドを呼び出すことができます。  
  
 ただし、次の2つの<xref:System.Object.ReferenceEquals%2A>シナリオでは、メソッドの戻り値が異常であるように見えることがあります。  
  
-   値型を比較する場合。 <xref:System.Object.ReferenceEquals%2A>と`objA` が値型の場合、メソッドに渡される前にボックス化されます。 `objB` `objA`これは、と`objB`の両方が値型の同じインスタンスを表している場合、次`false`の例に示すように、メソッドは<xref:System.Object.ReferenceEquals%2A>を返します。  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     値型のボックス化の詳細については、「[ボックス化とボックス化解除](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)」を参照してください。  
  
-   文字列を比較する場合。 と`objA` <xref:System.Object.ReferenceEquals%2A> `true`が文字列の場合、文字列がインターンプールされている場合、メソッドはを返します。 `objB` 値が等しいかどうかのテストは実行されません。  次の例では`s1` 、 `s2`とが等しいのは、1つのインターン文字列の2つのインスタンスであるためです。 ただし、 `s4`とは等しくありません。これは、同じ文字列値があるにもかかわらず、その文字列がインターンプールされないためです。 `s3`  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     文字列インターンの詳細については<xref:System.String.IsInterned%2A?displayProperty=nameWithType>、「」を参照してください。  
  
   
  
## Examples  
 次の例で<xref:System.Object.ReferenceEquals%2A>は、を使用して、2つのオブジェクトが同じインスタンスであるかどうかを確認します。  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のオブジェクトを表す文字列を返します。</summary>
        <returns>現在のオブジェクトを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType>は、.NET Framework の主要な書式設定メソッドです。 オブジェクトを文字列形式に変換して、表示に適した状態にします。 (.NET Framework での書式設定のサポートについては、「[型の書式設定](~/docs/standard/base-types/formatting-types.md)」を参照してください)。<xref:System.Object.ToString%2A?displayProperty=nameWithType>メソッドの既定の実装では、オブジェクトの型の完全修飾名が返されます。  
  
> [!IMPORTANT]
>  別の種類のメンバーリストからのリンクに従って、このページに到達した可能性があります。 これは、その型がをオーバーライド<xref:System.Object.ToString%2A?displayProperty=nameWithType>しないためです。 代わりに、 <xref:System.Object.ToString%2A?displayProperty=nameWithType>メソッドの機能を継承します。  
  
 型は、特定<xref:System.Object.ToString%2A?displayProperty=nameWithType>の型のより適切な文字列表現を提供するために、メソッドを頻繁にオーバーライドします。 また、型は、 <xref:System.Object.ToString%2A?displayProperty=nameWithType>書式指定文字列またはカルチャに依存した書式設定をサポートするために、メソッドをオーバーロードすることもよくあります。  
  
 このセクションの内容:  
  
 [既定のオブジェクトの ToString () メソッド](#Default)   
 [オブジェクトのオーバーライド () メソッド](#Overriding)   
 [ToString メソッドのオーバーロード](#Overloading)   
 [オブジェクトの ToString メソッドの拡張](#Extending)   
 [Windows ランタイムのメモ](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>既定のオブジェクトの ToString () メソッド  
 次の例に示す<xref:System.Object.ToString%2A>ように、メソッドの既定の実装では、 <xref:System.Object>の型の完全修飾名が返されます。  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 は<xref:System.Object> .NET Framework 内のすべての参照型の基底クラスであるため、この動作は、 <xref:System.Object.ToString%2A>メソッドをオーバーライドしない参照型によって継承されます。 次に例を示します。 これは、すべて`Object1` <xref:System.Object>のメンバーの既定の実装を受け入れるという名前のクラスを定義します。 この<xref:System.Object.ToString%2A>メソッドは、オブジェクトの完全修飾型名を返します。  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>オブジェクトのオーバーライド () メソッド  
 型は、通常<xref:System.Object.ToString%2A?displayProperty=nameWithType> 、メソッドをオーバーライドして、オブジェクトインスタンスを表す文字列を返します。 たとえば<xref:System.Char>、、 <xref:System.Int32>、 <xref:System.Object.ToString%2A>などの基本型は、オブジェクトが表す値の文字列形式を返す実装を提供します。 <xref:System.String> 次の例では、クラス`Object2`を定義します<xref:System.Object.ToString%2A> 。このクラスは、メソッドをオーバーライドして、型名とその値を返します。  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 次の表に、.net の型カテゴリの一覧を示し、メソッドを<xref:System.Object.ToString%2A?displayProperty=nameWithType>オーバーライドするかどうかを示します。  
  
|型のカテゴリ|Object. ToString () をオーバーライドします。|動作|  
|-------------------|-----------------------------------|--------------|  
|クラス|N/A|N/A|  
|構造体|はい (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|`Object.ToString()` と同じ|  
|列挙|はい (<xref:System.Enum.ToString?displayProperty=nameWithType>)|メンバー名|  
|Interface|いいえ|N/A|  
|Delegate|いいえ|N/A|  
  
 オーバーライド<xref:System.Object.ToString%2A>の詳細については、「継承に関する注意事項」を参照してください。  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>ToString メソッドのオーバーロード  
 パラメーターを受け取らないメソッドを<xref:System.Object.ToString?displayProperty=nameWithType>オーバーライドするだけでなく、 `ToString`多くの型はメソッドをオーバーロードして、パラメーターを受け取るメソッドのバージョンを提供します。 ほとんどの場合、これは変数の書式設定とカルチャに依存した書式設定のサポートを提供するために行われます。  
  
 次の例では`ToString` 、メソッドをオーバーロードして、 `Automobile`クラスのさまざまなフィールドの値を含む結果の文字列を返します。 4つの書式指定文字列を定義します。 G は、モデル名と年を返します。D: モデル名、年、およびドアの数を返します。C: モデル名、年、およびシリンダーの数を返します。とは、4つのフィールド値すべてを含む文字列を返します。  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 次の例では、 <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>オーバーロードされたメソッドを呼び出して、通貨値のカルチャに依存した書式設定を表示します。  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 書式指定文字列とカルチャに依存した書式設定の詳細については、「[型の書式設定](~/docs/standard/base-types/formatting-types.md)」を参照してください。 数値でサポートされる書式指定文字列については、「[標準の数値書式指定](~/docs/standard/base-types/standard-numeric-format-strings.md)文字列」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。 日付と時刻の値でサポートされる書式指定文字列については、「[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)」および「[カスタム日時書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)」を参照してください。  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>オブジェクトの ToString メソッドの拡張  
 型は既定<xref:System.Object.ToString%2A?displayProperty=nameWithType>のメソッドを継承するため、その動作が望ましくなく、変更される可能性があります。 これは、配列とコレクションクラスに特に当てはまります。 配列またはコレクションクラス`ToString`のメソッドは、そのメンバーの値を表示することを期待する場合がありますが、次の例に示すように、型の完全修飾型名を表示します。  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 結果の文字列を生成するには、いくつかのオプションがあります。  
  
-   型が配列<xref:System.Collections.IEnumerable> 、コレクションオブジェクト、またはインターフェイスまたは<xref:System.Collections.Generic.IEnumerable%601>インターフェイスを実装するオブジェクトである場合は、の`foreach` C#ステートメントまた`For Each...Next`は Visual Basic 内の構造体を使用して、その要素を列挙できます。  
  
-   `sealed`クラスが (でC#は) または`NotInheritable` (Visual Basic) でない場合は、カスタマイズするメソッドを持つ<xref:System.Object.ToString%2A?displayProperty=nameWithType>基底クラスから継承するラッパークラスを開発できます。 少なくとも、次の操作を行う必要があります。  
  
    1.  必要なコンストラクターを実装します。 派生クラスは、基底クラスのコンストラクターを継承しません。  
  
    2.  <xref:System.Object.ToString%2A?displayProperty=nameWithType>メソッドをオーバーライドして、必要な結果文字列を返します。  
  
     次の例では、 <xref:System.Collections.Generic.List%601>クラスのラッパークラスを定義します。 メソッドを<xref:System.Object.ToString%2A?displayProperty=nameWithType>オーバーライドして、完全修飾型名ではなく、コレクションの各メソッドの値を表示します。  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   必要な結果文字列を返す[拡張メソッド](~/docs/standard/design-guidelines/extension-methods.md)を開発します。 この方法では既定<xref:System.Object.ToString%2A?displayProperty=nameWithType>のメソッドをオーバーライドできないことに注意してください (つまり、拡張クラス (内C#) またはモジュール (Visual Basic) は、 `ToString`元の型 `ToString` の代わりに呼び出されるという名前のパラメーターなしのメソッドを持つことはできません。メソッド。 パラメーターなし`ToString`の置換には、他の名前を指定する必要があります。  
  
     次の<xref:System.Collections.Generic.List%601>例では、クラスを拡張する2つのメソッドを定義しています。 <xref:System.String>パラメーターなし`ToString2`のメソッドと`ToString` 、書式指定文字列を表すパラメーターを持つメソッドです。  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>のメモ[!INCLUDE[wrt](~/includes/wrt-md.md)]  
 の<xref:System.Object.ToString%2A> <xref:System.Object.ToString%2A>クラスでメソッドを呼び出すと、オーバーライドされないクラスの既定の動作が提供されます。 [!INCLUDE[wrt](~/includes/wrt-md.md)] これは、 [!INCLUDE[wrt](~/includes/wrt-md.md)] .NET Framework がに提供するサポートの一部です (「 [Windows ストアアプリと Windows ランタイムの .NET Framework サポート](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)」を参照してください)。 のクラスは[!INCLUDE[wrt](~/includes/wrt-md.md)]を継承<xref:System.Object>せず、常にを<xref:System.Object.ToString%2A>実装することはありません。 ただし、これらの<xref:System.Object.ToString%2A>メソッドをC#または<xref:System.Object.Equals%28System.Object%29>Visual Basic コード<xref:System.Object.GetHashCode%2A>で使用する場合、これらのメソッドは常に、、、およびの各メソッドを持っているように見え、.NET Framework はこれらのメソッドの既定の動作を提供します。  
  
 以降では、共通言語ランタイムは、の既定の<xref:System.Object.ToString%2A?displayProperty=nameWithType>実装に戻る前に[!INCLUDE[wrt](~/includes/wrt-md.md)] 、オブジェクトに対して[istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)を使用します。 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]または Visual Basic にC#記述されているクラス<xref:System.Object.ToString%2A>は、メソッドをオーバーライドできます。  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)]と istringable インターフェイス  
 [!INCLUDE[wrt](~/includes/wrt-md.md)] <xref:System.Object.ToString%2A?displayProperty=nameWithType>以降では、に istringable インターフェイスが含まれています。これは、1つのメソッドである[istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)が、によって提供される基本的な書式設定をサポートしています。 [](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) [!INCLUDE[win81](~/includes/win81-md.md)] あいまいさを防ぐには、マネージ型に[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装しないでください。  
  
 マネージオブジェクトがネイティブコードまたは JavaScript やC++/cx などの言語で記述されたコードによって呼び出されると、 [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装するように見えます。 共通言語ランタイムは、istringable からの呼び出しを、マネージオブジェクト<xref:System.Object.ToString%2A?displayProperty=nameWithType>に実装されてい[ないイベントの](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)に自動的にルーティングします。 [](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)  
  
> [!WARNING]
>  共通言語ランタイムは、アプリ内[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]のすべてのマネージ型に対して[istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を自動的に実装するため、独自の[istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)実装を提供しないことをお勧めします。 [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装すると`ToString` [!INCLUDE[wrt](~/includes/wrt-md.md)]、、/cx、または JavaScript C++からを呼び出すときに意図しない動作が発生する可能性があります。  
  
 [!INCLUDE[wrt](~/includes/wrt-md.md)]コンポーネントでエクスポートされたパブリックマネージ型に[istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装する場合は、次の制限が適用されます。  
  
-   [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)インターフェイスは、"クラスが実装する" 関係でのみ定義できます。  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     C# では、上記のようになります。  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     Visual Basic では、上記のようになります。  
  
-   インターフェイスに[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装することはできません。  
  
-   パラメーターの型を[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)として宣言することはできません。  
  
-   [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)は、メソッド、プロパティ、またはフィールドの戻り値の型にすることはできません。  
  
-   次のようなメソッド定義を使用して、 [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)の実装を基底クラスから隠すことはできません。  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     代わりに、 [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)の実装では、常に基底クラスの実装をオーバーライドする必要があります。 `ToString` の実装を隠すことができるのは、厳密に型指定されたクラス インスタンスで呼び出す場合だけです。  
  
 さまざまな条件下では、 [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を実装するマネージ型、または[ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)実装を隠すマネージ型にネイティブコードから呼び出すと、予期しない動作が発生する可能性があることに注意してください。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>独自の型を実装する場合は、 <see cref="M:System.Object.ToString" />メソッドをオーバーライドして、これらの型に対して意味のある値を返す必要があります。 の書式設定<see cref="M:System.Object.ToString" />をより詳細に制御する必要がある派生<see cref="T:System.IFormattable" />クラスは、インターフェイスを実装できます。 このメソッドを使用すると、書式設定を制御する書式指定文字列<see cref="T:System.IFormatProvider" />を定義したり、カルチャ固有の書式設定用に提供できるオブジェクトを使用したりすることができます。 <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" />  
  
メソッドのオーバーライド<see cref="M:System.Object.ToString" />は、次のガイドラインに従う必要があります。 
-返される文字列は、わかりやすく、人間が判読できるものにする必要があります。  
  
-返される文字列は、オブジェクトインスタンスの値を一意に識別する必要があります。  
  
-返される文字列は、デバッガーによる表示に適しているように、可能な限り短くする必要があります。  
  
-オーバーライドでは、また<see cref="F:System.String.Empty" />は null 文字列を返すことはできません。 <see cref="M:System.Object.ToString" />  
  
<see cref="M:System.Object.ToString" /> -オーバーライドで例外をスローすることはできません。  
  
-インスタンスの文字列表現がカルチャに依存しているか、複数の方法で書式設定できる場合<see cref="T:System.IFormattable" />は、インターフェイスを実装します。  
  
-返された文字列に機密情報が含まれている場合は、まず適切なアクセス許可を要求する必要があります。 要求が成功した場合は、機密情報を返すことができます。それ以外の場合は、機密情報を除外する文字列を返す必要があります。  
  
-オーバーライド<see cref="M:System.Object.ToString" />には、デバッグの複雑さを回避するための、監視可能な副作用はありません。 たとえば、メソッドの<see cref="M:System.Object.ToString" />呼び出しでインスタンスフィールドの値を変更することはできません。  
  
-型が解析メソッド ( <see langword="Parse" /> <see langword="TryParse" />またはメソッド、コンストラクター、または文字列から型のインスタンスをインスタンス化するその他の静的メソッド) を実装している場合は、 <see cref="M:System.Object.ToString" />メソッドによって返される文字列をオブジェクトインスタンスに変換されます。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
      </Docs>
    </Member>
  </Members>
</Type>
