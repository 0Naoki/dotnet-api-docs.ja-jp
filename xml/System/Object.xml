<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="20858d8f3a77386f2e8091f66a99f0a104d2e86b" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39766560" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>.NET Framework クラス階層のすべてのクラスをサポートし、派生クラスに下位レベルのサービスを提供します。 これは、.NET Framework の全クラスの基本クラスであり、型階層のルートです。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常の言語は、クラスからの継承を宣言する必要ありません<xref:System.Object>継承は暗黙的なためです。  
  
 .NET Framework のすべてのクラスから派生しているため<xref:System.Object>で定義されているすべてのメソッド、<xref:System.Object>クラスは、システム内のすべてのオブジェクトで使用できます。 派生クラスと、これらのメソッドの一部をオーバーライドしないでください。  
  
-   <xref:System.Object.Equals%2A> -オブジェクト間の比較をサポートしています。  
  
-   <xref:System.Object.Finalize%2A> -オブジェクトが自動的にクリアされる前に、クリーンアップ操作を実行します。  
  
-   <xref:System.Object.GetHashCode%2A> -ハッシュ テーブルの使用をサポートするために、オブジェクトの値に対応する番号を生成します。  
  
-   <xref:System.Object.ToString%2A> -クラスのインスタンスを記述する人間が判読できるテキスト文字列を製造しています。  
  
## <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 インスタンスを受け取るクラスのメンバーを作成するには、どの型のオブジェクトを処理する必要があります、コレクションなどのクラスを設計する場合、<xref:System.Object>クラス。 ただし、ボックス化と型をボックス化解除のプロセスは、パフォーマンス コストを実行します。 新しいクラスの特定の値型を頻繁に処理することがわかっている場合は、ボックス化のコストを最小限に 2 つの方針のいずれかを使用できます。  
  
-   受け取る一般的なメソッドを作成、<xref:System.Object>型、および一連の頻繁に処理するクラスを期待する各値の型をそのまま使用する型固有のメソッド オーバー ロードします。 呼び出し元のパラメーター型を受け取る型固有のメソッドが存在する場合は、ボックス化は発生せず、型固有のメソッドが呼び出されます。 呼び出し元のパラメーター型と一致するメソッドの引数がない場合は、パラメーターがボックス化され、一般的なメソッドが呼び出されます。  
  
-   ジェネリックを使用するには、型とそのメンバーをデザインします。 共通言語ランタイムは、クラスのインスタンスを作成し、ジェネリック型引数を指定するときに、クローズ ジェネリック型を作成します。 ジェネリック メソッドの種類に固有であり、呼び出し元のパラメーターをボックス化せずに呼び出すことができます。  
  
 受け入れて返す汎用クラスの開発に必要な場合がありますが<xref:System.Object>型も型固有のクラスが頻繁に使用される型を処理するために提供することでパフォーマンスを向上できます。 たとえば、固有の設定とブール値を取得するクラスを提供するブール値のボックス化とボックス化解除のコストを排除します。  
  
   
  
## Examples  
 次の例から派生したポイントの種類の定義、<xref:System.Object>クラスし、多くの仮想メソッドのオーバーライド、<xref:System.Object>クラス。 さらに、例は、静的なの多くを呼び出す方法を示しています。 インスタンスのメソッドと、<xref:System.Object>クラス。  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>パブリック静的 (<see langword="Shared" /> Visual Basic で) この型のメンバーはスレッド セーフです。 インスタンス メンバーには、スレッド セーフであるとは限りません。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Object" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターは派生クラスでコンス トラクターによって呼び出されますが、直接のインスタンスを作成する使用することも、<xref:System.Object>クラス。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>2 つのオブジェクトのインスタンスが等しいかどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">現在のオブジェクトと比較するオブジェクト。</param>
        <summary>指定のオブジェクトが現在のオブジェクトと等しいかどうかを判断します。</summary>
        <returns>指定したオブジェクトが現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在のインスタンス間の比較の種類と`obj`パラメーターは、現在のインスタンスは、参照型または値型かどうかによって異なります。  
  
-   現在のインスタンスが、参照型の場合、<xref:System.Object.Equals%28System.Object%29>参照の等価性のテストのメソッドと呼び出しを<xref:System.Object.Equals%28System.Object%29>メソッドへの呼び出しには、<xref:System.Object.ReferenceEquals%2A>メソッド。 参照の等価性と比較されるオブジェクト変数が同じオブジェクトを参照していることを意味します。 次の例は、このような比較の結果を示しています。 定義、`Person`参照型である、クラスと呼び出し、`Person`新しい 2 つがインスタンス化するクラスのコンス トラクター`Person`オブジェクト、`person1a`と`person2`値が同じであります。 割り当てます`person1a`別のオブジェクト変数に`person1b`します。 例を示しますから出力として`person1a`と`person1b`が同じオブジェクトを参照するために等しい。 ただし、`person1a`と`person2`が、同じ値が等しいか、ありません。  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   現在のインスタンスが値の型の場合、<xref:System.Object.Equals%28System.Object%29>メソッドの値の等価性を調べます。 値の等価性には、次のことを意味します。  
  
    -   2 つのオブジェクトでは、同じ型です。 次の例に示すように、 <xref:System.Byte> 12 の値を持つオブジェクトが等しくない、<xref:System.Int32>を 2 つのオブジェクトがある実行時の型が異なるため、12 の値を持つオブジェクト。  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   2 つのオブジェクトのパブリックおよびプライベート フィールドの値が等しいです。 次の例は、値の等価性をテストします。 定義、`Person`構造体、値型であると呼び出し、`Person`新しい 2 つがインスタンス化するクラスのコンス トラクター`Person`オブジェクト、`person1`と`person2`値が同じであります。 別のオブジェクトを参照してください、2 つのオブジェクト変数が、例の出力に示すよう`person1`と`person2`がプライベートの同じ値があるために等しい`personName`フィールド。  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 <xref:System.Object>クラスは、.NET Framework のすべての型の基本クラス、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッドは、他のすべての種類の既定の等値比較を提供します。 型が多くの場合、オーバーライド、ただし、<xref:System.Object.Equals%2A>値の等価性を実装するメソッド。 詳細については、ノートを呼び出し元とノート セクションでは継承クラスの参照します。  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>ノートには、 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 呼び出すと、<xref:System.Object.Equals%28System.Object%29>内のクラスのメソッドのオーバー ロード、 [!INCLUDE[wrt](~/includes/wrt-md.md)]、既定の動作をオーバーライドしないクラスを提供します<xref:System.Object.Equals%28System.Object%29>します。 これは、.NET Framework では、サポートの一部、 [!INCLUDE[wrt](~/includes/wrt-md.md)] (を参照してください[フレームワークをサポートして Windows ストア アプリ用 .NET と Windows ランタイム](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。 クラス、[!INCLUDE[wrt](~/includes/wrt-md.md)]継承しない<xref:System.Object>、現在実装されていないと、<xref:System.Object.Equals%28System.Object%29>メソッド。 ただし、あるように見えます<xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>と<xref:System.Object.GetHashCode%2A>メソッド、c# または Visual Basic のコードで使用すると、.NET Framework は、これらのメソッドの既定の動作を提供します。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] c# または Visual Basic で記述されたクラスでオーバーライドできます、<xref:System.Object.Equals%28System.Object%29>メソッドのオーバー ロードします。  
  
## <a name="notes-for-callers"></a>呼び出し元のノート  
 派生クラスでオーバーライドよく、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>値の等価性を実装するメソッド。 さらに、型でも頻繁に追加の厳密に型指定されたオーバー ロードが提供、`Equals`メソッドを実装することで、通常、<xref:System.IEquatable%601>インターフェイス。 呼び出すと、`Equals`等しいかどうかをテストするメソッド、現在のインスタンスを上書きするかどうかを知っておくべき<xref:System.Object.Equals%2A?displayProperty=nameWithType>に特定の呼び出し方法を理解して、`Equals`メソッドが解決します。 それ以外の場合、意図したものとは異なる等価性テストを実行して、メソッドは、予期しない値を返す可能性があります。  
  
 具体的な例を次に示します。 3 つのインスタンス化します<xref:System.Text.StringBuilder>で同一の文字列オブジェクトし、する 4 つの呼び出しを行い、`Equals`メソッド。 最初のメソッド呼び出しを返します。 `true`、および残りの 3 つの戻り値`false`します。  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 厳密に型指定の最初のケースで<xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType>値の等価性をテストするメソッド オーバー ロードが呼び出されます。 2 つの文字列が割り当てられるため、<xref:System.Text.StringBuilder>オブジェクトが等しい、メソッドを返します`true`します。 ただし、<xref:System.Text.StringBuilder>をオーバーライドしない<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>します。 このため、ときに、<xref:System.Text.StringBuilder>オブジェクトにキャスト、<xref:System.Object>ときに、<xref:System.Text.StringBuilder>インスタンスが型の変数に割り当てられている<xref:System.Object>とタイミング、<xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>メソッドが渡される 2 つ<xref:System.Text.StringBuilder>オブジェクト、既定<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッドが呼び出されます。 <xref:System.Text.StringBuilder> 、参照型では、これは、2 つを渡すことに相当<xref:System.Text.StringBuilder>オブジェクトを<xref:System.Object.ReferenceEquals%2A>メソッド。 3 つすべて<xref:System.Text.StringBuilder>オブジェクトが同一の文字列を含む、3 つの異なるオブジェクトを参照しています。 その結果、これら 3 つのメソッド呼び出しを返す`false`します。  
  
 現在のオブジェクトを別のオブジェクト参照の等価性を比較するには呼び出すことによって、<xref:System.Object.ReferenceEquals%2A>メソッド。 Visual basic で使用することも、`is`キーワード (たとえば、 `If Me Is otherObject Then ...`)。  
  
## <a name="notes-for-inheritors"></a>継承時の注意  
 その型が継承によって定義されている機能で、独自の型を定義するときに、`Equals`その基本型のメソッド。 次の表の既定の実装、`Equals`の主要なカテゴリを .NET Framework 型のメソッド。  
  
|型のカテゴリ|によって定義される等価性|コメント|  
|-------------------|-------------------------|--------------|  
|直接派生したクラス <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|参照の等価性。呼び出しに相当<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>します。|  
|構造体|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|値の等価性。直接バイト単位の比較またはリフレクションを使用してフィールドを比較します。|  
|列挙|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|値は、同じ列挙型と同じ基になる値が必要です。|  
|Delegate|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|デリゲートには、同一の呼び出しリストと同じ型が必要です。|  
|Interface|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|参照の等価性。|  
  
 オーバーライドする常に、値型の<xref:System.Object.Equals%2A>リフレクションに依存するテストが等しいかどうかは、パフォーマンスの低下を提供します。 既定の実装をオーバーライドすることもできます。<xref:System.Object.Equals%2A>参照型参照の等価性ではなく値の等価性をテストすると、値の等価性の正確な意味を定義します。 このような実装の<xref:System.Object.Equals%2A>返す`true`同じインスタンスでない場合でも、2 つのオブジェクトが同じの値があるかどうか。 型の実行者は、オブジェクトの値を構成するものを決定する、通常は、一部またはすべてのデータ オブジェクトのインスタンス変数に格納されています。 値など、<xref:System.String>オブジェクトは、文字列の文字に基づいて、<xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType>メソッドのオーバーライド、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>を返すメソッドを`true`いずれかの 2 つの文字列と同じ順序で同じ文字が含まれているインスタンス。  
  
 次の例は、オーバーライドする方法を示します、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>値の等価性をテストするメソッド。 これは、上書き、<xref:System.Object.Equals%2A>のメソッド、`Person`クラス。 場合`Person`等しいかどうかの基本クラス実装を受け入れられる 2 つ`Person`オブジェクトは 1 つのオブジェクトが参照されている場合のみ等しいとなります。 ただし、ここでは 2 つ`Person`オブジェクトが同じ値を持つ場合に等価、`Person.Id`プロパティ。  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 オーバーライドするだけでなく<xref:System.Object.Equals%2A>、実装することができます、<xref:System.IEquatable%601>等しいかどうかを厳密に型指定されたテストを提供するインターフェイス。  
  
 次のステートメントは、のすべての実装の場合は true である必要があります、<xref:System.Object.Equals%28System.Object%29>メソッド。 一覧で、 `x`、 `y`、および`z`れていないオブジェクト参照を表す**null**します。  
  
-   `x.Equals(x)` 返します`true`、浮動小数点型に関連する場合は除きます。 ISO と IEC/IEEE 60559:2011、情報技術--マイクロプロセッサ システム - 浮動小数点演算を参照してください。  
  
-   `x.Equals(y)` 同じ値を返します`y.Equals(x)`します。  
  
-   `x.Equals(y)` 返します`true`両方`x`と`y`は`NaN`します。  
  
-   場合`(x.Equals(y) && y.Equals(z))`返します`true`、し`x.Equals(z)`返します`true`します。  
  
-   連続して呼び出す`x.Equals(y)`によって参照されるオブジェクトと同じ値を返す`x`と`y`は変更されません。  
  
-   `x.Equals(null)` が `false` を返します。  
  
 実装<xref:System.Object.Equals%2A>; 例外をスローする必要があります、常の値を返す必要があります。 たとえば場合、`obj`は`null`、<xref:System.Object.Equals%2A>メソッドが返す必要があります`false`スローする代わりに、<xref:System.ArgumentNullException>します。  
  
 オーバーライドする場合は、次のガイドラインをに従って<xref:System.Object.Equals%28System.Object%29>:  
  
-   実装する型<xref:System.IComparable>オーバーライドする必要があります<xref:System.Object.Equals%28System.Object%29>します。  
  
-   オーバーライドする型<xref:System.Object.Equals%28System.Object%29>もオーバーライドする必要があります<xref:System.Object.GetHashCode%2A>。 そうしないと、ハッシュ テーブルが正しく機能しない可能性があります。  
  
-   実装を検討する必要があります、<xref:System.IEquatable%601>強くをサポートするインターフェイスが等しいかどうかのテストを入力します。 <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>実装と一貫した結果を返す必要があります<xref:System.Object.Equals%2A>します。  
  
-   場合は、プログラミング言語が演算子のオーバー ロードをサポートしていると、指定された型に対して等値演算子をオーバー ロードする、オーバーライドすることも必要があります、<xref:System.Object.Equals%28System.Object%29>等値演算子と同じ結果を返します。 これにより、そのクラスのライブラリ コードを使用することを確認<xref:System.Object.Equals%2A>(など<xref:System.Collections.ArrayList>と<xref:System.Collections.Hashtable>) アプリケーション コードでは、等値演算子の使用方法と整合性があるように動作します。  
  
### <a name="guidelines-for-reference-types"></a>参照型のガイドライン  
 オーバーライドするに、次のガイドラインが適用<xref:System.Object.Equals%28System.Object%29>参照型。  
  
-   オーバーライドを検討<xref:System.Object.Equals%2A>場合、型のセマンティクスは、という事実に基づいての型がいくつかの値を表します。  
  
-   ほとんどの参照型でする必要がありますをオーバーライドする場合でもを等値演算子をオーバー ロードしない<xref:System.Object.Equals%2A>します。 ただしなど、複雑な数値型の値のセマンティクスを持つが想定されている参照型を実装している場合は、等値演算子をオーバーライドする必要があります。  
  
-   オーバーライドしないでください<xref:System.Object.Equals%2A>変更可能な参照型にします。 これは、オーバーライドするため<xref:System.Object.Equals%2A>もオーバーライドする必要があります、<xref:System.Object.GetHashCode%2A>メソッド、前のセクションで説明したようにします。 これは、ハッシュ テーブルで、オブジェクトが失われた可能性がありますが、有効期間中に変更可能な参照型のインスタンスのハッシュ コードを変更できることを意味します。  
  
### <a name="guidelines-for-value-types"></a>値型のガイドライン  
 オーバーライドするに、次のガイドラインが適用<xref:System.Object.Equals%28System.Object%29>値型。  
  
-   1 つまたは複数のフィールドを含む値型を定義する場合は参照型の値が、オーバーライドする必要があります<xref:System.Object.Equals%28System.Object%29>します。 <xref:System.Object.Equals%28System.Object%29>実装によって提供される<xref:System.ValueType>値型がバイト単位の比較ではフィールドは、すべての値の型がリフレクションを使用して、フィールドが参照型を含む値型のフィールドの比較を実行します。  
  
-   オーバーライドする場合は<xref:System.Object.Equals%2A>演算子のオーバー ロードをサポートする開発言語とは、等値演算子をオーバー ロードする必要があります。  
  
-   実装する必要があります、<xref:System.IEquatable%601>インターフェイス。 厳密に型指定された呼び出し<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>メソッドは、ボックス化を回避、`obj`引数。  
  
   
  
## Examples  
 次の例は、`Point`をオーバーライドするクラス、<xref:System.Object.Equals%2A>値の等価性を提供するメソッドと`Point3D`クラスから派生した`Point`。 `Point`オーバーライド<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>値の等価性をテストする、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッドは呼び出されません。 ただし、`Point3D.Equals`呼び出し`Point.Equals`ため`Point`実装<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>値の等価性を提供するようにします。  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 `Point.Equals`ことを確認する方法を確認します、`obj`引数がない**null**このオブジェクトと同じ型のインスタンスを参照しているとします。 かどうか、いずれかのチェックが失敗した、メソッドを返します`false`します。  
  
 `Point.Equals`メソッドの呼び出し、<xref:System.Object.GetType%2A>する 2 つのオブジェクトのランタイム型が同じであるかどうかを判断するメソッド。 メソッドは、フォームのチェックを使用する場合`obj is Point`(C#) または`TryCast(obj, Point)`Visual Basic の場合、チェックは返して`true`の場合、`obj`の派生クラスのインスタンスは、`Point`場合でも、`obj`と現在インスタンスは、同じ実行時の型のではありません。 両方のオブジェクトが同じ型、メソッドのキャストのあることを確認したら`obj`入力`Point`し、2 つのオブジェクトのインスタンス フィールドを比較した結果を返します。  
  
 `Point3D.Equals`、継承した`Point.Equals`メソッドをオーバーライド<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>が、何を行う前に呼び出されます。 `Point3D`シール クラスは、(`NotInheritable` Visual Basic で)、チェックイン フォーム`obj is Point`(C#) または`TryCast(obj, Point)`Visual Basic では、ことを確認するための適切な`obj`は、`Point3D`オブジェクト。 ある場合、`Point3D`オブジェクトにキャストされた、`Point`オブジェクトし、の基本クラスの実装に渡される<xref:System.Object.Equals%2A>します。 場合にのみ、継承された`Point.Equals`メソッドを返します。`true`メソッドの比較には、`z`インスタンス フィールドを、派生クラスで導入されました。  
  
 次の例では、定義、`Rectangle`として 2 つの四角形を内部的に実装するクラスを`Point`オブジェクト。 `Rectangle`クラスにも上書き<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>値の等価性を提供します。  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 C# および Visual Basic などの一部の言語では、演算子のオーバー ロードをサポートします。 オーバーライドする必要がありますも、型は、等値演算子をオーバー ロード、ときに、<xref:System.Object.Equals%28System.Object%29>同じ機能を提供するメソッド。 記述することでこれは通常、<xref:System.Object.Equals%28System.Object%29>メソッドに関して次の例のように、オーバー ロードされた等値演算子。  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 `Complex`値型であるから得ることはできません。  そのため、上書きを<xref:System.Object.Equals%28System.Object%29>メソッドを呼び出す必要はありません<xref:System.Object.GetType%2A>を確認する正確な実行時入力できますが、各オブジェクトの代わりに使用して、`is`演算子 (C#) または`TypeOf`の種類を確認するVisualbasicの演算子`obj`パラメーター。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">比較対象の第 1 オブジェクト。</param>
        <param name="objB">2 番目に比較するオブジェクト。</param>
        <summary>指定されたインスタンスが等しいかどうかを判断します。</summary>
        <returns>オブジェクトが等しいと見なされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 <paramref name="objA" /> と <paramref name="objB" /> の両方が **null** の場合、このメソッドは <see langword="true" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 静的な<xref:System.Object.Equals%28System.Object%2CSystem.Object%29>かどうか 2 つのオブジェクト、メソッドを示します`objA`と`objB`が等しい。 オブジェクトの値をテストすることもできます**null**等しいかどうか。 比較`objA`と`objB`次のように等しいかどうか。  
  
-   2 つのオブジェクトが同じオブジェクト参照を表すかどうかを決定します。 かどうかは、これらは、メソッドを返します`true`します。 このテストの呼び出しと同じですが、<xref:System.Object.ReferenceEquals%2A>メソッド。 さらに、両方`objA`と`objB`は**null**、メソッドを返します`true`します。  
  
-   判断したかどうか`objA`または`objB`は**null**。 そのため、返された場合`false`します。  
  
-   2 つのオブジェクトは、同じオブジェクト参照を表していないかどうか、およびはどちらも**null**、呼び出す`objA`.`Equals`(`objB`) し、結果を返します。 つまり、`objA`オーバーライド、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッドでは、このオーバーライドが呼び出されます。  
  
   
  
## Examples  
 次の例を示しています、<xref:System.Object.Equals%28System.Object%2CSystem.Object%29>メソッドとの比較、<xref:System.Object.ReferenceEquals%2A>メソッド。  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>オブジェクトがガベージ コレクションにより収集される前に、そのオブジェクトがリソースを解放し、その他のクリーンアップ操作を実行できるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.Finalize%2A>オブジェクトが破棄される前に、現在のオブジェクトによって保持されているアンマネージ リソースのクリーンアップ操作を実行するメソッドを使用します。 メソッドが保護されているし、そのため、このクラスまたは派生クラスからのみアクセスできますが。  
  
 このセクションの内容:  
  
-   [終了処理のしくみ](#How)  
  
-   [実装についてのメモ](#Notes)  
  
-   [SafeHandle の代替手段](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>終了処理のしくみ  
 <xref:System.Object>クラスの実装を提供しない、<xref:System.Object.Finalize%2A>メソッド、およびガベージ コレクターから派生した型をマークしません<xref:System.Object>終了がオーバーライドされない限り、<xref:System.Object.Finalize%2A>メソッド。  
  
 型をオーバーライドする場合、<xref:System.Object.Finalize%2A>ファイナライズのキューと呼ばれる内部構造をメソッド、ガベージ コレクターは追加型の各インスタンスのエントリ。 ファイナライザーのキューには、ガベージ コレクターが、メモリを解放する前に終了コードを実行する必要があります、マネージ ヒープ内のすべてのオブジェクトのエントリが含まれています。 ガベージ コレクターを呼び出して、<xref:System.Object.Finalize%2A>メソッドは、次の条件下で自動的に。  
  
-   ガベージ コレクターが、オブジェクトがへの呼び出しで終了処理から除外されていない場合に、オブジェクトが、アクセスできないことを検出した後、<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>メソッド。  
  
-   **.NET Framework のみで**、アプリケーション ドメインのシャット ダウン中に、オブジェクトが終了処理から除外しない限り、します。 シャット ダウン中、引き続きアクセス可能であるものオブジェクトが完了します。  
  
 <xref:System.Object.Finalize%2A> 自動的に 1 回だけ呼び出す特定のインスタンスで、オブジェクトが再などのメカニズムを使用して、登録されている場合を除き、<xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType>と<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>メソッドが、その後に呼び出されていません。  
  
 <xref:System.Object.Finalize%2A> 操作には、次の制限があります。  
  
-   ファイナライザーが実行される場合の正確な時間が定義されていません。 リソースの確定的解放をことを確認し、クラスのインスタンスを実装する、`Close`メソッドを提供または、<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>実装します。  
  
-   2 つのオブジェクトのファイナライザーは、1 つのオブジェクトを参照する他の場合でも、特定の順序で実行する保証はありません。 オブジェクト A がオブジェクト B への参照を両方ファイナライザーがある場合は、オブジェクト B が既にファイナライズされているオブジェクトのファイナライザーの開始時にします。  
  
-   ファイナライザーが実行されているスレッドでは、指定されていません。  
  
 <xref:System.Object.Finalize%2A>メソッドが完了するまで実行されない、または次の例外的な状況ではまったく実行されない可能性があります。  
  
-   別のファイナライザーを無期限にブロックする場合 (そのことはありません取得して、ロックを取得しようと、無限ループになる)。 ランタイムがファイナライザーの実行を完了しようとするとため、その他のファイナライザーが呼び出されません場合、ファイナライザーがブロック無期限にします。  
  
-   場合は、ランタイムをクリーンアップする機会を与えることがなく、プロセスを終了します。 この場合、ランタイムの最初の通知プロセスの終了は DLL_PROCESS_DETACH 通知です。  
  
 ランタイムは、ファイナライズ可能なオブジェクトの数が減少し続けます中にのみシャット ダウン中にオブジェクトの終了が続行されます。  
  
 場合<xref:System.Object.Finalize%2A>またはのオーバーライドを<xref:System.Object.Finalize%2A>、例外をスローし、ランタイムが、既定のポリシーをオーバーライドするアプリケーションによってホストされていない、プロセスとはアクティブなランタイムが終了する`try` / `finally`ブロックまたはファイナライザーが実行されます。 この動作は、ファイナライザーが解放またはリソースを破棄できない場合にプロセスの整合性を保証します。  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Finalize メソッドをオーバーライドします。 
 オーバーライドする必要があります<xref:System.Object.Finalize%2A>のファイル ハンドルやガベージ コレクション中にそれらを使用するマネージ オブジェクトが破棄されたときに解放する必要がありますのあるデータベース接続などのアンマネージ リソースを使用するクラス。 実装しないでください、<xref:System.Object.Finalize%2A>ガベージ コレクターがマネージ リソースを自動的に解放するためのメソッドがオブジェクトを管理します。  
  
> [!IMPORTANT]
>  場合、<xref:System.Runtime.InteropServices.SafeHandle>オブジェクトが使用可能なアンマネージ リソースをラップする、セーフ ハンドルの dispose パターンを実装し、無効にすることをお勧めの方法が<xref:System.Object.Finalize%2A>します。 詳細については、次を参照してください。[代わりに、SafeHandle](#SafeHandle)セクション。  
  
 <xref:System.Object.Finalize%2A?displayProperty=nameWithType>メソッドは既定では、何しますが、オーバーライドする必要があります<xref:System.Object.Finalize%2A>必要に応じて、およびアンマネージ リソースを解放するだけである場合のみです。 メモリを再利用は、少なくとも 2 つのガベージ コレクションを必要とするために、終了処理操作を実行する場合にかなり長くかかる傾向があります。 さらに、オーバーライドする必要があります、<xref:System.Object.Finalize%2A>メソッド参照の型だけです。 共通言語ランタイムは、参照型のみを終了します。 値型にファイナライザーが無視されます。  

スコープ、<xref:System.Object.Finalize%2A?displayProperty=nameWithType>メソッドは`protected`します。 クラス内でこのメソッドをオーバーライドする場合は、このスコープの範囲を維持する必要があります。 保持することで、<xref:System.Object.Finalize%2A>メソッドを protected に呼び出し元のオブジェクトから、アプリケーションのユーザーを防ぐ<xref:System.Object.Finalize%2A>メソッドを直接します。
  
 すべての実装の<xref:System.Object.Finalize%2A>派生型の基本型の実装を呼び出す必要があります<xref:System.Object.Finalize%2A>します。 これを呼び出すアプリケーション コードが許可されている場合のみ<xref:System.Object.Finalize%2A>します。 オブジェクトの<xref:System.Object.Finalize%2A>メソッドは、基底クラスのそれ以外のすべてのオブジェクトに対するメソッドを呼び出すことはできません。 これは、共通言語ランタイムがシャットダウンされる場合など、呼び出し元のオブジェクトと呼び出された別のオブジェクトが同時にガベージ コレクションされることがあるからです。 
  
> [!NOTE]
>  C# コンパイラ オーバーライドはできません、<xref:System.Object.Finalize%2A>メソッド。 代わりに、実装することでファイナライザーを提供する、[デストラクター](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)クラス。 C# のデストラクターは、その基底クラスのデストラクターを自動的に呼び出します。  
>   
>  Visual C を実装するため独自の構文を提供することも、<xref:System.Object.Finalize%2A>メソッド。 詳細については、の「デストラクターおよびファイナライザー」セクションを参照してください。[方法: 定義とクラスの使用、および構造体 (C +/cli CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)します。  
  
 ガベージ コレクションは非決定的であるため、ガベージ コレクターがファイナライズを実行するときに正確にはおわからない場合。 リソースを解放する、すぐに選択することできますも実装するために、 [dispose パターン](~/docs/standard/design-guidelines/dispose-pattern.md)と<xref:System.IDisposable>インターフェイス。 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>実装を呼び出すことができるクラスのコンシューマーが、アンマネージ リソースを解放して、使用することができます、<xref:System.Object.Finalize%2A>アンマネージ リソースを解放するメソッドを<xref:System.IDisposable.Dispose%2A>メソッドは呼び出されません。  
  
 <xref:System.Object.Finalize%2A> ガベージ コレクション中にクリーンアップされた後に、(つまり、オブジェクトにアクセスできるように再度) オブジェクトを復活させる方法を含め、ほとんどすべてのアクションを実行することができます。 ただし、オブジェクトできますのみ再生できるは 1 回です。<xref:System.Object.Finalize%2A>ガベージ コレクション中に再生されたオブジェクトで呼び出すことはできません。 1 つのアクションを実装の<xref:System.Object.Finalize%2A>かかることはありません: 例外をスローする必要がありますしません。 メソッドによってスローされた例外がから呼び出された場合、<xref:System.Object.Finalize%2A>メソッドによって処理されない、<xref:System.Object.Finalize%2A>メソッド、ランタイムを想定、<xref:System.Object.Finalize%2A>メソッドが返され、呼び出しは引き続き、<xref:System.Object.Finalize%2A>他のオブジェクトのメソッド。 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>代替手段としての SafeHandle  
 信頼性の高いファイナライザーを作成することが難しい、アプリケーションの状態に関する想定を行うことはできませんしなどのシステム例外をハンドルされていないため<xref:System.OutOfMemoryException>と<xref:System.StackOverflowException>ファイナライザーを終了します。 派生したオブジェクトを使用するアンマネージ リソースを解放するには、クラスのファイナライザーを実装するには、代わりに、 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> 、アンマネージ リソースをラップするクラスし、ファイナライザーなしの dispose パターンを実装します。 .NET Framework の次のクラスには、<xref:Microsoft.Win32?displayProperty=nameWithType>名前空間から派生した<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> ファイル ハンドルのラッパー クラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> メモリ マップト ファイル ハンドルのラッパー クラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> アンマネージ メモリ ブロックへのポインターのラッパー クラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>、 <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>、および<xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle>暗号化ハンドルのラッパー クラスします。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> パイプ ハンドルのラッパー クラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> レジストリ キーを識別するハンドルのラッパー クラスです。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 待機ハンドルのラッパー クラスです。  
  
 次の例では、 [dispose パターン](~/docs/standard/design-guidelines/dispose-pattern.md)オーバーライドする代わりにセーフ ハンドルを使った、<xref:System.Object.Finalize%2A>メソッド。 定義、`FileAssociation`特定のファイル拡張子を持つファイルを処理するアプリケーションのレジストリ情報をラップするクラス。 として返される 2 つのレジストリ ハンドル`out`Windows によるパラメーター [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)に渡される関数呼び出し、<xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>コンス トラクター。 型の保護された`Dispose`メソッドを呼び出して、`SafeRegistryHandle.Dispose`これら 2 つのハンドルを解放します。  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 次の例では、ことを確認、<xref:System.Object.Finalize%2A>オブジェクトをオーバーライドするときに、メソッドが呼び出された<xref:System.Object.Finalize%2A>は破棄されます。 実稼働アプリケーションでそれに注意してください、<xref:System.Object.Finalize%2A>オブジェクトによって保持されているアンマネージ リソースを解放するメソッドはオーバーライドされます。 なお、c# の例がオーバーライドする代わりにデストラクターを提供する、<xref:System.Object.Finalize%2A>メソッド。  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 オーバーライドする例については、<xref:System.Object.Finalize%2A>メソッドを参照してください、<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>既定のハッシュ関数として機能します。</summary>
        <returns>現在のオブジェクトのハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハッシュ コードが挿入およびなどハッシュ ベースのコレクション内のオブジェクトを識別するために使用する数値、<xref:System.Collections.Generic.Dictionary%602>クラス、<xref:System.Collections.Hashtable>クラス、または型から派生した、<xref:System.Collections.DictionaryBase>クラス。 <xref:System.Object.GetHashCode%2A>メソッドは、アルゴリズムのオブジェクトの等価性の簡単なチェックを必要があります。 このハッシュ コードを提供します。  
  
> [!NOTE]
>  ハッシュ テーブルのハッシュ コードを使用する方法についての情報といくつかの追加のハッシュ コード アルゴリズムを参照してください、[ハッシュ関数](https://en.wikipedia.org/wiki/Hash_function)Wikipedia 内のエントリ。  
  
 等しいと同じ戻り値のハッシュ コードを 2 つのオブジェクト。 ただし、その逆は true。 (等しくない) の異なるオブジェクトが同一のハッシュ コードを持てないため、同じハッシュ コードをオブジェクトの等価性を意味しません。 さらに、.NET Framework とは限りませんの既定の実装、<xref:System.Object.GetHashCode%2A>メソッド、およびこのメソッドで異なる場合がありますを返す .NET Framework のバージョンと 32 ビットおよび 64 ビットのプラットフォームなどのプラットフォームの値。 これらの理由から、使わないこのメソッドの既定の実装固有のオブジェクト識別子としてハッシュの目的で。 これから次の 2 つの影響。  
  
-   等しいハッシュ コードがオブジェクトの等価性を意味する想定しないでください。  
  
-   なるか、同じオブジェクトをアプリケーション ドメイン、プロセス、およびプラットフォーム間でハッシュ可能性がありますのでが作成されたアプリケーション ドメインの外部ハッシュ コードを使用する必要があることはありません。  
  
> [!WARNING]
>  ハッシュ コードは、効率的な挿入とハッシュ テーブルに基づくコレクション内の参照です。 ハッシュ コードは、永続的な値ではありません。 このためには。  
>   
> -   ハッシュ コード値をシリアル化したり、それらをデータベースに保存しないでください。  
> -   キー付きコレクションからオブジェクトを取得するのにキーとしてハッシュ コードを使用できません。  
> -   アプリケーション ドメインまたはプロセスの間では、ハッシュ コードを送信しません。 場合によっては、ハッシュ コードをプロセスごとまたはアプリケーションごとのドメインごとに計算することがあります。  
> -   強力な暗号的ハッシュを作成する必要がある場合は、暗号化ハッシュ関数によって返される値ではなくハッシュ コードを使わないでください。 暗号化ハッシュから派生したクラスを使用して、<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType>または<xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>クラス。  
> -   ハッシュ コードを 2 つのオブジェクトが等しいかどうかを判断するには、等しいかどうかをテストしないでください。 (等しくないオブジェクトは、同一のハッシュ コードを持つことができます)等しいかどうかをテストするには、呼び出し、<xref:System.Object.ReferenceEquals%2A>または<xref:System.Object.Equals%2A>メソッド。  
  
 <xref:System.Object.GetHashCode%2A>派生型でメソッドをオーバーライドすることができます。 場合<xref:System.Object.GetHashCode%2A>がオーバーライドされていないハッシュ コードを呼び出すことによって計算が参照型、<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>ハッシュ コードを計算する基本クラスのメソッド ベースのオブジェクトの参照の詳細についてを参照してください<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>します。 つまり、2 つのオブジェクトを<xref:System.Object.ReferenceEquals%2A>メソッドを返します。`true`された同一のハッシュ コード。 値の型をオーバーライドしない場合<xref:System.Object.GetHashCode%2A>、<xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType>基本クラスのメソッドでは、リフレクションを使用して、型のフィールドの値に基づいてハッシュ コードを計算します。 つまり、フィールドが同じ値を持つ値の型では、同じハッシュ コードがあります。 オーバーライドの詳細については<xref:System.Object.GetHashCode%2A>、「ノート継承クラス」を参照してください。  
  
> [!WARNING]
>  オーバーライドする場合、<xref:System.Object.GetHashCode%2A>メソッドをオーバーライドすることがも<xref:System.Object.Equals%2A>、またはその逆です。 場合、オーバーライドされた<xref:System.Object.Equals%2A>メソッドを返します。`true`等しいかどうか、オーバーライドされた 2 つのオブジェクトをテストするときに<xref:System.Object.GetHashCode%2A>メソッドは、2 つのオブジェクトに対して同じ値を返す必要があります。  
  
 ハッシュ テーブル内のキーとして使用されるオブジェクトがの便利な実装を提供しないかどうか<xref:System.Object.GetHashCode%2A>、ハッシュ コード プロバイダーを指定するには指定することによって、<xref:System.Collections.IEqualityComparer>のオーバー ロードのいずれかに実装、<xref:System.Collections.Hashtable>クラスのコンス トラクター。  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>ノートには、 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 呼び出すと、<xref:System.Object.GetHashCode%2A>内のクラスのメソッド、 [!INCLUDE[wrt](~/includes/wrt-md.md)]、既定の動作をオーバーライドしないクラスを提供します<xref:System.Object.GetHashCode%2A>します。 これは、.NET Framework では、サポートの一部、 [!INCLUDE[wrt](~/includes/wrt-md.md)] (を参照してください[フレームワークをサポートして Windows ストア アプリ用 .NET と Windows ランタイム](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。 クラス、[!INCLUDE[wrt](~/includes/wrt-md.md)]継承しない<xref:System.Object>、現在実装されていないと、<xref:System.Object.GetHashCode%2A>します。 ただし、あるように見えます<xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>と<xref:System.Object.GetHashCode%2A>メソッド、c# または Visual Basic のコードで使用すると、.NET Framework は、これらのメソッドの既定の動作を提供します。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] c# または Visual Basic で記述されたクラスでオーバーライドできます、<xref:System.Object.GetHashCode%2A>メソッド。  
  
   
  
## Examples  
 同じか、またはより小さい範囲を持つ数値のハッシュ コードを計算する最も簡単な方法の 1 つ、<xref:System.Int32>型は、その値を返すことだけです。 次の例では、このような実装を`Number`構造体。  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 多くの場合、型には、ハッシュ コードの生成に参加できる複数のデータ フィールドがあります。 ハッシュ コードを生成する方法の 1 つを使用してこれらのフィールドを結合する、`XOR (eXclusive OR)`操作は、次の例に示すようにします。  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 前の例は、(n1、n2) の同じハッシュ コードを返します (n2、n1)、および、必要な多数の衝突を生成する可能性があります。 このような場合のハッシュ コードが同一でないように、ソリューションの数は使用できます。 1 つのハッシュ コードを返すには、`Tuple`各フィールドの順序を反映するオブジェクト。 次の例を使用して、考えられる実装を示しています、<xref:System.Tuple%602>クラス。 ただしをインスタンス化のパフォーマンスのオーバーヘッドを`Tuple`オブジェクトは、ハッシュ テーブルに多数のオブジェクトを格納するアプリケーションの全体的なパフォーマンスに大きな影響可能性があります。  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 2 番目の代替ソリューションには、連続するフィールドのハッシュ コードを 2 つ以上のビットを左シフトすることで、個々 のハッシュ コードを重み付けが含まれます。 最適な状態で、破棄されるのではなくを超えて 31 ビット シフトをラップするよりも破棄されます。 C# および Visual Basic の両方で左シフト演算子でビットを破棄するので、次のような左 shift キーのラップ メソッドを作成する必要があります。  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 次の例は、のハッシュ コードを計算するこのシフトのラップ メソッドを使用するし、`Point`前の例で使用される構造体。  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>ハッシュ関数を使用して、オブジェクトの値に対応する番号 (ハッシュ コード) をすばやく生成します。ハッシュ関数は通常、各種類に固有し、一意である、する必要があります少なくとも 1 つのインスタンス フィールドの入力として使用します。静的フィールドの値を使用して、ハッシュ コードを計算する必要がありません。派生したクラスの<see cref="T:System.Object" />、<see langword="GetHashCode" />メソッドが基底クラスに委任できる<see cref="M:System.Object.GetHashCode" />実装の派生クラスには参照の等価性に等しいかどうかが定義されている場合のみです。既定の実装<see cref="M:System.Object.GetHashCode" />参照型で返されると等価のハッシュ コードを返します、<see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />メソッド。オーバーライドできます<see cref="M:System.Object.GetHashCode" />変更不可の参照の種類。一般に、変更可能な参照型でオーバーライドする<see cref="M:System.Object.GetHashCode" />場合にのみ: は変更できませんフィールドのハッシュ コードを計算できますまたは - を collecti に含まれていますが、オブジェクトに、変更可能なオブジェクトのハッシュ コードが変更されないことを確認する -。そのハッシュ コードに依存します。それ以外の場合、ハッシュ テーブルで変更可能なオブジェクトが失われることを考える場合があります。オーバーライドする場合は<see cref="M:System.Object.GetHashCode" />変更可能な参照型の場合、ドキュメントがようにクリア オブジェクトがハッシュ テーブルに格納されている場合、型のユーザーがオブジェクトの値を変更しないでください。値型の場合は、<see cref="M:System.ValueType.GetHashCode" />リフレクションを使用する既定のハッシュ コード実装を提供します。パフォーマンス向上のためにオーバーライドすることを検討する必要があります。<block subset="none" type="note"><para> 詳細とさまざまな方法でのハッシュ コードを計算する例については、「例」を参照してください。</para></block>  次のプロパティのハッシュ関数には: - 2 つのオブジェクトが等しいと評価を比較する場合、<see cref="M:System.Object.GetHashCode" />の各オブジェクトのメソッドは、同じ値を返す必要があります。ただし、2 つのオブジェクトが等しく、として比較されない場合、 <see cref="M:System.Object.GetHashCode" /> 2 つのオブジェクトのメソッドは、異なる値を返す必要はありません。 -<see cref="M:System.Object.GetHashCode" />メソッドは、オブジェクトがオブジェクトの戻り値を決定するオブジェクトの状態に変更がない限り、同じハッシュ コードを返す必要があります一貫して[System.Object.Equals](xref:System.Object.Equals*)メソッド。これが、アプリケーションの現在の実行にのみ true であると、アプリケーションをもう一度実行している場合に他のハッシュ コードを返すことことに注意してください。 -については、最適なパフォーマンスを大きくがクラスター化されている入力を含む、すべての入力に対して均等に分散にハッシュ関数が生成されます。ハッシュ テーブルの最適なパフォーマンスの結果のハッシュ コードに対する大規模な変更でオブジェクトの状態の小さい変更があります。 ハッシュ関数は、コストを計算することがあります。 -<see cref="M:System.Object.GetHashCode" />メソッドが例外をスローする必要があります。実装など、<see cref="M:System.String.GetHashCode" />メソッドによって提供される、<see cref="T:System.String" />クラスは、まったく同じ文字列値の同一のハッシュ コードを返します。そのため、2 つ<see cref="T:System.String" />オブジェクトが同じ文字列値を表す場合、同じハッシュ コードを返します。また、メソッドを使用して、すべての文字文字列の入力が特定の範囲でクラスター化する場合でも、ある程度ランダムに分散型の出力を生成する (たとえば、多くのユーザーの場合でも、下位 128 ASCII 文字のみを含む文字列がある、文字列を含めたりする 65,535 の Unicode 文字の)。クラスの適切なハッシュ関数を提供すると、それらのオブジェクトをハッシュ テーブルに追加のパフォーマンスは大きく変わります。ハッシュ関数の適切な実装を提供するキーを持つハッシュ テーブルには、要素の検索と (たとえば、o (1) 操作など) の定数の時間がかかります。ハッシュ関数の不適切な実装でのハッシュ テーブルに、検索のパフォーマンスがハッシュ テーブル内の項目の数に依存 (たとえば、O (`n`) 操作、場所`n`はハッシュ テーブル内の項目の数です)。悪意のあるユーザーは、次の条件下で、ハッシュ テーブルに依存するアプリケーションのパフォーマンスが低下する可能性が大幅に競合の数を増やすためのデータを入力できます。 - ハッシュ関数が頻繁に競合を生成します。 -ハッシュ テーブル内のオブジェクトの大部分が等しいか、いずれかの別のおよそのハッシュ コードを生成します。 -ユーザーは、ハッシュ コードの計算元となるデータを入力します。オーバーライドするクラスを派生<see cref="M:System.Object.GetHashCode" />もオーバーライドする必要があります<see cref="M:System.Object.Equals(System.Object)" />等しいと見なされる 2 つのオブジェクトに同じハッシュ コードがあることを保証するために、それ以外の場合、<see cref="T:System.Collections.Hashtable" />型が正しく機能しない可能性があります。</para>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスの <see cref="T:System.Type" /> を取得します。</summary>
        <returns>現在のインスタンスの正確なランタイム型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object?displayProperty=nameWithType>すべての型の基本クラスを .NET Framework 型システムでは、<xref:System.Object.GetType%2A>を返すメソッドを使用できます<xref:System.Type>すべての .NET Framework 型を表すオブジェクト。 .NET Framework には、次の 5 つの種類のカテゴリが認識されます。  
  
-   派生したクラス、 <xref:System.Object?displayProperty=nameWithType>、  
  
-   値の型から派生した<xref:System.ValueType?displayProperty=nameWithType>します。  
  
-   派生したインターフェイス、 <xref:System.Object?displayProperty=nameWithType> .NET Framework 2.0 以降します。  
  
-   派生した列挙型、<xref:System.Enum?displayProperty=nameWithType>します。  
  
-   派生した代理人<xref:System.MulticastDelegate?displayProperty=nameWithType>します。  
  
 2 つのオブジェクトの`x`と`y`同一ランタイムの型がある`Object.ReferenceEquals(x.GetType(),y.GetType())`返します`true`します。 次の例では、<xref:System.Object.GetType%2A>メソッドを<xref:System.Object.ReferenceEquals%2A>メソッドを 1 つの数値が他の 2 つの数値の値と同じ型かどうかを確認します。  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  オブジェクトがを特定の種類であるかどうかを確認するのには、言語の型の比較のキーワードを使用したり構築できます。 たとえば、使用することができます、 `TypeOf…Is` Visual Basic で作成または`is`キーワード (C#)。  
  
 <xref:System.Object.GetType%2A>メソッドがから派生したすべての型によって継承される<xref:System.Object>します。 これには、独自の言語の比較キーワード以外にも、使用できることを意味、<xref:System.Object.GetType%2A>として次の例は、特定のオブジェクトの種類を判断するメソッド。  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <xref:System.Type>オブジェクトは、現在のクラスに関連付けられたメタデータを公開<xref:System.Object>します。  
  
   
  
## Examples  
 次のコード例を示している<xref:System.Object.GetType%2A>現在のインスタンスのランタイム型を返します。  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Object" /> の簡易コピーを作成します。</summary>
        <returns>現在の <see cref="T:System.Object" /> の簡易コピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.MemberwiseClone%2A>メソッドは、新しいオブジェクトを作成し、新しいオブジェクトを現在のオブジェクトの非静的フィールドをコピーして簡易コピーを作成します。 フィールドが値型の場合は、フィールドのビットごとのコピーが実行されます。 フィールドが参照型の場合は、参照がコピーされますが、参照先オブジェクトがないです。そのため、元のオブジェクトとその複製は、同じオブジェクトを参照します。  
  
 たとえば、オブジェクト A と B をさらに、参照の参照オブジェクト C X という名前のオブジェクトX の簡易コピーは、オブジェクト A と B を参照する新しいオブジェクト X2 を作成します。これに対し、X の詳細コピーが A2 および B2、A のコピーは、新しいオブジェクトを参照する新しいオブジェクト X2 を作成し、B. B2、さらに、c ドライブのコピーである新しいオブジェクト C2 を参照この例では、shallow とディープ コピー操作の違いを示します。  
  
 簡易コピー操作を実行している場合、詳細コピー操作を実装する方法はたくさんあります、<xref:System.Object.MemberwiseClone%2A>メソッドは、ニーズを満たしていません。 次に例を示します。  
  
-   最初のオブジェクトから取得したプロパティ値を 2 番目のオブジェクトを作成するコピーされるオブジェクトのクラスのコンス トラクターを呼び出します。 これは、そのクラス コンス トラクターによってオブジェクトの値がまったく定義されていると仮定します。  
  
-   呼び出す、<xref:System.Object.MemberwiseClone%2A>メソッドをオブジェクトの簡易コピーを作成し、値は、プロパティやフィールドは参照型の値が元のオブジェクトと同じ新しいオブジェクトを割り当てます。 `DeepCopy`メソッドの例では、この方法を示します。  
  
-   コピーには、ディープ オブジェクトをシリアル化し、別のオブジェクト変数をシリアル化されたデータを復元します。  
  
-   再帰でリフレクションを使用して、詳細コピー操作を実行します。  
  
   
  
## Examples  
 次の例を示しています、<xref:System.Object.MemberwiseClone%2A>メソッド。 定義、`ShallowCopy`メソッドを呼び出す、<xref:System.Object.MemberwiseClone%2A>簡易コピー操作を実行するメソッド、`Person`オブジェクト。 定義、`DeepCopy`に対してディープ コピー操作を実行するメソッド、`Person`オブジェクト。  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 この例で、`Person.IdInfo`プロパティが返す、`IdInfo`オブジェクト。 例を示しますから出力としてときに、`Person`オブジェクトが呼び出すことによって複製、<xref:System.Object.MemberwiseClone%2A>メソッドは、複製された`Person`オブジェクトには、元のオブジェクトの独立したコピーがある同じ共有を`Person.IdInfo`オブジェクト参照。 その結果、クローンの変更する`Person.IdInfo`プロパティが変更元のオブジェクトの`Person.IdInfo`プロパティ。 その一方で、詳細コピー操作を実行ときに、複製された`Person`オブジェクトを含むその`Person.IdInfo`プロパティは、元のオブジェクトの影響を与えずに変更できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">比較対象の第 1 オブジェクト。</param>
        <param name="objB">比較する 2 番目のオブジェクト。</param>
        <summary>指定した複数の <see cref="T:System.Object" /> インスタンスが同一かどうかを判断します。</summary>
        <returns>
          <paramref name="objA" /> が <paramref name="objB" /> と同一のインスタンスである場合、または両方のインスタンスが **null** の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 異なり、<xref:System.Object.Equals%2A>と等値演算子のメソッド、<xref:System.Object.ReferenceEquals%2A>メソッドをオーバーライドすることはできません。 このため、テストする場合は、2 つのオブジェクトが等しいかどうかの参照との実装の詳細を確認したら、`Equals`メソッドを呼び出すことができます、<xref:System.Object.ReferenceEquals%2A>メソッド。  
  
 ただし、戻り値の<xref:System.Object.ReferenceEquals%2A>これら 2 つのシナリオでは異常と考えられるメソッドがあります。  
  
-   ときに、値の型を比較します。 場合`objA`と`objB`は、値の型に渡される前にボックス化されている、<xref:System.Object.ReferenceEquals%2A>メソッド。 つまり、両方`objA`と`objB`値の型の同じインスタンスを表す、<xref:System.Object.ReferenceEquals%2A>メソッドを返しますそれにもかかわらず`false`次の例に示すように、します。  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     値型のボックス化については、次を参照してください。[ボックス化とボックス化解除](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)します。  
  
-   ときに、文字列を比較します。 場合`objA`と`objB`文字列の場合は、<xref:System.Object.ReferenceEquals%2A>メソッドを返します。`true`場合は、文字列がインターン プールに存在します。 値の等価性テストを行うことはできません。  次の例では、`s1`と`s2`隔離された単一の文字列の 2 つのインスタンスであるために値が等しい。 ただし、`s3`と`s4`が、まったく同じ文字列値がありますは、その文字列がインターンしないために、等しくない場合は、します。  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     文字列インターンの詳細については、次を参照してください。<xref:System.String.IsInterned%2A?displayProperty=nameWithType>します。  
  
   
  
## Examples  
 次の例では<xref:System.Object.ReferenceEquals%2A>を 2 つのオブジェクトは、同じインスタンスを決定します。  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のオブジェクトを表す文字列を返します。</summary>
        <returns>現在のオブジェクトを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> メジャーでは、.NET Framework のメソッドを書式設定します。 表示に適したあるように、オブジェクトを文字列表現に変換します。 (.NET Framework でのサポートを書式設定方法の詳細については、次を参照してください[型の書式設定](~/docs/standard/base-types/formatting-types.md)。)。既定の実装、<xref:System.Object.ToString%2A?displayProperty=nameWithType>メソッドがオブジェクトの型の完全修飾名を返します。  
  
> [!IMPORTANT]
>  リンクから別の型のメンバーの一覧からこのページが表示がある可能性があります。 その型をオーバーライドしないためにです<xref:System.Object.ToString%2A?displayProperty=nameWithType>します。 代わりの機能を継承、<xref:System.Object.ToString%2A?displayProperty=nameWithType>メソッド。  
  
 型は頻繁に、オーバーライド、<xref:System.Object.ToString%2A?displayProperty=nameWithType>特定の種類の方が適切な文字列形式を提供するメソッド。 型でも頻繁にオーバー ロード、<xref:System.Object.ToString%2A?displayProperty=nameWithType>書式指定文字列またはカルチャの書式設定のサポートを提供するメソッド。  
  
 このセクションの内容:  
  
 [既定の Object.ToString() メソッド](#Default)   
 [Object.ToString() メソッドをオーバーライドします。](#Overriding)   
 [ToString メソッドをオーバー ロード](#Overloading)   
 [Object.ToString メソッドを拡張します。](#Extending)   
 [Windows ランタイムのノート](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>既定の Object.ToString() メソッド  
 既定の実装、<xref:System.Object.ToString%2A>メソッドの型の完全修飾名を返します、 <xref:System.Object>、次の例を示しています。  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 <xref:System.Object>すべての参照型の基底クラスには、.NET Framework では、この動作は上書きをしない参照型によって継承されます、<xref:System.Object.ToString%2A>メソッド。 次に例を示します。 という名前のクラスが定義`Object1`すべての既定の実装を受け入れる<xref:System.Object>メンバー。 その<xref:System.Object.ToString%2A>メソッドは、オブジェクトの完全修飾型名を返します。  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>Object.ToString() メソッドをオーバーライドします。  
 型は通常、オーバーライド、<xref:System.Object.ToString%2A?displayProperty=nameWithType>オブジェクト インスタンスを表す文字列を返すメソッド。 たとえば、基本の型など<xref:System.Char>、 <xref:System.Int32>、および<xref:System.String>提供<xref:System.Object.ToString%2A>オブジェクトによって表される値の文字列形式を返す実装します。 次の例は、クラスを定義`Object2`、オーバーライドする、<xref:System.Object.ToString%2A>と値の型名を返すメソッド。  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 次の表は、.NET Framework の型のカテゴリを一覧表示し、オーバーライドするかどうかを示します、<xref:System.Object.ToString%2A?displayProperty=nameWithType>メソッド。  
  
|型のカテゴリ|上書き Object.ToString()|[動作]|  
|-------------------|-----------------------------------|--------------|  
|クラス|N/A|N/A|  
|構造体|[はい] (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Object.ToString() と同じ|  
|列挙|[はい] (<xref:System.Enum.ToString?displayProperty=nameWithType>)|メンバー名|  
|Interface|×|N/A|  
|Delegate|×|N/A|  
  
 オーバーライドの詳細については、継承クラス「ノートを参照してください<xref:System.Object.ToString%2A>します。  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>ToString メソッドをオーバー ロード  
 パラメーターなしでオーバーライドするだけでなく<xref:System.Object.ToString?displayProperty=nameWithType>メソッドでは、さまざまな種類のオーバー ロード、`ToString`メソッドのパラメーターを使用できるバージョンを提供するメソッド。 ほとんどの場合、この変数の書式とカルチャの書式設定のサポートを提供する行われます。  
  
 次の例のオーバー ロード、`ToString`のさまざまなフィールドの値を含む結果の文字列を返すメソッドを`Automobile`クラス。 次の 4 つの書式指定文字列を定義します G で、モデルの名前と年度; を返します。D で、モデルの名前、year、および; のドアの数を返しますC で、モデルの名前、year、およびシリンダー; の数を返しますA で、すべての 4 つのフィールド値を持つ文字列を返します。  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 次の例では、オーバー ロードされた<xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>カルチャの通貨値の書式設定を表示するメソッド。  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 書式指定文字列とカルチャの書式設定の詳細については、次を参照してください。[型の書式設定](~/docs/standard/base-types/formatting-types.md)します。 書式指定文字列を数値でサポートされている、次を参照してください。 [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md)と[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)します。 日付と時刻の値でサポートされている書式指定文字列を参照してください。 [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md)と[Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md)します。  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>Object.ToString メソッドを拡張します。  
 型は、既定値を継承するため<xref:System.Object.ToString%2A?displayProperty=nameWithType>メソッド、望ましくない動作を検索して変更します、。 これは配列とコレクション クラスの特に当てはまります。 お察し中に、`ToString`メソッド配列またはコレクションのメンバーの値を表示するクラスの代わりに、型の完全修飾型名として表示例を次に示します。  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 希望する結果の文字列を生成するためにいくつかのオプションがあります。  
  
-   型が配列、コレクション オブジェクト、または実装するオブジェクトの場合、<xref:System.Collections.IEnumerable>または<xref:System.Collections.Generic.IEnumerable%601>インターフェイスを使用してその要素を列挙することができます、 `foreach` (C#) ステートメントまたは`For Each...Next`Visual Basic で作成します。  
  
-   クラスがない場合`sealed`(で C# の場合) または`NotInheritable`持つ基底クラスから継承するラッパー クラスを開発する (Visual Basic の場合) で<xref:System.Object.ToString%2A?displayProperty=nameWithType>をカスタマイズするメソッド。 少なくとも、以下を実行する必要があります。  
  
    1.  必要なコンス トラクターを実装します。 派生クラスでは、その基底クラスのコンス トラクターは継承しません。  
  
    2.  上書き、<xref:System.Object.ToString%2A?displayProperty=nameWithType>を希望する結果の文字列を返すメソッド。  
  
     次の例のラッパー クラスを定義する、<xref:System.Collections.Generic.List%601>クラス。 これは、上書き、<xref:System.Object.ToString%2A?displayProperty=nameWithType>完全修飾型名ではなく、コレクションの各メソッドの値を表示するメソッド。  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   開発、[拡張メソッド](~/docs/standard/design-guidelines/extension-methods.md)する結果の文字列を返します。 既定値をオーバーライドすることはできません注<xref:System.Object.ToString%2A?displayProperty=nameWithType>この方法でメソッド (、拡張機能クラス (c#) または (Visual Basic) でのモジュールがという名前のパラメーターなしのメソッドを含めることはできません、`ToString`元の型の代わりに呼び出される`ToString`メソッド. その他のいくつかのパラメーターなしの名前を指定する必要があります`ToString`置換します。  
  
     次の例を拡張する 2 つのメソッドを定義する、<xref:System.Collections.Generic.List%601>クラス: パラメーターなし`ToString2`メソッド、および`ToString`メソッドを<xref:System.String>書式指定文字列を表すパラメーター。  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>ノートには、 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 呼び出すと、<xref:System.Object.ToString%2A>内のクラスのメソッド、 [!INCLUDE[wrt](~/includes/wrt-md.md)]、既定の動作をオーバーライドしないクラスを提供します<xref:System.Object.ToString%2A>します。 これは、.NET Framework では、サポートの一部、 [!INCLUDE[wrt](~/includes/wrt-md.md)] (を参照してください[フレームワークをサポートして Windows ストア アプリ用 .NET と Windows ランタイム](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。 クラス、[!INCLUDE[wrt](~/includes/wrt-md.md)]継承しない<xref:System.Object>、常に実装していないと、<xref:System.Object.ToString%2A>します。 ただし、常にように見えますが<xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>と<xref:System.Object.GetHashCode%2A>メソッド、c# または Visual Basic のコードで使用すると、.NET Framework は、これらのメソッドの既定の動作を提供します。  
  
 以降では、 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]、共通言語ランタイムを使用して[IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)で、[!INCLUDE[wrt](~/includes/wrt-md.md)]オブジェクトの既定の実装に戻る前に<xref:System.Object.ToString%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] c# または Visual Basic で記述されたクラスでオーバーライドできます、<xref:System.Object.ToString%2A>メソッド。  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)]と IStringable インターフェイス  
 以降で[!INCLUDE[win81](~/includes/win81-md.md)]、[!INCLUDE[wrt](~/includes/wrt-md.md)]が含まれています、 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)インターフェイスの 1 つのメソッドを持つ[IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)と同等の基本的な書式設定サポートを提供します。によって提供される<xref:System.Object.ToString%2A?displayProperty=nameWithType>します。 あいまいさを防ぐには実装しないでください[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)マネージ型にします。  
  
 ネイティブ コードまたは JavaScript または C++ などの言語で記述されたコードでのマネージ オブジェクトを呼び出すときに/cli 実装するために表示される、CX [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)します。 共通言語ランタイムはからの呼び出しに自動的にルーティング[IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)に<xref:System.Object.ToString%2A?displayProperty=nameWithType>イベント[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)はマネージ オブジェクトで実装されていません。  
  
> [!WARNING]
>  共通言語ランタイムの自動実装するため、 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)内の型のすべての管理[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]アプリをお勧めすることを指定しない独自[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)実装します。 実装する[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を呼び出すときに、予期しない動作可能性`ToString`から、 [!INCLUDE[wrt](~/includes/wrt-md.md)]、C++/cli、/CX または JavaScript。  
  
 実装することを選択する場合[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)でエクスポートしたパブリック マネージ型で、[!INCLUDE[wrt](~/includes/wrt-md.md)]コンポーネントでは、次の制限が適用されます。  
  
-   定義することができます、 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)など、「クラスが実装する」関係でしかインターフェイス  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     C# では、上記のようになります。  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     Visual Basic では、上記のようになります。  
  
-   実装することはできません[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)インターフェイス。  
  
-   型パラメーターを宣言することはできません[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)します。  
  
-   [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)メソッド、プロパティ、またはフィールドの戻り値の型にすることはできません。  
  
-   非表示にすることはできません、 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)次などのメソッド定義を使用して基底クラスから実装します。  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     代わりに、 [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)実装は、基本クラスの実装を常にオーバーライドする必要があります。 `ToString` の実装を隠すことができるのは、厳密に型指定されたクラス インスタンスで呼び出す場合だけです。  
  
 さまざまな条件下で実装するマネージ型をネイティブ コードから呼び出すこと[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)の表示と非その[ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)実装は、予期しない動作を引き起こすことができます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする独自の型を実装するときに、<see cref="M:System.Object.ToString" />これらの種類の意味のある値を返すメソッド。派生クラスよりも書式設定制御を必要とする<see cref="M:System.Object.ToString" />提供を実装できます、<see cref="T:System.IFormattable" />インターフェイス。その<see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" />メソッドを使用すると、使用する書式を制御する書式指定文字列を定義して、<see cref="T:System.IFormatProvider" />カルチャに固有の書式を提供できるオブジェクト。オーバーライド、<see cref="M:System.Object.ToString" />メソッドが次のガイドラインに従う必要があります:-親しみやすく、人間が判読できる、返される文字列があります。 -返される文字列は、オブジェクトのインスタンスの値を一意に識別する必要があります。 -返される文字列は、デバッガーによって表示に適したできるように、できるだけ短くことがあります。 -<see cref="M:System.Object.ToString" />オーバーライドを返さないでください<see cref="F:System.String.Empty" />または null 文字列です。 -<see cref="M:System.Object.ToString" />上書きで例外をスローする必要があります。 場合、インスタンスの文字列表現は、カルチャに依存または複数の方法で書式設定することができます、実装、<see cref="T:System.IFormattable" />インターフェイス。 -返される文字列には、機密情報が含まれている場合、適切なアクセス許可をまず要求する必要があります。要求が成功すると、機密情報; を返すことができます。それ以外の場合、機密情報を除外する文字列を返す必要があります。 -<see cref="M:System.Object.ToString" />オーバーライドがデバッグでは、複雑な問題を回避するために副作用がありません。呼び出しなど、<see cref="M:System.Object.ToString" />メソッドはインスタンス フィールドの値を変更しないでください。 -の種類が解析メソッドを実装する場合 (または<see langword="Parse" />または<see langword="TryParse" />メソッド、コンス トラクター、または文字列から型のインスタンスをインスタンス化するいくつかその他の静的メソッド)、によって返される文字列を確認する必要がある、<see cref="M:System.Object.ToString" />メソッドを指定できますオブジェクトのインスタンスに変換されます。</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>