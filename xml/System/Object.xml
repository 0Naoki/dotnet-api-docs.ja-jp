<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="20858d8f3a77386f2e8091f66a99f0a104d2e86b" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39766560" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="041e9-101">.NET Framework クラス階層のすべてのクラスをサポートし、派生クラスに下位レベルのサービスを提供します。</span>
      <span class="sxs-lookup">
        <span data-stu-id="041e9-101">Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes.</span>
      </span>
      <span data-ttu-id="041e9-102">これは、.NET Framework の全クラスの基本クラスであり、型階層のルートです。</span>
      <span class="sxs-lookup">
        <span data-stu-id="041e9-102">This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="041e9-103">通常の言語は、クラスからの継承を宣言する必要ありません<xref:System.Object>継承は暗黙的なためです。</span><span class="sxs-lookup"><span data-stu-id="041e9-103">Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit.</span></span>  
  
 <span data-ttu-id="041e9-104">.NET Framework のすべてのクラスから派生しているため<xref:System.Object>で定義されているすべてのメソッド、<xref:System.Object>クラスは、システム内のすべてのオブジェクトで使用できます。</span><span class="sxs-lookup"><span data-stu-id="041e9-104">Because all classes in the .NET Framework are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system.</span></span> <span data-ttu-id="041e9-105">派生クラスと、これらのメソッドの一部をオーバーライドしないでください。</span><span class="sxs-lookup"><span data-stu-id="041e9-105">Derived classes can and do override some of these methods, including:</span></span>  
  
-   <span data-ttu-id="041e9-106"><xref:System.Object.Equals%2A> -オブジェクト間の比較をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="041e9-106"><xref:System.Object.Equals%2A> - Supports comparisons between objects.</span></span>  
  
-   <span data-ttu-id="041e9-107"><xref:System.Object.Finalize%2A> -オブジェクトが自動的にクリアされる前に、クリーンアップ操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="041e9-107"><xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed.</span></span>  
  
-   <span data-ttu-id="041e9-108"><xref:System.Object.GetHashCode%2A> -ハッシュ テーブルの使用をサポートするために、オブジェクトの値に対応する番号を生成します。</span><span class="sxs-lookup"><span data-stu-id="041e9-108"><xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table.</span></span>  
  
-   <span data-ttu-id="041e9-109"><xref:System.Object.ToString%2A> -クラスのインスタンスを記述する人間が判読できるテキスト文字列を製造しています。</span><span class="sxs-lookup"><span data-stu-id="041e9-109"><xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="041e9-110">パフォーマンスに関する考慮事項</span><span class="sxs-lookup"><span data-stu-id="041e9-110">Performance Considerations</span></span>  
 <span data-ttu-id="041e9-111">インスタンスを受け取るクラスのメンバーを作成するには、どの型のオブジェクトを処理する必要があります、コレクションなどのクラスを設計する場合、<xref:System.Object>クラス。</span><span class="sxs-lookup"><span data-stu-id="041e9-111">If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class.</span></span> <span data-ttu-id="041e9-112">ただし、ボックス化と型をボックス化解除のプロセスは、パフォーマンス コストを実行します。</span><span class="sxs-lookup"><span data-stu-id="041e9-112">However, the process of boxing and unboxing a type carries a performance cost.</span></span> <span data-ttu-id="041e9-113">新しいクラスの特定の値型を頻繁に処理することがわかっている場合は、ボックス化のコストを最小限に 2 つの方針のいずれかを使用できます。</span><span class="sxs-lookup"><span data-stu-id="041e9-113">If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</span></span>  
  
-   <span data-ttu-id="041e9-114">受け取る一般的なメソッドを作成、<xref:System.Object>型、および一連の頻繁に処理するクラスを期待する各値の型をそのまま使用する型固有のメソッド オーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="041e9-114">Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</span></span> <span data-ttu-id="041e9-115">呼び出し元のパラメーター型を受け取る型固有のメソッドが存在する場合は、ボックス化は発生せず、型固有のメソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="041e9-115">If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</span></span> <span data-ttu-id="041e9-116">呼び出し元のパラメーター型と一致するメソッドの引数がない場合は、パラメーターがボックス化され、一般的なメソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="041e9-116">If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</span></span>  
  
-   <span data-ttu-id="041e9-117">ジェネリックを使用するには、型とそのメンバーをデザインします。</span><span class="sxs-lookup"><span data-stu-id="041e9-117">Design your type and its members to use generics.</span></span> <span data-ttu-id="041e9-118">共通言語ランタイムは、クラスのインスタンスを作成し、ジェネリック型引数を指定するときに、クローズ ジェネリック型を作成します。</span><span class="sxs-lookup"><span data-stu-id="041e9-118">The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</span></span> <span data-ttu-id="041e9-119">ジェネリック メソッドの種類に固有であり、呼び出し元のパラメーターをボックス化せずに呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="041e9-119">The generic method is type-specific and can be invoked without boxing the calling parameter.</span></span>  
  
 <span data-ttu-id="041e9-120">受け入れて返す汎用クラスの開発に必要な場合がありますが<xref:System.Object>型も型固有のクラスが頻繁に使用される型を処理するために提供することでパフォーマンスを向上できます。</span><span class="sxs-lookup"><span data-stu-id="041e9-120">Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</span></span> <span data-ttu-id="041e9-121">たとえば、固有の設定とブール値を取得するクラスを提供するブール値のボックス化とボックス化解除のコストを排除します。</span><span class="sxs-lookup"><span data-stu-id="041e9-121">For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="041e9-122">次の例から派生したポイントの種類の定義、<xref:System.Object>クラスし、多くの仮想メソッドのオーバーライド、<xref:System.Object>クラス。</span><span class="sxs-lookup"><span data-stu-id="041e9-122">The following example defines a Point type derived from the <xref:System.Object> class and overrides many of the virtual methods of the <xref:System.Object> class.</span></span> <span data-ttu-id="041e9-123">さらに、例は、静的なの多くを呼び出す方法を示しています。 インスタンスのメソッドと、<xref:System.Object>クラス。</span><span class="sxs-lookup"><span data-stu-id="041e9-123">In addition, the example shows how to call many of the static and instance methods of the <xref:System.Object> class.</span></span>  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="041e9-124">パブリック静的 (<see langword="Shared" /> Visual Basic で) この型のメンバーはスレッド セーフです。</span>
      <span class="sxs-lookup">
        <span data-stu-id="041e9-124">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span>
      </span>
      <span data-ttu-id="041e9-125">インスタンス メンバーには、スレッド セーフであるとは限りません。</span>
      <span class="sxs-lookup">
        <span data-stu-id="041e9-125">Instance members are not guaranteed to be thread-safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="041e9-126">
            <see cref="T:System.Object" /> クラスの新しいインスタンスを初期化します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-126">Initializes a new instance of the <see cref="T:System.Object" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="041e9-127">このコンス トラクターは派生クラスでコンス トラクターによって呼び出されますが、直接のインスタンスを作成する使用することも、<xref:System.Object>クラス。</span><span class="sxs-lookup"><span data-stu-id="041e9-127">This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="041e9-128">2 つのオブジェクトのインスタンスが等しいかどうかを判断します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-128">Determines whether two object instances are equal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="041e9-129">現在のオブジェクトと比較するオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-129">The object to compare with the current object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="041e9-130">指定のオブジェクトが現在のオブジェクトと等しいかどうかを判断します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-130">Determines whether the specified object is equal to the current object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="041e9-131">指定したオブジェクトが現在のオブジェクトと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-131">
              <see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="041e9-132">現在のインスタンス間の比較の種類と`obj`パラメーターは、現在のインスタンスは、参照型または値型かどうかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="041e9-132">The type of comparison between the current instance and the `obj` parameter depends on whether the current instance is a reference type or a value type.</span></span>  
  
-   <span data-ttu-id="041e9-133">現在のインスタンスが、参照型の場合、<xref:System.Object.Equals%28System.Object%29>参照の等価性のテストのメソッドと呼び出しを<xref:System.Object.Equals%28System.Object%29>メソッドへの呼び出しには、<xref:System.Object.ReferenceEquals%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-133">If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="041e9-134">参照の等価性と比較されるオブジェクト変数が同じオブジェクトを参照していることを意味します。</span><span class="sxs-lookup"><span data-stu-id="041e9-134">Reference equality means that the object variables that are compared refer to the same object.</span></span> <span data-ttu-id="041e9-135">次の例は、このような比較の結果を示しています。</span><span class="sxs-lookup"><span data-stu-id="041e9-135">The following example illustrates the result of such a comparison.</span></span> <span data-ttu-id="041e9-136">定義、`Person`参照型である、クラスと呼び出し、`Person`新しい 2 つがインスタンス化するクラスのコンス トラクター`Person`オブジェクト、`person1a`と`person2`値が同じであります。</span><span class="sxs-lookup"><span data-stu-id="041e9-136">It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value.</span></span> <span data-ttu-id="041e9-137">割り当てます`person1a`別のオブジェクト変数に`person1b`します。</span><span class="sxs-lookup"><span data-stu-id="041e9-137">It also assigns `person1a` to another object variable, `person1b`.</span></span> <span data-ttu-id="041e9-138">例を示しますから出力として`person1a`と`person1b`が同じオブジェクトを参照するために等しい。</span><span class="sxs-lookup"><span data-stu-id="041e9-138">As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object.</span></span> <span data-ttu-id="041e9-139">ただし、`person1a`と`person2`が、同じ値が等しいか、ありません。</span><span class="sxs-lookup"><span data-stu-id="041e9-139">However, `person1a` and `person2` are not equal, although they have the same value.</span></span>  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   <span data-ttu-id="041e9-140">現在のインスタンスが値の型の場合、<xref:System.Object.Equals%28System.Object%29>メソッドの値の等価性を調べます。</span><span class="sxs-lookup"><span data-stu-id="041e9-140">If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality.</span></span> <span data-ttu-id="041e9-141">値の等価性には、次のことを意味します。</span><span class="sxs-lookup"><span data-stu-id="041e9-141">Value equality means the following:</span></span>  
  
    -   <span data-ttu-id="041e9-142">2 つのオブジェクトでは、同じ型です。</span><span class="sxs-lookup"><span data-stu-id="041e9-142">The two objects are of the same type.</span></span> <span data-ttu-id="041e9-143">次の例に示すように、 <xref:System.Byte> 12 の値を持つオブジェクトが等しくない、<xref:System.Int32>を 2 つのオブジェクトがある実行時の型が異なるため、12 の値を持つオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="041e9-143">As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.</span></span>  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   <span data-ttu-id="041e9-144">2 つのオブジェクトのパブリックおよびプライベート フィールドの値が等しいです。</span><span class="sxs-lookup"><span data-stu-id="041e9-144">The values of the public and private fields of the two objects are equal.</span></span> <span data-ttu-id="041e9-145">次の例は、値の等価性をテストします。</span><span class="sxs-lookup"><span data-stu-id="041e9-145">The following example tests for value equality.</span></span> <span data-ttu-id="041e9-146">定義、`Person`構造体、値型であると呼び出し、`Person`新しい 2 つがインスタンス化するクラスのコンス トラクター`Person`オブジェクト、`person1`と`person2`値が同じであります。</span><span class="sxs-lookup"><span data-stu-id="041e9-146">It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value.</span></span> <span data-ttu-id="041e9-147">別のオブジェクトを参照してください、2 つのオブジェクト変数が、例の出力に示すよう`person1`と`person2`がプライベートの同じ値があるために等しい`personName`フィールド。</span><span class="sxs-lookup"><span data-stu-id="041e9-147">As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field.</span></span>  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 <span data-ttu-id="041e9-148"><xref:System.Object>クラスは、.NET Framework のすべての型の基本クラス、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッドは、他のすべての種類の既定の等値比較を提供します。</span><span class="sxs-lookup"><span data-stu-id="041e9-148">Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method provides the default equality comparison for all other types.</span></span> <span data-ttu-id="041e9-149">型が多くの場合、オーバーライド、ただし、<xref:System.Object.Equals%2A>値の等価性を実装するメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-149">However, types often override the <xref:System.Object.Equals%2A> method to implement value equality.</span></span> <span data-ttu-id="041e9-150">詳細については、ノートを呼び出し元とノート セクションでは継承クラスの参照します。</span><span class="sxs-lookup"><span data-stu-id="041e9-150">For more information, see the Notes for Callers and Notes for Inheritors sections.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="041e9-151">ノートには、 [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="041e9-151">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="041e9-152">呼び出すと、<xref:System.Object.Equals%28System.Object%29>内のクラスのメソッドのオーバー ロード、 [!INCLUDE[wrt](~/includes/wrt-md.md)]、既定の動作をオーバーライドしないクラスを提供します<xref:System.Object.Equals%28System.Object%29>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-152">When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="041e9-153">これは、.NET Framework では、サポートの一部、 [!INCLUDE[wrt](~/includes/wrt-md.md)] (を参照してください[フレームワークをサポートして Windows ストア アプリ用 .NET と Windows ランタイム](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。</span><span class="sxs-lookup"><span data-stu-id="041e9-153">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="041e9-154">クラス、[!INCLUDE[wrt](~/includes/wrt-md.md)]継承しない<xref:System.Object>、現在実装されていないと、<xref:System.Object.Equals%28System.Object%29>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-154">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and currently don’t implement an <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="041e9-155">ただし、あるように見えます<xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>と<xref:System.Object.GetHashCode%2A>メソッド、c# または Visual Basic のコードで使用すると、.NET Framework は、これらのメソッドの既定の動作を提供します。</span><span class="sxs-lookup"><span data-stu-id="041e9-155">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]<span data-ttu-id="041e9-156"> c# または Visual Basic で記述されたクラスでオーバーライドできます、<xref:System.Object.Equals%28System.Object%29>メソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="041e9-156"> classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload.</span></span>  
  
## <a name="notes-for-callers"></a><span data-ttu-id="041e9-157">呼び出し元のノート</span><span class="sxs-lookup"><span data-stu-id="041e9-157">Notes for Callers</span></span>  
 <span data-ttu-id="041e9-158">派生クラスでオーバーライドよく、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>値の等価性を実装するメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-158">Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to implement value equality.</span></span> <span data-ttu-id="041e9-159">さらに、型でも頻繁に追加の厳密に型指定されたオーバー ロードが提供、`Equals`メソッドを実装することで、通常、<xref:System.IEquatable%601>インターフェイス。</span><span class="sxs-lookup"><span data-stu-id="041e9-159">In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="041e9-160">呼び出すと、`Equals`等しいかどうかをテストするメソッド、現在のインスタンスを上書きするかどうかを知っておくべき<xref:System.Object.Equals%2A?displayProperty=nameWithType>に特定の呼び出し方法を理解して、`Equals`メソッドが解決します。</span><span class="sxs-lookup"><span data-stu-id="041e9-160">When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType> and understand how a particular call to an `Equals` method is resolved.</span></span> <span data-ttu-id="041e9-161">それ以外の場合、意図したものとは異なる等価性テストを実行して、メソッドは、予期しない値を返す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="041e9-161">Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</span></span>  
  
 <span data-ttu-id="041e9-162">具体的な例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="041e9-162">The following example provides an illustration.</span></span> <span data-ttu-id="041e9-163">3 つのインスタンス化します<xref:System.Text.StringBuilder>で同一の文字列オブジェクトし、する 4 つの呼び出しを行い、`Equals`メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-163">It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods.</span></span> <span data-ttu-id="041e9-164">最初のメソッド呼び出しを返します。 `true`、および残りの 3 つの戻り値`false`します。</span><span class="sxs-lookup"><span data-stu-id="041e9-164">The first method call returns `true`, and the remaining three return `false`.</span></span>  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 <span data-ttu-id="041e9-165">厳密に型指定の最初のケースで<xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType>値の等価性をテストするメソッド オーバー ロードが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="041e9-165">In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> method overload, which tests for value equality, is called.</span></span> <span data-ttu-id="041e9-166">2 つの文字列が割り当てられるため、<xref:System.Text.StringBuilder>オブジェクトが等しい、メソッドを返します`true`します。</span><span class="sxs-lookup"><span data-stu-id="041e9-166">Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`.</span></span> <span data-ttu-id="041e9-167">ただし、<xref:System.Text.StringBuilder>をオーバーライドしない<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-167">However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="041e9-168">このため、ときに、<xref:System.Text.StringBuilder>オブジェクトにキャスト、<xref:System.Object>ときに、<xref:System.Text.StringBuilder>インスタンスが型の変数に割り当てられている<xref:System.Object>とタイミング、<xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>メソッドが渡される 2 つ<xref:System.Text.StringBuilder>オブジェクト、既定<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="041e9-168">Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="041e9-169"><xref:System.Text.StringBuilder> 、参照型では、これは、2 つを渡すことに相当<xref:System.Text.StringBuilder>オブジェクトを<xref:System.Object.ReferenceEquals%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-169">Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="041e9-170">3 つすべて<xref:System.Text.StringBuilder>オブジェクトが同一の文字列を含む、3 つの異なるオブジェクトを参照しています。</span><span class="sxs-lookup"><span data-stu-id="041e9-170">Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects.</span></span> <span data-ttu-id="041e9-171">その結果、これら 3 つのメソッド呼び出しを返す`false`します。</span><span class="sxs-lookup"><span data-stu-id="041e9-171">As a result, these three method calls return `false`.</span></span>  
  
 <span data-ttu-id="041e9-172">現在のオブジェクトを別のオブジェクト参照の等価性を比較するには呼び出すことによって、<xref:System.Object.ReferenceEquals%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-172">You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="041e9-173">Visual basic で使用することも、`is`キーワード (たとえば、 `If Me Is otherObject Then ...`)。</span><span class="sxs-lookup"><span data-stu-id="041e9-173">In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`).</span></span>  
  
## <a name="notes-for-inheritors"></a><span data-ttu-id="041e9-174">継承時の注意</span><span class="sxs-lookup"><span data-stu-id="041e9-174">Notes for Inheritors</span></span>  
 <span data-ttu-id="041e9-175">その型が継承によって定義されている機能で、独自の型を定義するときに、`Equals`その基本型のメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-175">When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type.</span></span> <span data-ttu-id="041e9-176">次の表の既定の実装、`Equals`の主要なカテゴリを .NET Framework 型のメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-176">The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework.</span></span>  
  
|<span data-ttu-id="041e9-177">型のカテゴリ</span><span class="sxs-lookup"><span data-stu-id="041e9-177">Type category</span></span>|<span data-ttu-id="041e9-178">によって定義される等価性</span><span class="sxs-lookup"><span data-stu-id="041e9-178">Equality defined by</span></span>|<span data-ttu-id="041e9-179">コメント</span><span class="sxs-lookup"><span data-stu-id="041e9-179">Comments</span></span>|  
|-------------------|-------------------------|--------------|  
|<span data-ttu-id="041e9-180">直接派生したクラス <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="041e9-180">Class derived directly from <xref:System.Object></span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="041e9-181">参照の等価性。呼び出しに相当<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-181">Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span></span>|  
|<span data-ttu-id="041e9-182">構造体</span><span class="sxs-lookup"><span data-stu-id="041e9-182">Structure</span></span>|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="041e9-183">値の等価性。直接バイト単位の比較またはリフレクションを使用してフィールドを比較します。</span><span class="sxs-lookup"><span data-stu-id="041e9-183">Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</span></span>|  
|<span data-ttu-id="041e9-184">列挙</span><span class="sxs-lookup"><span data-stu-id="041e9-184">Enumeration</span></span>|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="041e9-185">値は、同じ列挙型と同じ基になる値が必要です。</span><span class="sxs-lookup"><span data-stu-id="041e9-185">Values must have the same enumeration type and the same underlying value.</span></span>|  
|<span data-ttu-id="041e9-186">Delegate</span><span class="sxs-lookup"><span data-stu-id="041e9-186">Delegate</span></span>|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="041e9-187">デリゲートには、同一の呼び出しリストと同じ型が必要です。</span><span class="sxs-lookup"><span data-stu-id="041e9-187">Delegates must have the same type with identical invocation lists.</span></span>|  
|<span data-ttu-id="041e9-188">Interface</span><span class="sxs-lookup"><span data-stu-id="041e9-188">Interface</span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="041e9-189">参照の等価性。</span><span class="sxs-lookup"><span data-stu-id="041e9-189">Reference equality.</span></span>|  
  
 <span data-ttu-id="041e9-190">オーバーライドする常に、値型の<xref:System.Object.Equals%2A>リフレクションに依存するテストが等しいかどうかは、パフォーマンスの低下を提供します。</span><span class="sxs-lookup"><span data-stu-id="041e9-190">For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance.</span></span> <span data-ttu-id="041e9-191">既定の実装をオーバーライドすることもできます。<xref:System.Object.Equals%2A>参照型参照の等価性ではなく値の等価性をテストすると、値の等価性の正確な意味を定義します。</span><span class="sxs-lookup"><span data-stu-id="041e9-191">You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</span></span> <span data-ttu-id="041e9-192">このような実装の<xref:System.Object.Equals%2A>返す`true`同じインスタンスでない場合でも、2 つのオブジェクトが同じの値があるかどうか。</span><span class="sxs-lookup"><span data-stu-id="041e9-192">Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance.</span></span> <span data-ttu-id="041e9-193">型の実行者は、オブジェクトの値を構成するものを決定する、通常は、一部またはすべてのデータ オブジェクトのインスタンス変数に格納されています。</span><span class="sxs-lookup"><span data-stu-id="041e9-193">The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</span></span> <span data-ttu-id="041e9-194">値など、<xref:System.String>オブジェクトは、文字列の文字に基づいて、<xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType>メソッドのオーバーライド、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>を返すメソッドを`true`いずれかの 2 つの文字列と同じ順序で同じ文字が含まれているインスタンス。</span><span class="sxs-lookup"><span data-stu-id="041e9-194">For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to return `true` for any two string instances that contain the same characters in the same order.</span></span>  
  
 <span data-ttu-id="041e9-195">次の例は、オーバーライドする方法を示します、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>値の等価性をテストするメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-195">The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to test for value equality.</span></span> <span data-ttu-id="041e9-196">これは、上書き、<xref:System.Object.Equals%2A>のメソッド、`Person`クラス。</span><span class="sxs-lookup"><span data-stu-id="041e9-196">It overrides the <xref:System.Object.Equals%2A> method for the `Person` class.</span></span> <span data-ttu-id="041e9-197">場合`Person`等しいかどうかの基本クラス実装を受け入れられる 2 つ`Person`オブジェクトは 1 つのオブジェクトが参照されている場合のみ等しいとなります。</span><span class="sxs-lookup"><span data-stu-id="041e9-197">If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object.</span></span> <span data-ttu-id="041e9-198">ただし、ここでは 2 つ`Person`オブジェクトが同じ値を持つ場合に等価、`Person.Id`プロパティ。</span><span class="sxs-lookup"><span data-stu-id="041e9-198">However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property.</span></span>  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 <span data-ttu-id="041e9-199">オーバーライドするだけでなく<xref:System.Object.Equals%2A>、実装することができます、<xref:System.IEquatable%601>等しいかどうかを厳密に型指定されたテストを提供するインターフェイス。</span><span class="sxs-lookup"><span data-stu-id="041e9-199">In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality.</span></span>  
  
 <span data-ttu-id="041e9-200">次のステートメントは、のすべての実装の場合は true である必要があります、<xref:System.Object.Equals%28System.Object%29>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-200">The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="041e9-201">一覧で、 `x`、 `y`、および`z`れていないオブジェクト参照を表す**null**します。</span><span class="sxs-lookup"><span data-stu-id="041e9-201">In the list, `x`, `y`, and `z` represent object references that are not **null**.</span></span>  
  
-   <span data-ttu-id="041e9-202">`x.Equals(x)` 返します`true`、浮動小数点型に関連する場合は除きます。</span><span class="sxs-lookup"><span data-stu-id="041e9-202">`x.Equals(x)` returns `true`, except in cases that involve floating-point types.</span></span> <span data-ttu-id="041e9-203">ISO と IEC/IEEE 60559:2011、情報技術--マイクロプロセッサ システム - 浮動小数点演算を参照してください。</span><span class="sxs-lookup"><span data-stu-id="041e9-203">See ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic.</span></span>  
  
-   <span data-ttu-id="041e9-204">`x.Equals(y)` 同じ値を返します`y.Equals(x)`します。</span><span class="sxs-lookup"><span data-stu-id="041e9-204">`x.Equals(y)` returns the same value as `y.Equals(x)`.</span></span>  
  
-   <span data-ttu-id="041e9-205">`x.Equals(y)` 返します`true`両方`x`と`y`は`NaN`します。</span><span class="sxs-lookup"><span data-stu-id="041e9-205">`x.Equals(y)` returns `true` if both `x` and `y` are `NaN`.</span></span>  
  
-   <span data-ttu-id="041e9-206">場合`(x.Equals(y) && y.Equals(z))`返します`true`、し`x.Equals(z)`返します`true`します。</span><span class="sxs-lookup"><span data-stu-id="041e9-206">If `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.</span></span>  
  
-   <span data-ttu-id="041e9-207">連続して呼び出す`x.Equals(y)`によって参照されるオブジェクトと同じ値を返す`x`と`y`は変更されません。</span><span class="sxs-lookup"><span data-stu-id="041e9-207">Successive calls to `x.Equals(y)` return the same value as long as the objects referenced by `x` and `y` are not modified.</span></span>  
  
-   <span data-ttu-id="041e9-208">`x.Equals(null)` が `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="041e9-208">`x.Equals(null)` returns `false`.</span></span>  
  
 <span data-ttu-id="041e9-209">実装<xref:System.Object.Equals%2A>; 例外をスローする必要があります、常の値を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="041e9-209">Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value.</span></span> <span data-ttu-id="041e9-210">たとえば場合、`obj`は`null`、<xref:System.Object.Equals%2A>メソッドが返す必要があります`false`スローする代わりに、<xref:System.ArgumentNullException>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-210">For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>.</span></span>  
  
 <span data-ttu-id="041e9-211">オーバーライドする場合は、次のガイドラインをに従って<xref:System.Object.Equals%28System.Object%29>:</span><span class="sxs-lookup"><span data-stu-id="041e9-211">Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:</span></span>  
  
-   <span data-ttu-id="041e9-212">実装する型<xref:System.IComparable>オーバーライドする必要があります<xref:System.Object.Equals%28System.Object%29>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-212">Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>.</span></span>  
  
-   <span data-ttu-id="041e9-213">オーバーライドする型<xref:System.Object.Equals%28System.Object%29>もオーバーライドする必要があります<xref:System.Object.GetHashCode%2A>。 そうしないと、ハッシュ テーブルが正しく機能しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="041e9-213">Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly.</span></span>  
  
-   <span data-ttu-id="041e9-214">実装を検討する必要があります、<xref:System.IEquatable%601>強くをサポートするインターフェイスが等しいかどうかのテストを入力します。</span><span class="sxs-lookup"><span data-stu-id="041e9-214">You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality.</span></span> <span data-ttu-id="041e9-215"><xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>実装と一貫した結果を返す必要があります<xref:System.Object.Equals%2A>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-215">Your <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.</span></span>  
  
-   <span data-ttu-id="041e9-216">場合は、プログラミング言語が演算子のオーバー ロードをサポートしていると、指定された型に対して等値演算子をオーバー ロードする、オーバーライドすることも必要があります、<xref:System.Object.Equals%28System.Object%29>等値演算子と同じ結果を返します。</span><span class="sxs-lookup"><span data-stu-id="041e9-216">If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator.</span></span> <span data-ttu-id="041e9-217">これにより、そのクラスのライブラリ コードを使用することを確認<xref:System.Object.Equals%2A>(など<xref:System.Collections.ArrayList>と<xref:System.Collections.Hashtable>) アプリケーション コードでは、等値演算子の使用方法と整合性があるように動作します。</span><span class="sxs-lookup"><span data-stu-id="041e9-217">This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.</span></span>  
  
### <a name="guidelines-for-reference-types"></a><span data-ttu-id="041e9-218">参照型のガイドライン</span><span class="sxs-lookup"><span data-stu-id="041e9-218">Guidelines for Reference Types</span></span>  
 <span data-ttu-id="041e9-219">オーバーライドするに、次のガイドラインが適用<xref:System.Object.Equals%28System.Object%29>参照型。</span><span class="sxs-lookup"><span data-stu-id="041e9-219">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:</span></span>  
  
-   <span data-ttu-id="041e9-220">オーバーライドを検討<xref:System.Object.Equals%2A>場合、型のセマンティクスは、という事実に基づいての型がいくつかの値を表します。</span><span class="sxs-lookup"><span data-stu-id="041e9-220">Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s).</span></span>  
  
-   <span data-ttu-id="041e9-221">ほとんどの参照型でする必要がありますをオーバーライドする場合でもを等値演算子をオーバー ロードしない<xref:System.Object.Equals%2A>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-221">Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="041e9-222">ただしなど、複雑な数値型の値のセマンティクスを持つが想定されている参照型を実装している場合は、等値演算子をオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="041e9-222">However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</span></span>  
  
-   <span data-ttu-id="041e9-223">オーバーライドしないでください<xref:System.Object.Equals%2A>変更可能な参照型にします。</span><span class="sxs-lookup"><span data-stu-id="041e9-223">You should not override <xref:System.Object.Equals%2A> on a mutable reference type.</span></span> <span data-ttu-id="041e9-224">これは、オーバーライドするため<xref:System.Object.Equals%2A>もオーバーライドする必要があります、<xref:System.Object.GetHashCode%2A>メソッド、前のセクションで説明したようにします。</span><span class="sxs-lookup"><span data-stu-id="041e9-224">This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section.</span></span> <span data-ttu-id="041e9-225">これは、ハッシュ テーブルで、オブジェクトが失われた可能性がありますが、有効期間中に変更可能な参照型のインスタンスのハッシュ コードを変更できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="041e9-225">This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</span></span>  
  
### <a name="guidelines-for-value-types"></a><span data-ttu-id="041e9-226">値型のガイドライン</span><span class="sxs-lookup"><span data-stu-id="041e9-226">Guidelines for Value Types</span></span>  
 <span data-ttu-id="041e9-227">オーバーライドするに、次のガイドラインが適用<xref:System.Object.Equals%28System.Object%29>値型。</span><span class="sxs-lookup"><span data-stu-id="041e9-227">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:</span></span>  
  
-   <span data-ttu-id="041e9-228">1 つまたは複数のフィールドを含む値型を定義する場合は参照型の値が、オーバーライドする必要があります<xref:System.Object.Equals%28System.Object%29>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-228">If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="041e9-229"><xref:System.Object.Equals%28System.Object%29>実装によって提供される<xref:System.ValueType>値型がバイト単位の比較ではフィールドは、すべての値の型がリフレクションを使用して、フィールドが参照型を含む値型のフィールドの比較を実行します。</span><span class="sxs-lookup"><span data-stu-id="041e9-229">The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</span></span>  
  
-   <span data-ttu-id="041e9-230">オーバーライドする場合は<xref:System.Object.Equals%2A>演算子のオーバー ロードをサポートする開発言語とは、等値演算子をオーバー ロードする必要があります。</span><span class="sxs-lookup"><span data-stu-id="041e9-230">If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator.</span></span>  
  
-   <span data-ttu-id="041e9-231">実装する必要があります、<xref:System.IEquatable%601>インターフェイス。</span><span class="sxs-lookup"><span data-stu-id="041e9-231">You should implement the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="041e9-232">厳密に型指定された呼び出し<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>メソッドは、ボックス化を回避、`obj`引数。</span><span class="sxs-lookup"><span data-stu-id="041e9-232">Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> method avoids boxing the `obj` argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="041e9-233">次の例は、`Point`をオーバーライドするクラス、<xref:System.Object.Equals%2A>値の等価性を提供するメソッドと`Point3D`クラスから派生した`Point`。</span><span class="sxs-lookup"><span data-stu-id="041e9-233">The following example shows a `Point` class that overrides the <xref:System.Object.Equals%2A> method to provide value equality, and a `Point3D` class that is derived from `Point`.</span></span> <span data-ttu-id="041e9-234">`Point`オーバーライド<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>値の等価性をテストする、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッドは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="041e9-234">Because `Point` overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to test for value equality, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is not called.</span></span> <span data-ttu-id="041e9-235">ただし、`Point3D.Equals`呼び出し`Point.Equals`ため`Point`実装<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>値の等価性を提供するようにします。</span><span class="sxs-lookup"><span data-stu-id="041e9-235">However, `Point3D.Equals` calls `Point.Equals` because `Point` implements <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in a manner that provides value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 <span data-ttu-id="041e9-236">`Point.Equals`ことを確認する方法を確認します、`obj`引数がない**null**このオブジェクトと同じ型のインスタンスを参照しているとします。</span><span class="sxs-lookup"><span data-stu-id="041e9-236">The `Point.Equals` method checks to make sure that the `obj` argument is not **null** and that it references an instance of the same type as this object.</span></span> <span data-ttu-id="041e9-237">かどうか、いずれかのチェックが失敗した、メソッドを返します`false`します。</span><span class="sxs-lookup"><span data-stu-id="041e9-237">If either check fails, the method returns `false`.</span></span>  
  
 <span data-ttu-id="041e9-238">`Point.Equals`メソッドの呼び出し、<xref:System.Object.GetType%2A>する 2 つのオブジェクトのランタイム型が同じであるかどうかを判断するメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-238">The `Point.Equals` method calls the <xref:System.Object.GetType%2A> method to determine whether the run-time types of the two objects are identical.</span></span> <span data-ttu-id="041e9-239">メソッドは、フォームのチェックを使用する場合`obj is Point`(C#) または`TryCast(obj, Point)`Visual Basic の場合、チェックは返して`true`の場合、`obj`の派生クラスのインスタンスは、`Point`場合でも、`obj`と現在インスタンスは、同じ実行時の型のではありません。</span><span class="sxs-lookup"><span data-stu-id="041e9-239">If the method used a check of the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic, the check would return `true` in cases where `obj` is an instance of a derived class of `Point`, even though `obj` and the current instance are not of the same run-time type.</span></span> <span data-ttu-id="041e9-240">両方のオブジェクトが同じ型、メソッドのキャストのあることを確認したら`obj`入力`Point`し、2 つのオブジェクトのインスタンス フィールドを比較した結果を返します。</span><span class="sxs-lookup"><span data-stu-id="041e9-240">Having verified that both objects are of the same type, the method casts `obj` to type `Point` and returns the result of comparing the instance fields of the two objects.</span></span>  
  
 <span data-ttu-id="041e9-241">`Point3D.Equals`、継承した`Point.Equals`メソッドをオーバーライド<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>が、何を行う前に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="041e9-241">In `Point3D.Equals`, the inherited `Point.Equals` method, which overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, is invoked before anything else is done.</span></span> <span data-ttu-id="041e9-242">`Point3D`シール クラスは、(`NotInheritable` Visual Basic で)、チェックイン フォーム`obj is Point`(C#) または`TryCast(obj, Point)`Visual Basic では、ことを確認するための適切な`obj`は、`Point3D`オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="041e9-242">Because `Point3D` is a sealed class (`NotInheritable` in Visual Basic), a check in the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic is adequate to ensure that `obj` is a `Point3D` object.</span></span> <span data-ttu-id="041e9-243">ある場合、`Point3D`オブジェクトにキャストされた、`Point`オブジェクトし、の基本クラスの実装に渡される<xref:System.Object.Equals%2A>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-243">If it is a `Point3D` object, it is cast to a `Point` object and passed to the base class implementation of <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="041e9-244">場合にのみ、継承された`Point.Equals`メソッドを返します。`true`メソッドの比較には、`z`インスタンス フィールドを、派生クラスで導入されました。</span><span class="sxs-lookup"><span data-stu-id="041e9-244">Only when the inherited `Point.Equals` method returns `true` does the method compare the `z` instance fields introduced in the derived class.</span></span>  
  
 <span data-ttu-id="041e9-245">次の例では、定義、`Rectangle`として 2 つの四角形を内部的に実装するクラスを`Point`オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="041e9-245">The following example defines a `Rectangle` class that internally implements a rectangle as two `Point` objects.</span></span> <span data-ttu-id="041e9-246">`Rectangle`クラスにも上書き<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>値の等価性を提供します。</span><span class="sxs-lookup"><span data-stu-id="041e9-246">The `Rectangle` class also overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to provide for value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 <span data-ttu-id="041e9-247">C# および Visual Basic などの一部の言語では、演算子のオーバー ロードをサポートします。</span><span class="sxs-lookup"><span data-stu-id="041e9-247">Some languages such as C# and Visual Basic support operator overloading.</span></span> <span data-ttu-id="041e9-248">オーバーライドする必要がありますも、型は、等値演算子をオーバー ロード、ときに、<xref:System.Object.Equals%28System.Object%29>同じ機能を提供するメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-248">When a type overloads the equality operator, it must also override the <xref:System.Object.Equals%28System.Object%29> method to provide the same functionality.</span></span> <span data-ttu-id="041e9-249">記述することでこれは通常、<xref:System.Object.Equals%28System.Object%29>メソッドに関して次の例のように、オーバー ロードされた等値演算子。</span><span class="sxs-lookup"><span data-stu-id="041e9-249">This is typically accomplished by writing the <xref:System.Object.Equals%28System.Object%29> method in terms of the overloaded equality operator, as in the following example.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 <span data-ttu-id="041e9-250">`Complex`値型であるから得ることはできません。</span><span class="sxs-lookup"><span data-stu-id="041e9-250">Because `Complex` is a value type, it cannot be derived from.</span></span>  <span data-ttu-id="041e9-251">そのため、上書きを<xref:System.Object.Equals%28System.Object%29>メソッドを呼び出す必要はありません<xref:System.Object.GetType%2A>を確認する正確な実行時入力できますが、各オブジェクトの代わりに使用して、`is`演算子 (C#) または`TypeOf`の種類を確認するVisualbasicの演算子`obj`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="041e9-251">Therefore, the override to <xref:System.Object.Equals%28System.Object%29> method need not call <xref:System.Object.GetType%2A> to determine the precise run-time type of each object, but can instead use the `is` operator in C# or the `TypeOf` operator in Visual Basic to check the type of the `obj` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">
          <span data-ttu-id="041e9-252">比較対象の第 1 オブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-252">The first object to compare.</span>
          </span>
        </param>
        <param name="objB">
          <span data-ttu-id="041e9-253">2 番目に比較するオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-253">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="041e9-254">指定されたインスタンスが等しいかどうかを判断します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-254">Determines whether the specified object instances are considered equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="041e9-255">オブジェクトが等しいと見なされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-255">
              <see langword="true" /> if the objects are considered equal; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="041e9-256">
            <paramref name="objA" /> と <paramref name="objB" /> の両方が **null** の場合、このメソッドは <see langword="true" /> を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-256">If both <paramref name="objA" /> and <paramref name="objB" /> are **null**, the method returns <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="041e9-257">静的な<xref:System.Object.Equals%28System.Object%2CSystem.Object%29>かどうか 2 つのオブジェクト、メソッドを示します`objA`と`objB`が等しい。</span><span class="sxs-lookup"><span data-stu-id="041e9-257">The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal.</span></span> <span data-ttu-id="041e9-258">オブジェクトの値をテストすることもできます**null**等しいかどうか。</span><span class="sxs-lookup"><span data-stu-id="041e9-258">It also enables you to test objects whose value is **null** for equality.</span></span> <span data-ttu-id="041e9-259">比較`objA`と`objB`次のように等しいかどうか。</span><span class="sxs-lookup"><span data-stu-id="041e9-259">It compares `objA` and `objB` for equality as follows:</span></span>  
  
-   <span data-ttu-id="041e9-260">2 つのオブジェクトが同じオブジェクト参照を表すかどうかを決定します。</span><span class="sxs-lookup"><span data-stu-id="041e9-260">It determines whether the two objects represent the same object reference.</span></span> <span data-ttu-id="041e9-261">かどうかは、これらは、メソッドを返します`true`します。</span><span class="sxs-lookup"><span data-stu-id="041e9-261">If they do, the method returns `true`.</span></span> <span data-ttu-id="041e9-262">このテストの呼び出しと同じですが、<xref:System.Object.ReferenceEquals%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-262">This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="041e9-263">さらに、両方`objA`と`objB`は**null**、メソッドを返します`true`します。</span><span class="sxs-lookup"><span data-stu-id="041e9-263">In addition, if both `objA` and `objB` are **null**, the method returns `true`.</span></span>  
  
-   <span data-ttu-id="041e9-264">判断したかどうか`objA`または`objB`は**null**。</span><span class="sxs-lookup"><span data-stu-id="041e9-264">It determines whether either `objA` or `objB` is **null**.</span></span> <span data-ttu-id="041e9-265">そのため、返された場合`false`します。</span><span class="sxs-lookup"><span data-stu-id="041e9-265">If so, it returns `false`.</span></span>  
  
-   <span data-ttu-id="041e9-266">2 つのオブジェクトは、同じオブジェクト参照を表していないかどうか、およびはどちらも**null**、呼び出す`objA`.`Equals`(`objB`) し、結果を返します。</span><span class="sxs-lookup"><span data-stu-id="041e9-266">If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result.</span></span> <span data-ttu-id="041e9-267">つまり、`objA`オーバーライド、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>メソッドでは、このオーバーライドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="041e9-267">This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, this override is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="041e9-268">次の例を示しています、<xref:System.Object.Equals%28System.Object%2CSystem.Object%29>メソッドとの比較、<xref:System.Object.ReferenceEquals%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-268">The following example illustrates the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method and compares it with the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="041e9-269">オブジェクトがガベージ コレクションにより収集される前に、そのオブジェクトがリソースを解放し、その他のクリーンアップ操作を実行できるようにします。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-269">Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="041e9-270"><xref:System.Object.Finalize%2A>オブジェクトが破棄される前に、現在のオブジェクトによって保持されているアンマネージ リソースのクリーンアップ操作を実行するメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="041e9-270">The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</span></span> <span data-ttu-id="041e9-271">メソッドが保護されているし、そのため、このクラスまたは派生クラスからのみアクセスできますが。</span><span class="sxs-lookup"><span data-stu-id="041e9-271">The method is protected and therefore is accessible only through this class or through a derived class.</span></span>  
  
 <span data-ttu-id="041e9-272">このセクションの内容:</span><span class="sxs-lookup"><span data-stu-id="041e9-272">In this section:</span></span>  
  
-   [<span data-ttu-id="041e9-273">終了処理のしくみ</span><span class="sxs-lookup"><span data-stu-id="041e9-273">How finalization works</span></span>](#How)  
  
-   [<span data-ttu-id="041e9-274">実装についてのメモ</span><span class="sxs-lookup"><span data-stu-id="041e9-274">Notes for implementers</span></span>](#Notes)  
  
-   [<span data-ttu-id="041e9-275">SafeHandle の代替手段</span><span class="sxs-lookup"><span data-stu-id="041e9-275">The SafeHandle alternative</span></span>](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a><span data-ttu-id="041e9-276">終了処理のしくみ</span><span class="sxs-lookup"><span data-stu-id="041e9-276">How finalization works</span></span>  
 <span data-ttu-id="041e9-277"><xref:System.Object>クラスの実装を提供しない、<xref:System.Object.Finalize%2A>メソッド、およびガベージ コレクターから派生した型をマークしません<xref:System.Object>終了がオーバーライドされない限り、<xref:System.Object.Finalize%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-277">The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 <span data-ttu-id="041e9-278">型をオーバーライドする場合、<xref:System.Object.Finalize%2A>ファイナライズのキューと呼ばれる内部構造をメソッド、ガベージ コレクターは追加型の各インスタンスのエントリ。</span><span class="sxs-lookup"><span data-stu-id="041e9-278">If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</span></span> <span data-ttu-id="041e9-279">ファイナライザーのキューには、ガベージ コレクターが、メモリを解放する前に終了コードを実行する必要があります、マネージ ヒープ内のすべてのオブジェクトのエントリが含まれています。</span><span class="sxs-lookup"><span data-stu-id="041e9-279">The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</span></span> <span data-ttu-id="041e9-280">ガベージ コレクターを呼び出して、<xref:System.Object.Finalize%2A>メソッドは、次の条件下で自動的に。</span><span class="sxs-lookup"><span data-stu-id="041e9-280">The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:</span></span>  
  
-   <span data-ttu-id="041e9-281">ガベージ コレクターが、オブジェクトがへの呼び出しで終了処理から除外されていない場合に、オブジェクトが、アクセスできないことを検出した後、<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-281">After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="041e9-282">**.NET Framework のみで**、アプリケーション ドメインのシャット ダウン中に、オブジェクトが終了処理から除外しない限り、します。</span><span class="sxs-lookup"><span data-stu-id="041e9-282">**On .NET Framework only**, during shutdown of an application domain, unless the object is exempt from finalization.</span></span> <span data-ttu-id="041e9-283">シャット ダウン中、引き続きアクセス可能であるものオブジェクトが完了します。</span><span class="sxs-lookup"><span data-stu-id="041e9-283">During shutdown, even objects that are still accessible are finalized.</span></span>  
  
 <span data-ttu-id="041e9-284"><xref:System.Object.Finalize%2A> 自動的に 1 回だけ呼び出す特定のインスタンスで、オブジェクトが再などのメカニズムを使用して、登録されている場合を除き、<xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType>と<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>メソッドが、その後に呼び出されていません。</span><span class="sxs-lookup"><span data-stu-id="041e9-284"><xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method has not been subsequently called.</span></span>  
  
 <span data-ttu-id="041e9-285"><xref:System.Object.Finalize%2A> 操作には、次の制限があります。</span><span class="sxs-lookup"><span data-stu-id="041e9-285"><xref:System.Object.Finalize%2A> operations have the following limitations:</span></span>  
  
-   <span data-ttu-id="041e9-286">ファイナライザーが実行される場合の正確な時間が定義されていません。</span><span class="sxs-lookup"><span data-stu-id="041e9-286">The exact time when the finalizer executes is undefined.</span></span> <span data-ttu-id="041e9-287">リソースの確定的解放をことを確認し、クラスのインスタンスを実装する、`Close`メソッドを提供または、<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>実装します。</span><span class="sxs-lookup"><span data-stu-id="041e9-287">To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
-   <span data-ttu-id="041e9-288">2 つのオブジェクトのファイナライザーは、1 つのオブジェクトを参照する他の場合でも、特定の順序で実行する保証はありません。</span><span class="sxs-lookup"><span data-stu-id="041e9-288">The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</span></span> <span data-ttu-id="041e9-289">オブジェクト A がオブジェクト B への参照を両方ファイナライザーがある場合は、オブジェクト B が既にファイナライズされているオブジェクトのファイナライザーの開始時にします。</span><span class="sxs-lookup"><span data-stu-id="041e9-289">That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</span></span>  
  
-   <span data-ttu-id="041e9-290">ファイナライザーが実行されているスレッドでは、指定されていません。</span><span class="sxs-lookup"><span data-stu-id="041e9-290">The thread on which the finalizer runs is unspecified.</span></span>  
  
 <span data-ttu-id="041e9-291"><xref:System.Object.Finalize%2A>メソッドが完了するまで実行されない、または次の例外的な状況ではまったく実行されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="041e9-291">The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:</span></span>  
  
-   <span data-ttu-id="041e9-292">別のファイナライザーを無期限にブロックする場合 (そのことはありません取得して、ロックを取得しようと、無限ループになる)。</span><span class="sxs-lookup"><span data-stu-id="041e9-292">If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</span></span> <span data-ttu-id="041e9-293">ランタイムがファイナライザーの実行を完了しようとするとため、その他のファイナライザーが呼び出されません場合、ファイナライザーがブロック無期限にします。</span><span class="sxs-lookup"><span data-stu-id="041e9-293">Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</span></span>  
  
-   <span data-ttu-id="041e9-294">場合は、ランタイムをクリーンアップする機会を与えることがなく、プロセスを終了します。</span><span class="sxs-lookup"><span data-stu-id="041e9-294">If the process terminates without giving the runtime a chance to clean up.</span></span> <span data-ttu-id="041e9-295">この場合、ランタイムの最初の通知プロセスの終了は DLL_PROCESS_DETACH 通知です。</span><span class="sxs-lookup"><span data-stu-id="041e9-295">In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</span></span>  
  
 <span data-ttu-id="041e9-296">ランタイムは、ファイナライズ可能なオブジェクトの数が減少し続けます中にのみシャット ダウン中にオブジェクトの終了が続行されます。</span><span class="sxs-lookup"><span data-stu-id="041e9-296">The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</span></span>  
  
 <span data-ttu-id="041e9-297">場合<xref:System.Object.Finalize%2A>またはのオーバーライドを<xref:System.Object.Finalize%2A>、例外をスローし、ランタイムが、既定のポリシーをオーバーライドするアプリケーションによってホストされていない、プロセスとはアクティブなランタイムが終了する`try` / `finally`ブロックまたはファイナライザーが実行されます。</span><span class="sxs-lookup"><span data-stu-id="041e9-297">If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed.</span></span> <span data-ttu-id="041e9-298">この動作は、ファイナライザーが解放またはリソースを破棄できない場合にプロセスの整合性を保証します。</span><span class="sxs-lookup"><span data-stu-id="041e9-298">This behavior ensures process integrity if the finalizer cannot free or destroy resources.</span></span>  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a><span data-ttu-id="041e9-299">Finalize メソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="041e9-299">Overriding the Finalize method</span></span> 
 <span data-ttu-id="041e9-300">オーバーライドする必要があります<xref:System.Object.Finalize%2A>のファイル ハンドルやガベージ コレクション中にそれらを使用するマネージ オブジェクトが破棄されたときに解放する必要がありますのあるデータベース接続などのアンマネージ リソースを使用するクラス。</span><span class="sxs-lookup"><span data-stu-id="041e9-300">You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</span></span> <span data-ttu-id="041e9-301">実装しないでください、<xref:System.Object.Finalize%2A>ガベージ コレクターがマネージ リソースを自動的に解放するためのメソッドがオブジェクトを管理します。</span><span class="sxs-lookup"><span data-stu-id="041e9-301">You shouldn't implement a <xref:System.Object.Finalize%2A> method for managed objects because the garbage collector releases managed resources automatically.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="041e9-302">場合、<xref:System.Runtime.InteropServices.SafeHandle>オブジェクトが使用可能なアンマネージ リソースをラップする、セーフ ハンドルの dispose パターンを実装し、無効にすることをお勧めの方法が<xref:System.Object.Finalize%2A>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-302">If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="041e9-303">詳細については、次を参照してください。[代わりに、SafeHandle](#SafeHandle)セクション。</span><span class="sxs-lookup"><span data-stu-id="041e9-303">For more information, see [The SafeHandle alternative](#SafeHandle) section.</span></span>  
  
 <span data-ttu-id="041e9-304"><xref:System.Object.Finalize%2A?displayProperty=nameWithType>メソッドは既定では、何しますが、オーバーライドする必要があります<xref:System.Object.Finalize%2A>必要に応じて、およびアンマネージ リソースを解放するだけである場合のみです。</span><span class="sxs-lookup"><span data-stu-id="041e9-304">The <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources.</span></span> <span data-ttu-id="041e9-305">メモリを再利用は、少なくとも 2 つのガベージ コレクションを必要とするために、終了処理操作を実行する場合にかなり長くかかる傾向があります。</span><span class="sxs-lookup"><span data-stu-id="041e9-305">Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</span></span> <span data-ttu-id="041e9-306">さらに、オーバーライドする必要があります、<xref:System.Object.Finalize%2A>メソッド参照の型だけです。</span><span class="sxs-lookup"><span data-stu-id="041e9-306">In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only.</span></span> <span data-ttu-id="041e9-307">共通言語ランタイムは、参照型のみを終了します。</span><span class="sxs-lookup"><span data-stu-id="041e9-307">The common language runtime only finalizes reference types.</span></span> <span data-ttu-id="041e9-308">値型にファイナライザーが無視されます。</span><span class="sxs-lookup"><span data-stu-id="041e9-308">It ignores finalizers on value types.</span></span>  

<span data-ttu-id="041e9-309">スコープ、<xref:System.Object.Finalize%2A?displayProperty=nameWithType>メソッドは`protected`します。</span><span class="sxs-lookup"><span data-stu-id="041e9-309">The scope of the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method is `protected`.</span></span> <span data-ttu-id="041e9-310">クラス内でこのメソッドをオーバーライドする場合は、このスコープの範囲を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="041e9-310">You should maintain this limited scope when you override the method in your class.</span></span> <span data-ttu-id="041e9-311">保持することで、<xref:System.Object.Finalize%2A>メソッドを protected に呼び出し元のオブジェクトから、アプリケーションのユーザーを防ぐ<xref:System.Object.Finalize%2A>メソッドを直接します。</span><span class="sxs-lookup"><span data-stu-id="041e9-311">By keeping a <xref:System.Object.Finalize%2A> method protected, you prevent users of your application from calling an object's <xref:System.Object.Finalize%2A> method directly.</span></span>
  
 <span data-ttu-id="041e9-312">すべての実装の<xref:System.Object.Finalize%2A>派生型の基本型の実装を呼び出す必要があります<xref:System.Object.Finalize%2A>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-312">Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="041e9-313">これを呼び出すアプリケーション コードが許可されている場合のみ<xref:System.Object.Finalize%2A>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-313">This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="041e9-314">オブジェクトの<xref:System.Object.Finalize%2A>メソッドは、基底クラスのそれ以外のすべてのオブジェクトに対するメソッドを呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="041e9-314">An object's <xref:System.Object.Finalize%2A> method shouldn't call a method on any objects other than that of its base class.</span></span> <span data-ttu-id="041e9-315">これは、共通言語ランタイムがシャットダウンされる場合など、呼び出し元のオブジェクトと呼び出された別のオブジェクトが同時にガベージ コレクションされることがあるからです。</span><span class="sxs-lookup"><span data-stu-id="041e9-315">This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</span></span> 
  
> [!NOTE]
>  <span data-ttu-id="041e9-316">C# コンパイラ オーバーライドはできません、<xref:System.Object.Finalize%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-316">The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="041e9-317">代わりに、実装することでファイナライザーを提供する、[デストラクター](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)クラス。</span><span class="sxs-lookup"><span data-stu-id="041e9-317">Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class.</span></span> <span data-ttu-id="041e9-318">C# のデストラクターは、その基底クラスのデストラクターを自動的に呼び出します。</span><span class="sxs-lookup"><span data-stu-id="041e9-318">A C# destructor automatically calls the destructor of its base class.</span></span>  
>   
>  <span data-ttu-id="041e9-319">Visual C を実装するため独自の構文を提供することも、<xref:System.Object.Finalize%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-319">Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="041e9-320">詳細については、の「デストラクターおよびファイナライザー」セクションを参照してください。[方法: 定義とクラスの使用、および構造体 (C +/cli CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)します。</span><span class="sxs-lookup"><span data-stu-id="041e9-320">For more information, see the "Destructors and finalizers" section of [How to: Define and Consume Classes and Structs (C++/CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span></span>  
  
 <span data-ttu-id="041e9-321">ガベージ コレクションは非決定的であるため、ガベージ コレクターがファイナライズを実行するときに正確にはおわからない場合。</span><span class="sxs-lookup"><span data-stu-id="041e9-321">Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</span></span> <span data-ttu-id="041e9-322">リソースを解放する、すぐに選択することできますも実装するために、 [dispose パターン](~/docs/standard/design-guidelines/dispose-pattern.md)と<xref:System.IDisposable>インターフェイス。</span><span class="sxs-lookup"><span data-stu-id="041e9-322">To release resources immediately, you can also choose to implement the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) and the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="041e9-323"><xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>実装を呼び出すことができるクラスのコンシューマーが、アンマネージ リソースを解放して、使用することができます、<xref:System.Object.Finalize%2A>アンマネージ リソースを解放するメソッドを<xref:System.IDisposable.Dispose%2A>メソッドは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="041e9-323">The <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.</span></span>  
  
 <span data-ttu-id="041e9-324"><xref:System.Object.Finalize%2A> ガベージ コレクション中にクリーンアップされた後に、(つまり、オブジェクトにアクセスできるように再度) オブジェクトを復活させる方法を含め、ほとんどすべてのアクションを実行することができます。</span><span class="sxs-lookup"><span data-stu-id="041e9-324"><xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</span></span> <span data-ttu-id="041e9-325">ただし、オブジェクトできますのみ再生できるは 1 回です。<xref:System.Object.Finalize%2A>ガベージ コレクション中に再生されたオブジェクトで呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="041e9-325">However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection.</span></span> <span data-ttu-id="041e9-326">1 つのアクションを実装の<xref:System.Object.Finalize%2A>かかることはありません: 例外をスローする必要がありますしません。</span><span class="sxs-lookup"><span data-stu-id="041e9-326">There is one action that your implementation of <xref:System.Object.Finalize%2A> should never take: it should never throw an exception.</span></span> <span data-ttu-id="041e9-327">メソッドによってスローされた例外がから呼び出された場合、<xref:System.Object.Finalize%2A>メソッドによって処理されない、<xref:System.Object.Finalize%2A>メソッド、ランタイムを想定、<xref:System.Object.Finalize%2A>メソッドが返され、呼び出しは引き続き、<xref:System.Object.Finalize%2A>他のオブジェクトのメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-327">If any exceptions thrown by methods called from the <xref:System.Object.Finalize%2A> method are unhandled by the <xref:System.Object.Finalize%2A> method, the runtime assumes that the <xref:System.Object.Finalize%2A> method returned and continues to call the <xref:System.Object.Finalize%2A> methods of other objects.</span></span> 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a><span data-ttu-id="041e9-328">代替手段としての SafeHandle</span><span class="sxs-lookup"><span data-stu-id="041e9-328">The SafeHandle alternative</span></span>  
 <span data-ttu-id="041e9-329">信頼性の高いファイナライザーを作成することが難しい、アプリケーションの状態に関する想定を行うことはできませんしなどのシステム例外をハンドルされていないため<xref:System.OutOfMemoryException>と<xref:System.StackOverflowException>ファイナライザーを終了します。</span><span class="sxs-lookup"><span data-stu-id="041e9-329">Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer.</span></span> <span data-ttu-id="041e9-330">派生したオブジェクトを使用するアンマネージ リソースを解放するには、クラスのファイナライザーを実装するには、代わりに、 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> 、アンマネージ リソースをラップするクラスし、ファイナライザーなしの dispose パターンを実装します。</span><span class="sxs-lookup"><span data-stu-id="041e9-330">Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</span></span> <span data-ttu-id="041e9-331">.NET Framework の次のクラスには、<xref:Microsoft.Win32?displayProperty=nameWithType>名前空間から派生した<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="041e9-331">The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=nameWithType> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span></span>  
  
-   <span data-ttu-id="041e9-332"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> ファイル ハンドルのラッパー クラスです。</span><span class="sxs-lookup"><span data-stu-id="041e9-332"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle.</span></span>  
  
-   <span data-ttu-id="041e9-333"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> メモリ マップト ファイル ハンドルのラッパー クラスです。</span><span class="sxs-lookup"><span data-stu-id="041e9-333"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles.</span></span>  
  
-   <span data-ttu-id="041e9-334"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> アンマネージ メモリ ブロックへのポインターのラッパー クラスです。</span><span class="sxs-lookup"><span data-stu-id="041e9-334"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory.</span></span>  
  
-   <span data-ttu-id="041e9-335"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>、 <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>、および<xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle>暗号化ハンドルのラッパー クラスします。</span><span class="sxs-lookup"><span data-stu-id="041e9-335"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles.</span></span>  
  
-   <span data-ttu-id="041e9-336"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> パイプ ハンドルのラッパー クラスです。</span><span class="sxs-lookup"><span data-stu-id="041e9-336"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles.</span></span>  
  
-   <span data-ttu-id="041e9-337"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> レジストリ キーを識別するハンドルのラッパー クラスです。</span><span class="sxs-lookup"><span data-stu-id="041e9-337"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key.</span></span>  
  
-   <span data-ttu-id="041e9-338"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 待機ハンドルのラッパー クラスです。</span><span class="sxs-lookup"><span data-stu-id="041e9-338"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle.</span></span>  
  
 <span data-ttu-id="041e9-339">次の例では、 [dispose パターン](~/docs/standard/design-guidelines/dispose-pattern.md)オーバーライドする代わりにセーフ ハンドルを使った、<xref:System.Object.Finalize%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-339">The following example uses the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="041e9-340">定義、`FileAssociation`特定のファイル拡張子を持つファイルを処理するアプリケーションのレジストリ情報をラップするクラス。</span><span class="sxs-lookup"><span data-stu-id="041e9-340">It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension.</span></span> <span data-ttu-id="041e9-341">として返される 2 つのレジストリ ハンドル`out`Windows によるパラメーター [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)に渡される関数呼び出し、<xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>コンス トラクター。</span><span class="sxs-lookup"><span data-stu-id="041e9-341">The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor.</span></span> <span data-ttu-id="041e9-342">型の保護された`Dispose`メソッドを呼び出して、`SafeRegistryHandle.Dispose`これら 2 つのハンドルを解放します。</span><span class="sxs-lookup"><span data-stu-id="041e9-342">The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles.</span></span>  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="041e9-343">次の例では、ことを確認、<xref:System.Object.Finalize%2A>オブジェクトをオーバーライドするときに、メソッドが呼び出された<xref:System.Object.Finalize%2A>は破棄されます。</span><span class="sxs-lookup"><span data-stu-id="041e9-343">The following example verifies that the <xref:System.Object.Finalize%2A> method is called when an object that overrides <xref:System.Object.Finalize%2A> is destroyed.</span></span> <span data-ttu-id="041e9-344">実稼働アプリケーションでそれに注意してください、<xref:System.Object.Finalize%2A>オブジェクトによって保持されているアンマネージ リソースを解放するメソッドはオーバーライドされます。</span><span class="sxs-lookup"><span data-stu-id="041e9-344">Note that, in a production application, the <xref:System.Object.Finalize%2A> method would be overridden to release unmanaged resources held by the object.</span></span> <span data-ttu-id="041e9-345">なお、c# の例がオーバーライドする代わりにデストラクターを提供する、<xref:System.Object.Finalize%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-345">Also note that the C# example provides a destructor instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 <span data-ttu-id="041e9-346">オーバーライドする例については、<xref:System.Object.Finalize%2A>メソッドを参照してください、<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-346">For an additional example that overrides the <xref:System.Object.Finalize%2A> method, see the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="041e9-347">既定のハッシュ関数として機能します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-347">Serves as the default hash function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="041e9-348">現在のオブジェクトのハッシュ コード。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-348">A hash code for the current object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="041e9-349">ハッシュ コードが挿入およびなどハッシュ ベースのコレクション内のオブジェクトを識別するために使用する数値、<xref:System.Collections.Generic.Dictionary%602>クラス、<xref:System.Collections.Hashtable>クラス、または型から派生した、<xref:System.Collections.DictionaryBase>クラス。</span><span class="sxs-lookup"><span data-stu-id="041e9-349">A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class.</span></span> <span data-ttu-id="041e9-350"><xref:System.Object.GetHashCode%2A>メソッドは、アルゴリズムのオブジェクトの等価性の簡単なチェックを必要があります。 このハッシュ コードを提供します。</span><span class="sxs-lookup"><span data-stu-id="041e9-350">The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="041e9-351">ハッシュ テーブルのハッシュ コードを使用する方法についての情報といくつかの追加のハッシュ コード アルゴリズムを参照してください、[ハッシュ関数](https://en.wikipedia.org/wiki/Hash_function)Wikipedia 内のエントリ。</span><span class="sxs-lookup"><span data-stu-id="041e9-351">For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](https://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia.</span></span>  
  
 <span data-ttu-id="041e9-352">等しいと同じ戻り値のハッシュ コードを 2 つのオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="041e9-352">Two objects that are equal return hash codes that are equal.</span></span> <span data-ttu-id="041e9-353">ただし、その逆は true。 (等しくない) の異なるオブジェクトが同一のハッシュ コードを持てないため、同じハッシュ コードをオブジェクトの等価性を意味しません。</span><span class="sxs-lookup"><span data-stu-id="041e9-353">However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</span></span> <span data-ttu-id="041e9-354">さらに、.NET Framework とは限りませんの既定の実装、<xref:System.Object.GetHashCode%2A>メソッド、およびこのメソッドで異なる場合がありますを返す .NET Framework のバージョンと 32 ビットおよび 64 ビットのプラットフォームなどのプラットフォームの値。</span><span class="sxs-lookup"><span data-stu-id="041e9-354">Furthermore, the .NET Framework does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms.</span></span> <span data-ttu-id="041e9-355">これらの理由から、使わないこのメソッドの既定の実装固有のオブジェクト識別子としてハッシュの目的で。</span><span class="sxs-lookup"><span data-stu-id="041e9-355">For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</span></span> <span data-ttu-id="041e9-356">これから次の 2 つの影響。</span><span class="sxs-lookup"><span data-stu-id="041e9-356">Two consequences follow from this:</span></span>  
  
-   <span data-ttu-id="041e9-357">等しいハッシュ コードがオブジェクトの等価性を意味する想定しないでください。</span><span class="sxs-lookup"><span data-stu-id="041e9-357">You should not assume that equal hash codes imply object equality.</span></span>  
  
-   <span data-ttu-id="041e9-358">なるか、同じオブジェクトをアプリケーション ドメイン、プロセス、およびプラットフォーム間でハッシュ可能性がありますのでが作成されたアプリケーション ドメインの外部ハッシュ コードを使用する必要があることはありません。</span><span class="sxs-lookup"><span data-stu-id="041e9-358">You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="041e9-359">ハッシュ コードは、効率的な挿入とハッシュ テーブルに基づくコレクション内の参照です。</span><span class="sxs-lookup"><span data-stu-id="041e9-359">A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</span></span> <span data-ttu-id="041e9-360">ハッシュ コードは、永続的な値ではありません。</span><span class="sxs-lookup"><span data-stu-id="041e9-360">A hash code is not a permanent value.</span></span> <span data-ttu-id="041e9-361">このためには。</span><span class="sxs-lookup"><span data-stu-id="041e9-361">For this reason:</span></span>  
>   
> -   <span data-ttu-id="041e9-362">ハッシュ コード値をシリアル化したり、それらをデータベースに保存しないでください。</span><span class="sxs-lookup"><span data-stu-id="041e9-362">Do not serialize hash code values or store them in databases.</span></span>  
> -   <span data-ttu-id="041e9-363">キー付きコレクションからオブジェクトを取得するのにキーとしてハッシュ コードを使用できません。</span><span class="sxs-lookup"><span data-stu-id="041e9-363">Do not use the hash code as the key to retrieve an object from a keyed collection.</span></span>  
> -   <span data-ttu-id="041e9-364">アプリケーション ドメインまたはプロセスの間では、ハッシュ コードを送信しません。</span><span class="sxs-lookup"><span data-stu-id="041e9-364">Do not send hash codes across application domains or processes.</span></span> <span data-ttu-id="041e9-365">場合によっては、ハッシュ コードをプロセスごとまたはアプリケーションごとのドメインごとに計算することがあります。</span><span class="sxs-lookup"><span data-stu-id="041e9-365">In some cases, hash codes may be computed on a per-process or per-application domain basis.</span></span>  
> -   <span data-ttu-id="041e9-366">強力な暗号的ハッシュを作成する必要がある場合は、暗号化ハッシュ関数によって返される値ではなくハッシュ コードを使わないでください。</span><span class="sxs-lookup"><span data-stu-id="041e9-366">Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="041e9-367">暗号化ハッシュから派生したクラスを使用して、<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType>または<xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>クラス。</span><span class="sxs-lookup"><span data-stu-id="041e9-367">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
> -   <span data-ttu-id="041e9-368">ハッシュ コードを 2 つのオブジェクトが等しいかどうかを判断するには、等しいかどうかをテストしないでください。</span><span class="sxs-lookup"><span data-stu-id="041e9-368">Do not test for equality of hash codes to determine whether two objects are equal.</span></span> <span data-ttu-id="041e9-369">(等しくないオブジェクトは、同一のハッシュ コードを持つことができます)等しいかどうかをテストするには、呼び出し、<xref:System.Object.ReferenceEquals%2A>または<xref:System.Object.Equals%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-369">(Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="041e9-370"><xref:System.Object.GetHashCode%2A>派生型でメソッドをオーバーライドすることができます。</span><span class="sxs-lookup"><span data-stu-id="041e9-370">The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type.</span></span> <span data-ttu-id="041e9-371">場合<xref:System.Object.GetHashCode%2A>がオーバーライドされていないハッシュ コードを呼び出すことによって計算が参照型、<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>ハッシュ コードを計算する基本クラスのメソッド ベースのオブジェクトの参照の詳細についてを参照してください<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-371">If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="041e9-372">つまり、2 つのオブジェクトを<xref:System.Object.ReferenceEquals%2A>メソッドを返します。`true`された同一のハッシュ コード。</span><span class="sxs-lookup"><span data-stu-id="041e9-372">In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes.</span></span> <span data-ttu-id="041e9-373">値の型をオーバーライドしない場合<xref:System.Object.GetHashCode%2A>、<xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType>基本クラスのメソッドでは、リフレクションを使用して、型のフィールドの値に基づいてハッシュ コードを計算します。</span><span class="sxs-lookup"><span data-stu-id="041e9-373">If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</span></span> <span data-ttu-id="041e9-374">つまり、フィールドが同じ値を持つ値の型では、同じハッシュ コードがあります。</span><span class="sxs-lookup"><span data-stu-id="041e9-374">In other words, value types whose fields have equal values have equal hash codes.</span></span> <span data-ttu-id="041e9-375">オーバーライドの詳細については<xref:System.Object.GetHashCode%2A>、「ノート継承クラス」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="041e9-375">For more information about overriding <xref:System.Object.GetHashCode%2A>, see the "Notes to Inheritors" section.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="041e9-376">オーバーライドする場合、<xref:System.Object.GetHashCode%2A>メソッドをオーバーライドすることがも<xref:System.Object.Equals%2A>、またはその逆です。</span><span class="sxs-lookup"><span data-stu-id="041e9-376">If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa.</span></span> <span data-ttu-id="041e9-377">場合、オーバーライドされた<xref:System.Object.Equals%2A>メソッドを返します。`true`等しいかどうか、オーバーライドされた 2 つのオブジェクトをテストするときに<xref:System.Object.GetHashCode%2A>メソッドは、2 つのオブジェクトに対して同じ値を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="041e9-377">If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.</span></span>  
  
 <span data-ttu-id="041e9-378">ハッシュ テーブル内のキーとして使用されるオブジェクトがの便利な実装を提供しないかどうか<xref:System.Object.GetHashCode%2A>、ハッシュ コード プロバイダーを指定するには指定することによって、<xref:System.Collections.IEqualityComparer>のオーバー ロードのいずれかに実装、<xref:System.Collections.Hashtable>クラスのコンス トラクター。</span><span class="sxs-lookup"><span data-stu-id="041e9-378">If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="041e9-379">ノートには、 [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="041e9-379">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="041e9-380">呼び出すと、<xref:System.Object.GetHashCode%2A>内のクラスのメソッド、 [!INCLUDE[wrt](~/includes/wrt-md.md)]、既定の動作をオーバーライドしないクラスを提供します<xref:System.Object.GetHashCode%2A>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-380">When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="041e9-381">これは、.NET Framework では、サポートの一部、 [!INCLUDE[wrt](~/includes/wrt-md.md)] (を参照してください[フレームワークをサポートして Windows ストア アプリ用 .NET と Windows ランタイム](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。</span><span class="sxs-lookup"><span data-stu-id="041e9-381">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="041e9-382">クラス、[!INCLUDE[wrt](~/includes/wrt-md.md)]継承しない<xref:System.Object>、現在実装されていないと、<xref:System.Object.GetHashCode%2A>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-382">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and currently don’t implement a <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="041e9-383">ただし、あるように見えます<xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>と<xref:System.Object.GetHashCode%2A>メソッド、c# または Visual Basic のコードで使用すると、.NET Framework は、これらのメソッドの既定の動作を提供します。</span><span class="sxs-lookup"><span data-stu-id="041e9-383">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]<span data-ttu-id="041e9-384"> c# または Visual Basic で記述されたクラスでオーバーライドできます、<xref:System.Object.GetHashCode%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-384"> classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="041e9-385">同じか、またはより小さい範囲を持つ数値のハッシュ コードを計算する最も簡単な方法の 1 つ、<xref:System.Int32>型は、その値を返すことだけです。</span><span class="sxs-lookup"><span data-stu-id="041e9-385">One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <xref:System.Int32> type is to simply return that value.</span></span> <span data-ttu-id="041e9-386">次の例では、このような実装を`Number`構造体。</span><span class="sxs-lookup"><span data-stu-id="041e9-386">The following example shows such an implementation for a `Number` structure.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 <span data-ttu-id="041e9-387">多くの場合、型には、ハッシュ コードの生成に参加できる複数のデータ フィールドがあります。</span><span class="sxs-lookup"><span data-stu-id="041e9-387">Frequently, a type has multiple data fields that can participate in generating the hash code.</span></span> <span data-ttu-id="041e9-388">ハッシュ コードを生成する方法の 1 つを使用してこれらのフィールドを結合する、`XOR (eXclusive OR)`操作は、次の例に示すようにします。</span><span class="sxs-lookup"><span data-stu-id="041e9-388">One way to generate a hash code is to combine these fields using an `XOR (eXclusive OR)` operation, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 <span data-ttu-id="041e9-389">前の例は、(n1、n2) の同じハッシュ コードを返します (n2、n1)、および、必要な多数の衝突を生成する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="041e9-389">The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</span></span> <span data-ttu-id="041e9-390">このような場合のハッシュ コードが同一でないように、ソリューションの数は使用できます。</span><span class="sxs-lookup"><span data-stu-id="041e9-390">A number of solutions are available so that hash codes in these cases are not identical.</span></span> <span data-ttu-id="041e9-391">1 つのハッシュ コードを返すには、`Tuple`各フィールドの順序を反映するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="041e9-391">One is to return the hash code of a `Tuple` object that reflects the order of each field.</span></span> <span data-ttu-id="041e9-392">次の例を使用して、考えられる実装を示しています、<xref:System.Tuple%602>クラス。</span><span class="sxs-lookup"><span data-stu-id="041e9-392">The following example shows a possible implementation that uses the <xref:System.Tuple%602> class.</span></span> <span data-ttu-id="041e9-393">ただしをインスタンス化のパフォーマンスのオーバーヘッドを`Tuple`オブジェクトは、ハッシュ テーブルに多数のオブジェクトを格納するアプリケーションの全体的なパフォーマンスに大きな影響可能性があります。</span><span class="sxs-lookup"><span data-stu-id="041e9-393">Note, though, that the performance overhead of instantiating a `Tuple` object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 <span data-ttu-id="041e9-394">2 番目の代替ソリューションには、連続するフィールドのハッシュ コードを 2 つ以上のビットを左シフトすることで、個々 のハッシュ コードを重み付けが含まれます。</span><span class="sxs-lookup"><span data-stu-id="041e9-394">A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</span></span> <span data-ttu-id="041e9-395">最適な状態で、破棄されるのではなくを超えて 31 ビット シフトをラップするよりも破棄されます。</span><span class="sxs-lookup"><span data-stu-id="041e9-395">Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded.</span></span> <span data-ttu-id="041e9-396">C# および Visual Basic の両方で左シフト演算子でビットを破棄するので、次のような左 shift キーのラップ メソッドを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="041e9-396">Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 <span data-ttu-id="041e9-397">次の例は、のハッシュ コードを計算するこのシフトのラップ メソッドを使用するし、`Point`前の例で使用される構造体。</span><span class="sxs-lookup"><span data-stu-id="041e9-397">The following example then uses this shift-and-wrap method to compute the hash code of the `Point` structure used in the previous examples.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="041e9-398">
            <para>ハッシュ関数を使用して、オブジェクトの値に対応する番号 (ハッシュ コード) をすばやく生成します。ハッシュ関数は通常、各種類に固有し、一意である、する必要があります少なくとも 1 つのインスタンス フィールドの入力として使用します。静的フィールドの値を使用して、ハッシュ コードを計算する必要がありません。派生したクラスの<see cref="T:System.Object" />、<see langword="GetHashCode" />メソッドが基底クラスに委任できる<see cref="M:System.Object.GetHashCode" />実装の派生クラスには参照の等価性に等しいかどうかが定義されている場合のみです。既定の実装<see cref="M:System.Object.GetHashCode" />参照型で返されると等価のハッシュ コードを返します、<see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />メソッド。オーバーライドできます<see cref="M:System.Object.GetHashCode" />変更不可の参照の種類。一般に、変更可能な参照型でオーバーライドする<see cref="M:System.Object.GetHashCode" />場合にのみ: は変更できませんフィールドのハッシュ コードを計算できますまたは - を collecti に含まれていますが、オブジェクトに、変更可能なオブジェクトのハッシュ コードが変更されないことを確認する -。そのハッシュ コードに依存します。それ以外の場合、ハッシュ テーブルで変更可能なオブジェクトが失われることを考える場合があります。オーバーライドする場合は<see cref="M:System.Object.GetHashCode" />変更可能な参照型の場合、ドキュメントがようにクリア オブジェクトがハッシュ テーブルに格納されている場合、型のユーザーがオブジェクトの値を変更しないでください。値型の場合は、<see cref="M:System.ValueType.GetHashCode" />リフレクションを使用する既定のハッシュ コード実装を提供します。パフォーマンス向上のためにオーバーライドすることを検討する必要があります。<block subset="none" type="note"><para> 詳細とさまざまな方法でのハッシュ コードを計算する例については、「例」を参照してください。</para></block>  次のプロパティのハッシュ関数には: - 2 つのオブジェクトが等しいと評価を比較する場合、<see cref="M:System.Object.GetHashCode" />の各オブジェクトのメソッドは、同じ値を返す必要があります。ただし、2 つのオブジェクトが等しく、として比較されない場合、 <see cref="M:System.Object.GetHashCode" /> 2 つのオブジェクトのメソッドは、異なる値を返す必要はありません。 -<see cref="M:System.Object.GetHashCode" />メソッドは、オブジェクトがオブジェクトの戻り値を決定するオブジェクトの状態に変更がない限り、同じハッシュ コードを返す必要があります一貫して[System.Object.Equals](xref:System.Object.Equals*)メソッド。これが、アプリケーションの現在の実行にのみ true であると、アプリケーションをもう一度実行している場合に他のハッシュ コードを返すことことに注意してください。 -については、最適なパフォーマンスを大きくがクラスター化されている入力を含む、すべての入力に対して均等に分散にハッシュ関数が生成されます。ハッシュ テーブルの最適なパフォーマンスの結果のハッシュ コードに対する大規模な変更でオブジェクトの状態の小さい変更があります。 ハッシュ関数は、コストを計算することがあります。 -<see cref="M:System.Object.GetHashCode" />メソッドが例外をスローする必要があります。実装など、<see cref="M:System.String.GetHashCode" />メソッドによって提供される、<see cref="T:System.String" />クラスは、まったく同じ文字列値の同一のハッシュ コードを返します。そのため、2 つ<see cref="T:System.String" />オブジェクトが同じ文字列値を表す場合、同じハッシュ コードを返します。また、メソッドを使用して、すべての文字文字列の入力が特定の範囲でクラスター化する場合でも、ある程度ランダムに分散型の出力を生成する (たとえば、多くのユーザーの場合でも、下位 128 ASCII 文字のみを含む文字列がある、文字列を含めたりする 65,535 の Unicode 文字の)。クラスの適切なハッシュ関数を提供すると、それらのオブジェクトをハッシュ テーブルに追加のパフォーマンスは大きく変わります。ハッシュ関数の適切な実装を提供するキーを持つハッシュ テーブルには、要素の検索と (たとえば、o (1) 操作など) の定数の時間がかかります。ハッシュ関数の不適切な実装でのハッシュ テーブルに、検索のパフォーマンスがハッシュ テーブル内の項目の数に依存 (たとえば、O (`n`) 操作、場所`n`はハッシュ テーブル内の項目の数です)。悪意のあるユーザーは、次の条件下で、ハッシュ テーブルに依存するアプリケーションのパフォーマンスが低下する可能性が大幅に競合の数を増やすためのデータを入力できます。 - ハッシュ関数が頻繁に競合を生成します。 -ハッシュ テーブル内のオブジェクトの大部分が等しいか、いずれかの別のおよそのハッシュ コードを生成します。 -ユーザーは、ハッシュ コードの計算元となるデータを入力します。オーバーライドするクラスを派生<see cref="M:System.Object.GetHashCode" />もオーバーライドする必要があります<see cref="M:System.Object.Equals(System.Object)" />等しいと見なされる 2 つのオブジェクトに同じハッシュ コードがあることを保証するために、それ以外の場合、<see cref="T:System.Collections.Hashtable" />型が正しく機能しない可能性があります。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-398">
              <para>A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object. Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input. Hash codes should not be computed by using the values of static fields.  For classes derived from <see cref="T:System.Object" />, the <see langword="GetHashCode" /> method can delegate to the base class <see cref="M:System.Object.GetHashCode" /> implementation only if the derived class defines equality to be reference equality. The default implementation of <see cref="M:System.Object.GetHashCode" /> for reference types returns a hash code that is equivalent to the one returned by the <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> method. You can override <see cref="M:System.Object.GetHashCode" /> for immutable reference types. In general, for mutable reference types, you should override <see cref="M:System.Object.GetHashCode" /> only if:  -   You can compute the hash code from fields that are not mutable; or  -   You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.  Otherwise, you might think that the mutable object is lost in the hash table. If you do choose to override <see cref="M:System.Object.GetHashCode" /> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.  For value types, <see cref="M:System.ValueType.GetHashCode" /> provides a default hash code implementation that uses reflection. You should consider overriding it for better performance.  <block subset="none" type="note"><para> For more information and examples that compute hash codes in a variety of ways, see the Examples section.  </para></block>  A hash function must have the following properties:  -   If two objects compare as equal, the <see cref="M:System.Object.GetHashCode" /> method for each object must return the same value. However, if two objects do not compare as equal, the <see cref="M:System.Object.GetHashCode" /> methods for the two objects do not have to return different values.  -   The <see cref="M:System.Object.GetHashCode" /> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's [System.Object.Equals](xref:System.Object.Equals*) method. Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.  -   For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered. An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.  -   Hash functions should be inexpensive to compute.  -   The <see cref="M:System.Object.GetHashCode" /> method should not throw exceptions.  For example, the implementation of the <see cref="M:System.String.GetHashCode" /> method provided by the <see cref="T:System.String" /> class returns identical hash codes for identical string values. Therefore, two <see cref="T:System.String" /> objects return the same hash code if they represent the same string value. Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).  Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table. In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation). In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(`n`) operation, where `n` is the number of items in the hash table). A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:  -   When hash functions produce frequent collisions.  -   When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.  -   When users input the data from which the hash code is computed.  Derived classes that override <see cref="M:System.Object.GetHashCode" /> must also override <see cref="M:System.Object.Equals(System.Object)" /> to guarantee that two objects considered equal have the same hash code; otherwise, the <see cref="T:System.Collections.Hashtable" /> type might not work correctly.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="041e9-399">現在のインスタンスの <see cref="T:System.Type" /> を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-399">Gets the <see cref="T:System.Type" /> of the current instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="041e9-400">現在のインスタンスの正確なランタイム型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-400">The exact runtime type of the current instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="041e9-401"><xref:System.Object?displayProperty=nameWithType>すべての型の基本クラスを .NET Framework 型システムでは、<xref:System.Object.GetType%2A>を返すメソッドを使用できます<xref:System.Type>すべての .NET Framework 型を表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="041e9-401">Because <xref:System.Object?displayProperty=nameWithType> is the base class for all types in the .NET Framework type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET Framework types.</span></span> <span data-ttu-id="041e9-402">.NET Framework には、次の 5 つの種類のカテゴリが認識されます。</span><span class="sxs-lookup"><span data-stu-id="041e9-402">The .NET Framework recognizes the following five categories of types:</span></span>  
  
-   <span data-ttu-id="041e9-403">派生したクラス、 <xref:System.Object?displayProperty=nameWithType>、</span><span class="sxs-lookup"><span data-stu-id="041e9-403">Classes, which are derived from <xref:System.Object?displayProperty=nameWithType>,</span></span>  
  
-   <span data-ttu-id="041e9-404">値の型から派生した<xref:System.ValueType?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-404">Value types, which are derived from <xref:System.ValueType?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="041e9-405">派生したインターフェイス、 <xref:System.Object?displayProperty=nameWithType> .NET Framework 2.0 以降します。</span><span class="sxs-lookup"><span data-stu-id="041e9-405">Interfaces, which are derived from <xref:System.Object?displayProperty=nameWithType> starting with the .NET Framework 2.0.</span></span>  
  
-   <span data-ttu-id="041e9-406">派生した列挙型、<xref:System.Enum?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-406">Enumerations, which are derived from <xref:System.Enum?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="041e9-407">派生した代理人<xref:System.MulticastDelegate?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-407">Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="041e9-408">2 つのオブジェクトの`x`と`y`同一ランタイムの型がある`Object.ReferenceEquals(x.GetType(),y.GetType())`返します`true`します。</span><span class="sxs-lookup"><span data-stu-id="041e9-408">For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`.</span></span> <span data-ttu-id="041e9-409">次の例では、<xref:System.Object.GetType%2A>メソッドを<xref:System.Object.ReferenceEquals%2A>メソッドを 1 つの数値が他の 2 つの数値の値と同じ型かどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="041e9-409">The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values.</span></span>  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="041e9-410">オブジェクトがを特定の種類であるかどうかを確認するのには、言語の型の比較のキーワードを使用したり構築できます。</span><span class="sxs-lookup"><span data-stu-id="041e9-410">To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</span></span> <span data-ttu-id="041e9-411">たとえば、使用することができます、 `TypeOf…Is` Visual Basic で作成または`is`キーワード (C#)。</span><span class="sxs-lookup"><span data-stu-id="041e9-411">For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.</span></span>  
  
 <span data-ttu-id="041e9-412"><xref:System.Object.GetType%2A>メソッドがから派生したすべての型によって継承される<xref:System.Object>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-412">The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>.</span></span> <span data-ttu-id="041e9-413">これには、独自の言語の比較キーワード以外にも、使用できることを意味、<xref:System.Object.GetType%2A>として次の例は、特定のオブジェクトの種類を判断するメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-413">This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <span data-ttu-id="041e9-414"><xref:System.Type>オブジェクトは、現在のクラスに関連付けられたメタデータを公開<xref:System.Object>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-414">The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="041e9-415">次のコード例を示している<xref:System.Object.GetType%2A>現在のインスタンスのランタイム型を返します。</span><span class="sxs-lookup"><span data-stu-id="041e9-415">The following code example demonstrates that <xref:System.Object.GetType%2A> returns the runtime type of the current instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="041e9-416">現在の <see cref="T:System.Object" /> の簡易コピーを作成します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-416">Creates a shallow copy of the current <see cref="T:System.Object" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="041e9-417">現在の <see cref="T:System.Object" /> の簡易コピー。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-417">A shallow copy of the current <see cref="T:System.Object" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="041e9-418"><xref:System.Object.MemberwiseClone%2A>メソッドは、新しいオブジェクトを作成し、新しいオブジェクトを現在のオブジェクトの非静的フィールドをコピーして簡易コピーを作成します。</span><span class="sxs-lookup"><span data-stu-id="041e9-418">The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</span></span> <span data-ttu-id="041e9-419">フィールドが値型の場合は、フィールドのビットごとのコピーが実行されます。</span><span class="sxs-lookup"><span data-stu-id="041e9-419">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="041e9-420">フィールドが参照型の場合は、参照がコピーされますが、参照先オブジェクトがないです。そのため、元のオブジェクトとその複製は、同じオブジェクトを参照します。</span><span class="sxs-lookup"><span data-stu-id="041e9-420">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="041e9-421">たとえば、オブジェクト A と B をさらに、参照の参照オブジェクト C X という名前のオブジェクトX の簡易コピーは、オブジェクト A と B を参照する新しいオブジェクト X2 を作成します。これに対し、X の詳細コピーが A2 および B2、A のコピーは、新しいオブジェクトを参照する新しいオブジェクト X2 を作成し、B. B2、さらに、c ドライブのコピーである新しいオブジェクト C2 を参照この例では、shallow とディープ コピー操作の違いを示します。</span><span class="sxs-lookup"><span data-stu-id="041e9-421">For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</span></span>  
  
 <span data-ttu-id="041e9-422">簡易コピー操作を実行している場合、詳細コピー操作を実装する方法はたくさんあります、<xref:System.Object.MemberwiseClone%2A>メソッドは、ニーズを満たしていません。</span><span class="sxs-lookup"><span data-stu-id="041e9-422">There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs.</span></span> <span data-ttu-id="041e9-423">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="041e9-423">These include the following:</span></span>  
  
-   <span data-ttu-id="041e9-424">最初のオブジェクトから取得したプロパティ値を 2 番目のオブジェクトを作成するコピーされるオブジェクトのクラスのコンス トラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="041e9-424">Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</span></span> <span data-ttu-id="041e9-425">これは、そのクラス コンス トラクターによってオブジェクトの値がまったく定義されていると仮定します。</span><span class="sxs-lookup"><span data-stu-id="041e9-425">This assumes that the values of an object are entirely defined by its class constructor.</span></span>  
  
-   <span data-ttu-id="041e9-426">呼び出す、<xref:System.Object.MemberwiseClone%2A>メソッドをオブジェクトの簡易コピーを作成し、値は、プロパティやフィールドは参照型の値が元のオブジェクトと同じ新しいオブジェクトを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="041e9-426">Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</span></span> <span data-ttu-id="041e9-427">`DeepCopy`メソッドの例では、この方法を示します。</span><span class="sxs-lookup"><span data-stu-id="041e9-427">The `DeepCopy` method in the example illustrates this approach.</span></span>  
  
-   <span data-ttu-id="041e9-428">コピーには、ディープ オブジェクトをシリアル化し、別のオブジェクト変数をシリアル化されたデータを復元します。</span><span class="sxs-lookup"><span data-stu-id="041e9-428">Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</span></span>  
  
-   <span data-ttu-id="041e9-429">再帰でリフレクションを使用して、詳細コピー操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="041e9-429">Use reflection with recursion to perform the deep copy operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="041e9-430">次の例を示しています、<xref:System.Object.MemberwiseClone%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-430">The following example illustrates the <xref:System.Object.MemberwiseClone%2A> method.</span></span> <span data-ttu-id="041e9-431">定義、`ShallowCopy`メソッドを呼び出す、<xref:System.Object.MemberwiseClone%2A>簡易コピー操作を実行するメソッド、`Person`オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="041e9-431">It defines a `ShallowCopy` method that calls the <xref:System.Object.MemberwiseClone%2A> method to perform a shallow copy operation on a `Person` object.</span></span> <span data-ttu-id="041e9-432">定義、`DeepCopy`に対してディープ コピー操作を実行するメソッド、`Person`オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="041e9-432">It also defines a `DeepCopy` method that performs a deep copy operation on a `Person` object.</span></span>  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 <span data-ttu-id="041e9-433">この例で、`Person.IdInfo`プロパティが返す、`IdInfo`オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="041e9-433">In this example, the `Person.IdInfo` property returns an `IdInfo` object.</span></span> <span data-ttu-id="041e9-434">例を示しますから出力としてときに、`Person`オブジェクトが呼び出すことによって複製、<xref:System.Object.MemberwiseClone%2A>メソッドは、複製された`Person`オブジェクトには、元のオブジェクトの独立したコピーがある同じ共有を`Person.IdInfo`オブジェクト参照。</span><span class="sxs-lookup"><span data-stu-id="041e9-434">As the output from the example shows, when a `Person` object is cloned by calling the <xref:System.Object.MemberwiseClone%2A> method, the cloned `Person` object is an independent copy of the original object, except that they share the same `Person.IdInfo` object reference.</span></span> <span data-ttu-id="041e9-435">その結果、クローンの変更する`Person.IdInfo`プロパティが変更元のオブジェクトの`Person.IdInfo`プロパティ。</span><span class="sxs-lookup"><span data-stu-id="041e9-435">As a result, modifying the clone's `Person.IdInfo` property changes the original object's `Person.IdInfo` property.</span></span> <span data-ttu-id="041e9-436">その一方で、詳細コピー操作を実行ときに、複製された`Person`オブジェクトを含むその`Person.IdInfo`プロパティは、元のオブジェクトの影響を与えずに変更できます。</span><span class="sxs-lookup"><span data-stu-id="041e9-436">On the other hand, when a deep copy operation is performed, the cloned `Person` object, including its `Person.IdInfo` property, can be modified without affecting the original object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">
          <span data-ttu-id="041e9-437">比較対象の第 1 オブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-437">The first object to compare.</span>
          </span>
        </param>
        <param name="objB">
          <span data-ttu-id="041e9-438">比較する 2 番目のオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-438">The second object  to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="041e9-439">指定した複数の <see cref="T:System.Object" /> インスタンスが同一かどうかを判断します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-439">Determines whether the specified <see cref="T:System.Object" /> instances are the same instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="041e9-440">
            <paramref name="objA" /> が <paramref name="objB" /> と同一のインスタンスである場合、または両方のインスタンスが **null** の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-440">
              <see langword="true" /> if <paramref name="objA" /> is the same instance as <paramref name="objB" /> or if both are **null**; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="041e9-441">異なり、<xref:System.Object.Equals%2A>と等値演算子のメソッド、<xref:System.Object.ReferenceEquals%2A>メソッドをオーバーライドすることはできません。</span><span class="sxs-lookup"><span data-stu-id="041e9-441">Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden.</span></span> <span data-ttu-id="041e9-442">このため、テストする場合は、2 つのオブジェクトが等しいかどうかの参照との実装の詳細を確認したら、`Equals`メソッドを呼び出すことができます、<xref:System.Object.ReferenceEquals%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-442">Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 <span data-ttu-id="041e9-443">ただし、戻り値の<xref:System.Object.ReferenceEquals%2A>これら 2 つのシナリオでは異常と考えられるメソッドがあります。</span><span class="sxs-lookup"><span data-stu-id="041e9-443">However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:</span></span>  
  
-   <span data-ttu-id="041e9-444">ときに、値の型を比較します。</span><span class="sxs-lookup"><span data-stu-id="041e9-444">When comparing value types.</span></span> <span data-ttu-id="041e9-445">場合`objA`と`objB`は、値の型に渡される前にボックス化されている、<xref:System.Object.ReferenceEquals%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-445">If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="041e9-446">つまり、両方`objA`と`objB`値の型の同じインスタンスを表す、<xref:System.Object.ReferenceEquals%2A>メソッドを返しますそれにもかかわらず`false`次の例に示すように、します。</span><span class="sxs-lookup"><span data-stu-id="041e9-446">This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     <span data-ttu-id="041e9-447">値型のボックス化については、次を参照してください。[ボックス化とボックス化解除](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)します。</span><span class="sxs-lookup"><span data-stu-id="041e9-447">For information on boxing value types, see [Boxing and Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span></span>  
  
-   <span data-ttu-id="041e9-448">ときに、文字列を比較します。</span><span class="sxs-lookup"><span data-stu-id="041e9-448">When comparing strings.</span></span> <span data-ttu-id="041e9-449">場合`objA`と`objB`文字列の場合は、<xref:System.Object.ReferenceEquals%2A>メソッドを返します。`true`場合は、文字列がインターン プールに存在します。</span><span class="sxs-lookup"><span data-stu-id="041e9-449">If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned.</span></span> <span data-ttu-id="041e9-450">値の等価性テストを行うことはできません。</span><span class="sxs-lookup"><span data-stu-id="041e9-450">It does not perform a test for value equality.</span></span>  <span data-ttu-id="041e9-451">次の例では、`s1`と`s2`隔離された単一の文字列の 2 つのインスタンスであるために値が等しい。</span><span class="sxs-lookup"><span data-stu-id="041e9-451">In the following example, `s1` and `s2` are equal because they are two instances of a single interned string.</span></span> <span data-ttu-id="041e9-452">ただし、`s3`と`s4`が、まったく同じ文字列値がありますは、その文字列がインターンしないために、等しくない場合は、します。</span><span class="sxs-lookup"><span data-stu-id="041e9-452">However, `s3` and `s4` are not equal, because although they are have identical string values, that string is not interned.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     <span data-ttu-id="041e9-453">文字列インターンの詳細については、次を参照してください。<xref:System.String.IsInterned%2A?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-453">For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="041e9-454">次の例では<xref:System.Object.ReferenceEquals%2A>を 2 つのオブジェクトは、同じインスタンスを決定します。</span><span class="sxs-lookup"><span data-stu-id="041e9-454">The following example uses <xref:System.Object.ReferenceEquals%2A> to determine if two objects are the same instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="041e9-455">現在のオブジェクトを表す文字列を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-455">Returns a string that represents the current object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="041e9-456">現在のオブジェクトを表す文字列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-456">A string that represents the current object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="041e9-457"><xref:System.Object.ToString%2A?displayProperty=nameWithType> メジャーでは、.NET Framework のメソッドを書式設定します。</span><span class="sxs-lookup"><span data-stu-id="041e9-457"><xref:System.Object.ToString%2A?displayProperty=nameWithType> is the major formatting method in the .NET Framework.</span></span> <span data-ttu-id="041e9-458">表示に適したあるように、オブジェクトを文字列表現に変換します。</span><span class="sxs-lookup"><span data-stu-id="041e9-458">It converts an object to its string representation so that it is suitable for display.</span></span> <span data-ttu-id="041e9-459">(.NET Framework でのサポートを書式設定方法の詳細については、次を参照してください[型の書式設定](~/docs/standard/base-types/formatting-types.md)。)。既定の実装、<xref:System.Object.ToString%2A?displayProperty=nameWithType>メソッドがオブジェクトの型の完全修飾名を返します。</span><span class="sxs-lookup"><span data-stu-id="041e9-459">(For information about formatting support in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method return the fully qualified name of the object's type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="041e9-460">リンクから別の型のメンバーの一覧からこのページが表示がある可能性があります。</span><span class="sxs-lookup"><span data-stu-id="041e9-460">You may have reached this page by following the link from the member list of another type.</span></span> <span data-ttu-id="041e9-461">その型をオーバーライドしないためにです<xref:System.Object.ToString%2A?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-461">That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="041e9-462">代わりの機能を継承、<xref:System.Object.ToString%2A?displayProperty=nameWithType>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-462">Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="041e9-463">型は頻繁に、オーバーライド、<xref:System.Object.ToString%2A?displayProperty=nameWithType>特定の種類の方が適切な文字列形式を提供するメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-463">Types frequently override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide a more suitable string representation of a particular type.</span></span> <span data-ttu-id="041e9-464">型でも頻繁にオーバー ロード、<xref:System.Object.ToString%2A?displayProperty=nameWithType>書式指定文字列またはカルチャの書式設定のサポートを提供するメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-464">Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide support for format strings or culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="041e9-465">このセクションの内容:</span><span class="sxs-lookup"><span data-stu-id="041e9-465">In this section:</span></span>  
  
 <span data-ttu-id="041e9-466">[既定の Object.ToString() メソッド](#Default) </span><span class="sxs-lookup"><span data-stu-id="041e9-466">[The default Object.ToString() method](#Default) </span></span>  
 <span data-ttu-id="041e9-467">[Object.ToString() メソッドをオーバーライドします。](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="041e9-467">[Overriding the Object.ToString() method](#Overriding) </span></span>  
 <span data-ttu-id="041e9-468">[ToString メソッドをオーバー ロード](#Overloading) </span><span class="sxs-lookup"><span data-stu-id="041e9-468">[Overloading the ToString method](#Overloading) </span></span>  
 <span data-ttu-id="041e9-469">[Object.ToString メソッドを拡張します。](#Extending) </span><span class="sxs-lookup"><span data-stu-id="041e9-469">[Extending the Object.ToString method](#Extending) </span></span>  
 [<span data-ttu-id="041e9-470">Windows ランタイムのノート</span><span class="sxs-lookup"><span data-stu-id="041e9-470">Notes for the Windows Runtime</span></span>](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a><span data-ttu-id="041e9-471">既定の Object.ToString() メソッド</span><span class="sxs-lookup"><span data-stu-id="041e9-471">The default Object.ToString() method</span></span>  
 <span data-ttu-id="041e9-472">既定の実装、<xref:System.Object.ToString%2A>メソッドの型の完全修飾名を返します、 <xref:System.Object>、次の例を示しています。</span><span class="sxs-lookup"><span data-stu-id="041e9-472">The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows.</span></span>  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 <span data-ttu-id="041e9-473"><xref:System.Object>すべての参照型の基底クラスには、.NET Framework では、この動作は上書きをしない参照型によって継承されます、<xref:System.Object.ToString%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-473">Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method.</span></span> <span data-ttu-id="041e9-474">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="041e9-474">The following example illustrates this.</span></span> <span data-ttu-id="041e9-475">という名前のクラスが定義`Object1`すべての既定の実装を受け入れる<xref:System.Object>メンバー。</span><span class="sxs-lookup"><span data-stu-id="041e9-475">It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members.</span></span> <span data-ttu-id="041e9-476">その<xref:System.Object.ToString%2A>メソッドは、オブジェクトの完全修飾型名を返します。</span><span class="sxs-lookup"><span data-stu-id="041e9-476">Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name.</span></span>  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a><span data-ttu-id="041e9-477">Object.ToString() メソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="041e9-477">Overriding the Object.ToString() method</span></span>  
 <span data-ttu-id="041e9-478">型は通常、オーバーライド、<xref:System.Object.ToString%2A?displayProperty=nameWithType>オブジェクト インスタンスを表す文字列を返すメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-478">Types commonly override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return a string that represents the object instance.</span></span> <span data-ttu-id="041e9-479">たとえば、基本の型など<xref:System.Char>、 <xref:System.Int32>、および<xref:System.String>提供<xref:System.Object.ToString%2A>オブジェクトによって表される値の文字列形式を返す実装します。</span><span class="sxs-lookup"><span data-stu-id="041e9-479">For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents.</span></span> <span data-ttu-id="041e9-480">次の例は、クラスを定義`Object2`、オーバーライドする、<xref:System.Object.ToString%2A>と値の型名を返すメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-480">The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value.</span></span>  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 <span data-ttu-id="041e9-481">次の表は、.NET Framework の型のカテゴリを一覧表示し、オーバーライドするかどうかを示します、<xref:System.Object.ToString%2A?displayProperty=nameWithType>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-481">The following table lists the type categories in the .NET Framework and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
|<span data-ttu-id="041e9-482">型のカテゴリ</span><span class="sxs-lookup"><span data-stu-id="041e9-482">Type category</span></span>|<span data-ttu-id="041e9-483">上書き Object.ToString()</span><span class="sxs-lookup"><span data-stu-id="041e9-483">Overrides Object.ToString()</span></span>|<span data-ttu-id="041e9-484">[動作]</span><span class="sxs-lookup"><span data-stu-id="041e9-484">Behavior</span></span>|  
|-------------------|-----------------------------------|--------------|  
|<span data-ttu-id="041e9-485">クラス</span><span class="sxs-lookup"><span data-stu-id="041e9-485">Class</span></span>|<span data-ttu-id="041e9-486">N/A</span><span class="sxs-lookup"><span data-stu-id="041e9-486">n/a</span></span>|<span data-ttu-id="041e9-487">N/A</span><span class="sxs-lookup"><span data-stu-id="041e9-487">n/a</span></span>|  
|<span data-ttu-id="041e9-488">構造体</span><span class="sxs-lookup"><span data-stu-id="041e9-488">Structure</span></span>|<span data-ttu-id="041e9-489">[はい] (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="041e9-489">Yes (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="041e9-490">Object.ToString() と同じ</span><span class="sxs-lookup"><span data-stu-id="041e9-490">Same as Object.ToString()</span></span>|  
|<span data-ttu-id="041e9-491">列挙</span><span class="sxs-lookup"><span data-stu-id="041e9-491">Enumeration</span></span>|<span data-ttu-id="041e9-492">[はい] (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="041e9-492">Yes (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="041e9-493">メンバー名</span><span class="sxs-lookup"><span data-stu-id="041e9-493">The member name</span></span>|  
|<span data-ttu-id="041e9-494">Interface</span><span class="sxs-lookup"><span data-stu-id="041e9-494">Interface</span></span>|<span data-ttu-id="041e9-495">×</span><span class="sxs-lookup"><span data-stu-id="041e9-495">No</span></span>|<span data-ttu-id="041e9-496">N/A</span><span class="sxs-lookup"><span data-stu-id="041e9-496">n/a</span></span>|  
|<span data-ttu-id="041e9-497">Delegate</span><span class="sxs-lookup"><span data-stu-id="041e9-497">Delegate</span></span>|<span data-ttu-id="041e9-498">×</span><span class="sxs-lookup"><span data-stu-id="041e9-498">No</span></span>|<span data-ttu-id="041e9-499">N/A</span><span class="sxs-lookup"><span data-stu-id="041e9-499">n/a</span></span>|  
  
 <span data-ttu-id="041e9-500">オーバーライドの詳細については、継承クラス「ノートを参照してください<xref:System.Object.ToString%2A>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-500">See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>.</span></span>  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a><span data-ttu-id="041e9-501">ToString メソッドをオーバー ロード</span><span class="sxs-lookup"><span data-stu-id="041e9-501">Overloading the ToString method</span></span>  
 <span data-ttu-id="041e9-502">パラメーターなしでオーバーライドするだけでなく<xref:System.Object.ToString?displayProperty=nameWithType>メソッドでは、さまざまな種類のオーバー ロード、`ToString`メソッドのパラメーターを使用できるバージョンを提供するメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-502">In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=nameWithType> method, many types overload the `ToString` method to provide versions of the method that accept parameters.</span></span> <span data-ttu-id="041e9-503">ほとんどの場合、この変数の書式とカルチャの書式設定のサポートを提供する行われます。</span><span class="sxs-lookup"><span data-stu-id="041e9-503">Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="041e9-504">次の例のオーバー ロード、`ToString`のさまざまなフィールドの値を含む結果の文字列を返すメソッドを`Automobile`クラス。</span><span class="sxs-lookup"><span data-stu-id="041e9-504">The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class.</span></span> <span data-ttu-id="041e9-505">次の 4 つの書式指定文字列を定義します G で、モデルの名前と年度; を返します。D で、モデルの名前、year、および; のドアの数を返しますC で、モデルの名前、year、およびシリンダー; の数を返しますA で、すべての 4 つのフィールド値を持つ文字列を返します。</span><span class="sxs-lookup"><span data-stu-id="041e9-505">It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</span></span>  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 <span data-ttu-id="041e9-506">次の例では、オーバー ロードされた<xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>カルチャの通貨値の書式設定を表示するメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-506">The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method to display culture-sensitive formatting of a currency value.</span></span>  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 <span data-ttu-id="041e9-507">書式指定文字列とカルチャの書式設定の詳細については、次を参照してください。[型の書式設定](~/docs/standard/base-types/formatting-types.md)します。</span><span class="sxs-lookup"><span data-stu-id="041e9-507">For more information on format strings and culture-sensitive formatting, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span> <span data-ttu-id="041e9-508">書式指定文字列を数値でサポートされている、次を参照してください。 [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md)と[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)します。</span><span class="sxs-lookup"><span data-stu-id="041e9-508">For the format strings supported by numeric values, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="041e9-509">日付と時刻の値でサポートされている書式指定文字列を参照してください。 [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md)と[Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md)します。</span><span class="sxs-lookup"><span data-stu-id="041e9-509">For the format strings supported by date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a><span data-ttu-id="041e9-510">Object.ToString メソッドを拡張します。</span><span class="sxs-lookup"><span data-stu-id="041e9-510">Extending the Object.ToString method</span></span>  
 <span data-ttu-id="041e9-511">型は、既定値を継承するため<xref:System.Object.ToString%2A?displayProperty=nameWithType>メソッド、望ましくない動作を検索して変更します、。</span><span class="sxs-lookup"><span data-stu-id="041e9-511">Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, you may find its behavior undesirable and want to change it.</span></span> <span data-ttu-id="041e9-512">これは配列とコレクション クラスの特に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="041e9-512">This is particularly true of arrays and collection classes.</span></span> <span data-ttu-id="041e9-513">お察し中に、`ToString`メソッド配列またはコレクションのメンバーの値を表示するクラスの代わりに、型の完全修飾型名として表示例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="041e9-513">While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 <span data-ttu-id="041e9-514">希望する結果の文字列を生成するためにいくつかのオプションがあります。</span><span class="sxs-lookup"><span data-stu-id="041e9-514">You have several options to produce the result string that you'd like.</span></span>  
  
-   <span data-ttu-id="041e9-515">型が配列、コレクション オブジェクト、または実装するオブジェクトの場合、<xref:System.Collections.IEnumerable>または<xref:System.Collections.Generic.IEnumerable%601>インターフェイスを使用してその要素を列挙することができます、 `foreach` (C#) ステートメントまたは`For Each...Next`Visual Basic で作成します。</span><span class="sxs-lookup"><span data-stu-id="041e9-515">If the type is an array, a collection object, or an object that implements the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interfaces, you can enumerate its elements by using the `foreach` statement in C# or the `For Each...Next` construct in Visual Basic.</span></span>  
  
-   <span data-ttu-id="041e9-516">クラスがない場合`sealed`(で C# の場合) または`NotInheritable`持つ基底クラスから継承するラッパー クラスを開発する (Visual Basic の場合) で<xref:System.Object.ToString%2A?displayProperty=nameWithType>をカスタマイズするメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-516">If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=nameWithType> method you want to customize.</span></span> <span data-ttu-id="041e9-517">少なくとも、以下を実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="041e9-517">At a minimum, this requires that you do the following:</span></span>  
  
    1.  <span data-ttu-id="041e9-518">必要なコンス トラクターを実装します。</span><span class="sxs-lookup"><span data-stu-id="041e9-518">Implement any necessary constructors.</span></span> <span data-ttu-id="041e9-519">派生クラスでは、その基底クラスのコンス トラクターは継承しません。</span><span class="sxs-lookup"><span data-stu-id="041e9-519">Derived classes do not inherit their base class constructors.</span></span>  
  
    2.  <span data-ttu-id="041e9-520">上書き、<xref:System.Object.ToString%2A?displayProperty=nameWithType>を希望する結果の文字列を返すメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-520">Override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the result string that you'd like.</span></span>  
  
     <span data-ttu-id="041e9-521">次の例のラッパー クラスを定義する、<xref:System.Collections.Generic.List%601>クラス。</span><span class="sxs-lookup"><span data-stu-id="041e9-521">The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class.</span></span> <span data-ttu-id="041e9-522">これは、上書き、<xref:System.Object.ToString%2A?displayProperty=nameWithType>完全修飾型名ではなく、コレクションの各メソッドの値を表示するメソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-522">It overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to display the value of each method of the collection rather than the fully qualified type name.</span></span>  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   <span data-ttu-id="041e9-523">開発、[拡張メソッド](~/docs/standard/design-guidelines/extension-methods.md)する結果の文字列を返します。</span><span class="sxs-lookup"><span data-stu-id="041e9-523">Develop an [extension method](~/docs/standard/design-guidelines/extension-methods.md) that returns the result string that you want.</span></span> <span data-ttu-id="041e9-524">既定値をオーバーライドすることはできません注<xref:System.Object.ToString%2A?displayProperty=nameWithType>この方法でメソッド (、拡張機能クラス (c#) または (Visual Basic) でのモジュールがという名前のパラメーターなしのメソッドを含めることはできません、`ToString`元の型の代わりに呼び出される`ToString`メソッド.</span><span class="sxs-lookup"><span data-stu-id="041e9-524">Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method.</span></span> <span data-ttu-id="041e9-525">その他のいくつかのパラメーターなしの名前を指定する必要があります`ToString`置換します。</span><span class="sxs-lookup"><span data-stu-id="041e9-525">You'll have to provide some other name for your parameterless `ToString` replacement.</span></span>  
  
     <span data-ttu-id="041e9-526">次の例を拡張する 2 つのメソッドを定義する、<xref:System.Collections.Generic.List%601>クラス: パラメーターなし`ToString2`メソッド、および`ToString`メソッドを<xref:System.String>書式指定文字列を表すパラメーター。</span><span class="sxs-lookup"><span data-stu-id="041e9-526">The following example defines two methods that extend the <xref:System.Collections.Generic.List%601> class: a parameterless `ToString2` method, and a `ToString` method with a <xref:System.String> parameter that represents a format string.</span></span>  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="041e9-527">ノートには、 [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="041e9-527">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="041e9-528">呼び出すと、<xref:System.Object.ToString%2A>内のクラスのメソッド、 [!INCLUDE[wrt](~/includes/wrt-md.md)]、既定の動作をオーバーライドしないクラスを提供します<xref:System.Object.ToString%2A>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-528">When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="041e9-529">これは、.NET Framework では、サポートの一部、 [!INCLUDE[wrt](~/includes/wrt-md.md)] (を参照してください[フレームワークをサポートして Windows ストア アプリ用 .NET と Windows ランタイム](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。</span><span class="sxs-lookup"><span data-stu-id="041e9-529">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="041e9-530">クラス、[!INCLUDE[wrt](~/includes/wrt-md.md)]継承しない<xref:System.Object>、常に実装していないと、<xref:System.Object.ToString%2A>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-530">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and don’t always implement a <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="041e9-531">ただし、常にように見えますが<xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>と<xref:System.Object.GetHashCode%2A>メソッド、c# または Visual Basic のコードで使用すると、.NET Framework は、これらのメソッドの既定の動作を提供します。</span><span class="sxs-lookup"><span data-stu-id="041e9-531">However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</span></span>  
  
 <span data-ttu-id="041e9-532">以降では、 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]、共通言語ランタイムを使用して[IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)で、[!INCLUDE[wrt](~/includes/wrt-md.md)]オブジェクトの既定の実装に戻る前に<xref:System.Object.ToString%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="041e9-532">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], the common language runtime will use [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) on a [!INCLUDE[wrt](~/includes/wrt-md.md)] object before falling back to the default implementation of <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]<span data-ttu-id="041e9-533"> c# または Visual Basic で記述されたクラスでオーバーライドできます、<xref:System.Object.ToString%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="041e9-533"> classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method.</span></span>  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a><span data-ttu-id="041e9-534">[!INCLUDE[wrt](~/includes/wrt-md.md)]と IStringable インターフェイス</span><span class="sxs-lookup"><span data-stu-id="041e9-534">The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface</span></span>  
 <span data-ttu-id="041e9-535">以降で[!INCLUDE[win81](~/includes/win81-md.md)]、[!INCLUDE[wrt](~/includes/wrt-md.md)]が含まれています、 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)インターフェイスの 1 つのメソッドを持つ[IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)と同等の基本的な書式設定サポートを提供します。によって提供される<xref:System.Object.ToString%2A?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="041e9-535">Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="041e9-536">あいまいさを防ぐには実装しないでください[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)マネージ型にします。</span><span class="sxs-lookup"><span data-stu-id="041e9-536">To prevent ambiguity, you should not implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types.</span></span>  
  
 <span data-ttu-id="041e9-537">ネイティブ コードまたは JavaScript または C++ などの言語で記述されたコードでのマネージ オブジェクトを呼び出すときに/cli 実装するために表示される、CX [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)します。</span><span class="sxs-lookup"><span data-stu-id="041e9-537">When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span> <span data-ttu-id="041e9-538">共通言語ランタイムはからの呼び出しに自動的にルーティング[IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)に<xref:System.Object.ToString%2A?displayProperty=nameWithType>イベント[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)はマネージ オブジェクトで実装されていません。</span><span class="sxs-lookup"><span data-stu-id="041e9-538">The common language runtime will automatically route calls from [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=nameWithType> in the event [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="041e9-539">共通言語ランタイムの自動実装するため、 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)内の型のすべての管理[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]アプリをお勧めすることを指定しない独自[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)実装します。</span><span class="sxs-lookup"><span data-stu-id="041e9-539">Because the common language runtime auto-implements [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation.</span></span> <span data-ttu-id="041e9-540">実装する[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)を呼び出すときに、予期しない動作可能性`ToString`から、 [!INCLUDE[wrt](~/includes/wrt-md.md)]、C++/cli、/CX または JavaScript。</span><span class="sxs-lookup"><span data-stu-id="041e9-540">Implementing [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.</span></span>  
  
 <span data-ttu-id="041e9-541">実装することを選択する場合[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)でエクスポートしたパブリック マネージ型で、[!INCLUDE[wrt](~/includes/wrt-md.md)]コンポーネントでは、次の制限が適用されます。</span><span class="sxs-lookup"><span data-stu-id="041e9-541">If you do choose to implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in a public managed type that is exported in a [!INCLUDE[wrt](~/includes/wrt-md.md)] component, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="041e9-542">定義することができます、 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)など、「クラスが実装する」関係でしかインターフェイス</span><span class="sxs-lookup"><span data-stu-id="041e9-542">You can define the [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface only in a "class implements" relationship, such as</span></span>  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     <span data-ttu-id="041e9-543">C# では、上記のようになります。</span><span class="sxs-lookup"><span data-stu-id="041e9-543">in C#, or</span></span>  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     <span data-ttu-id="041e9-544">Visual Basic では、上記のようになります。</span><span class="sxs-lookup"><span data-stu-id="041e9-544">in Visual Basic.</span></span>  
  
-   <span data-ttu-id="041e9-545">実装することはできません[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)インターフェイス。</span><span class="sxs-lookup"><span data-stu-id="041e9-545">You cannot implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on an interface.</span></span>  
  
-   <span data-ttu-id="041e9-546">型パラメーターを宣言することはできません[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)します。</span><span class="sxs-lookup"><span data-stu-id="041e9-546">You cannot declare a parameter to be of type [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span>  
  
-   <span data-ttu-id="041e9-547">[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)メソッド、プロパティ、またはフィールドの戻り値の型にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="041e9-547">[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cannot be the return type of a method, property, or field.</span></span>  
  
-   <span data-ttu-id="041e9-548">非表示にすることはできません、 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)次などのメソッド定義を使用して基底クラスから実装します。</span><span class="sxs-lookup"><span data-stu-id="041e9-548">You cannot hide your [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation from base classes by using a method definition such as the following:</span></span>  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     <span data-ttu-id="041e9-549">代わりに、 [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)実装は、基本クラスの実装を常にオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="041e9-549">Instead, the [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation.</span></span> <span data-ttu-id="041e9-550">`ToString` の実装を隠すことができるのは、厳密に型指定されたクラス インスタンスで呼び出す場合だけです。</span><span class="sxs-lookup"><span data-stu-id="041e9-550">You can hide a `ToString` implementation only by invoking it on a strongly typed class instance.</span></span>  
  
 <span data-ttu-id="041e9-551">さまざまな条件下で実装するマネージ型をネイティブ コードから呼び出すこと[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)の表示と非その[ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)実装は、予期しない動作を引き起こすことができます。</span><span class="sxs-lookup"><span data-stu-id="041e9-551">Note that under a variety of conditions, calls from native code to a managed type that implements [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) or hides its [ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation can produce unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="041e9-552">
            <para>オーバーライドする独自の型を実装するときに、<see cref="M:System.Object.ToString" />これらの種類の意味のある値を返すメソッド。派生クラスよりも書式設定制御を必要とする<see cref="M:System.Object.ToString" />提供を実装できます、<see cref="T:System.IFormattable" />インターフェイス。その<see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" />メソッドを使用すると、使用する書式を制御する書式指定文字列を定義して、<see cref="T:System.IFormatProvider" />カルチャに固有の書式を提供できるオブジェクト。オーバーライド、<see cref="M:System.Object.ToString" />メソッドが次のガイドラインに従う必要があります:-親しみやすく、人間が判読できる、返される文字列があります。 -返される文字列は、オブジェクトのインスタンスの値を一意に識別する必要があります。 -返される文字列は、デバッガーによって表示に適したできるように、できるだけ短くことがあります。 -<see cref="M:System.Object.ToString" />オーバーライドを返さないでください<see cref="F:System.String.Empty" />または null 文字列です。 -<see cref="M:System.Object.ToString" />上書きで例外をスローする必要があります。 場合、インスタンスの文字列表現は、カルチャに依存または複数の方法で書式設定することができます、実装、<see cref="T:System.IFormattable" />インターフェイス。 -返される文字列には、機密情報が含まれている場合、適切なアクセス許可をまず要求する必要があります。要求が成功すると、機密情報; を返すことができます。それ以外の場合、機密情報を除外する文字列を返す必要があります。 -<see cref="M:System.Object.ToString" />オーバーライドがデバッグでは、複雑な問題を回避するために副作用がありません。呼び出しなど、<see cref="M:System.Object.ToString" />メソッドはインスタンス フィールドの値を変更しないでください。 -の種類が解析メソッドを実装する場合 (または<see langword="Parse" />または<see langword="TryParse" />メソッド、コンス トラクター、または文字列から型のインスタンスをインスタンス化するいくつかその他の静的メソッド)、によって返される文字列を確認する必要がある、<see cref="M:System.Object.ToString" />メソッドを指定できますオブジェクトのインスタンスに変換されます。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="041e9-552">
              <para>When you implement your own types, you should override the <see cref="M:System.Object.ToString" /> method to return values that are meaningful for those types. Derived classes that require more control over formatting than <see cref="M:System.Object.ToString" /> provides can implement the <see cref="T:System.IFormattable" /> interface. Its <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> method enables you to define format strings that control formatting and to use an <see cref="T:System.IFormatProvider" /> object that can provide for culture-specific formatting.  Overrides of the <see cref="M:System.Object.ToString" /> method should follow these guidelines:  -   The returned string should be friendly and readable by humans.  -   The returned string should uniquely identify the value of the object instance.  -   The returned string should be as short as possible so that it is suitable for display by a debugger.  -   Your <see cref="M:System.Object.ToString" /> override should not return <see cref="F:System.String.Empty" /> or a null string.  -   Your <see cref="M:System.Object.ToString" /> override should not throw an exception.  -   If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <see cref="T:System.IFormattable" /> interface.  -   If the returned string includes sensitive information, you should first demand an appropriate permission. If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.  -   Your <see cref="M:System.Object.ToString" /> override should have no observable side effects to avoid complications in debugging. For example, a call to the <see cref="M:System.Object.ToString" /> method should not change the value of instance fields.  -   If your type implements a parsing method (or <see langword="Parse" /> or <see langword="TryParse" /> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <see cref="M:System.Object.ToString" /> method can be converted to an object instance.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>