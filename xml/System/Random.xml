<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="447dee75b747e7a9f668a091a7e5101818494ba4" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53222617" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="09be5-101">擬似乱数ジェネレーターを表します。擬似乱数ジェネレーターは、乱数についての統計的な要件を満たす数値系列を生成するデバイスです。</span><span class="sxs-lookup"><span data-stu-id="09be5-101">Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09be5-102">数値の有限のセットから等しい確率で擬似乱数が選択されます。</span><span class="sxs-lookup"><span data-stu-id="09be5-102">Pseudo-random numbers are chosen with equal probability from a finite set of numbers.</span></span> <span data-ttu-id="09be5-103">選択し、数学的アルゴリズムが使用されるが、実際には十分にランダムなために、選択した番号は完全にランダムではありません。</span><span class="sxs-lookup"><span data-stu-id="09be5-103">The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes.</span></span> <span data-ttu-id="09be5-104">現在の実装、<xref:System.Random>クラスは E. Donald Knuth の減算乱数ジェネレーター アルゴリズムの変更版に基づいています。</span><span class="sxs-lookup"><span data-stu-id="09be5-104">The current implementation of the <xref:System.Random> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm.</span></span> <span data-ttu-id="09be5-105">詳細については、D. E. を参照してください。</span><span class="sxs-lookup"><span data-stu-id="09be5-105">For more information, see D. E.</span></span> <span data-ttu-id="09be5-106">クヌースします。</span><span class="sxs-lookup"><span data-stu-id="09be5-106">Knuth.</span></span> <span data-ttu-id="09be5-107">*コンピューターのプログラミングでは、ボリューム 2 のアート:Seminumerical アルゴリズム*します。</span><span class="sxs-lookup"><span data-stu-id="09be5-107">*The Art of Computer Programming, Volume 2: Seminumerical Algorithms*.</span></span> <span data-ttu-id="09be5-108">Addison Wesley、読み取り、MA、3 番目のエディション、1997 です。</span><span class="sxs-lookup"><span data-stu-id="09be5-108">Addison-Wesley, Reading, MA, third edition, 1997.</span></span>  
  
 <span data-ttu-id="09be5-109">ランダムなパスワードを作成するのに適したものなどの暗号強度が高いランダムな数値を生成するには使用、<xref:System.Security.Cryptography.RNGCryptoServiceProvider>クラスまたは派生クラスを<xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="09be5-109">To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <xref:System.Security.Cryptography.RNGCryptoServiceProvider> class or derive a class from <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="09be5-110">このトピックの内容:</span><span class="sxs-lookup"><span data-stu-id="09be5-110">In this topic:</span></span>  
  
 <span data-ttu-id="09be5-111">[乱数ジェネレーターをインスタンス化します。](#Instantiate) </span><span class="sxs-lookup"><span data-stu-id="09be5-111">[Instantiating the random number generator](#Instantiate) </span></span>  
 <span data-ttu-id="09be5-112">[複数のインスタンス化を回避します。](#Multiple) </span><span class="sxs-lookup"><span data-stu-id="09be5-112">[Avoiding multiple instantiations](#Multiple) </span></span>  
 <span data-ttu-id="09be5-113">[System.Random クラスおよびスレッドの安全性](#ThreadSafety) </span><span class="sxs-lookup"><span data-stu-id="09be5-113">[The System.Random class and thread safety](#ThreadSafety) </span></span>  
 <span data-ttu-id="09be5-114">[さまざまな種類の乱数を生成します。](#Functionality) </span><span class="sxs-lookup"><span data-stu-id="09be5-114">[Generating different types of random numbers](#Functionality) </span></span>  
 <span data-ttu-id="09be5-115">[独自のアルゴリズムの置換](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="09be5-115">[Substituting your own algorithm](#Overriding) </span></span>  
 <span data-ttu-id="09be5-116">[System.Random を使用するには.](#Operations) </span><span class="sxs-lookup"><span data-stu-id="09be5-116">[How do you use System.Random to…](#Operations) </span></span>  
 [<span data-ttu-id="09be5-117">ランダムな値の同じシーケンスを取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-117">Retrieve the same sequence of random values</span></span>](#Same)  
 [<span data-ttu-id="09be5-118">ランダムな値の一意のシーケンスを取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-118">Retrieve unique sequences of random values</span></span>](#Unique)  
 [<span data-ttu-id="09be5-119">指定した範囲の整数を取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-119">Retrieve integers in a specified range</span></span>](#Range)  
 [<span data-ttu-id="09be5-120">指定した桁数を持つ整数を取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-120">Retrieve integers with a specified number of digits</span></span>](#Digits)  
 [<span data-ttu-id="09be5-121">指定した範囲の浮動小数点値を取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-121">Retrieve floating-point values in a specified range</span></span>](#Floats)  
 [<span data-ttu-id="09be5-122">ランダムなブール値を生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-122">Generate random Boolean values</span></span>](#Boolean)  
 [<span data-ttu-id="09be5-123">64 ビットの整数の乱数を生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-123">Generate random 64-bit integers</span></span>](#Long)  
 [<span data-ttu-id="09be5-124">指定した範囲内のバイトを取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-124">Retrieve bytes in a specified range</span></span>](#Bytes)  
 [<span data-ttu-id="09be5-125">配列またはコレクションから要素をランダムに取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-125">Retrieve an element from an array or collection at random</span></span>](#Array)  
 [<span data-ttu-id="09be5-126">配列またはコレクションからの一意の要素を取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-126">Retrieve a unique element from an array or collection</span></span>](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a><span data-ttu-id="09be5-127">乱数ジェネレーターをインスタンス化します。</span><span class="sxs-lookup"><span data-stu-id="09be5-127">Instantiating the random number generator</span></span>  
 <span data-ttu-id="09be5-128">シード値 (擬似乱数生成アルゴリズムの開始値) を提供することで、乱数ジェネレーターをインスタンス化する、<xref:System.Random.%23ctor%2A>クラスのコンス トラクター。</span><span class="sxs-lookup"><span data-stu-id="09be5-128">You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <xref:System.Random.%23ctor%2A> class constructor.</span></span>  <span data-ttu-id="09be5-129">明示的または暗黙的にシード値を指定できます。</span><span class="sxs-lookup"><span data-stu-id="09be5-129">You can supply the seed value either explicitly or implicitly:</span></span>  
  
-   <span data-ttu-id="09be5-130"><xref:System.Random.%23ctor%28System.Int32%29>コンス トラクターは指定する明示的なシード値を使用します。</span><span class="sxs-lookup"><span data-stu-id="09be5-130">The <xref:System.Random.%23ctor%28System.Int32%29> constructor uses an explicit seed value that you supply.</span></span>  
  
-   <span data-ttu-id="09be5-131"><xref:System.Random.%23ctor>コンス トラクターでは、システム クロックを使用して、シード値を提供します。</span><span class="sxs-lookup"><span data-stu-id="09be5-131">The <xref:System.Random.%23ctor> constructor uses the system clock to provide a seed value.</span></span> <span data-ttu-id="09be5-132">これは、乱数ジェネレーターをインスタンス化する最も一般的な方法です。</span><span class="sxs-lookup"><span data-stu-id="09be5-132">This is the most common way of instantiating the random number generator.</span></span>  
  
 <span data-ttu-id="09be5-133">同じシードが個別に使用される場合<xref:System.Random>オブジェクト、同じ一連のランダムな番号が生成されます。</span><span class="sxs-lookup"><span data-stu-id="09be5-133">If the same seed is used for separate <xref:System.Random> objects, they will generate the same series of random numbers.</span></span> <span data-ttu-id="09be5-134">乱数値を処理するテスト スイートを作成するため、またはそのデータをランダムな数値から派生したゲームを再生するために役立ちます。 ことができます。</span><span class="sxs-lookup"><span data-stu-id="09be5-134">This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers.</span></span> <span data-ttu-id="09be5-135">ただし、<xref:System.Random>同一のシード値がインスタンス化している場合でも、異なるバージョンの .NET Framework で実行されているプロセス内のオブジェクトが別の一連のランダムな数値を返す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="09be5-135">However, note that <xref:System.Random> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.</span></span>  
  
 <span data-ttu-id="09be5-136">ランダムな数値のさまざまなシーケンスを生成するために行うことができます、シード値時間に依存のための新しいインスタンスごとに別の系列を生成<xref:System.Random>します。</span><span class="sxs-lookup"><span data-stu-id="09be5-136">To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <xref:System.Random>.</span></span> <span data-ttu-id="09be5-137">パラメーター化された<xref:System.Random.%23ctor%28System.Int32%29>コンス トラクターがかかることができます、<xref:System.Int32>値に基づいてタイマー刻みの数、現在の時刻では、パラメーターなし<xref:System.Random.%23ctor>コンス トラクターでは、システム クロックを使用して、シード値を生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-137">The parameterized <xref:System.Random.%23ctor%28System.Int32%29> constructor can take an <xref:System.Int32> value based on the number of ticks in the current time, whereas the parameterless <xref:System.Random.%23ctor> constructor uses the system clock to generate its seed value.</span></span> <span data-ttu-id="09be5-138">ただし、クロックは有限の解像度があるために、このパラメーターなしのコンス トラクターを異なるを作成する使用<xref:System.Random>連続でオブジェクトが同一のシーケンスのランダムな数値を生成する乱数ジェネレーターを作成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-138">However, because the clock has finite resolution, using the parameterless constructor to create different <xref:System.Random> objects in close succession creates random number generators that produce identical sequences of random numbers.</span></span> <span data-ttu-id="09be5-139">次の例 2 つ<xref:System.Random>連続でインスタンス化されるオブジェクトは、同一の一連のランダムな数値を生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-139">The following example illustrates how two <xref:System.Random> objects that are instantiated in close succession generate an identical series of random numbers.</span></span> <span data-ttu-id="09be5-140">ほとんどの Windows システムで<xref:System.Random>互いの 15 ミリ秒以内に作成されたオブジェクトが同一のシード値を持つ可能性があります。</span><span class="sxs-lookup"><span data-stu-id="09be5-140">On most Windows systems, <xref:System.Random> objects created within 15 milliseconds of one another are likely to have identical seed values.</span></span>  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 <span data-ttu-id="09be5-141">この問題を回避するには、1 つを作成<xref:System.Random>複数のオブジェクトではなくオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="09be5-141">To avoid this problem, create a single <xref:System.Random> object instead of multiple objects.</span></span>  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a><span data-ttu-id="09be5-142">複数のインスタンス化を回避します。</span><span class="sxs-lookup"><span data-stu-id="09be5-142">Avoiding multiple instantiations</span></span>  
 <span data-ttu-id="09be5-143">2 つの random number generator または立て続けに短いループ内の初期化中には、ランダムな数値の同一のシーケンスを生成できる 2 つの random number generator が作成されます。</span><span class="sxs-lookup"><span data-stu-id="09be5-143">Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers.</span></span> <span data-ttu-id="09be5-144">ほとんどの場合、これは、開発者の意図でありをインスタンス化し、乱数ジェネレーターの初期化がプロセスが比較的安価であるため、パフォーマンスの問題につながることができます。</span><span class="sxs-lookup"><span data-stu-id="09be5-144">In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.</span></span>  
  
 <span data-ttu-id="09be5-145">両方のパフォーマンスを向上させるために、誤って同じ数値のシーケンスを生成する別の random number generator を作成しないようにする、1 つを作成すること勧め<xref:System.Random>オブジェクトを作成する代わりに、時間の経過と共に多くの乱数を生成するには新しい<xref:System.Random>1 つの乱数を生成するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="09be5-145">Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <xref:System.Random> object to generate many random numbers over time, instead of creating new <xref:System.Random> objects to generate one random number.</span></span>  
  
 <span data-ttu-id="09be5-146">ただし、<xref:System.Random>クラスは、スレッド セーフであります。</span><span class="sxs-lookup"><span data-stu-id="09be5-146">However, the <xref:System.Random> class isn't thread safe.</span></span> <span data-ttu-id="09be5-147">呼び出す場合<xref:System.Random>、複数のスレッドからメソッドが次のセクションで説明されているガイドラインに従います。</span><span class="sxs-lookup"><span data-stu-id="09be5-147">If you call <xref:System.Random> methods from multiple threads, follow the guidelines discussed in the next section.</span></span>  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a><span data-ttu-id="09be5-148">System.Random クラスおよびスレッドの安全性</span><span class="sxs-lookup"><span data-stu-id="09be5-148">The System.Random class and thread safety</span></span>  
 <span data-ttu-id="09be5-149">個々 のインスタンス化するのではなく<xref:System.Random>オブジェクト、1 つを作成することをお勧めします。<xref:System.Random>インスタンスにより、アプリが必要なすべての乱数を生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-149">Instead of instantiating individual <xref:System.Random> objects, we recommend that you create a single <xref:System.Random> instance to generate all the random numbers needed by your app.</span></span> <span data-ttu-id="09be5-150">ただし、<xref:System.Random>オブジェクトはスレッド セーフではありません。</span><span class="sxs-lookup"><span data-stu-id="09be5-150">However, <xref:System.Random> objects are not thread safe.</span></span> <span data-ttu-id="09be5-151">アプリを呼び出す場合<xref:System.Random>複数のスレッドからメソッド、1 つのスレッドが一度に乱数ジェネレーターをアクセスできるようにする同期オブジェクトを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="09be5-151">If your app calls <xref:System.Random> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time.</span></span> <span data-ttu-id="09be5-152">いることを確認しない場合、<xref:System.Random>オブジェクトがスレッド セーフな方法でアクセスされる、ランダムな数値を返すメソッドを呼び出すには 0 が返されます。</span><span class="sxs-lookup"><span data-stu-id="09be5-152">If you don't ensure that the <xref:System.Random> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.</span></span>  
  
 <span data-ttu-id="09be5-153">次の例では、c# 使用[lock ステートメント](~/docs/csharp/language-reference/keywords/lock-statement.md)および Visual Basic [SyncLock ステートメント](~/docs/visual-basic/language-reference/statements/synclock-statement.md)を 1 つ乱数ジェネレーターにスレッド セーフ方式で 11 のスレッドによってアクセスすることを確認します。</span><span class="sxs-lookup"><span data-stu-id="09be5-153">The following example uses the C# [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) and the Visual Basic [SyncLock statement](~/docs/visual-basic/language-reference/statements/synclock-statement.md) to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner.</span></span> <span data-ttu-id="09be5-154">各スレッドで 200万の乱数を生成し生成されたランダムな数字の数をカウント、その合計を計算し、実行が完了すると、すべてのスレッドの合計を更新します。</span><span class="sxs-lookup"><span data-stu-id="09be5-154">Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.</span></span>  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 <span data-ttu-id="09be5-155">例では、次の方法でスレッド セーフを保証します。</span><span class="sxs-lookup"><span data-stu-id="09be5-155">The example ensures thread-safety in the following ways:</span></span>  
  
-   <span data-ttu-id="09be5-156"><xref:System.ThreadStaticAttribute>乱数を生成し、スレッドごとに、その合計の合計数を追跡するスレッド ローカル変数を定義する属性を使用します。</span><span class="sxs-lookup"><span data-stu-id="09be5-156">The <xref:System.ThreadStaticAttribute> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.</span></span>  
  
-   <span data-ttu-id="09be5-157">ロック (、 `lock` (C#) ステートメント、 `SyncLock` Visual Basic でのステートメント) の合計数とすべてのスレッドで生成されたすべてのランダムな数の合計、変数へのアクセスを保護します。</span><span class="sxs-lookup"><span data-stu-id="09be5-157">A lock (the `lock` statement in C# and the `SyncLock` statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.</span></span>  
  
-   <span data-ttu-id="09be5-158">セマフォ (、<xref:System.Threading.CountdownEvent>オブジェクト)、メイン スレッドがブロックまで他のすべてのスレッドが実行を完了することを確認するために使用します。</span><span class="sxs-lookup"><span data-stu-id="09be5-158">A semaphore (the <xref:System.Threading.CountdownEvent> object) is used to ensure that the main thread blocks until all other threads complete execution.</span></span>  
  
-   <span data-ttu-id="09be5-159">この例では、かどうか、乱数ジェネレーターが破損を特定することにランダムな番号の生成方法の 2 つの連続した呼び出しは、0 を返すかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="09be5-159">The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0.</span></span> <span data-ttu-id="09be5-160">破損が検出された場合の例では、<xref:System.Threading.CancellationTokenSource>オブジェクトからすべてのスレッドを取り消す必要があることを通知します。</span><span class="sxs-lookup"><span data-stu-id="09be5-160">If corruption is detected, the example uses the <xref:System.Threading.CancellationTokenSource> object to signal that all threads should be canceled.</span></span>  
  
-   <span data-ttu-id="09be5-161">状態を調べ、各スレッドごとの乱数を生成する前に、<xref:System.Threading.CancellationToken>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="09be5-161">Before generating each random number, each thread checks the state of the <xref:System.Threading.CancellationToken> object.</span></span> <span data-ttu-id="09be5-162">キャンセルが要求される場合の例では、<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>スレッドをキャンセルするメソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-162">If cancellation is requested, the example calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method to cancel the thread.</span></span>  
  
 <span data-ttu-id="09be5-163">使用する点を除いて、次の例は、最初と同じ、<xref:System.Threading.Tasks.Task>オブジェクトとラムダ式の代わりに<xref:System.Threading.Thread>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="09be5-163">The following example is identical to the first, except that it uses a <xref:System.Threading.Tasks.Task> object and a lambda expression instead of <xref:System.Threading.Thread> objects.</span></span>  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 <span data-ttu-id="09be5-164">最初の例から次の方法で異なります。</span><span class="sxs-lookup"><span data-stu-id="09be5-164">It differs from the first example in the following ways:</span></span>  
  
-   <span data-ttu-id="09be5-165">使用する必要はありませんので、生成されたランダムな数字の数と各タスクでは、その合計を追跡する変数はタスクは、ローカル、<xref:System.ThreadStaticAttribute>属性。</span><span class="sxs-lookup"><span data-stu-id="09be5-165">The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="09be5-166">静的な<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>メソッドを使用して、すべてのタスクが完了する前に、メイン スレッドが完了しないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="09be5-166">The static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method is used to ensure that the main thread doesn't complete before all tasks have finished.</span></span> <span data-ttu-id="09be5-167">必要はありません、<xref:System.Threading.CountdownEvent>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="09be5-167">There is no need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
-   <span data-ttu-id="09be5-168">タスクのキャンセルに起因する例外が表示される、<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-168">The exception that results from task cancellation is surfaced in the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="09be5-169">前の例では、各スレッドで処理されます。</span><span class="sxs-lookup"><span data-stu-id="09be5-169">In the previous example, it is handled by each thread.</span></span>  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a><span data-ttu-id="09be5-170">さまざまな種類の乱数を生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-170">Generating different types of random numbers</span></span>  
 <span data-ttu-id="09be5-171">乱数ジェネレーターは、次の種類の乱数を生成できるメソッドを提供します。</span><span class="sxs-lookup"><span data-stu-id="09be5-171">The random number generator provides methods that let you generate the following kinds of random numbers:</span></span>  
  
-   <span data-ttu-id="09be5-172">一連の<xref:System.Byte>値。</span><span class="sxs-lookup"><span data-stu-id="09be5-172">A series of <xref:System.Byte> values.</span></span> <span data-ttu-id="09be5-173">メソッドに戻るようにする要素の数に初期化された配列を渡すことによってバイト値の数を決定する、<xref:System.Random.NextBytes%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-173">You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <xref:System.Random.NextBytes%2A> method.</span></span> <span data-ttu-id="09be5-174">次の例では、20 バイトを生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-174">The following example generates 20 bytes.</span></span>  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   <span data-ttu-id="09be5-175">1 つの整数。</span><span class="sxs-lookup"><span data-stu-id="09be5-175">A single integer.</span></span> <span data-ttu-id="09be5-176">最大値は 0 から整数にするかどうかを選択できます (<xref:System.Int32.MaxValue?displayProperty=nameWithType> - 1) を呼び出して、<xref:System.Random.Next>メソッドは、0 から呼び出すことによって、特定の値までの整数、<xref:System.Random.Next%28System.Int32%29>メソッド、または、を呼び出すことによって値の範囲内の整数<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-176">You can choose whether you want an integer from 0 to a maximum value (<xref:System.Int32.MaxValue?displayProperty=nameWithType> - 1) by calling the <xref:System.Random.Next> method, an integer between 0 and a specific value by calling the <xref:System.Random.Next%28System.Int32%29> method, or an integer within a range of values by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="09be5-177">パラメーター化されたオーバー ロードで指定された最大値は排他的です。生成された実際の最大数は、1 つは、指定した値より小さくします。</span><span class="sxs-lookup"><span data-stu-id="09be5-177">In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.</span></span>  
  
     <span data-ttu-id="09be5-178">次の例では、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> -10 ~ 10 の間の 10 個の乱数を生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-178">The following example calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to generate 10 random numbers between -10 and 10.</span></span> <span data-ttu-id="09be5-179">メソッドの 2 番目の引数がメソッドによって返されるランダムな値の範囲の上限を指定することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="09be5-179">Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method.</span></span> <span data-ttu-id="09be5-180">つまり、メソッドは、1 つを返すことができる最大の整数値よりも小さい値です。</span><span class="sxs-lookup"><span data-stu-id="09be5-180">In other words, the largest integer that the method can return is one less than this value.</span></span>  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   <span data-ttu-id="09be5-181">呼び出すことによって 1.0 より小さい 0.0 から 1 つの浮動小数点値、<xref:System.Random.NextDouble%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-181">A single floating-point value from 0.0 to less than 1.0 by calling the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="09be5-182">メソッドによって返される乱数の排他的上限値は、その実際の上限は 0.99999999999999978 1 です。</span><span class="sxs-lookup"><span data-stu-id="09be5-182">The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978.</span></span> <span data-ttu-id="09be5-183">次の例では、10 個のランダムな浮動小数点数値を生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-183">The following example generates 10 random floating-point numbers.</span></span>  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="09be5-184"><xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>メソッドでは、返される乱数の範囲を指定できます。</span><span class="sxs-lookup"><span data-stu-id="09be5-184">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method allows you to specify the range of the returned random number.</span></span> <span data-ttu-id="09be5-185">ただし、`maxValue`範囲の上限に返される数値を指定するには、パラメーターは、排他、包括、いない値。</span><span class="sxs-lookup"><span data-stu-id="09be5-185">However, the `maxValue` parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="09be5-186">つまり、メソッドの呼び出し`Next(0, 100)`0 ~ 99 の範囲演算子と not between 0 と 100 の値を返します。</span><span class="sxs-lookup"><span data-stu-id="09be5-186">This means that the method call `Next(0, 100)` returns a value between 0 and 99, and not between 0 and 100.</span></span>  
  
 <span data-ttu-id="09be5-187">使用することも、<xref:System.Random>などのタスクを生成するためのクラス[ランダム T:System.Boolean 値](#Boolean)生成、[ランダムな浮動小数点値以外の 0 ~ 1 の範囲で](#Floats)を生成する[64 ビットの整数の乱数](#Long)、および[の一意の要素を配列またはコレクションからランダムに取得](#UniqueArray)します。</span><span class="sxs-lookup"><span data-stu-id="09be5-187">You can also use the <xref:System.Random> class for such tasks as generating [random T:System.Boolean values](#Boolean), generating [random floating point values with a range other than 0 to 1](#Floats), generating [random 64-bit integers](#Long), and [randomly retrieving a unique element from an array or collection](#UniqueArray).</span></span> <span data-ttu-id="09be5-188">これらおよびその他の一般的なタスクは、次を参照してください、 [System.Random を使用する.。](#Operations)</span><span class="sxs-lookup"><span data-stu-id="09be5-188">For these and other common tasks, see the [How do you use System.Random to…](#Operations)</span></span> <span data-ttu-id="09be5-189">セクション。</span><span class="sxs-lookup"><span data-stu-id="09be5-189">section.</span></span>  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a><span data-ttu-id="09be5-190">独自のアルゴリズムの置換</span><span class="sxs-lookup"><span data-stu-id="09be5-190">Substituting your own algorithm</span></span>  
 <span data-ttu-id="09be5-191">継承することによって、独自の乱数を実装することができます、<xref:System.Random>クラスと乱数の生成アルゴリズムを指定します。</span><span class="sxs-lookup"><span data-stu-id="09be5-191">You can implement your own random number generator by inheriting from the <xref:System.Random> class and supplying your random number generation algorithm.</span></span> <span data-ttu-id="09be5-192">オーバーライドする必要があります、独自のアルゴリズムを指定する、<xref:System.Random.Sample%2A>メソッドで、乱数生成アルゴリズムを実装します。</span><span class="sxs-lookup"><span data-stu-id="09be5-192">To supply your own algorithm, you must override the <xref:System.Random.Sample%2A> method, which implements the random number generation algorithm.</span></span> <span data-ttu-id="09be5-193">オーバーライドすることも必要があります、 <xref:System.Random.Next>、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>、および<xref:System.Random.NextBytes%2A>メソッドのオーバーライドを呼び出すことを確認する<xref:System.Random.Sample%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-193">You should also override the <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, and <xref:System.Random.NextBytes%2A> methods to ensure that they call your overridden <xref:System.Random.Sample%2A> method.</span></span> <span data-ttu-id="09be5-194">オーバーライドする必要はありません、<xref:System.Random.Next%28System.Int32%29>と<xref:System.Random.NextDouble%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-194">You don't have to override the <xref:System.Random.Next%28System.Int32%29> and <xref:System.Random.NextDouble%2A> methods.</span></span>  
  
 <span data-ttu-id="09be5-195">派生する例については、<xref:System.Random>クラスし、その既定擬似乱数ジェネレーター、変更を参照してください、<xref:System.Random.Sample%2A>リファレンス ページです。</span><span class="sxs-lookup"><span data-stu-id="09be5-195">For an example that derives from the <xref:System.Random> class and modifies its default pseudo-random number generator, see the <xref:System.Random.Sample%2A> reference page.</span></span>  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a><span data-ttu-id="09be5-196">System.Random を使用するには.</span><span class="sxs-lookup"><span data-stu-id="09be5-196">How do you use System.Random to…</span></span>  
 <span data-ttu-id="09be5-197">次のセクションでは、説明し、ランダムな数値をアプリで使用する方法のいくつかのサンプル コードを提供します。</span><span class="sxs-lookup"><span data-stu-id="09be5-197">The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.</span></span>  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a><span data-ttu-id="09be5-198">ランダムな値の同じシーケンスを取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-198">Retrieve the same sequence of random values</span></span>  
 <span data-ttu-id="09be5-199">ゲームのプレイとソフトウェア テスト シナリオで同じランダムな数値のシーケンスを生成することがあります。</span><span class="sxs-lookup"><span data-stu-id="09be5-199">Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing.</span></span> <span data-ttu-id="09be5-200">ランダムな数値のシーケンスが同じテストを使用すると、回帰を検出し、バグの修正を確認できます。</span><span class="sxs-lookup"><span data-stu-id="09be5-200">Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes.</span></span> <span data-ttu-id="09be5-201">ゲームで同じランダムな数値のシーケンスを使用して以前のゲームを再生することができます。</span><span class="sxs-lookup"><span data-stu-id="09be5-201">Using the same sequence of random number in games allows you to replay previous games.</span></span>  
  
 <span data-ttu-id="09be5-202">同じシード値を提供することで同じランダムな数値のシーケンスを生成することができます、<xref:System.Random.%23ctor%28System.Int32%29>コンス トラクター。</span><span class="sxs-lookup"><span data-stu-id="09be5-202">You can generate the same sequence of random numbers by providing the same seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="09be5-203">シード値は、擬似乱数生成アルゴリズムの開始値を提供します。</span><span class="sxs-lookup"><span data-stu-id="09be5-203">The seed value provides a starting value for the pseudo-random number generation algorithm.</span></span> <span data-ttu-id="09be5-204">次の例では、任意のシード値として 100100 をでインスタンス化する、<xref:System.Random>オブジェクト、20 個のランダムな浮動小数点値を表示およびシード値が引き続き発生します。</span><span class="sxs-lookup"><span data-stu-id="09be5-204">The following example uses 100100 as an arbitrary seed value to instantiate the <xref:System.Random> object, displays 20 random floating-point values, and persists the seed value.</span></span> <span data-ttu-id="09be5-205">シード値を復元する、新しいランダムな番号ジェネレーターのインスタンスを作成し、20 同じのランダムな浮動小数点値を表示します。</span><span class="sxs-lookup"><span data-stu-id="09be5-205">It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.</span></span>  <span data-ttu-id="09be5-206">例も、異なるバージョンの .NET Framework 上で実行する場合に、ランダムな数値のさまざまなシーケンスを生成可能性がありますに注意してください。</span><span class="sxs-lookup"><span data-stu-id="09be5-206">Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.</span></span>  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a><span data-ttu-id="09be5-207">乱数の一意のシーケンスを取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-207">Retrieve unique sequences of random numbers</span></span>  
 <span data-ttu-id="09be5-208">インスタンスに異なるシード値を提供する、<xref:System.Random>クラスにより各乱数ジェネレーターの値のさまざまなシーケンスを生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-208">Providing different seed values to instances of the <xref:System.Random> class causes each random number generator to produce a different sequence of values.</span></span> <span data-ttu-id="09be5-209">シード値を明示的に呼び出していずれかで行うことができます、<xref:System.Random.%23ctor%28System.Int32%29>コンス トラクター、または暗黙的に呼び出して、<xref:System.Random.%23ctor>コンス トラクター。</span><span class="sxs-lookup"><span data-stu-id="09be5-209">You can provide a seed value either explicitly by calling the <xref:System.Random.%23ctor%28System.Int32%29> constructor, or implicitly by calling the <xref:System.Random.%23ctor> constructor.</span></span> <span data-ttu-id="09be5-210">ほとんどの開発者は、システム クロックを使用してパラメーターなしのコンス トラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="09be5-210">Most developers call the parameterless constructor, which uses the system clock.</span></span> <span data-ttu-id="09be5-211">次の例では、このアプローチを使用して 2 つのインスタンスを作成する<xref:System.Random>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="09be5-211">The following example uses this approach to instantiate two <xref:System.Random> instances.</span></span> <span data-ttu-id="09be5-212">各インスタンスは、一連の 10 個のランダムな整数を表示します。</span><span class="sxs-lookup"><span data-stu-id="09be5-212">Each instance displays a series of 10 random integers.</span></span>  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 <span data-ttu-id="09be5-213">ただし、有限の解像度のため、システム クロックが約 15 ミリ秒未満である時間の相違点を検出しません。</span><span class="sxs-lookup"><span data-stu-id="09be5-213">However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds.</span></span> <span data-ttu-id="09be5-214">そのため、コードを呼び出す場合、 <xref:System.Random.%23ctor> 2 つのインスタンスを作成するオーバー ロード<xref:System.Random>する可能性がありますが誤ってするオブジェクトを提供する、同一のシード値を連続してオブジェクトします。</span><span class="sxs-lookup"><span data-stu-id="09be5-214">Therefore, if your code calls the <xref:System.Random.%23ctor> overload to instantiate two <xref:System.Random> objects in succession, you might inadvertently be providing the objects with identical seed values.</span></span> <span data-ttu-id="09be5-215">前の例では、これを参照してくださいをコメント アウト、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>メソッドの呼び出しとコンパイルと実行の例をもう一度です。</span><span class="sxs-lookup"><span data-stu-id="09be5-215">To see this in the previous example, comment out the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method call, and compile and run the example again.</span></span>  
  
 <span data-ttu-id="09be5-216">これが事態を防ぐためにお勧め、1 つのインスタンスを作成する<xref:System.Random>複数のではなくオブジェクトします。</span><span class="sxs-lookup"><span data-stu-id="09be5-216">To prevent this from happening, we recommend that you instantiate a single <xref:System.Random> object rather than multiple ones.</span></span> <span data-ttu-id="09be5-217">ただし、<xref:System.Random>いないスレッド セーフであるためにアクセスする場合は、いくつかの同期デバイスを使用する必要があります、<xref:System.Random>詳細については複数のスレッドからのインスタンスは、「 [、ランダムなクラスおよびスレッドの安全性](#ThreadSafety)この以前トピックです。</span><span class="sxs-lookup"><span data-stu-id="09be5-217">However, since <xref:System.Random> isn't thread safe, you must use some synchronization device if you access a <xref:System.Random> instance from multiple threads; for more information, see [The Random class and thread safety](#ThreadSafety) earlier in this topic.</span></span> <span data-ttu-id="09be5-218">など、遅延メカニズムを使用する代わりに、<xref:System.Threading.Thread.Sleep%2A>メソッドの前の例では、インスタンス化には、15 を超えるミリ秒間隔が発生することを確認するために使用します。</span><span class="sxs-lookup"><span data-stu-id="09be5-218">Alternately, you can use a delay mechanism, such as the <xref:System.Threading.Thread.Sleep%2A> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.</span></span>  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a><span data-ttu-id="09be5-219">指定した範囲の整数を取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-219">Retrieve integers in a specified range</span></span>  
 <span data-ttu-id="09be5-220">指定した範囲の整数を取得するには呼び出すことによって、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>メソッドは、返される乱数ジェネレーターの数値の上限と下限を指定することができます。</span><span class="sxs-lookup"><span data-stu-id="09be5-220">You can retrieve integers in a specified range by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return.</span></span> <span data-ttu-id="09be5-221">上限は、排他、包括、いない値です。</span><span class="sxs-lookup"><span data-stu-id="09be5-221">The upper bound is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="09be5-222">つまり、メソッドによって返される値の範囲に含まれていません。</span><span class="sxs-lookup"><span data-stu-id="09be5-222">That is, it isn't included in the range of values returned by the method.</span></span> <span data-ttu-id="09be5-223">次の例では、このメソッドを使用して、-10 ~ 10 の間の整数の乱数を生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-223">The following example uses this method to generate random integers between -10 and 10.</span></span> <span data-ttu-id="09be5-224">1 つの値として、目的の値よりも大きい値である、11 を指定しているメモの`maxValue`メソッド呼び出しの引数。</span><span class="sxs-lookup"><span data-stu-id="09be5-224">Note that it specifies 11, which is one greater than the desired value, as the value of the `maxValue` argument in the method call.</span></span>  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a><span data-ttu-id="09be5-225">指定した桁数を持つ整数を取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-225">Retrieve integers with a specified number of digits</span></span>  
 <span data-ttu-id="09be5-226">呼び出すことができます、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>指定した桁数で数値を取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-226">You can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to retrieve numbers with a specified number of digits.</span></span> <span data-ttu-id="09be5-227">呼び出すこと (1000 から 9999 の範囲数) の 4 桁の番号を取得するには、たとえば、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>メソッドを`minValue`値は 1000 と`maxValue`として次の例は、10000 の値。</span><span class="sxs-lookup"><span data-stu-id="09be5-227">For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method with a `minValue` value of 1000 and a `maxValue` value of 10000, as the following example shows.</span></span>  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a><span data-ttu-id="09be5-228">指定した範囲の浮動小数点値を取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-228">Retrieve floating-point values in a specified range</span></span>  
 <span data-ttu-id="09be5-229"><xref:System.Random.NextDouble%2A>メソッド 0 を返しますランダムな浮動小数点値の範囲を 1 未満にします。</span><span class="sxs-lookup"><span data-stu-id="09be5-229">The <xref:System.Random.NextDouble%2A> method returns random floating-point values that range from 0 to less than 1.</span></span> <span data-ttu-id="09be5-230">ただし、多くの場合、たいその他のいくつかの範囲にランダムな値を生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-230">However, you'll often want to generate random values in some other range.</span></span>  
  
 <span data-ttu-id="09be5-231">によって返される数に必要な開始時間間隔と 0 の違いを追加するには必要な最小値と最大値までの間隔が 1 の場合、<xref:System.Random.NextDouble%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-231">If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="09be5-232">次の例は、-1 から 0 までの 10 個の乱数を生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-232">The following example does this to generate 10 random numbers between -1 and 0.</span></span>  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 <span data-ttu-id="09be5-233">浮動小数点乱数を生成する下限は 0 が、上限は 1 より大きい (または、負の数値の場合の下限の境界が-1 未満です、上限は 0)、0 以外のバインドでランダムな数値を乗算します。</span><span class="sxs-lookup"><span data-stu-id="09be5-233">To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound.</span></span> <span data-ttu-id="09be5-234">次の例はこれを 2,000万浮動小数点乱数を生成する範囲 0 ~<xref:System.Int64.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="09be5-234">The following example does this to generate 20 million random floating-point numbers that range from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="09be5-235">も、メソッドによって生成されるランダムな値の分布を表示します。</span><span class="sxs-lookup"><span data-stu-id="09be5-235">In also displays the distribution of the random values generated by the method.</span></span>  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 <span data-ttu-id="09be5-236">などの任意の 2 つの値の間で浮動小数点乱数を生成する、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>メソッドは、整数の場合は、次の数式を使用します。</span><span class="sxs-lookup"><span data-stu-id="09be5-236">To generate random floating-point numbers between two arbitrary values, like the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method does for integers, use the following formula:</span></span>  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 <span data-ttu-id="09be5-237">次の例では、11.0 に 10.0 から 100万の乱数の範囲を生成し、その分布が表示されます。</span><span class="sxs-lookup"><span data-stu-id="09be5-237">The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.</span></span>  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a><span data-ttu-id="09be5-238">ランダムなブール値を生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-238">Generate random Boolean values</span></span>  
 <span data-ttu-id="09be5-239"><xref:System.Random>クラスを生成するメソッドを提供しません<xref:System.Boolean>値。</span><span class="sxs-lookup"><span data-stu-id="09be5-239">The <xref:System.Random> class doesn't provide methods that generate <xref:System.Boolean> values.</span></span> <span data-ttu-id="09be5-240">ただし、独自のクラスまたはそのメソッドを定義できます。</span><span class="sxs-lookup"><span data-stu-id="09be5-240">However, you can define your own class or method to do that.</span></span> <span data-ttu-id="09be5-241">次の例では、クラスを定義する`BooleanGenerator`、単一のメソッドと`NextBoolean`します。</span><span class="sxs-lookup"><span data-stu-id="09be5-241">The following example defines a class, `BooleanGenerator`, with a single method, `NextBoolean`.</span></span> <span data-ttu-id="09be5-242">`BooleanGenerator`ストア クラス、<xref:System.Random>秘密の変数としてのオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="09be5-242">The `BooleanGenerator` class stores a <xref:System.Random> object as a private variable.</span></span> <span data-ttu-id="09be5-243">`NextBoolean`メソッドの呼び出し、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>メソッドにより、結果と、<xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType>メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-243">The `NextBoolean` method calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method and passes the result to the <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="09be5-244">ランダムな数の上限を指定する引数として 2 が使用されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="09be5-244">Note that 2 is used as the argument to specify the upper bound of the random number.</span></span> <span data-ttu-id="09be5-245">これは、排他的な値であるため、メソッドの呼び出しは、0 または 1 を返します。</span><span class="sxs-lookup"><span data-stu-id="09be5-245">Since this is an exclusive value, the method call returns either 0 or 1.</span></span>  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 <span data-ttu-id="09be5-246">乱数を生成する別のクラスを作成する代わりに<xref:System.Boolean>値、例では、1 つのメソッドが定義だけでした。</span><span class="sxs-lookup"><span data-stu-id="09be5-246">Instead of creating a separate class to generate random <xref:System.Boolean> values, the example could simply have defined a single method.</span></span> <span data-ttu-id="09be5-247">ただし、その場合、<xref:System.Random>オブジェクトを新しいをインスタンス化を回避するためにクラス レベルの変数として定義する必要があります<xref:System.Random>各メソッド呼び出し内のインスタンス。</span><span class="sxs-lookup"><span data-stu-id="09be5-247">In that case, however, the <xref:System.Random> object should have been defined as a class-level variable to avoid instantiating a new <xref:System.Random> instance in each method call.</span></span> <span data-ttu-id="09be5-248">Visual basic でとして Random インスタンスを定義することができます、[静的](~/docs/visual-basic/language-reference/modifiers/static.md)変数、`NextBoolean`メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-248">In Visual Basic, the Random instance can be defined as a [Static](~/docs/visual-basic/language-reference/modifiers/static.md) variable in the `NextBoolean` method.</span></span>  <span data-ttu-id="09be5-249">次の例は、実装を提供します。</span><span class="sxs-lookup"><span data-stu-id="09be5-249">The following example provides an implementation.</span></span>  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a><span data-ttu-id="09be5-250">64 ビットの整数の乱数を生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-250">Generate random 64-bit integers</span></span>  
 <span data-ttu-id="09be5-251">オーバー ロード、<xref:System.Random.Next%2A>メソッドは、32 ビット整数を返します。</span><span class="sxs-lookup"><span data-stu-id="09be5-251">The overloads of the <xref:System.Random.Next%2A> method return 32-bit integers.</span></span> <span data-ttu-id="09be5-252">ただし、場合によっては、64 ビット整数を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="09be5-252">However, in some cases, you might want to work with 64-bit integers.</span></span> <span data-ttu-id="09be5-253">このことは次のように実行できます。</span><span class="sxs-lookup"><span data-stu-id="09be5-253">You can do this as follows:</span></span>  
  
1.  <span data-ttu-id="09be5-254">呼び出す、<xref:System.Random.NextDouble%2A>取得倍精度浮動小数点値。</span><span class="sxs-lookup"><span data-stu-id="09be5-254">Call the <xref:System.Random.NextDouble%2A> method to retrieve a double-precision floating point value.</span></span>  
  
2.  <span data-ttu-id="09be5-255">その値に乗算<xref:System.Int64.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="09be5-255">Multiply that value by <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="09be5-256">次の例では、この手法を使用して、20 件の長整数の乱数を生成するし、10 個のと同じグループ内に分類されています。</span><span class="sxs-lookup"><span data-stu-id="09be5-256">The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups.</span></span> <span data-ttu-id="09be5-257">0 から、各グループ内の数をカウントすることによってランダムな数値の分布を評価し、<xref:System.Int64.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="09be5-257">It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="09be5-258">例の出力に示すよう番号が長整数の範囲を増減均等に分散されます。</span><span class="sxs-lookup"><span data-stu-id="09be5-258">As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.</span></span>  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 <span data-ttu-id="09be5-259">ビットの操作を使用する代替手法は、真の乱数を生成しません。</span><span class="sxs-lookup"><span data-stu-id="09be5-259">An alternative technique that uses bit manipulation does not generate truly random numbers.</span></span> <span data-ttu-id="09be5-260">この手法を呼び出す<xref:System.Random.Next>2 つの整数、左シフト 1 で 32 ビット、および Or を生成することです。</span><span class="sxs-lookup"><span data-stu-id="09be5-260">This technique calls <xref:System.Random.Next> to generate two integers, left-shifts one by 32 bits, and ORs them together.</span></span> <span data-ttu-id="09be5-261">この手法では、2 つの制限があります。</span><span class="sxs-lookup"><span data-stu-id="09be5-261">This technique has two limitations:</span></span>  
  
1.  <span data-ttu-id="09be5-262">31 ビットは符号ビットであるため、結果の長整数のビット 31 の値は常に 0 です。</span><span class="sxs-lookup"><span data-stu-id="09be5-262">Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.</span></span>  <span data-ttu-id="09be5-263">これは、31 ビット、および論理和をランダムな 0 または 1、左シフトを生成することによって対処できますで元のランダムな long 整数。</span><span class="sxs-lookup"><span data-stu-id="09be5-263">This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.</span></span>  
  
2.  <span data-ttu-id="09be5-264">重大、ため、によって返される値の確率<xref:System.Random.Next>の場合は 0 には存在する場合は、少数のランダムな数値範囲 0x0 0x00000000FFFFFFFF で。</span><span class="sxs-lookup"><span data-stu-id="09be5-264">More seriously, because the probability that the value returned by <xref:System.Random.Next> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.</span></span>  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a><span data-ttu-id="09be5-265">指定した範囲内のバイトを取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-265">Retrieve bytes in a specified range</span></span>  
 <span data-ttu-id="09be5-266">オーバー ロード、<xref:System.Random.Next%2A>メソッドを使用する乱数の範囲を指定できますが、<xref:System.Random.NextBytes%2A>メソッドはありません。</span><span class="sxs-lookup"><span data-stu-id="09be5-266">The overloads of the <xref:System.Random.Next%2A> method allow you to specify the range of random numbers, but the <xref:System.Random.NextBytes%2A> method does not.</span></span> <span data-ttu-id="09be5-267">次の例では、実装、`NextBytes`メソッドが返されるバイトの範囲を指定することができます。</span><span class="sxs-lookup"><span data-stu-id="09be5-267">The following example implements a `NextBytes` method that lets you specify the range of the returned bytes.</span></span> <span data-ttu-id="09be5-268">定義、`Random2`クラスから派生した<xref:System.Random>オーバー ロードとその`NextBytes`メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-268">It defines a `Random2` class that derives from <xref:System.Random> and overloads its `NextBytes` method.</span></span>  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 <span data-ttu-id="09be5-269">`NextBytes(Byte[], Byte, Byte)`メソッドへの呼び出しをラップします、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>メソッド最小値と最大値よりも大きい 1 つを指定します (この場合は、0 と 101) バイト配列で返されるようにします。</span><span class="sxs-lookup"><span data-stu-id="09be5-269">The `NextBytes(Byte[], Byte, Byte)` method wraps a call to the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array.</span></span> <span data-ttu-id="09be5-270">整数値がによって返されることを確認していますので、<xref:System.Random.Next%2A>の範囲内のメソッドは、<xref:System.Byte>データ型、おできます安全にキャストに (c#) に変換したり (Visual Basic) で整数からバイト。</span><span class="sxs-lookup"><span data-stu-id="09be5-270">Because we are sure that the integer values returned by the <xref:System.Random.Next%2A> method are within the range of the <xref:System.Byte> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.</span></span>  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a><span data-ttu-id="09be5-271">配列またはコレクションから要素をランダムに取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-271">Retrieve an element from an array or collection at random</span></span>  
 <span data-ttu-id="09be5-272">ランダムな数値は、多くの場合、配列またはコレクションから値を取得するインデックスとして機能します。</span><span class="sxs-lookup"><span data-stu-id="09be5-272">Random numbers often serve as indexes to retrieve values from arrays or collections.</span></span> <span data-ttu-id="09be5-273">ランダムなインデックス値を取得するを呼び出すことができます、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>メソッドをおよびの値としての配列の下限値を使用してその`minValue`引数と 1 つの値として、配列の上限を超えるその`maxValue`引数。</span><span class="sxs-lookup"><span data-stu-id="09be5-273">To retrieve a random index value, you can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, and use the lower bound of the array as the value of its `minValue` argument and one greater than the upper bound of the array as the value of its `maxValue` argument.</span></span> <span data-ttu-id="09be5-274">これに相当の 0 から始まる配列の場合は、その<xref:System.Array.Length%2A>プロパティ、またはいずれかによって返される値より大きい、<xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType>メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-274">For a zero-based array, this is equivalent to its <xref:System.Array.Length%2A> property, or one greater than the value returned by the <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="09be5-275">次の例は、都市の配列からランダムに米国の州の都市の名前を取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-275">The following example randomly retrieves the name of a city in the United States from an array of cities.</span></span>  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a><span data-ttu-id="09be5-276">配列またはコレクションからの一意の要素を取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-276">Retrieve a unique element from an array or collection</span></span>  
 <span data-ttu-id="09be5-277">乱数ジェネレーターは、重複する値を常に返すことができます。</span><span class="sxs-lookup"><span data-stu-id="09be5-277">A random number generator can always return duplicate values.</span></span> <span data-ttu-id="09be5-278">番号の範囲が小さくなります。 または、生成された値の数が大きくなる、重複の確率が大きくなります。</span><span class="sxs-lookup"><span data-stu-id="09be5-278">As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows.</span></span> <span data-ttu-id="09be5-279">ランダムな値は一意である必要があります、他の番号は、パフォーマンスが低下ますます重複を補正するために生成されます。</span><span class="sxs-lookup"><span data-stu-id="09be5-279">If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.</span></span>  
  
 <span data-ttu-id="09be5-280">このシナリオを処理するための手法を数多くあります。</span><span class="sxs-lookup"><span data-stu-id="09be5-280">There are a number of techniques to handle this scenario.</span></span> <span data-ttu-id="09be5-281">1 つの一般的な解決策では、配列やコレクションを取得する値を格納する浮動小数点乱数を格納する並列配列を作成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-281">One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers.</span></span> <span data-ttu-id="09be5-282">2 番目の配列はランダムな数値では、最初の配列の作成時に設定されます。 および<xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>メソッドは並列配列の値を使用して、最初の配列を並べ替えに使用します。</span><span class="sxs-lookup"><span data-stu-id="09be5-282">The second array is populated with random numbers at the time the first array is created, and the <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is used to sort the first array by using the values in the parallel array.</span></span>  
  
 <span data-ttu-id="09be5-283">など、ソリティア ゲームを開発する場合に各カードが 1 回だけ使用されるようにします。</span><span class="sxs-lookup"><span data-stu-id="09be5-283">For example, if you're developing a Solitaire game, you want to ensure that each card is used only once.</span></span> <span data-ttu-id="09be5-284">カードとカードが処理済みかどうかを追跡を取得する乱数を生成するには、代わりに、デッキの並べ替えに使用できるランダムな数値の並列配列を作成できます。</span><span class="sxs-lookup"><span data-stu-id="09be5-284">Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck.</span></span> <span data-ttu-id="09be5-285">デッキが並べ替えられると、アプリは次のカード デッキでのインデックスを示しますへのポインターを維持できます。</span><span class="sxs-lookup"><span data-stu-id="09be5-285">Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.</span></span>  
  
 <span data-ttu-id="09be5-286">このアプローチの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="09be5-286">The following example illustrates this approach.</span></span> <span data-ttu-id="09be5-287">定義、`Card`クラスとトランプを表す`Dealer`トランプのシャッフルを処理するクラス。</span><span class="sxs-lookup"><span data-stu-id="09be5-287">It defines a `Card` class that represents a playing card and a `Dealer` class that deals a deck of shuffled cards.</span></span> <span data-ttu-id="09be5-288">`Dealer`クラスのコンス トラクターは 2 つの配列を設定します、`deck`クラス スコープを持つと、すべてのカード デッキ; とローカルを表す配列`order`を持つ同じ数の要素の配列、`deck`配列とは設定されます。ランダムに生成された<xref:System.Double>値。</span><span class="sxs-lookup"><span data-stu-id="09be5-288">The `Dealer` class constructor populates two arrays: a `deck` array that has class scope and that represents all the cards in the deck; and a local `order` array that has the same number of elements as the `deck` array and is populated with randomly generated <xref:System.Double> values.</span></span>  <span data-ttu-id="09be5-289"><xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>並べ替えメソッドが呼び出されてから、`deck`内の値に基づいて配列、`order`配列。</span><span class="sxs-lookup"><span data-stu-id="09be5-289">The <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is then called to sort the `deck` array based on the values in the `order` array.</span></span>  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 <span data-ttu-id="09be5-290">次の例では、単一乱数ジェネレーターと呼び出しを作成します。 その<xref:System.Random.NextBytes%2A>、 <xref:System.Random.Next%2A>、および<xref:System.Random.NextDouble%2A>さまざまな範囲内のランダムな数値のシーケンスを生成するメソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-290">The following example creates a single random number generator and calls its <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, and <xref:System.Random.NextDouble%2A> methods to generate sequences of random numbers within different ranges.</span></span>  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 <span data-ttu-id="09be5-291">次の例は、インデックスとして使用される整数の乱数を生成する、配列から文字列値を取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-291">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="09be5-292">派生したクラスの最低限の実装では、.NET Framework 1.0 および 1.1 では、<see cref="T:System.Random" />をオーバーライドするために必要な<see cref="M:System.Random.Sample" />乱数を生成するための新しいまたは変更されたアルゴリズムを定義するメソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-292">In the .NET Framework 1.0 and 1.1, a minimum implementation of a class derived from <see cref="T:System.Random" /> required overriding the <see cref="M:System.Random.Sample" /> method to define a new or modified algorithm for generating random numbers.</span></span> <span data-ttu-id="09be5-293">派生クラスの基本クラスの実装に任せるでした、 <see cref="M:System.Random.Next" />、 <see cref="M:System.Random.Next(System.Int32)" />、 <see cref="M:System.Random.Next(System.Int32,System.Int32)" />、 <see cref="M:System.Random.NextBytes(System.Byte[])" />、および<see cref="M:System.Random.NextDouble" />の派生クラスの実装を呼び出すメソッドを<see cref="M:System.Random.Sample" />メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-293">The derived class could then rely on the base class implementation of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, and <see cref="M:System.Random.NextDouble" /> methods to call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.</span></span>  
  
<span data-ttu-id="09be5-294">.NET Framework 2.0 以降の動作で、 <see cref="M:System.Random.Next" />、 <see cref="M:System.Random.Next(System.Int32,System.Int32)" />、および<see cref="M:System.Random.NextBytes(System.Byte[])" />メソッドがこれらのメソッドの派生クラスの実装を必ずしも呼び出すはありませんができるように変更されて、<see cref="M:System.Random.Sample" />メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-294">In the .NET Framework 2.0 and later, the behavior of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, and <see cref="M:System.Random.NextBytes(System.Byte[])" /> methods have changed so that these methods do not necessarily call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.</span></span> <span data-ttu-id="09be5-295">派生するクラスの結果として、 <see cref="T:System.Random" /> .NET Framework 2.0 をターゲットして、後でこれら 3 つのメソッドをオーバーライドする必要がありますもします。</span><span class="sxs-lookup"><span data-stu-id="09be5-295">As a result, classes derived from <see cref="T:System.Random" /> that target the .NET Framework 2.0 and later should also override these three methods.</span></span></para></block>
    <block subset="none" type="usage"><para><span data-ttu-id="09be5-296">乱数ジェネレーターの実装、<see cref="T:System.Random" />クラスは、同じままで、.NET Framework のメジャー バージョン間で保証されません。</span><span class="sxs-lookup"><span data-stu-id="09be5-296">The implementation of the random number generator in the <see cref="T:System.Random" /> class isn't guaranteed to remain the same across major versions of the .NET Framework.</span></span> <span data-ttu-id="09be5-297">その結果、同じシードは、.NET Framework のさまざまなバージョンで同じ擬似乱数シーケンスになりますとは考えないでください。</span><span class="sxs-lookup"><span data-stu-id="09be5-297">As a result, you shouldn't assume that the same seed will result in the same pseudo-random sequence in different versions of the .NET Framework.</span></span></para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="09be5-298"><see cref="T:System.Random" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="09be5-298">Initializes a new instance of the <see cref="T:System.Random" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09be5-299">時間に応じて決定される既定のシード値を使用し、<see cref="T:System.Random" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="09be5-299">Initializes a new instance of the <see cref="T:System.Random" /> class, using a time-dependent default seed value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09be5-300">既定のシード値では、システム クロックからは派生し、有限の解像度があります。</span><span class="sxs-lookup"><span data-stu-id="09be5-300">The default seed value is derived from the system clock and has finite resolution.</span></span> <span data-ttu-id="09be5-301">その結果、異なる<xref:System.Random>連続で既定のコンス トラクターへの呼び出しによって作成されるオブジェクトと同じ既定のシード値になり、そのため、まったく同じ乱数のセットが生成されます。</span><span class="sxs-lookup"><span data-stu-id="09be5-301">As a result, different <xref:System.Random> objects that are created in close succession by a call to the default constructor will have identical default seed values and, therefore, will produce identical sets of random numbers.</span></span> <span data-ttu-id="09be5-302">この問題を回避するには、1 つを使用して<xref:System.Random>すべての乱数を生成するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="09be5-302">This problem can be avoided by using a single <xref:System.Random> object to generate all random numbers.</span></span> <span data-ttu-id="09be5-303">システム クロックによって返されるシード値を変更しをこの新しいシード値を明示的に提供することによって、対処することも、<xref:System.Random.%23ctor%28System.Int32%29>コンス トラクター。</span><span class="sxs-lookup"><span data-stu-id="09be5-303">You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="09be5-304">詳細については、次を参照してください。、<xref:System.Random.%23ctor%28System.Int32%29>コンス トラクター。</span><span class="sxs-lookup"><span data-stu-id="09be5-304">For more information, see the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span>  
  
 <span data-ttu-id="09be5-305">乱数ジェネレーターのランダム シーケンスを生成する場合は、このコンス トラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="09be5-305">Call this constructor if you want your random number generator to generate a random sequence of numbers.</span></span> <span data-ttu-id="09be5-306">異なる乱数ジェネレーターの同じ乱数の固定のシーケンスを生成するには、呼び出し、<xref:System.Random.%23ctor%28System.Int32%29>固定のシード値を持つコンス トラクター。</span><span class="sxs-lookup"><span data-stu-id="09be5-306">To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <xref:System.Random.%23ctor%28System.Int32%29> constructor with a fixed seed value .</span></span> <span data-ttu-id="09be5-307">これは、<xref:System.Random>コンス トラクター オーバー ロードは、ランダムな数字を使用するアプリをテストするときによく使用します。</span><span class="sxs-lookup"><span data-stu-id="09be5-307">This <xref:System.Random> constructor overload is frequently used when testing apps that use random numbers.</span></span>  
  
 <span data-ttu-id="09be5-308">各を呼び出す、乱数ジェネレーターをインスタンス化した後<xref:System.Random>メソッドなど<xref:System.Random.Next>または<xref:System.Random.NextDouble>乱数を生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-308">Once you've instantiated the random number generator, you call individual <xref:System.Random> methods, such as <xref:System.Random.Next> or <xref:System.Random.NextDouble>, to generate random numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09be5-309">次の例では、3 つのインスタンスを作成する既定のコンス トラクターを使用して<xref:System.Random>オブジェクトし、それぞれの 5 つのランダムな整数のシーケンスが表示されます。</span><span class="sxs-lookup"><span data-stu-id="09be5-309">The following example uses the default constructor to instantiate three <xref:System.Random> objects and displays a sequence of five random integers for each.</span></span> <span data-ttu-id="09be5-310">ため、最初の 2 つ<xref:System.Random>オブジェクトが作成連続で、システム クロックに基づく同一のシード値を使用してインスタンス化され、そのため、ランダムな数値のシーケンスが同じ生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-310">Because the first two <xref:System.Random> objects are created in close succession, they are instantiated using identical seed values based on the system clock and, therefore, they produce an identical sequence of random numbers.</span></span> <span data-ttu-id="09be5-311">その一方で、3 つ目の既定のコンス トラクター<xref:System.Random>オブジェクトが呼び出すことによって引き起こされる 2 秒間遅延後に呼び出されると、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-311">On the other hand, the default constructor of the third <xref:System.Random> object is called after a two-second delay caused by calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="09be5-312">3 番目の異なるシード値が生成されますので<xref:System.Random>オブジェクトのさまざまな一連のランダムな数値が生成されます。</span><span class="sxs-lookup"><span data-stu-id="09be5-312">Because this produces a different seed value for the third <xref:System.Random> object, it produces a different sequence of random numbers.</span></span>  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed"><span data-ttu-id="09be5-313">擬似乱数系列の開始値を計算するために使用する数値。</span><span class="sxs-lookup"><span data-stu-id="09be5-313">A number used to calculate a starting value for the pseudo-random number sequence.</span></span> <span data-ttu-id="09be5-314">負数を指定した場合、その数値の絶対値が使用されます。</span><span class="sxs-lookup"><span data-stu-id="09be5-314">If a negative number is specified, the absolute value of the number is used.</span></span></param>
        <summary><span data-ttu-id="09be5-315">指定したシード値を使用して <see cref="T:System.Random" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="09be5-315">Initializes a new instance of the <see cref="T:System.Random" /> class, using the specified seed value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09be5-316">別の同一のシード値を提供する<xref:System.Random>と、ランダムな数値の同一のシーケンスを生成するために各インスタンスのオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="09be5-316">Providing an identical seed value to different <xref:System.Random> objects causes each instance to produce identical sequences of random numbers.</span></span> <span data-ttu-id="09be5-317">乱数ジェネレーターに依存するアプリをテストするときにこれは多くの場合です。</span><span class="sxs-lookup"><span data-stu-id="09be5-317">This is often done when testing apps that rely on random number generators.</span></span>  
  
 <span data-ttu-id="09be5-318">アプリケーションは、さまざまなランダムな番号のシーケンスを必要とする場合は、異なるシード値を繰り返し、このコンス トラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="09be5-318">If your application requires different random number sequences, invoke this constructor repeatedly with different seed values.</span></span> <span data-ttu-id="09be5-319">一意のシード値を生成する方法の 1 つは、時間に依存するようにすることです。</span><span class="sxs-lookup"><span data-stu-id="09be5-319">One way to produce a unique seed value is to make it time-dependent.</span></span> <span data-ttu-id="09be5-320">たとえば、として、システム クロックからシード値の取得、<xref:System.Random.%23ctor>オーバー ロードは。</span><span class="sxs-lookup"><span data-stu-id="09be5-320">For example, derive the seed value from the system clock, as the <xref:System.Random.%23ctor> overload does.</span></span> <span data-ttu-id="09be5-321">ただし、システム クロックは異なるシード値にこのコンス トラクターの別の呼び出しを提供するための十分な解決策があります。</span><span class="sxs-lookup"><span data-stu-id="09be5-321">However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value.</span></span> <span data-ttu-id="09be5-322">最初の 2 つに示すように、擬似乱数のと同じシーケンスを生成する乱数ジェネレーターでこの結果<xref:System.Random>次の例では、内のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="09be5-322">This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <xref:System.Random> objects in the following example.</span></span> <span data-ttu-id="09be5-323">これを回避するには、各呼び出しでは、または呼び出しでシード値を区別するアルゴリズムを適用、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>メソッドを異なるシード値を持つ各コンス トラクターを提供することを確認します。</span><span class="sxs-lookup"><span data-stu-id="09be5-323">To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to ensure that you provide each constructor with a different seed value.</span></span>  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 <span data-ttu-id="09be5-324">1 つのインスタンスを作成することも<xref:System.Random>オブジェクト使用して、アプリケーションですべての乱数を生成することです。</span><span class="sxs-lookup"><span data-stu-id="09be5-324">Another option is to instantiate a single <xref:System.Random> object that you use to generate all the random numbers in your application.</span></span> <span data-ttu-id="09be5-325">かなり安価では、乱数ジェネレーターのインスタンス化であるために、若干優れたパフォーマンスが得られます。</span><span class="sxs-lookup"><span data-stu-id="09be5-325">This yields slightly better performance, since instantiating a random number generator is fairly expensive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09be5-326">次の例では、作成<xref:System.Random>シード パラメーターを受け取るし、ランダムな整数と double のシーケンスを生成するクラスのコンス トラクターを持つオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="09be5-326">The following example creates <xref:System.Random> objects with the class constructor that takes a seed parameter and generates a sequence of random integers and doubles.</span></span> <span data-ttu-id="09be5-327">例を示しますが、同じシーケンスを生成するときに、<xref:System.Random>コンス トラクターとシード パラメーターを使用してオブジェクトを再作成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-327">The example illustrates that the same sequence is generated when the <xref:System.Random> object is created again with the constructor and seed parameter.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="09be5-328">ランダムな整数を返します。</span><span class="sxs-lookup"><span data-stu-id="09be5-328">Returns a random integer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09be5-329">0 以上のランダムな整数を返します。</span><span class="sxs-lookup"><span data-stu-id="09be5-329">Returns a non-negative random integer.</span></span></summary>
        <returns><span data-ttu-id="09be5-330">0 以上で <see cref="F:System.Int32.MaxValue" /> より小さい 32 ビット符号付き整数。</span><span class="sxs-lookup"><span data-stu-id="09be5-330">A 32-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int32.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09be5-331"><xref:System.Random.Next%2A?displayProperty=nameWithType> 0 ~ 値の範囲の乱数を生成します。 より小さい<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="09be5-331"><xref:System.Random.Next%2A?displayProperty=nameWithType> generates a random number whose value ranges from 0 to less than <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="09be5-332">その他のいくつかの正の数を 0 から値の範囲の乱数を生成するには、使用、<xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType>メソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="09be5-332">To generate a random number whose value ranges from 0 to some other positive number, use the <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="09be5-333">別の範囲内の乱数を生成するには、使用、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>メソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="09be5-333">To generate a random number within a different range, use the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09be5-334">次の例を繰り返し呼び出すので、<xref:System.Random.Next%2A>特定の数のユーザーによって要求された乱数を生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-334">The following example makes repeated calls to the <xref:System.Random.Next%2A> method to generate a specific number of random numbers requested by the user.</span></span> <span data-ttu-id="09be5-335"><xref:System.Console.ReadLine%2A?displayProperty=nameWithType>メソッドを使用して、顧客の入力を取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-335">The <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> method is used to get customer input.</span></span>  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 <span data-ttu-id="09be5-336">次の例では、派生クラスを<xref:System.Random>によって生成された一様分布からの配布とは異なるランダムな数値のシーケンスを生成する、<xref:System.Random.Sample%2A>基本クラスのメソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-336">The following example derives a class from <xref:System.Random> to generate a sequence of random numbers whose distribution differs from the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span> <span data-ttu-id="09be5-337">これは、上書き、<xref:System.Random.Sample%2A>ランダムな数字、および上書きの分布を提供するメソッドを<xref:System.Random.Next%2A?displayProperty=nameWithType>一連のランダムな数字を使用する方法。</span><span class="sxs-lookup"><span data-stu-id="09be5-337">It overrides the <xref:System.Random.Sample%2A> method to provide the distribution of random numbers, and overrides the <xref:System.Random.Next%2A?displayProperty=nameWithType> method to use series of random numbers.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="09be5-338">クラスを派生させる場合は、.NET Framework version 2.0 では、以降<see cref="T:System.Random" />をオーバーライドし、<see cref="M:System.Random.Sample" />メソッドは、の派生クラスの実装によって提供されているディストリビューション、<see cref="M:System.Random.Sample" />メソッドが基底クラスへの呼び出しで使用されていません。実装、<see cref="M:System.Random.Next" />メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-338">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next" /> method.</span></span> <span data-ttu-id="09be5-339">一様分布がベースによって返される代わりに、<see cref="T:System.Random" />クラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="09be5-339">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="09be5-340">この動作の全体的なパフォーマンスの向上、<see cref="T:System.Random" />クラス。</span><span class="sxs-lookup"><span data-stu-id="09be5-340">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="09be5-341">呼び出すには、この動作を変更する、<see cref="M:System.Random.Sample" />派生クラスでメソッドをオーバーライドすることする必要がありますも、<see cref="M:System.Random.Next" />メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-341">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next" /> method.</span></span></para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue"><span data-ttu-id="09be5-342">生成される乱数の排他的上限値。</span><span class="sxs-lookup"><span data-stu-id="09be5-342">The exclusive upper bound of the random number to be generated.</span></span> <span data-ttu-id="09be5-343"><paramref name="maxValue" /> は 0 以上にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="09be5-343"><paramref name="maxValue" /> must be greater than or equal to 0.</span></span></param>
        <summary><span data-ttu-id="09be5-344">指定した最大値より小さい 0 以上のランダムな整数を返します。</span><span class="sxs-lookup"><span data-stu-id="09be5-344">Returns a non-negative random integer that is less than the specified maximum.</span></span></summary>
        <returns><span data-ttu-id="09be5-345">0 以上で <paramref name="maxValue" /> 未満の 32 ビット符号付き整数。つまり、通常は戻り値の範囲に 0 は含まれますが、<paramref name="maxValue" /> は含まれません。</span><span class="sxs-lookup"><span data-stu-id="09be5-345">A 32-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />; that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.</span></span> <span data-ttu-id="09be5-346">ただし、<paramref name="maxValue" /> が 0 の場合は、<paramref name="maxValue" /> が返されます。</span><span class="sxs-lookup"><span data-stu-id="09be5-346">However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09be5-347"><xref:System.Random.Next%28System.Int32%29>オーバー ロードは 0 からランダムな整数の範囲を返します`maxValue`- 1。</span><span class="sxs-lookup"><span data-stu-id="09be5-347">The <xref:System.Random.Next%28System.Int32%29> overload returns random integers that range from 0 to `maxValue` - 1.</span></span> <span data-ttu-id="09be5-348">ただし場合、`maxValue`が 0 の場合、メソッドは 0 を返します。</span><span class="sxs-lookup"><span data-stu-id="09be5-348">However, if `maxValue` is 0, the method returns 0.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09be5-349">次の例では、ランダムな整数のさまざまなオーバー ロードを持つ、<xref:System.Random.Next%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-349">The following example generates random integers with various overloads of the <xref:System.Random.Next%2A> method.</span></span>  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 <span data-ttu-id="09be5-350">次の例は、インデックスとして使用される整数の乱数を生成する、配列から文字列値を取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-350">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="09be5-351">配列の最も大きいインデックスが 1 つ未満の長さ、値のため、<xref:System.Array.Length%2A?displayProperty=nameWithType>としてプロパティを指定する、`maxValue`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="09be5-351">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="09be5-352"><paramref name="maxValue" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="09be5-352"><paramref name="maxValue" /> is less than 0.</span></span></exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue"><span data-ttu-id="09be5-353">返される乱数の包括的下限値。</span><span class="sxs-lookup"><span data-stu-id="09be5-353">The inclusive lower bound of the random number returned.</span></span></param>
        <param name="maxValue"><span data-ttu-id="09be5-354">返される乱数の排他的上限値。</span><span class="sxs-lookup"><span data-stu-id="09be5-354">The exclusive upper bound of the random number returned.</span></span> <span data-ttu-id="09be5-355"><paramref name="maxValue" /> は <paramref name="minValue" /> 以上である必要があります。</span><span class="sxs-lookup"><span data-stu-id="09be5-355"><paramref name="maxValue" /> must be greater than or equal to <paramref name="minValue" />.</span></span></param>
        <summary><span data-ttu-id="09be5-356">指定した範囲内のランダムな整数を返します。</span><span class="sxs-lookup"><span data-stu-id="09be5-356">Returns a random integer that is within a specified range.</span></span></summary>
        <returns><span data-ttu-id="09be5-357"><paramref name="minValue" /> 以上で <paramref name="maxValue" /> 未満の 32 ビット符号付整数。つまり、戻り値の範囲に <paramref name="minValue" /> は含まれますが <paramref name="maxValue" /> は含まれません。</span><span class="sxs-lookup"><span data-stu-id="09be5-357">A 32-bit signed integer greater than or equal to <paramref name="minValue" /> and less than <paramref name="maxValue" />; that is, the range of return values includes <paramref name="minValue" /> but not <paramref name="maxValue" />.</span></span> <span data-ttu-id="09be5-358"><paramref name="minValue" /> が <paramref name="maxValue" /> と等しい場合は、<paramref name="minValue" /> が返されます。</span><span class="sxs-lookup"><span data-stu-id="09be5-358">If <paramref name="minValue" /> equals <paramref name="maxValue" />, <paramref name="minValue" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09be5-359"><xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>オーバー ロードはその範囲からランダムな整数を返します`minValue`に`maxValue`- 1。</span><span class="sxs-lookup"><span data-stu-id="09be5-359">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> overload returns random integers that range from `minValue` to `maxValue` - 1.</span></span> <span data-ttu-id="09be5-360">ただし場合、 `maxValue` equals `minValue`、メソッドを返します`minValue`します。</span><span class="sxs-lookup"><span data-stu-id="09be5-360">However, if `maxValue` equals `minValue`, the method returns `minValue`.</span></span>  
  
 <span data-ttu-id="09be5-361">その他のオーバー ロードとは異なり、<xref:System.Random.Next%2A>のみ負でない値を返すには、メソッドは、このメソッドは負の整数の乱数を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="09be5-361">Unlike the other overloads of the <xref:System.Random.Next%2A> method, which return only non-negative values, this method can return a negative random integer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09be5-362">次の例では、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 3 つの異なる範囲の整数の乱数を生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-362">The following example uses the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to generate random integers with three distinct ranges.</span></span> <span data-ttu-id="09be5-363">例では、実際の出力に渡されるシステム提供のシード値によって異なります、<xref:System.Random>クラスのコンス トラクター。</span><span class="sxs-lookup"><span data-stu-id="09be5-363">Note that the exact output from the example depends on the system-supplied seed value passed to the <xref:System.Random> class constructor.</span></span>  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 <span data-ttu-id="09be5-364">次の例は、インデックスとして使用される整数の乱数を生成する、配列から文字列値を取得します。</span><span class="sxs-lookup"><span data-stu-id="09be5-364">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="09be5-365">配列の最も大きいインデックスが 1 つ未満の長さ、値のため、<xref:System.Array.Length%2A?displayProperty=nameWithType>としてプロパティを指定する、`maxValue`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="09be5-365">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="09be5-366"><paramref name="minValue" /> が <paramref name="maxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="09be5-366"><paramref name="minValue" /> is greater than <paramref name="maxValue" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="09be5-367">クラスを派生させる場合は、.NET Framework version 2.0 では、以降<see cref="T:System.Random" />をオーバーライドし、<see cref="M:System.Random.Sample" />メソッドは、の派生クラスの実装によって提供されているディストリビューション、<see cref="M:System.Random.Sample" />メソッドが基底クラスへの呼び出しで使用されていません。実装、<see cref="M:System.Random.Next(System.Int32,System.Int32)" />場合、メソッドがオーバー ロードの違い、<paramref name="minValue" />と<paramref name="maxValue" />パラメーターがより大きい<see cref="F:System.Int32.MaxValue" />します。</span><span class="sxs-lookup"><span data-stu-id="09be5-367">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload if the difference between the <paramref name="minValue" /> and <paramref name="maxValue" /> parameters is greater than <see cref="F:System.Int32.MaxValue" />.</span></span> <span data-ttu-id="09be5-368">一様分布がベースによって返される代わりに、<see cref="T:System.Random" />クラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="09be5-368">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="09be5-369">この動作の全体的なパフォーマンスの向上、<see cref="T:System.Random" />クラス。</span><span class="sxs-lookup"><span data-stu-id="09be5-369">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="09be5-370">呼び出すには、この動作を変更する、<see cref="M:System.Random.Sample" />派生クラスでメソッドをオーバーライドすることする必要がありますも、<see cref="M:System.Random.Next(System.Int32,System.Int32)" />メソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="09be5-370">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload.</span></span></para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="09be5-371">乱数を格納するバイト配列。</span><span class="sxs-lookup"><span data-stu-id="09be5-371">An array of bytes to contain random numbers.</span></span></param>
        <summary><span data-ttu-id="09be5-372">指定したバイト配列の要素に乱数を格納します。</span><span class="sxs-lookup"><span data-stu-id="09be5-372">Fills the elements of a specified array of bytes with random numbers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09be5-373">バイトの配列の各要素に設定されているランダムな数より大きいまたは 0 に等しいまたはそれよりも小さいと<xref:System.Byte.MaxValue>します。</span><span class="sxs-lookup"><span data-stu-id="09be5-373">Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <xref:System.Byte.MaxValue>.</span></span>  
  
 <span data-ttu-id="09be5-374">たとえば、ランダムなパスワードを作成するための適切な暗号で保護されたランダムな数値を生成するメソッドなど、使用<xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="09be5-374">For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09be5-375">次の例では、使用する方法、<xref:System.Random.NextBytes%2A>メソッドでランダムなバイト値を含むバイト配列を設定します。</span><span class="sxs-lookup"><span data-stu-id="09be5-375">The following example demonstrates how to use the <xref:System.Random.NextBytes%2A> method to fill an array of bytes with random byte values.</span></span>  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="09be5-376"><paramref name="buffer" /> は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="09be5-376"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="09be5-377">クラスを派生させる場合は、.NET Framework version 2.0 では、以降<see cref="T:System.Random" />をオーバーライドし、<see cref="M:System.Random.Sample" />メソッドは、の派生クラスの実装によって提供されているディストリビューション、<see cref="M:System.Random.Sample" />メソッドが基底クラスへの呼び出しで使用されていません。実装、<see cref="M:System.Random.NextBytes(System.Byte[])" />メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-377">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span> <span data-ttu-id="09be5-378">一様分布がベースによって返される代わりに、<see cref="T:System.Random" />クラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="09be5-378">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="09be5-379">この動作の全体的なパフォーマンスの向上、<see cref="T:System.Random" />クラス。</span><span class="sxs-lookup"><span data-stu-id="09be5-379">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="09be5-380">呼び出すには、この動作を変更する、<see cref="M:System.Random.Sample" />派生クラスでメソッドをオーバーライドすることする必要がありますも、<see cref="M:System.Random.NextBytes(System.Byte[])" />メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-380">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span></para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09be5-381">0.0 以上 1.0 未満のランダムな浮動小数点数を返します。</span><span class="sxs-lookup"><span data-stu-id="09be5-381">Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.</span></span></summary>
        <returns><span data-ttu-id="09be5-382">0.0 以上 1.0 未満の倍精度浮動小数点数。</span><span class="sxs-lookup"><span data-stu-id="09be5-382">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09be5-383">このメソッドによって返される乱数の実際の上限は、0.99999999999999978 です。</span><span class="sxs-lookup"><span data-stu-id="09be5-383">The actual upper bound of the random number returned by this method is 0.99999999999999978.</span></span>  
  
 <span data-ttu-id="09be5-384">0.0 と 1.0 以外の範囲内のランダムな浮動小数点値を取得するには、「指定された範囲の浮動小数点値を取得」のセクションを参照してください。、<xref:System.Random>クラスに関するトピック。</span><span class="sxs-lookup"><span data-stu-id="09be5-384">To retrieve random floating-point values within a range other than 0.0 and 1.0, see the "Retrieve floating-point values in a specified range" section of the <xref:System.Random> class topic.</span></span>  
  
 <span data-ttu-id="09be5-385">このメソッドは、保護されたメソッドのパブリック バージョン<xref:System.Random.Sample%2A>します。</span><span class="sxs-lookup"><span data-stu-id="09be5-385">This method is the public version of the protected method, <xref:System.Random.Sample%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09be5-386">次の例では、<xref:System.Random.NextDouble%2A>ランダムな倍精度小数点数のシーケンスを生成するメソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-386">The following example uses the <xref:System.Random.NextDouble%2A> method to generate sequences of random doubles.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 <span data-ttu-id="09be5-387">次の例では、 <xref:System.Random.NextDouble%2A> 100 の乱数を生成するメソッドを番号し、その頻度分布が表示されます。</span><span class="sxs-lookup"><span data-stu-id="09be5-387">The following example calls the <xref:System.Random.NextDouble%2A> method to generate 100 random numbers and displays their frequency distribution.</span></span>  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09be5-388">0.0 と 1.0 の間のランダムな浮動小数点数を返します。</span><span class="sxs-lookup"><span data-stu-id="09be5-388">Returns a random floating-point number between 0.0 and 1.0.</span></span></summary>
        <returns><span data-ttu-id="09be5-389">0.0 以上 1.0 未満の倍精度浮動小数点数。</span><span class="sxs-lookup"><span data-stu-id="09be5-389">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09be5-390">派生クラスを別のランダムな配布や、異なる乱数ジェネレーターの原則を生成する、<xref:System.Random>クラスし、オーバーライド、<xref:System.Random.Sample%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-390">To produce a different random distribution or a different random number generator principle, derive a class from the <xref:System.Random> class and override the <xref:System.Random.Sample%2A> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="09be5-391"><xref:System.Random.Sample%2A>メソッドは`protected`、内でのみアクセス可能であることを意味する、<xref:System.Random>クラスとその派生クラス。</span><span class="sxs-lookup"><span data-stu-id="09be5-391">The <xref:System.Random.Sample%2A> method is `protected`, which means that it is accessible only within the <xref:System.Random> class and its derived classes.</span></span> <span data-ttu-id="09be5-392">0 から 1 の乱数を生成する、<xref:System.Random>インスタンスを呼び出し、<xref:System.Random.NextDouble%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-392">To generate a random number between 0 and 1 from a <xref:System.Random> instance, call the <xref:System.Random.NextDouble%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09be5-393">次の例では、派生クラスを<xref:System.Random>をオーバーライドし、<xref:System.Random.Sample%2A>ランダムな数値の分布を生成します。</span><span class="sxs-lookup"><span data-stu-id="09be5-393">The following example derives a class from <xref:System.Random> and overrides the <xref:System.Random.Sample%2A> method to generate a distribution of random numbers.</span></span> <span data-ttu-id="09be5-394">この分布はによって生成された一様分布とは異なる、<xref:System.Random.Sample%2A>基本クラスのメソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-394">This distribution is different than the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="09be5-395">クラスを派生させる場合は、.NET Framework version 2.0 では、以降<see cref="T:System.Random" />をオーバーライドし、<see cref="M:System.Random.Sample" />メソッドは、の派生クラスの実装によって提供されているディストリビューション、<see cref="M:System.Random.Sample" />メソッドが基底クラスへの呼び出しで使用されていません。次のメソッドの実装:</span><span class="sxs-lookup"><span data-stu-id="09be5-395">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the following methods:</span></span> 
<span data-ttu-id="09be5-396">-   <see cref="M:System.Random.NextBytes(System.Byte[])" /> メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-396">-   The <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span>  
  
<span data-ttu-id="09be5-397">-   <see cref="M:System.Random.Next" /> メソッド。</span><span class="sxs-lookup"><span data-stu-id="09be5-397">-   The <see cref="M:System.Random.Next" /> method.</span></span>  
  
<span data-ttu-id="09be5-398">-<see cref="M:System.Random.Next(System.Int32,System.Int32)" />メソッド場合 (<paramref name="maxValue" /> - <paramref name="minValue" />) よりも大きい<see cref="F:System.Int32.MaxValue" />します。</span><span class="sxs-lookup"><span data-stu-id="09be5-398">-   The <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method, if (<paramref name="maxValue" /> - <paramref name="minValue" />) is greater than <see cref="F:System.Int32.MaxValue" />.</span></span>  
  
<span data-ttu-id="09be5-399">一様分布がベースによって提供される代わりに、<see cref="T:System.Random" />クラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="09be5-399">Instead, the uniform distribution provided by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="09be5-400">この動作の全体的なパフォーマンスの向上、<see cref="T:System.Random" />クラス。</span><span class="sxs-lookup"><span data-stu-id="09be5-400">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="09be5-401">実装を呼び出すには、この動作を変更する、<see cref="M:System.Random.Sample" />メソッド、派生クラスでは、これら 3 つのメンバーの動作もオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="09be5-401">To modify this behavior to call the implementation of the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the behavior of these three members.</span></span> <span data-ttu-id="09be5-402">具体的な例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="09be5-402">The example provides an illustration.</span></span></para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>