<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a5d099662a51c9ac6e434b6e8eb94d1a73c68700" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70541463" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>擬似乱数ジェネレーターを表します。擬似乱数ジェネレーターは、乱数についての統計的な要件を満たす数値系列を生成するデバイスです。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 擬似乱数は、少数の数値から等しい確率で選択されます。 選択した数値は、数学的アルゴリズムを使用して選択するため、完全にはランダムではありませんが、実用的な目的では十分にランダムです。 <xref:System.Random>クラスの現在の実装は、変更されたバージョンの Donald クヌースの減法乱数ジェネレーターアルゴリズムに基づいています。 詳細については、「d. e.」を参照してください。 クヌース. *コンピュータープログラミングの Art、Volume 2: Seminumerical アルゴリズム*。 Addison-Wesley、読み取り、MA、第3版、1997。  
  
 ランダムなパスワードの作成に適したランダムな値など、暗号的に安全な乱数を生成する<xref:System.Security.Cryptography.RNGCryptoServiceProvider>には、クラスを使用<xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>するか、からクラスを派生させます。  
  
 このトピックの内容:  
  
 [乱数ジェネレーターのインスタンス化](#Instantiate)   
 [複数のインスタンス化の回避](#Multiple)   
 [Random クラスとスレッドセーフ](#ThreadSafety)   
 [さまざまな種類の乱数を生成する](#Functionality)   
 [独自のアルゴリズムを使用する](#Overriding)   
 [使用する方法を教えてください。](#Operations)   
 [同じランダムな値のシーケンスを取得します。](#Same)  
 [ランダムな値の一意のシーケンスを取得する](#Unique)  
 [指定された範囲の整数を取得します。](#Range)  
 [指定された桁数の整数を取得します](#Digits)  
 [指定された範囲の浮動小数点値を取得します。](#Floats)  
 [ランダムなブール値の生成](#Boolean)  
 [ランダムな64ビット整数の生成](#Long)  
 [指定した範囲のバイトを取得します。](#Bytes)  
 [配列またはコレクションからランダムに要素を取得する](#Array)  
 [配列またはコレクションから一意の要素を取得する](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>乱数ジェネレーターのインスタンス化  
 乱数ジェネレーターをインスタンス化するには、シード値 (疑似乱数生成アルゴリズムの開始値) を<xref:System.Random.%23ctor%2A>クラスコンストラクターに渡します。  シード値は、明示的または暗黙的に指定できます。  
  
-   コンストラクター <xref:System.Random.%23ctor%28System.Int32%29>は、明示的に指定したシード値を使用します。  
  
-   コンストラクター <xref:System.Random.%23ctor>は、システムクロックを使用してシード値を指定します。 これは、乱数ジェネレーターをインスタンス化する最も一般的な方法です。  
  
 異なる<xref:System.Random>オブジェクトに対して同じシードを使用すると、同じ一連の乱数が生成されます。 これは、ランダムな値を処理するテストスイートを作成する場合や、ランダムな数値からデータを派生するゲームを再生する場合に便利です。 ただし、異なるバージョン<xref:System.Random>の .NET Framework で実行されているプロセス内のオブジェクトは、同じシード値を使用してインスタンス化されている場合でも、異なる一連の乱数を返す可能性があることに注意してください。  
  
 乱数の異なるシーケンスを生成するには、シード値を時間に依存させることができます。これにより、の<xref:System.Random>新しいインスタンスごとに異なる系列が生成されます。 パラメーター化<xref:System.Random.%23ctor%28System.Int32%29>されたコンストラクター <xref:System.Int32>は、現在の時刻のタイマー刻みの数に基づいて値を<xref:System.Random.%23ctor>受け取ることができます。一方、パラメーターなしのコンストラクターは、システムクロックを使用してシード値を生成します。 ただし、クロックには有限の解決があるため、パラメーターなしのコンストラクター <xref:System.Random>を使用して、連続して異なるオブジェクトを作成すると、ランダムな数値のシーケンスを生成する乱数ジェネレーターが作成されます。 次の例は、連続<xref:System.Random>してインスタンス化された2つのオブジェクトが、同一の連続する乱数を生成する方法を示しています。 ほとんどの Windows システムで<xref:System.Random>は、1つのオブジェクトで15ミリ秒以内に作成されたオブジェクトのシード値が同一である可能性があります。  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 この問題を回避するには、 <xref:System.Random>複数のオブジェクトではなく、単一のオブジェクトを作成します。  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>複数のインスタンス化の回避  
 2つの乱数ジェネレーターを密ループまたは高速連続で初期化すると、2つの乱数ジェネレーターが作成され、乱数の同一シーケンスが生成されます。 ほとんどの場合、これは開発者の意図ではなく、ランダムな数値ジェネレーターのインスタンス化と初期化は比較的コストのかかるプロセスであるため、パフォーマンスの問題が発生する可能性があります。  
  
 パフォーマンスを向上させ、同一の数値シーケンスを生成する個別の乱数ジェネレーターが誤って作成されない<xref:System.Random>ようにするために、1つのオブジェクトを作成し、時間の経過と共に多数の乱数を生成することをお勧めします。1 <xref:System.Random>つの乱数を生成する新しいオブジェクト。  
  
 ただし、クラス<xref:System.Random>はスレッドセーフではありません。 複数のスレッド<xref:System.Random>からメソッドを呼び出す場合は、次のセクションで説明するガイドラインに従ってください。  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>Random クラスとスレッドセーフ  
 個々<xref:System.Random>のオブジェクトをインスタンス化するのではなく、1 <xref:System.Random>つのインスタンスを作成して、アプリに必要なすべての乱数を生成することをお勧めします。 ただし、 <xref:System.Random>オブジェクトはスレッドセーフではありません。 アプリが複数の<xref:System.Random>スレッドからメソッドを呼び出す場合は、同期オブジェクトを使用して、一度に1つのスレッドだけが乱数ジェネレーターにアクセスできるようにする必要があります。 <xref:System.Random>オブジェクトがスレッドセーフな方法でアクセスされていることを確認しない場合、ランダムな数値を返すメソッドを呼び出すと0が返されます。  
  
 次の例ではC# 、 [lock ステートメント](~/docs/csharp/language-reference/keywords/lock-statement.md)と Visual Basic [SyncLock ステートメント](~/docs/visual-basic/language-reference/statements/synclock-statement.md)を使用して、スレッドセーフな方法で、1つのランダムな数値ジェネレーターが11個のスレッドによってアクセスされるようにします。 各スレッドは、200万の乱数を生成し、生成された乱数の数をカウントし、合計を計算した後、実行が終了したときにすべてのスレッドの合計を更新します。  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 この例では、次の方法でスレッドセーフを確保します。  
  
-   属性<xref:System.ThreadStaticAttribute>は、生成された乱数の合計数と各スレッドの合計を追跡するスレッドローカル変数を定義するために使用されます。  
  
-   ロック ( `lock`のC#ステートメントと Visual Basic の`SyncLock`ステートメント) によって、すべてのスレッドで生成されたすべてのランダムな数値の合計数と合計の変数へのアクセスが保護されます。  
  
-   セマフォ ( <xref:System.Threading.CountdownEvent>オブジェクト) を使用して、他のすべてのスレッドが実行を完了するまでメインスレッドがブロックされるようにします。  
  
-   この例では、乱数生成メソッドの2回の連続呼び出しが0を返すかどうかを判断することによって、乱数ジェネレーターが破損しているかどうかを確認します。 破損が検出された場合、この<xref:System.Threading.CancellationTokenSource>例ではオブジェクトを使用して、すべてのスレッドがキャンセルされることを通知します。  
  
-   各スレッドは、ランダムな数値を生成する前に、 <xref:System.Threading.CancellationToken>オブジェクトの状態を確認します。 キャンセルが要求された場合、この<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>例ではメソッドを呼び出してスレッドをキャンセルします。  
  
 次の例は、オブジェクトでは<xref:System.Threading.Tasks.Task> <xref:System.Threading.Thread>なくオブジェクトとラムダ式を使用する点を除いて、最初の例と同じです。  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 これは、次の方法の最初の例とは異なります。  
  
-   生成される乱数の数と各タスクの合計を追跡する変数は、タスクに対してローカルであるため、 <xref:System.ThreadStaticAttribute>属性を使用する必要はありません。  
  
-   静的<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>メソッドは、すべてのタスクが完了する前にメインスレッドが完了していないことを確認するために使用されます。 <xref:System.Threading.CountdownEvent>オブジェクトは必要ありません。  
  
-   タスクのキャンセルによって生成される例外は<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 、メソッドで表示されます。 前の例では、各スレッドによって処理されます。  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>さまざまな種類の乱数を生成する  
 乱数ジェネレーターには、次の種類の乱数を生成できるメソッドが用意されています。  
  
-   一連の<xref:System.Byte>値。 バイト値の数を決定するには、メソッドがメソッドに<xref:System.Random.NextBytes%2A>返す要素の数に初期化された配列を渡します。 次の例では、20バイトが生成されます。  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   単一の整数。 メソッドを<xref:System.Random.Next%28System.Int32%29> <xref:System.Int32.MaxValue?displayProperty=nameWithType> <xref:System.Random.Next>呼び出すことによって0から最大値 (-1) までの整数を指定できます。また <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 、メソッドを呼び出して0から特定の値までの整数を指定するか、メソッド。 パラメーター化されたオーバーロードでは、指定された最大値は排他的です。つまり、生成される実際の最大数は、指定された値より1だけ少なくなります。  
  
     次の例では<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 、メソッドを呼び出して、-10 ~ 10 の範囲の10個の乱数を生成します。 メソッドの2番目の引数は、メソッドによって返されるランダム値の範囲の排他的上限を指定することに注意してください。 言い換えると、メソッドが返すことができる最大の整数は、この値より1小さい値になります。  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   <xref:System.Random.NextDouble%2A>メソッドを呼び出すことによって、0.0 ~ 1.0 未満の1つの浮動小数点値。 メソッドによって返される乱数の排他的上限は1であるため、実際の上限は0.99999999999999978 です。 次の例では、10個のランダムな浮動小数点数が生成されます。  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>メソッドを使用すると、返される乱数値の範囲を指定できます。 ただし、返される上限の数値を指定するパラメーターは、包含的な値ではなく、排他的です。 `maxValue` これは、メソッド呼び出し`Next(0, 100)`が 0 ~ 99 の範囲の値を返すことを意味します。0と100の間では返されません。  
  
 また、このような<xref:System.Random>タスクには、ランダムな[T:System.Boolean 値](#Boolean)の生成、 [0 ~ 1 以外の範囲を持つランダム浮動小数点値](#Floats)の生成、[ランダムな64ビット整数](#Long)の生成、ランダムに使用することもできます。 [配列またはコレクションから一意の要素を取得](#UniqueArray)します。 これらのタスクおよびその他の一般的なタスクについては、「 [How to use The Random to..](#Operations) . 下.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>独自のアルゴリズムを使用する  
 独自の乱数ジェネレーターを実装するには、 <xref:System.Random>クラスから継承し、乱数生成アルゴリズムを指定します。 独自のアルゴリズムを提供するには、乱数<xref:System.Random.Sample%2A>生成アルゴリズムを実装するメソッドをオーバーライドする必要があります。 また、 <xref:System.Random.Next>、、および<xref:System.Random.NextBytes%2A>の<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>各メソッドをオーバーライドして、オーバーライド<xref:System.Random.Sample%2A>されたメソッドを呼び出すようにする必要もあります。 メソッド<xref:System.Random.Next%28System.Int32%29> と <xref:System.Random.NextDouble%2A> メソッドをオーバーライドする必要はありません。  
  
 <xref:System.Random>クラスから派生し、既定の擬似乱数ジェネレーターを変更する例につい<xref:System.Random.Sample%2A>ては、リファレンスページを参照してください。  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>使用する方法を教えてください。  
 以下のセクションでは、アプリで乱数を使用するいくつかの方法のサンプルコードについて説明します。  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>同じランダムな値のシーケンスを取得します。  
 ソフトウェアテストシナリオとゲームプレイで、同じ乱数シーケンスを生成することが必要になる場合があります。 乱数の同じシーケンスを使用してテストすることで、回帰を検出し、バグ修正を確認することができます。 ゲームで同じ乱数シーケンスを使用すると、以前のゲームを再生できます。  
  
 同じシード値を<xref:System.Random.%23ctor%28System.Int32%29>コンストラクターに渡すことによって、同じ乱数シーケンスを生成することができます。 シード値は、擬似乱数生成アルゴリズムの開始値を提供します。 次の例では、任意の<xref:System.Random>シード値として100100を使用してオブジェクトをインスタンス化し、20個のランダムな浮動小数点値を表示し、シード値を保持します。 次に、シード値を復元し、新しい乱数ジェネレーターをインスタンス化し、同じ20個のランダムな浮動小数点値を表示します。  この例では、異なるバージョンの .NET Framework で実行した場合に、異なる乱数シーケンスが生成される可能性があることに注意してください。  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>ランダムな数値の一意のシーケンスを取得する  
 クラスのインスタンスに異なるシード値を<xref:System.Random>指定すると、各乱数ジェネレーターによって異なる値のシーケンスが生成されます。 シード値は、 <xref:System.Random.%23ctor%28System.Int32%29>コンストラクターを呼び出すことによって明示的に指定することも、 <xref:System.Random.%23ctor>コンストラクターを呼び出すことによって暗黙的に指定することもできます。 ほとんどの開発者は、システムクロックを使用するパラメーターなしのコンストラクターを呼び出します。 次の例では、この方法を<xref:System.Random>使用して、2つのインスタンスをインスタンス化します。 各インスタンスには、10個のランダムな整数が表示されます。  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 ただし、このような制限があるため、システムクロックでは、約15ミリ秒未満の時間差は検出されません。 したがって、2つ<xref:System.Random.%23ctor> <xref:System.Random>のオブジェクトを連続してインスタンス化するためにコードがオーバーロードを呼び出した場合、誤って同じシード値を持つオブジェクトを提供することがあります。 前の例でこれを確認するには、 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>メソッド呼び出しをコメントアウトし、この例をもう一度コンパイルして実行します。  
  
 これが起こらないようにするために、複数のオブジェクト<xref:System.Random>ではなく、単一のオブジェクトをインスタンス化することをお勧めします。 ただし、は<xref:System.Random>スレッドセーフではないため、複数のスレッドからインスタンスに<xref:System.Random>アクセスする場合は、同期デバイスを使用する必要があります。詳細については、このトピックで前述した「[ランダムクラスとスレッドセーフ](#ThreadSafety)」を参照してください。 または、前の例で使用した<xref:System.Threading.Thread.Sleep%2A>メソッドなどの遅延メカニズムを使用して、インスタンス化が15ミリ秒以上離れていることを確認することもできます。  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>指定された範囲の整数を取得します。  
 指定された範囲の整数を取得するに<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>は、メソッドを呼び出します。これにより、乱数ジェネレーターが返す数値の下限と上限の両方を指定できます。 上限は、包含的な値ではなく、排他的です。 つまり、メソッドによって返される値の範囲には含まれません。 次の例では、このメソッドを使用して、-10 ~ 10 の間のランダムな整数を生成します。 これは、メソッド呼び出しの`maxValue`引数の値として、目的の値より1大きい1を示す11を指定することに注意してください。  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>指定された桁数の整数を取得します  
 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>メソッドを呼び出して、指定した桁数の数値を取得できます。 たとえば、4桁の数字 (つまり、1000 ~ 9999 の範囲の数値) を取得するには、次の<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>例に示す`minValue`ように、1000の`maxValue`値と1万の値を使用してメソッドを呼び出します。  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>指定された範囲の浮動小数点値を取得します。  
 この<xref:System.Random.NextDouble%2A>メソッドは、0から1未満の範囲のランダム浮動小数点値を返します。 ただし、多くの場合、他の範囲でランダムな値を生成することをお勧めします。  
  
 最小値と最大値の間の間隔が1の場合は、目的の開始間隔と0の差を<xref:System.Random.NextDouble%2A>メソッドによって返される数値に加算できます。 次の例では、-1 から0までの10個の乱数を生成します。  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 下限が0で、上限が1より大きい (負の値の場合、下限が-1 より小さく、上限が0である) ランダム浮動小数点数を生成するには、0以外の値で乱数を乗算します。 次の例では、0 <xref:System.Int64.MaxValue?displayProperty=nameWithType>~ の範囲の2000万のランダム浮動小数点数を生成します。 では、メソッドによって生成されるランダム値の分布も表示されます。  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 整数のメソッドの<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>ように、任意の2つの値の間にランダムな浮動小数点数を生成するには、次の式を使用します。  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 次の例では、10.0 から11.0 までの範囲の100万乱数を生成し、それらの分布を表示します。  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>ランダムなブール値の生成  
 クラス<xref:System.Random>には、値を生成<xref:System.Boolean>するメソッドが用意されていません。 ただし、独自のクラスまたはメソッドを定義して、それを行うことができます。 次の例では、単一`BooleanGenerator`の`NextBoolean`メソッドを使用して、クラスを定義しています。 クラス`BooleanGenerator`は、オブジェクト<xref:System.Random>をプライベート変数として格納します。 メソッドはメソッドを<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>呼び出し、結果を<xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType>メソッドに渡します。 `NextBoolean` 2を引数として使用して、乱数の上限を指定することに注意してください。 これは排他的な値であるため、メソッドの呼び出しは0または1のいずれかを返します。  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 個別のクラスを作成してランダム<xref:System.Boolean>な値を生成するのではなく、単に1つのメソッドを定義するだけで済みます。 ただし、この場合、オブジェクトは<xref:System.Random>クラスレベル変数として定義されている必要があります。 <xref:System.Random>これは、各メソッドの呼び出しで新しいインスタンスがインスタンス化されるのを回避するためです。 Visual Basic では、ランダムインスタンスを`NextBoolean`メソッドの[静的](~/docs/visual-basic/language-reference/modifiers/static.md)変数として定義できます。  次の例は、の実装を示しています。  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>ランダムな64ビット整数の生成  
 <xref:System.Random.Next%2A>メソッドのオーバーロードは、32ビットの整数を返します。 ただし、場合によっては、64ビットの整数を使用する必要があります。 このことは次のように実行できます。  
  
1.  メソッドを<xref:System.Random.NextDouble%2A>呼び出して、倍精度浮動小数点値を取得します。  
  
2.  この値をで<xref:System.Int64.MaxValue?displayProperty=nameWithType>乗算します。  
  
 次の例では、この手法を使用して、2000万のランダムな長整数を生成し、10個の等しいグループに分類しています。 次に、各グループの数値を0からにカウントする<xref:System.Int64.MaxValue?displayProperty=nameWithType>ことで、乱数の分布を評価します。 この例の出力に示すように、数値は長整数の範囲によってより均等に分布されます。  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 ビット操作を使用する別の手法では、真の乱数は生成されません。 この手法で<xref:System.Random.Next>は、を呼び出して2つの整数を生成し、32ビットずつ左シフトして、それらをまとめています。 この手法には、次の2つの制限があります。  
  
1.  ビット31は符号ビットであるため、結果として得られる長整数のビット31の値は常に0になります。  これを解決するには、ランダムな0または1を生成し、31ビットを左にシフトして、それを元のランダム長整数にします。  
  
2.  より真剣に言えば、によって<xref:System.Random.Next>返される値が0になる可能性があるため、範囲 0x0 ~ 0x00000000ffffffff の乱数が少ない場合は、数が少なくなります。  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>指定した範囲のバイトを取得します。  
 <xref:System.Random.Next%2A>メソッドのオーバーロードでは、乱数の範囲を指定できます<xref:System.Random.NextBytes%2A>が、メソッドでは指定できません。 次の例では`NextBytes` 、返されるバイトの範囲を指定できるメソッドを実装しています。 このクラスは`Random2` 、から<xref:System.Random>派生し、その`NextBytes`メソッドをオーバーロードするクラスを定義します。  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 メソッド`NextBytes(Byte[], Byte, Byte)`は、メソッドの<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>呼び出しをラップし、最小値と最大値 (この場合は0と 101) をバイト配列に返すことを指定します。 <xref:System.Random.Next%2A>メソッドによって返される整数値は<xref:System.Byte>データ型の範囲内にあることが確実であるため、(でC#は) それらを安全にキャストするか、(Visual Basic) 整数からバイトに変換することができます。  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>配列またはコレクションからランダムに要素を取得する  
 ランダムな数値は、多くの場合、配列またはコレクションから値を取得するためのインデックスとして機能します。 ランダムインデックス値を取得するには、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>メソッドを呼び出し、配列の下限を引数`minValue`の値として使用します。また、配列の上限を`maxValue`引数の値として1つ大きくします。 0から始まる配列の場合、これは<xref:System.Array.Length%2A>プロパティと同じか、または<xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType>メソッドによって返される値よりも1だけ大きくなります。 次の例では、都市の配列から米国にある市区町村の名前をランダムに取得します。  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>配列またはコレクションから一意の要素を取得する  
 乱数ジェネレーターは、常に重複する値を返すことができます。 数値の範囲が小さくなるか、生成される値の数が多いほど、重複の可能性が大きくなります。 ランダムな値を一意にする必要がある場合は、重複を補正するためにより多くの数値が生成されるため、パフォーマンスが低下します。  
  
 このシナリオに対処するための手法がいくつかあります。 一般的な解決策の1つは、取得する値を格納する配列またはコレクション、およびランダムな浮動小数点数を含む並列配列を作成することです。 2番目の配列には、最初の配列が作成<xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>された時点で乱数が格納され、メソッドを使用して、並列配列の値を使用して最初の配列が並べ替えられます。  
  
 たとえば、ソリティアゲームを開発している場合は、各カードが1回だけ使用されていることを確認する必要があります。 カードを取得するために乱数を生成する代わりに、カードが既に処理されているかどうかを追跡するには、デッキの並べ替えに使用できるランダムな数値の並列配列を作成します。 デッキが並べ替えられると、アプリは、デッキの次のカードのインデックスを示すポインターを維持できます。  
  
 このアプローチの例を次に示します。 再生カードを`Card`表すクラス`Dealer`と、シャッフルされたカードのデッキを扱うクラスを定義します。 クラス`Dealer`コンストラクターは、2つの配列`deck` (クラススコープを持ち、デッキ内のすべてのカードを表す配列) と、 `order` `deck`配列と同じ数の要素を持ち、値が設定されるローカル配列を作成します。ランダムに生成<xref:System.Double>された値を持つ。  次<xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>に、メソッドを呼び出して、 `deck`配列内`order`の値に基づいて配列を並べ替えます。  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 次の例では<xref:System.Random.NextBytes%2A>、乱数ジェネレーターを1つ作成し、、、および<xref:System.Random.NextDouble%2A>の各メソッドを呼び出して、 <xref:System.Random.Next%2A>異なる範囲内の乱数のシーケンスを生成します。  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 次の例では、配列から文字列値を取得するためにインデックスとして使用されるランダムな整数が生成されます。  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>.NET Framework 1.0 および1.1 では、から<see cref="T:System.Random" />派生したクラスの最小実装で、メソッドを<see cref="M:System.Random.Sample" />オーバーライドして、乱数を生成するための新しいまたは変更されたアルゴリズムを定義します。 <see cref="M:System.Random.Next" />派生クラスは<see cref="M:System.Random.Next(System.Int32)" /> <see cref="M:System.Random.NextDouble" /> 、 、 <see cref="M:System.Random.NextBytes(System.Byte[])" /> 、、、およびの各メソッドの基本クラスの実装に依存して、メソッドの派生クラスの実装を呼び出すことができます。 <see cref="M:System.Random.Sample" />  <see cref="M:System.Random.Next(System.Int32,System.Int32)" />  
  
.NET Framework 2.0 以降<see cref="M:System.Random.Next" />では、これらのメソッドが<see cref="M:System.Random.Sample" />メソッドの<see cref="M:System.Random.Next(System.Int32,System.Int32)" />派生クラス<see cref="M:System.Random.NextBytes(System.Byte[])" />の実装を呼び出すことがないように、、、およびメソッドの動作が変更されています。 その結果、.NET Framework 2.0 以降を<see cref="T:System.Random" />対象とするから派生したクラスでも、これら3つのメソッドをオーバーライドする必要があります。</para></block>
    <block subset="none" type="usage"><para><see cref="T:System.Random" />クラスの乱数ジェネレーターの実装は、.NET Framework のメジャーバージョン間で同じままであることは保証されていません。 その結果、同じシードによって、.NET Framework の異なるバージョンで同じ擬似ランダムシーケンスが生成されるとは限りません。</para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Random" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>時間に応じて決定される既定のシード値を使用し、<see cref="T:System.Random" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のシード値は、システムクロックから派生し、有限の解決があります。 結果として、 <xref:System.Random>パラメーターなしのコンストラクターの呼び出しによって連続して作成された異なるオブジェクトの既定のシード値は同じになります。したがって、では、同一の乱数セットが生成されます。 この問題を回避するには、単一<xref:System.Random>のオブジェクトを使用してすべての乱数を生成します。 また、システムクロックによって返されたシード値を変更し、この新しいシード値を<xref:System.Random.%23ctor%28System.Int32%29>コンストラクターに明示的に指定することによって回避することもできます。 詳細については、 <xref:System.Random.%23ctor%28System.Int32%29>コンストラクターを参照してください。  
  
 乱数ジェネレーターでランダムな数値シーケンスを生成する場合は、このコンストラクターを呼び出します。 異なる乱数ジェネレーターに対して同じである固定シーケンスの乱数を生成するには、固定<xref:System.Random.%23ctor%28System.Int32%29>のシード値を使用してコンストラクターを呼び出します。 この<xref:System.Random>コンストラクターのオーバーロードは、ランダムな数値を使用するアプリをテストするときによく使用されます。  
  
 乱数ジェネレーターをインスタンス化したら、や<xref:System.Random> <xref:System.Random.NextDouble>などの個別のメソッドを呼び出し<xref:System.Random.Next>て、乱数を生成します。  
  
   
  
## Examples  
 次の例では、パラメーターなしのコンストラクター <xref:System.Random>を使用して、3つのオブジェクトをインスタンス化し、それぞれに対して5つのランダムな整数のシーケンスを表示します。 最初の2つ<xref:System.Random>のオブジェクトは、連続して作成されるので、システムクロックに基づいて同一のシード値を使用してインスタンス化されるため、同じシーケンスの乱数が生成されます。 一方、3番目<xref:System.Random>のオブジェクトのパラメーターなしのコンストラクターは、メソッドの<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>呼び出しによって発生する2秒の遅延の後に呼び出されます。 これにより、3番目<xref:System.Random>のオブジェクトに対して異なるシード値が生成されるため、異なる乱数シーケンスが生成されます。  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">擬似乱数系列の開始値を計算するために使用する数値。 負数を指定した場合、その数値の絶対値が使用されます。</param>
        <summary>指定したシード値を使用して <see cref="T:System.Random" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 異なる<xref:System.Random>オブジェクトに対して同一のシード値を指定すると、各インスタンスは同じシーケンスの乱数を生成します。 これは、ランダムな数値ジェネレーターに依存するアプリをテストする場合によく行われます。  
  
 アプリケーションで異なる乱数シーケンスが必要な場合は、別のシード値を使用してこのコンストラクターを繰り返し呼び出します。 一意のシード値を生成する方法の1つは、時間に依存するようにすることです。 たとえば、オーバーロードの<xref:System.Random.%23ctor>場合と同じように、システムクロックからシード値を派生させます。 ただし、システムクロックには、別のシード値を持つこのコンストラクターの異なる呼び出しを提供するための十分な解決策がない可能性があります。 この結果、次の例の最初の2つ<xref:System.Random>のオブジェクトに示すように、擬似乱数の同じシーケンスを生成する乱数ジェネレーターが生成されます。 これを回避するには、各呼び出しのシード値を区別するためのアルゴリズムを<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>適用するか、またはメソッドを呼び出して、各コンストラクターに異なるシード値を指定していることを確認します。  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 もう1つの方法は、 <xref:System.Random>アプリケーションのすべての乱数を生成するために使用する単一のオブジェクトをインスタンス化することです。 乱数ジェネレーターのインスタンス化にはかなりのコストがかかるため、パフォーマンスが若干向上します。  
  
   
  
## Examples  
 次の例で<xref:System.Random>は、シードパラメーターを受け取り、ランダムな整数と倍精度のシーケンスを生成するクラスコンストラクターを使用してオブジェクトを作成します。 この例では、コンストラクターとシードパラメーターを使用<xref:System.Random>してオブジェクトを再作成するときに、同じシーケンスが生成されることを示しています。  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ランダムな整数を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>0 以上のランダムな整数を返します。</summary>
        <returns>0 以上で <see cref="F:System.Int32.MaxValue" /> より小さい 32 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType>0からより<xref:System.Int32.MaxValue?displayProperty=nameWithType>小さい値までの範囲の乱数を生成します。 0から他の正の値までの範囲の乱数を生成するには<xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> 、メソッドオーバーロードを使用します。 異なる範囲内の乱数を生成するには、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>メソッドオーバーロードを使用します。  
  
   
  
## Examples  
 次の例では、 <xref:System.Random.Next%2A>メソッドを繰り返し呼び出して、ユーザーによって要求された特定の数の乱数を生成します。 メソッド<xref:System.Console.ReadLine%2A?displayProperty=nameWithType>は、顧客の入力を取得するために使用されます。  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 次の例では、から<xref:System.Random>クラスを派生させる<xref:System.Random.Sample%2A>ことにより、基底クラスのメソッドによって生成される均一分布とは異なる分布を持つ乱数のシーケンスを生成します。 <xref:System.Random.Sample%2A>メソッドをオーバーライドして乱数の分布を指定し、 <xref:System.Random.Next%2A?displayProperty=nameWithType>メソッドをオーバーライドして一連の乱数を使用します。  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>.NET Framework バージョン2.0 以降では、から<see cref="T:System.Random" />クラスを派生させ、メソッドを<see cref="M:System.Random.Sample" />オーバーライドした場合、 <see cref="M:System.Random.Sample" />メソッドの派生クラス実装によって提供される分布は、基本クラスの呼び出しでは使用されません。<see cref="M:System.Random.Next" />メソッドの実装。 代わりに、基本<see cref="T:System.Random" />クラスによって返される一様分布が使用されます。 この動作により、 <see cref="T:System.Random" />クラスの全体的なパフォーマンスが向上します。 派生クラスで<see cref="M:System.Random.Sample" />メソッドを呼び出すようにこの動作を変更するには、 <see cref="M:System.Random.Next" />メソッドもオーバーライドする必要があります。</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">生成される乱数の排他的上限値。 <paramref name="maxValue" /> は 0 以上にする必要があります。</param>
        <summary>指定した最大値より小さい 0 以上のランダムな整数を返します。</summary>
        <returns>0 以上で <paramref name="maxValue" /> 未満の 32 ビット符号付き整数。つまり、通常は戻り値の範囲に 0 は含まれますが、<paramref name="maxValue" /> は含まれません。 ただし、<paramref name="maxValue" /> が 0 の場合は、<paramref name="maxValue" /> が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オーバーロード<xref:System.Random.Next%28System.Int32%29>は、 `maxValue` 0 ~-1 の範囲のランダムな整数を返します。 ただし、が`maxValue` 0 の場合、メソッドは0を返します。  
  
   
  
## Examples  
 次の例では、 <xref:System.Random.Next%2A>メソッドのさまざまなオーバーロードを使用して、ランダムな整数を生成します。  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 次の例では、配列から文字列値を取得するためにインデックスとして使用されるランダムな整数が生成されます。 配列の最大インデックスはその長さよりも小さいため、 <xref:System.Array.Length%2A?displayProperty=nameWithType>プロパティの値は`maxValue`パラメーターとして指定されます。  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue" /> が 0 未満です。</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">返される乱数の包括的下限値。</param>
        <param name="maxValue">返される乱数の排他的上限値。 <paramref name="maxValue" /> は <paramref name="minValue" /> 以上である必要があります。</param>
        <summary>指定した範囲内のランダムな整数を返します。</summary>
        <returns><paramref name="minValue" /> 以上で <paramref name="maxValue" /> 未満の 32 ビット符号付整数。つまり、戻り値の範囲に <paramref name="minValue" /> は含まれますが <paramref name="maxValue" /> は含まれません。 <paramref name="minValue" /> が <paramref name="maxValue" /> と等しい場合は、<paramref name="minValue" /> が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オーバーロード<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>は、 `minValue`から-1 までの範囲のランダムな整数を返します。 `maxValue` ただし、が`maxValue`に`minValue`等しい場合、メソッド`minValue`はを返します。  
  
 負でない値のみを<xref:System.Random.Next%2A>返すメソッドの他のオーバーロードとは異なり、このメソッドは負の整数を返すことができます。  
  
   
  
## Examples  
 次の例では<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 、メソッドを使用して、3つの異なる範囲を持つランダムな整数を生成します。 この例の正確な出力は、 <xref:System.Random>クラスコンストラクターに渡されるシステム指定のシード値によって異なります。  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 次の例では、配列から文字列値を取得するためにインデックスとして使用されるランダムな整数が生成されます。 配列の最大インデックスはその長さよりも小さいため、 <xref:System.Array.Length%2A?displayProperty=nameWithType>プロパティの値は`maxValue`パラメーターとして指定されます。  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minValue" /> が <paramref name="maxValue" /> より大きくなっています。</exception>
        <block subset="none" type="overrides"><para>.NET Framework バージョン2.0 以降では、から<see cref="T:System.Random" />クラスを派生させ、メソッドを<see cref="M:System.Random.Sample" />オーバーライドした場合、 <see cref="M:System.Random.Sample" />メソッドの派生クラス実装によって提供される分布は、基本クラスの呼び出しでは使用されません。パラメーター <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> <paramref name="minValue" /> <see cref="F:System.Int32.MaxValue" />とパラメーターの差がより大きい場合のメソッドオーバーロードの実装。 <paramref name="maxValue" /> 代わりに、基本<see cref="T:System.Random" />クラスによって返される一様分布が使用されます。 この動作により、 <see cref="T:System.Random" />クラスの全体的なパフォーマンスが向上します。 派生クラスで<see cref="M:System.Random.Sample" />メソッドを呼び出すようにこの動作を変更するには、 <see cref="M:System.Random.Next(System.Int32,System.Int32)" />メソッドのオーバーロードもオーバーライドする必要があります。</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">乱数を格納するバイト配列。</param>
        <summary>指定したバイト配列の要素に乱数を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 バイト配列の各要素は、0以上かつ以下の乱数に設定されて<xref:System.Byte.MaxValue>います。  
  
 たとえば、ランダムなパスワードの作成に適した暗号的に保護さ<xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>れたランダムな数値を生成するには、などのメソッドを使用します。  
  
   
  
## Examples  
 次の例は、メソッドを使用<xref:System.Random.NextBytes%2A>して、バイト配列にランダムバイト値を格納する方法を示しています。  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <block subset="none" type="overrides"><para>.NET Framework バージョン2.0 以降では、から<see cref="T:System.Random" />クラスを派生させ、メソッドを<see cref="M:System.Random.Sample" />オーバーライドした場合、 <see cref="M:System.Random.Sample" />メソッドの派生クラス実装によって提供される分布は、基本クラスの呼び出しでは使用されません。<see cref="M:System.Random.NextBytes(System.Byte[])" />メソッドの実装。 代わりに、基本<see cref="T:System.Random" />クラスによって返される一様分布が使用されます。 この動作により、 <see cref="T:System.Random" />クラスの全体的なパフォーマンスが向上します。 派生クラスで<see cref="M:System.Random.Sample" />メソッドを呼び出すようにこの動作を変更するには、 <see cref="M:System.Random.NextBytes(System.Byte[])" />メソッドもオーバーライドする必要があります。</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>0.0 以上 1.0 未満のランダムな浮動小数点数を返します。</summary>
        <returns>0.0 以上 1.0 未満の倍精度浮動小数点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドによって返される乱数の実際の上限は0.99999999999999978 です。  
  
 0.0 および1.0 以外の範囲内のランダムな浮動小数点値を取得するには、 <xref:System.Random>クラスのトピックの「指定された範囲の浮動小数点値を取得する」セクションを参照してください。  
  
 このメソッドは、保護されたメソッド<xref:System.Random.Sample%2A>のパブリックバージョンです。  
  
   
  
## Examples  
 次の例では<xref:System.Random.NextDouble%2A> 、メソッドを使用して、ランダムな倍精度のシーケンスを生成します。  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 次の例では<xref:System.Random.NextDouble%2A> 、メソッドを呼び出して、100の乱数を生成し、その頻度分布を表示します。  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>0.0 と 1.0 の間のランダムな浮動小数点数を返します。</summary>
        <returns>0.0 以上 1.0 未満の倍精度浮動小数点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 異なるランダム分布または異なる乱数ジェネレーターの原則を生成するには、 <xref:System.Random>クラスからクラスを派生させ、 <xref:System.Random.Sample%2A>メソッドをオーバーライドします。  
  
> [!IMPORTANT]
>  メソッドはです`protected`。これは、 <xref:System.Random>クラスとその派生クラス内でのみアクセスできることを意味します。 <xref:System.Random.Sample%2A> <xref:System.Random>インスタンスから0と1の間の乱数を生成するには<xref:System.Random.NextDouble%2A> 、メソッドを呼び出します。  
  
   
  
## Examples  
 次の例では、から<xref:System.Random>クラスを派生<xref:System.Random.Sample%2A>し、メソッドをオーバーライドして、乱数の分布を生成します。 この分布は、基本クラスの<xref:System.Random.Sample%2A>メソッドによって生成される均一分布とは異なります。  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>.NET Framework バージョン2.0 以降では、から<see cref="T:System.Random" />クラスを派生させ、メソッドを<see cref="M:System.Random.Sample" />オーバーライドした場合、 <see cref="M:System.Random.Sample" />メソッドの派生クラス実装によって提供される分布は、基本クラスの呼び出しでは使用されません。次のメソッドの実装。 
-   <see cref="M:System.Random.NextBytes(System.Byte[])" /> メソッド。  
  
-   <see cref="M:System.Random.Next" /> メソッド。  
  
<see cref="M:System.Random.Next(System.Int32,System.Int32)" /> -メソッド ((<paramref name="maxValue" /> - ) がより <see cref="F:System.Int32.MaxValue" /> 大きい場合。<paramref name="minValue" />  
  
代わりに、基本<see cref="T:System.Random" />クラスによって提供される一様分布が使用されます。 この動作により、 <see cref="T:System.Random" />クラスの全体的なパフォーマンスが向上します。 派生クラスの<see cref="M:System.Random.Sample" />メソッドの実装を呼び出すようにこの動作を変更するには、これら3つのメンバーの動作もオーバーライドする必要があります。 具体的な例を次に示します。</para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>
