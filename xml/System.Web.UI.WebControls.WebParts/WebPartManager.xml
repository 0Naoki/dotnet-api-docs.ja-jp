<Type Name="WebPartManager" FullName="System.Web.UI.WebControls.WebParts.WebPartManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c703891c7a4ebdf7f78b5a40a7746c8ac071f701" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70371780" /></Metadata><TypeSignature Language="C#" Value="public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartManager extends System.Web.UI.Control implements class System.Web.UI.INamingContainer, class System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartManager&#xA;Inherits Control&#xA;Implements INamingContainer, IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartManager : System::Web::UI::Control, System::Web::UI::INamingContainer, System::Web::UI::WebControls::WebParts::IPersonalizable" />
  <TypeSignature Language="F#" Value="type WebPartManager = class&#xA;    inherit Control&#xA;    interface INamingContainer&#xA;    interface IPersonalizable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.WebControls.WebParts.IPersonalizable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ViewStateModeById</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Web パーツ コントロール、Web パーツ機能、および Web ページ上で発生するイベントのすべてを管理する、Web パーツ コントロール セットの中心的なクラスとして機能します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager>は、Web パーツアプリケーションのハブまたはコントロールセンターとして機能します。 Web パーツコントロールを使用するすべてのページに、1<xref:System.Web.UI.WebControls.WebParts.WebPartManager>つのコントロールインスタンスだけを指定する必要があります。 Web パーツアプリケーションのほとんどの側面と同様に<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 、コントロールは認証されたユーザーに対してのみ機能します。 さらに、その機能は、 <xref:System.Web.UI.WebControls.WebParts.WebZone>クラスを継承する Web パーツゾーン内に存在するサーバーコントロールとほぼ同じように機能します。 これらのゾーンの外部にあるページに配置されているサーバーコントロールは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Web パーツの機能やコントロールとの対話をほとんど必要としません。  
  
 ページの Web パーツ機能のハブとして、コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager>は次の表に示すタスクの種類を実行します。  
  
|タスクカテゴリ|コントロールの動作|  
|-------------------|---------------------------|  
|Web パーツコントロールの追跡|<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、接続、ゾーンなどの Web パーツの機能を提供する、ページ上のさまざまな種類のコントロールを追跡します。|  
|Web パーツコントロールの追加と削除|ページ上のコントロールを追加、削除、および<xref:System.Web.UI.WebControls.WebParts.WebPart>終了するためのメソッドを提供します。|  
|接続の管理|コントロール間の接続を作成し、接続を監視します。また、接続を追加および削除するプロセスも監視します。|  
|コントロールとページのカスタマイズ|ユーザーがコントロールをページ上の別の場所に移動し、ユーザーがコントロールの外観、プロパティ、および動作を編集できるビューを起動できるようにします。 では、各ページにユーザー固有のパーソナル化の設定が保持されます。|  
|切り替え (異なるページビューを)|ページレイアウトの変更やコントロールの編集などの特定のタスクをユーザーが実行できるように、ページを異なる特別なビューに切り替えます。|  
|Web パーツのライフサイクルイベントの発生|開発者は、コントロールが追加、移動、接続、または削除されたときなど、Web パーツコントロールのライフサイクルイベントを処理できます。|  
|コントロールのインポートとエクスポートを有効にする|コントロールの<xref:System.Web.UI.WebControls.WebParts.WebPart>プロパティの状態を含む XML ストリームをエクスポートします。また、ユーザーがファイルをインポートして、他のページやサイトの複雑なコントロールをカスタマイズする場合に便利です。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスには、プロパティの大きなセットがあります。 他のコントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager>を追跡する役割と一貫性があるため、Web パーツコントロールのコレクションまたはその他の特殊な Web パーツオブジェクトを参照する多数のプロパティがあります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A> 、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>、 、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>、 、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>、 、およびの各プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager>は、コントロールが追跡を行うために使用するすべてのコレクションです。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>管理タスク。  
  
 別のプロパティグループには、Web パーツアプリケーションで発生する特定のシナリオに適用されるカスタマイズ可能な警告が含まれています。 これには<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>、、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>、および<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>プロパティが含まれます。  
  
 クラス<xref:System.Web.UI.WebControls.WebParts.WebPartManager>は、多くの Web サーバーコントロールで使用される、継承された基本プロパティの一部をオーバーライドします。 これには<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>、、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>およびの各プロパティが含まれます。  
  
 最後に、アプリケーションの現在の状態にアクセスするのに役立つプロパティのグループがあります。 プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>は、ページの現在の表示モードを示します。 プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A>は、コントロールがクライアント側スクリプトのレンダリングを許可されているかどうかを示します。これは、ユーザーがさまざまな機能を持つブラウザーを使用している場合や、スクリプトが無効になっている場合に関連します。 プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>は、拡張ケースに使用される重要な Web パーツメソッドの多くの呼び出しを含むユーティリティクラスを参照する場合に便利です。 これらのメソッドの呼び出しを別のクラス ( <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>クラス) で非表示にすることによって<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 、クラス独自の API が簡略化されます。 プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>は、ユーザーのパーソナル化設定を格納し、そのデータを永続的なストレージに保持するパーソナル化オブジェクトへのアクセスを提供します。 プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>は、ユーザー <xref:System.Web.UI.WebControls.WebParts.WebPart>またはアプリケーションによって現在選択されているページ上のコントロールを示します。 プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>は、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール上のカスタムのパーソナル化データが変更されたかどうかを示します。  
  
 コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager>には、5つの組み込みの表示モード、または Web ページのビューが含まれています。 開発者は、クラス<xref:System.Web.UI.WebControls.WebParts.WebZone> <xref:System.Web.UI.WebControls.WebParts.ToolZone>やクラスなどの型を拡張することで、この機能を拡張し、カスタム表示モードを作成できます。 特定の表示モードに対応する適切な種類のコントロールがページに存在する場合は、ユーザーがページをさまざまな表示モードに切り替えることができます。  
  
> [!NOTE]
>  この機能を拡張して、ユーザーがページに対応するゾーンがなくてもカスタム表示モードに切り替えることができるようにすることができます。 ただし、既定の動作では、表示モードはゾーンに対応しています。  
  
 標準表示モードは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスのパブリックフィールドによって表されます。 次の表は、フィールドとそれらが参照する表示モードをまとめたものです。 前に説明したように、ページの現在の表示モードは常に<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>プロパティで参照され、ページ上に存在するゾーンの種類に応じて、特定のページで使用できる表示モードのセットは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>プロパティに含まれています。  
  
|フィールド|表示モードの詳細|  
|-----------|--------------------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|Web ページの通常のユーザービュー。既定と最も一般的な表示モード。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|ページレイアウトを変更するためにユーザーがコントロールを再配置または削除できるビュー。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|編集中のユーザーインターフェイス (UI) が表示されるビュー。ユーザーは、通常のブラウズモードで表示されるコントロールの外観、プロパティ、および動作を編集できます。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|カタログ UI が表示されるビュー。ユーザーは、使用可能なコントロールのカタログからページにコントロールを追加できます。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|接続 UI が表示されるビュー。ユーザーは、コントロール間の接続、管理、または接続解除を行うことができます。|  
  
 コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager>には、Web パーツのページやコントロールのライフサイクルに不可欠な多数のイベントも含まれています。 これらのイベントにより、Web パーツコントロールの動作をプログラムによって細かく制御できます。 ほとんどのメソッドは、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール (または、コントロールとして動作するよう<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>に、ゾーンに配置され<xref:System.Web.UI.WebControls.WebParts.WebPart>ている他のサーバーコントロールまたはユーザーコントロール) に直接関係しています。 ただし、いくつかのイベントは、ページ上のページまたは接続の状態に関連しています。 次の表は、使用可能なイベントの一覧とその用途をまとめたものです。  
  
> [!NOTE]
>  次の表のいずれの場合も、"コントロール" とは、ゾーン<xref:System.Web.UI.WebControls.WebParts.WebPart>内に存在し、実行時に<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>オブジェクトとしてラップされるコントロールまたはサーバーコントロールを指します。  
  
|event|説明|  
|-----------|-----------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|コントロールがページに追加される直前に発生し、承認されていることを確認します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|ページ上のすべての接続がアクティブになった後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|ページ上のすべての接続をアクティブ化するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|ページの現在の表示モードが変更された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|ページの表示モードを変更するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|コントロールの選択が取り消された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|コントロールの選択をキャンセルするプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|コントロールがゾーンに追加された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|コントロールをゾーンに追加するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|コントロールが閉じられた (ページから削除された) 後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|コントロールを閉じるプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|動的コントロールのインスタンス (プログラムによって作成された、またはカタログから追加されたもの) が完全に削除された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|動的コントロールを削除するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|コントロールがゾーン内または別のゾーン内で移動された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|コントロールを移動するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|接続に参加するために選択された2つのコントロールが接続を確立した後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|2つのコントロールを接続するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|接続されている2つのコントロールが切断された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|2つのコントロールを切断するプロセスの直前に発生します。|  
  
 コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager>には、Web パーツページを管理するためのさまざまなメソッドがあります。 ここに記載されていないメソッドの大きなセットは、名前が*EventName*の形式であるメソッドです。 これらのメソッドは、通常、関連付けられたイベントを発生させ<xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>、イベントに型のハンドラーを提供します。 これらのメソッドのほとんどは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスを継承する開発者によってオーバーライドされる可能性があります。 また、ページ開発者は、これらのメソッドに関連付けられたイベントのカスタムハンドラーを提供できます。 たとえば、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>イベントの場合、ページ開発者は、Web ページのマークアップ`OnWebPartAdded`の`<asp:webpartmanager>`要素に属性を追加し、カスタムメソッド名を属性に割り当てて、イベントのカスタム処理を提供することができます。 属性は<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>メソッドに対応します。この基本的なパターンのイベント処理は、ほとんどの Web パーツイベントとその関連メソッドに対して機能します。  
  
 また、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールには、コントロール (コントロールとして<xref:System.Web.UI.WebControls.WebParts.WebPart>使用<xref:System.Web.UI.WebControls.WebParts.WebPart>されるサーバーコントロールまたはユーザーコントロール) を管理するためのタスクに固有のメソッドがあります。 これらのメソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>には<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> 、、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>、、、、、、、、、、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>、、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>および。  
  
 別のメソッドセットは、接続に特化しています。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>これには<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>、、、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> 、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 、、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>、、、、などのメソッドが含ま<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>れます<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>  
  
 最後に、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>いくつかのメソッドはパーソナル化機能に重点を置いています。 これらのメソッドには、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>、および <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A> が含まれます。  
  
 プロパティを<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> <xref:System.Web.UI.WebControls.WebParts.WebPartManager> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>使用してアクセスできるその他のメソッドの詳細については、クラスのドキュメントを参照してください。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールの宣言型の使用とプログラムによる使用の両方を示しています。  
  
 このコード例には、次の4つの部分があります。  
  
-   Web パーツページの表示モードを変更できるユーザーコントロール。  
  
-   接続できる2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール`<asp:webpartmanager>`と要素を含む Web ページ。  
  
-   2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールとカスタムインターフェイスを含むソースコードファイル。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 ユーザーコントロールにはドロップダウンリストコントロールがあります。このコントロールには、ページ上に存在する Web パーツコントロールがある場合に、使用可能な表示モードが表示されます。 このコード例の web ページでは、このユーザーコントロールがページのマークアップ<xref:System.Web.UI.WebControls.WebParts.WebPartManager>の要素のすぐ下に宣言されており`Register` 、web ページの上部付近にディレクティブがあり、コントロールが登録されています。 このコントロールの表示モードとソースコードの説明の詳細については、 [「チュートリアル:Web パーツページ](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)での表示モードの変更  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/DisplayModeMenuVB.ascx#6)]  
  
 Web ページの宣言型マークアップに`Register`は、ユーザーコントロールとカスタムコントロールの両方に対するディレクティブが含まれています。 要素、カスタムコントロールを格納する要素、および要素があります。`<asp:connectionszone>` `<asp:webpartzone>` `<asp:webpartmanager>` このページには、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールの接続に関連するイベントを処理するインラインコードも含まれています。接続したり、コントロールを切断したりすると、このコードの効果を確認できます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 この例の3番目の部分は、コントロールのソースコードです。 という名前`IZipCode`のインターフェイスがあり、このインターフェイスが`ZipCodeWebPart`クラスに実装されていることに注意してください。 このクラスには、プロバイダーとし`ProvideIZipCode`て機能するという名前の特殊なコールバックメソッドがあります。 という`WeatherWebPart`名前のその他の型は、という名前`GetIZipCode`の特殊なメソッドを使用して実装されます。これにより、コントロールは、他のコントロールのコンシューマーとして機能することができます。  
  
 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 このコード例では、ソースをアセンブリにコンパイルし、Web ページの`Register`ディレクティブがアセンブリ名を参照していることを前提としています。 のコンパイル方法を示すチュートリアルについては[、「チュートリアル:カスタム Web サーバーコントロール](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)の開発と使用  
  
 [!code-csharp[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/ZipCodeComponent.vb#2)]  
  
 ブラウザーに Web ページを読み込んだ後、**[表示モード]** ドロップダウンリストコントロールをクリックし、**[接続]** を選択してページを接続モードに切り替えます。 Connect モードでは`<asp:connectionszone>` 、要素を使用して、コントロール間の接続を作成できます。 接続モードで、**郵便番号**コントロールのタイトルバーにある下向きの矢印をクリックして動詞メニューをアクティブにし、**[接続]** をクリックします。 接続 UI が表示されたら、**[コンシューマーへの接続の作成]** リンクをクリックします。 ドロップダウンリストコントロールを持つセルが表示されます。 ドロップダウンリストで **[気象制御]** を選択し、**[接続]** をクリックして2つのコントロールの接続を完了します。 **[閉じる]** をクリックし、**[表示モード]** ドロップダウンリストを使用して、ページを通常ブラウズモードに戻します。 郵便番号を入力すると、コンシューマーコントロールが入力した値で更新されます。 プロパティは`ZipCode`ソースコードの`Personalizable`属性でマークされているので、このプロパティ値はブラウザーセッション間で保持されるため、ユーザーが入力した値が保存されます。 より洗練されたコンシューマーコントロールは、郵便番号情報を取得し、コードに基づいて気象情報を参照し、ユーザーに表示することができます。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />コントロールは拡張されるように設計されています。 Web パーツアプリケーションにとっては非常に重要なので、Web パーツコントロールセット内の特定の型またはコントロールを拡張する場合は、多くの場合<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 、クラスも拡張する必要があります。これは、 カスタム型は、Web パーツアプリケーションのコンテキストで動作します。 Web パーツリファレンスドキュメント (「」 <see cref="N:System.Web.UI.WebControls.WebParts" />を参照) では、Web パーツ型を拡張する方法について説明するときに、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスを拡張するために実行する必要があること、およびコード例で拡張する方法を示します。</para></block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンストラクター <xref:System.Web.UI.WebControls.WebParts.WebPartManager.%23ctor%2A>は、コントロールによって使用さ<xref:System.Web.UI.WebControls.WebParts.WebPartManager>れるいくつかの重要な変数を初期化します。 すべての Web パーツページに直接影響する割り当ての1つは、既定のページ表示モードが参照モード (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>) に設定されていることです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateConnections">
      <MemberSignature Language="C#" Value="protected virtual void ActivateConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ActivateConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ActivateConnections ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ActivateConnections();" />
      <MemberSignature Language="F#" Value="abstract member ActivateConnections : unit -&gt; unit&#xA;override this.ActivateConnections : unit -&gt; unit" Usage="webPartManager.ActivateConnections " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Web ページ上で現在アクティブでないすべての接続をアクティブにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、ゾーン内に<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>存在する他のサーバーコントロールとの<xref:System.Web.UI.WebControls.WebParts.WebPart>間の既存の接続をアクティブ化するために、ページへの各要求に対して呼び出されます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> 場合によっては、アクティブ化されている接続に競合がある場合、このメソッドは<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>メソッドを呼び出して、問題のある接続を終了します。 切断プロセス中に、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>イベントが発生します。 通常、開発者はこのイベントを取り消すことができますが、接続のアクティブ化プロセスを完了するために<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールが競合を解決する必要があるため、これが接続の間で競合している場合は、キャンセルできません。 詳細について<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>は、「イベント」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPart AddWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPart ^ AddWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="member this.AddWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.AddWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">Web ページに追加するか、ページ上で開く <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (あるいは、サーバー コントロールまたはユーザー コントロール)。</param>
        <param name="zone"><paramref name="webPart" /> の追加先となる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</param>
        <param name="zoneIndex"><paramref name="webPart" /> 内の他のコントロールに対して <paramref name="zone" /> 内で <paramref name="zone" /> が占める序数位置を表す整数。</param>
        <summary>Web ページにプログラムで <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを追加する標準メソッドを提供します。</summary>
        <returns>ページに追加された <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>は、新しい動的<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールをページに追加するために使用されます。また、以前にページで閉じられた静的コントロールまたは動的コントロールを再び開くためにも使用されます。 新しいコントロールを追加するためにメソッドが呼び出されると、実際には、 `webPart`パラメーターで参照されるコントロールのコピーが作成されます。 コントロールのコピーに対して新しい id が生成されるため、開発者は<xref:System.Web.UI.WebControls.WebParts.WebPart>メソッドから返されたコントロールを参照して、新しい id 値を取得する必要があります。 以前に閉じられたコントロールを再び開くためにメソッドを呼び出すと、 `webPart`パラメーターによって参照されるコントロールへの直接参照が返されます。  
  
> [!IMPORTANT]
>  コントロールをページに追加<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> <xref:System.Web.UI.ControlCollection.Add%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=nameWithType> <xref:System.Web.UI.ControlCollection.Add%2A>するには、プロパティによって参照されるコントロールのコレクションのメソッドではなく、メソッドを常に使用する必要があります。 <xref:System.Web.UI.WebControls.WebParts.WebPart>メソッドは例外をスローします。 コントロールでは<xref:System.Web.UI.WebControls.WebParts.WebPart>ないコントロール (つまり、実行時に<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>コントロールを使用してラップされるサーバーコントロール) を追加するには、最初に<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>メソッドを呼び出してコントロールを<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>作成し、次にメソッドを呼び出してを追加します。コントロール。 この方法のデモについては、「例」のセクションを参照してください。  
  
   
  
## Examples  
 次のコード例では、メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>を使用して、プログラムによってサーバーコントロールをページに追加する方法を示します。 ページマークアップには、 `<asp:webpartzone>`空の要素`<asp:webpartmanager>`と要素が含まれています。 **[カレンダーの追加]** ボタンを初めてクリックすると、イベントハンドラーのコードに<xref:System.Web.UI.WebControls.Calendar>よってコントロールが作成され、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>メソッドを<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>呼び出してオブジェクトとしてゾーンに追加されます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="zone" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="zone" /> が、ゾーンの <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールのコレクションに登録されていません。  
  
- または - 
 <paramref name="webPart" /> は、既に <paramref name="zone" /> にあります。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="zoneIndex" /> の値が 0 未満です。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="AuthorizeWebPart">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AuthorizeWebPart As WebPartAuthorizationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventHandler ^ AuthorizeWebPart;" />
      <MemberSignature Language="F#" Value="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " Usage="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" /> メソッドを呼び出すと発生し、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロールをページに追加できるかどうかを判断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>は、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールがページに追加されるたびに発生します。 コントロールをページに追加できる一般的なシナリオがいくつかあります。 これらの詳細については、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>メソッドの「解説」を参照してください。 コントロールを追加するときは、その<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>コントロールのプロパティが設定されているかどうかを確認し、存在する場合は、コントロールがページに追加されることを承認されているかどうかを確認する必要があります。  
  
 開発者は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>イベントのイベントハンドラーを作成して、コントロールのフィルター処理を提供できます。 コントロールの<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティ値がイベントハンドラーコードの条件を満たさない場合、コントロールはページに追加されません。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>イベントのカスタムイベントハンドラーを設定する方法を示しています。これにより、既定<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>のメソッドが自動的にオーバーライドされます。  
  
 `mgr1_AuthorizeWebPart`メソッド内のコードは、ページ上のコントロールのそれぞれ<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>のプロパティ値がに`user`設定されているかどうか`true`を確認し、存在する場合はを返します。これは、ページに対して承認され、追加されることを意味します。 これは、ユーザーのパーソナル化スコープのページでコントロールを表示できるようにするための既定の方法であることを前提としています。 ただし、この例では、コントロールの1つで<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティ値がに`admin`設定されています。 開発者は、管理ユーザーのみが表示できるように設計された特殊なコントロールにこのフィルターを配置できます。 このコントロールは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>イベント中の承認チェックに失敗し、表示されません。 プロパティが設定されていないコントロールも表示されることに注意してください。これらは、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティが設定されていないため、フィルター処理のシナリオに含まれないと想定されています。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="AvailableTransformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableTransformers As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ AvailableTransformers { System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableTransformers : System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールの間に Web パーツ接続を作成する場合に使用できる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> オブジェクトのコレクションを取得します。</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.TransformerTypeCollection" /> オブジェクトのセットが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>メソッドを使用してコレクションを作成します。 既定では、アプリケーション構成ファイルから使用可能なトランスフォーマーが読み取られます。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178187(v=vs.100)">Web パーツ接続の概要</related>
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartConnecting(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartConnecting(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartConnecting webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">接続を構成するコントロール。</param>
        <summary>2 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを接続するプロセスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>は、コントロール間の接続を形成するプロセスを個別の段階で実行できるようにするため、開発者は接続プロセスをより細かく制御できます。 メソッドは、初期チェックのセットを実行して`webPart` 、が接続を正しく形成できる状態であることを確認します。 が`webPart`すべてのチェックに合格した場合は、現在選択されているコントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>として設定され (プロパティを参照)、接続プロセスを続行できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">ページ上の現在の表示モードが <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" /> ではありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> は閉じています。  
  
または 
 <paramref name="webPart" /> が <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コレクションの一部ではありません。  
  
または 
 <paramref name="webPart" /> と <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> コントロールが等価です。</exception>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />コントロールを拡張する必要がある開発者は、派生クラスでこのメソッドをオーバーライドすることが必要になる場合があります。 1つの方法は、基本メソッドを呼び出して、追加のカスタム処理を追加することです。または、コントロール間の接続を開始するプロセスを完全にカスタマイズすることもできます。 たとえば、接続を作成する前に特定のデータが使用可能であることを確認することができます。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartEditing(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartEditing(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartEditing webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">編集対象のコントロール。</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを編集するプロセスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>は、コントロールを編集するプロセスを個別の段階で実行できるようにするため、開発者はプロセスをより細かく制御できます。 メソッドは、が編集可能な状態である`webPart`ことを確認するために、一連の初期チェックを実行します。 が`webPart`すべてのチェックに合格した場合は、現在選択されているコントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>として設定され (プロパティを参照)、編集プロセスを続行できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">ページ上の現在の表示モードが <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" /> ではありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> は閉じています。  
  
または 
 <paramref name="webPart" /> が <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コレクションの一部ではありません。  
  
または 
 <paramref name="webPart" /> と <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> コントロールが等価です。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="BrowseDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BrowseDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ BrowseDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable BrowseDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web パーツ コントロールが含まれたページの既定の表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フィールド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールに<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>よって作成および格納されるカスタムオブジェクトを参照します。 これは静的オブジェクトであるため、コントロールのインスタンスを必要とせ<xref:System.Web.UI.WebControls.WebParts.WebPartManager>ずに、クラスを介して直接参照できます。  
  
 Web パーツコントロールを含むページが最初に読み込まれるとき、既定<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>では (ブラウズモード) になります。 通常の Web ページの場合と同じようにユーザーが参照するだけの場合、ページはブラウズモードのままになります。 ユーザーがページのレイアウト、コントロール、外観、または動作をカスタマイズする場合は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>プロパティを通じて使用できる特殊な表示モードのいずれかにページを切り替える必要があります。  
  
   
  
## Examples  
 次のコード例は、プログラムによって<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>フィールドを操作する方法を示しています。 このコードは、サポートされている表示モードを使用してドロップダウンリストを設定します。この例では、参照とデザインが使用されています。 `Page_PreRender`メソッドでは、現在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>のプロパティがに<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>設定されているかどうかがコードによってチェックされることに注意してください。 存在する場合は、 `Label1` が表示され、存在しない場合は非表示になります。`Label1`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/CS/wpmgrBrowseDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/VB/wpmgrBrowseDisplayModevb.aspx#1)]  
  
 ブラウザーにページを読み込むと、既定でブラウズモードになります。 閲覧モードになっていることを示すラベルがページに表示されます。 ドロップダウンリストコントロールを使用して、ページをデザインモードに切り替えます。 `Page_PreRender`メソッドのコードが原因で、ラベルが非表示になっていることに注意してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web パーツのページ表示モード</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続に関係する <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールをチェックし、こうしたコントロールを接続できるかどうかを判断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>は、2つ<xref:System.Web.UI.WebControls.WebParts.WebPart>のコントロールを接続できるかどうかを判断するために使用されます。 メソッドは、通常、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>メソッドを呼び出す前に条件付きチェックとして使用されます。  
  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>は、2つのコントロールが接続を形成する前に満たす必要があるいくつかの条件をチェックします。 次の一覧は、接続を確立するための主要な基準をまとめたものです。 これらのすべての条件 (さらにいくつかの内部条件を含む) が`true`満たされている場合、メソッドはを返します。これは、コントロールが接続可能であることを意味します。  
  
-   プロバイダーおよびコンシューマーコントロールをにする`null`ことはできません。また、これらのコントロールは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>プロパティによって参照されるコントロールのコレクションに含まれている必要があります。  
  
-   プロバイダーとコンシューマーを同じコントロールにすることはできません。 つまり、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール自体に接続することはできません。  
  
-   プロバイダーとコンシューマーの両方の`null`オブジェクト(接続ポイント)をにすることはできません。<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint>  
  
-   プロバイダーとコンシューマーを閉じることはできません ( <xref:System.Web.UI.WebControls.WebParts.WebPart.IsClosed%2A>コントロールのプロパティ`true`をにすることはできません)。  
  
-   接続<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ControlType%2A>ポイントコントロールのプロパティは、コンシューマーとプロバイダーの両方のコントロールの型と一致している必要があります。  
  
-   コネクションポイントは両方とも有効になっ<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.GetEnabled%2A>ている必要が`true`あります (これらのメソッドは両方ともを返す必要があります)。  
  
-   各接続ポイントは、独自<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A>のプロパティに指定されているよりも多くの接続を形成することはできません。  
  
-   互換性のないコントロールを接続するために`null`オブジェクト(トランスフォーマー)が必要な場合、にすることはできません。<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> ただし、コントロールに既に互換性がある場合、トランスフォーマーは`null`である必要があります。  
  
-   トランスフォーマー (使用されている場合) は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>コレクション内で参照される必要があります。  
  
-   トランスフォーマー (使用されている場合) には、2つのコントロール間でデータを変換できるように、プロバイダーとコンシューマーと互換性のあるインターフェイスが必要です。 コンシューマーとプロバイダーのセカンダリインターフェイスにも互換性がある必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">コントロールを接続したときに、<paramref name="consumer" /> にデータを提供するコントロール。</param>
        <param name="providerConnectionPoint"><paramref name="provider" /> が接続に関与できるようにする <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />。</param>
        <param name="consumer">コントロールを接続したときに、<paramref name="provider" /> からデータを受け取るコントロール。</param>
        <param name="consumerConnectionPoint"><paramref name="consumer" /> が接続に関与できるように、コールバック メソッドとして機能する <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />。</param>
        <summary>コンシューマー コントロールとプロバイダー コントロールが互換性のあるインターフェイスを持ち、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> オブジェクトが不要な場合に、接続に関係する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> コントロールをチェックし、こうしたコントロールを接続できるかどうかを判断します。</summary>
        <returns><paramref name="provider" /> と <paramref name="consumer" /> を接続できるかどうかを示すブール値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、接続`provider`するために使用されます。また`consumer` 、両方のコントロールに<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>互換性のあるコネクションポイントの種類がある場合は、オブジェクトが不要になります。 このメソッドを使用して、プログラムによる接続を作成するためにを<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>呼び出す前に、2つのコントロールを接続できることを確認できます。  
  
 このオーバーロードは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29>メソッドオーバーロードと同じ実装を使用しますが、このオーバーロードにはトランスフォーマーが必要ないという唯一の例外があります。  
  
   
  
## Examples  
 このメソッドの使用方法を次のコード例に示します。  
  
 このコード例には、次の4つの部分があります。  
  
-   Web パーツページの表示モードを変更できるユーザーコントロール。  
  
-   接続できる2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール`<asp:webpartmanager>` 、要素、および<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>メソッドを使用して接続を作成するいくつかのイベント処理コードを含む Web ページ。  
  
-   2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールとカスタムインターフェイスを含むソースコードファイル。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、 [「チュートリアル:Web パーツページ](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)での表示モードの変更  
  
 Web ページの宣言型マークアップに`Register`は、ユーザーコントロールとカスタムコントロールの両方に対するディレクティブが含まれています。 要素、カスタムコントロールを格納する要素、および要素があります。`<asp:connectionszone>` `<asp:webpartzone>` `<asp:webpartmanager>` `Page_Load`メソッドでは、接続が確立できるかどうかをコードが確認し、存在する場合はプロバイダー、コンシューマー、およびそれぞれの接続ポイントを定義し、次に、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>によって参照される静的接続のセットに新しい接続を追加します。プロパティ。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 この例の3番目の部分は、コントロールのソースコードです。 これには、インターフェイスと 2 <xref:System.Web.UI.WebControls.WebParts.WebPart>つのカスタムコントロールが含まれています。1つはプロバイダーとして機能し、もう1つはコンシューマーとして機能します。 互換性のあるコネクションポイントがあるため (どちらもインターフェイス`IZipCode`を認識しているため)、接続を確立するためにトランスフォーマーは必要ありません。 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 のコンパイル方法を示すチュートリアルについては[、「チュートリアル:カスタム Web サーバーコントロール](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)の開発と使用  
  
 [!code-csharp[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/ZipCodeComponent.vb#2)]  
  
 ブラウザーに Web ページを読み込んだ後、**[表示モード]** ドロップダウンリストコントロールをクリックし、**[接続]** を選択してページを接続モードに切り替えます。 Connect モードでは`<asp:connectionszone>` 、要素を使用して、コントロール間の接続を作成できます。 接続モードで、**郵便番号**コントロールのタイトルバーにある下向きの矢印をクリックして動詞メニューをアクティブにし、**[接続]** をクリックします。 接続ユーザーインターフェイス (UI) が表示されたら、 `Page_Load`メソッドに含まれるコードによって接続が既に作成されていることを確認します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool&#xA;override this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">コントロールを接続したときに、<paramref name="consumer" /> にデータを提供するコントロール。</param>
        <param name="providerConnectionPoint"><paramref name="provider" /> が接続に関与できるように、コールバック メソッドとして機能する <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />。</param>
        <param name="consumer">コントロールを接続したときに、<paramref name="provider" /> からデータを受け取るコントロール。</param>
        <param name="consumerConnectionPoint"><paramref name="consumer" /> が接続に関与できるように、コールバック メソッドとして機能する <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />。</param>
        <param name="transformer">互換性のない <paramref name="provider" /> と <paramref name="consumer" /> の接続を可能にする <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />。</param>
        <summary>接続に関係する <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールをチェックして、こうしたコントロールが接続可能かどうかを判断し、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> オブジェクトを使用して互換性のないコンシューマーとプロバイダーの間に接続を作成します。</summary>
        <returns><paramref name="provider" /> と <paramref name="consumer" /> で接続を構成できるかどうかを示すブール値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、接続`provider`するために使用されます。また`consumer` 、両方のコントロールに<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>互換性のないコネクションポイントの種類がある場合は、オブジェクトが必要になります。 このメソッドを使用して、プログラムによる接続を作成するためにを<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>呼び出す前に、2つのコントロールを接続できることを確認できます。  
  
 このオーバーロードは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29>メソッドのオーバーロードと同じ実装を使用しますが、このオーバーロードにはトランスフォーマーが必要であるという唯一の例外があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CatalogDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ CatalogDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable CatalogDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのカタログから Web ページにサーバー コントロールを追加する場合に使用する表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フィールド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールに<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>よって作成および格納されるカスタムオブジェクトを参照します。 これは静的オブジェクトであるため、コントロールのインスタンスを必要とせ<xref:System.Web.UI.WebControls.WebParts.WebPartManager>ずに、クラスを介して直接参照できます。  
  
 ユーザーがコントロールをページに追加する場合、サーバーコントロールのカタログが使用可能な場合は、ページを (カタログ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>モード) に切り替えて、カタログユーザーインターフェイス (UI) が表示されるようにすることができます。 Web パーツカタログの UI は、 <xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase>ゾーンコントロールによって提供されます。 開発者は、デザイン時にこのゾーンをページに追加してから、サーバーコントロールをゾーンに追加して、ユーザーが実行時にこれらのコントロールをページに追加できるようにします。 開発者がこれらのコントロールを追加した後、カタログモードは、カタログモードを有効にするために必要なコントロールがあるため、ページでサポートされている表示モードになります。  
  
 ユーザーがページをカタログモードに切り替えると、ゾーンとそれに追加されたすべてのサーバーコントロールが表示されるようになり、ユーザーは、カタログからコントロールを選択してページに追加したり、ページからコントロールを削除したりできます。 コントロールがページに追加されると、通常のブラウズモードで表示され、ページが更新されます。  
  
   
  
## Examples  
 次のコード例は、プログラムによって<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>フィールドを操作する方法を示しています。 このコードは、ページのサポートされている表示モードを含むドロップダウンリストを設定します。この例では、参照、デザイン、およびカタログです。 カタログモードは、Web ページ内の`<asp:CatalogZone>`要素とその子要素によって使用できます。 `Page_PreRender`メソッドでは、現在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>のプロパティがに<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>設定されているかどうかがコードによってチェックされることに注意してください。 存在する場合は、 `Label1` が表示され、存在しない場合は非表示になります。`Label1`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/CS/wpmgrCatalogDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/VB/wpmgrCatalogDisplayModevb.aspx#1)]  
  
 ブラウザーにページを読み込むと、既定でブラウズモードになります。 ページのラベルが非表示になっていることに注意してください。 ドロップダウンリストコントロールを使用して、ページをカタログモードに切り替えます。 `Page_PreRender`メソッドのコードが原因で、ラベルが表示されるようになったことに注意してください。 カタログ内のコントロールを選択し、ページの2つのゾーンのいずれかに追加できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web パーツのページ表示モード</related>
      </Docs>
    </Member>
    <Member MemberName="CheckRenderClientScript">
      <MemberSignature Language="C#" Value="protected virtual bool CheckRenderClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckRenderClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CheckRenderClientScript () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckRenderClientScript();" />
      <MemberSignature Language="F#" Value="abstract member CheckRenderClientScript : unit -&gt; bool&#xA;override this.CheckRenderClientScript : unit -&gt; bool" Usage="webPartManager.CheckRenderClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ブラウザーから要求を行う機能および <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" /> プロパティの値をチェックし、クライアント スクリプトを表示するかどうかを判断します。</summary>
        <returns>クライアント スクリプトを表示するかどうかを示すブール値。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CloseProviderWarning">
      <MemberSignature Language="C#" Value="public virtual string CloseProviderWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CloseProviderWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CloseProviderWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CloseProviderWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CloseProviderWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>接続で他のコントロールに対するプロバイダーとして動作しているコントロールをユーザーが終了すると表示される警告を取得または設定します。</summary>
        <value>警告メッセージが含まれた文字列。 既定値は、.NET Framework が提供するカルチャ固有のメッセージです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーがコントロールを<xref:System.Web.UI.WebControls.WebParts.WebPart>閉じると、通常、メッセージは表示されません。 コントロールを閉じる方法の詳細については、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>メソッドを参照してください。  
  
 ただし、コントロールが別のコントロールに接続され、他のコントロールに対するデータのプロバイダーとして機能している場合は、ユーザーがコントロールを閉じるときに既定の警告メッセージが表示されます。 このメッセージは、プロバイダーコントロールが閉じようとしていることをユーザーに通知します。これは、コンシューマーとしてこのプロバイダーに接続されているコントロールが、使用するデータを保持しなくなることを意味します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>プロパティを使用すると、開発者は、ユーザーに表示される警告メッセージをカスタマイズできます。  
  
 ページ開発者がこのプロパティに空の文字列値または null 文字列値を割り当てた場合、ユーザーがプロバイダーであるコントロール<xref:System.Web.UI.WebControls.WebParts.WebPart>を終了しても警告メッセージボックスは表示されません。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>プロパティを使用してカスタム警告をユーザーに表示する方法を示しています。  
  
 このコード例には、次の4つの部分があります。  
  
-   Web パーツページの表示モードを変更できるユーザーコントロール。  
  
-   2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールとカスタムインターフェイスを含むソースコードファイル。  
  
-   接続できる2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール`<asp:webpartmanager>`と要素を含む Web ページ。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 次のコードには、例の Web ページ部分のみが含まれています。 また、カスタムユーザーコントロールと、上記で説明したカスタムコントロールのソースコードも必要になります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要の「例」セクションから、これらの2つの項目を取得します。  
  
 次の Web ページコードは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> `<asp:webpartmanager>`要素の宣言型マークアップでプロパティにカスタム警告メッセージを割り当てる方法を示しています。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 ブラウザーに Web ページを読み込んだ後、**[表示モード]** ドロップダウンリストコントロールをクリックし、**[接続]** を選択してページを接続モードに切り替えます。 Connect モードでは`<asp:connectionszone>` 、要素を使用して、コントロール間の接続を作成できます。 接続モードで、**郵便番号**コントロールのタイトルバーにある下向きの矢印をクリックして動詞メニューをアクティブにし、**[接続]** をクリックします。 接続ユーザーインターフェイス (UI) が表示されたら、**[コンシューマーへの接続の作成]** リンクをクリックします。 ドロップダウンリストコントロールを持つセルが表示されます。 ドロップダウンリストで **[気象制御]** を選択し、**[接続]** をクリックして2つのコントロールの接続を完了します。 **[閉じる]** をクリックし、**[表示モード]** ドロップダウンリストを使用して、ページを通常ブラウズモードに戻します。 最後に、**[郵便]** 番号 コントロール (この場合はプロバイダーコントロール) の動詞メニューをクリックし、**[閉じる]** を選択します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>プロパティに割り当てたカスタムメッセージが表示されます。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CloseWebPart">
      <MemberSignature Language="C#" Value="public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.CloseWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.CloseWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart"><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 内の終了する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> コントロールまたはサーバー コントロール。</param>
        <summary>Web ページ上に表示されなくても再度開くことができる方法で <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、また<xref:System.Web.UI.WebControls.WebParts.WebPart>は他のサーバーコントロールを削除して、それを最初に含んでいた Web ページ上にレンダリングされないようにします。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 閉じられたコントロールが<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>オブジェクトに追加されます。このオブジェクトは、終了したコントロールへの参照を保持し、コントロールをページに復元できるようにします。 閉じ<xref:System.Web.UI.WebControls.WebParts.WebPart>たコントロールは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>プロパティによって参照されるコレクションに引き続き表示されます。  
  
 コントロールを閉じることは、コントロールを削除することとは異なります。 閉じられたコントロールをページに復元することはできますが、削除されたコントロールインスタンスは完全に削除されるため、復元することはできません。 <xref:System.Web.UI.WebControls.WebParts.WebPart>またはサーバーコントロールが静的である (ページのマークアップで宣言されている) か、または動的に (プログラムによって、またはユーザーによって Web パーツカタログから追加された) かにかかわらず、ページ上で閉じて再度開くことができます。  
  
 通常、ユーザーは動詞メニュー <xref:System.Web.UI.WebControls.WebParts.WebPart>をクリックし、[閉じる] 動詞を選択して、コントロールを閉じることができます。 また、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>メソッドを直接呼び出してへ`webPart`の参照を渡すことによって、コントロールを閉じることもできます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールが閉じられているページで、開発者が`<asp:catalogzone>`要素を宣言`<asp:pagecatalogpart>`し、その中で要素を追加すると、ユーザーが実行時に終了したコントロールをページに復元するための単純なユーザーインターフェイス (UI) が提供されます。 ユーザーはページをカタログ表示モードに切り替えることができ、閉じたコントロールはページカタログ内に表示されます。 ユーザーは、終了したコントロールを選択して、任意の位置でページに戻すことができます。その後、選択したコントロールがページに復元され、通常どおりにレンダリングされます。  
  
 メソッドが呼び出されると、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> (複数のコントロールがある場合)、および (接続され<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>ているコントロールがある場合) といういくつかのイベントが発生します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 通常、開発者はこれらのイベントを取り消すことができますが、場合によってはキャンセルすることはできません。 詳細については、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>、および<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>の各イベントのドキュメントを参照してください。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> メソッドの使用方法を示します。  
  
 このコード例には、次の4つの部分があります。  
  
-   ページ表示モードを変更できるユーザーコントロール。  
  
-   カスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。  
  
-   Web ページ。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、 [「チュートリアル:Web パーツページ](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)での表示モードの変更  
  
 コード例の2番目の部分は、 <xref:System.Web.UI.WebControls.WebParts.WebPart>カスタムコントロールです。 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 この例では、動的コンパイルの方法を使用します。したがって、この`Assembly`コントロールの`Register`ディレクティブには、Web ページの上部に属性がありません。 のコンパイル方法を示すチュートリアルについては[、「チュートリアル:カスタム Web サーバーコントロール](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)の開発と使用  
  
 [!code-csharp[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/textdisplaywebpart.vb#3)]  
  
 コード例の3番目の部分は、Web ページです。 このページには<xref:System.Web.UI.WebControls.WebParts.CatalogZone> 、ゾーンが含ま`<asp:pagecatalogpart>`れており、その中で要素が宣言されています。 これは、閉じら<xref:System.Web.UI.WebControls.WebParts.WebPart>れたコントロールを含み、ユーザーがページに再び追加できるようにするものです。 メソッド`Button1_Click`は、メソッドを<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>直接呼び出してカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールを閉じます。ただし、ユーザーは動詞メニューを使用してコントロールを閉じることもできます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/closeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/closeWebPartVB.aspx#1)]  
  
 ブラウザーにページを読み込んだ後、コントロールのヘッダーの<xref:System.Web.UI.WebControls.WebParts.WebPart>動詞メニュー (矢印の記号) をクリックし、**[閉じる]** をクリックして、カスタムコントロールを閉じます。 次に、**[表示モード]** ドロップダウンリストコントロールで **[カタログ]** を選択して、ページをカタログモードに変更します。 閉じたコントロールでページカタログが表示されます。 閉じたコントロールの横のチェックボックスをオンにし、**[追加]** をクリックしてページに追加し、**[閉じる]** をクリックしてページをブラウズモードに戻します。 コントロールがページに復元されます。 ここで、**[WebPart を閉じる]** ボタンをクリックして、もう一度閉じます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> が <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コレクション内にありません。  
  
- または - 
 <paramref name="webPart" /> は共有コントロールで、別のユーザーによって既に終了されています。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowClose" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ConnectDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ ConnectDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable ConnectDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーが <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール間の接続を管理するための特殊なユーザー インターフェイス (UI) を表示する場合に使用する表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フィールド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールに<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>よって作成および格納されるカスタムオブジェクトを参照します。 これは静的オブジェクトであるため、コントロールのインスタンスを必要とせ<xref:System.Web.UI.WebControls.WebParts.WebPartManager>ずに、クラスを介して直接参照できます。  
  
 ユーザーが Web ページ上のコントロール<xref:System.Web.UI.WebControls.WebParts.WebPart>間の接続を管理する場合、 <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone>ページでゾーンが宣言されていると、ページを<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>モードに切り替えることができます。 接続表示モードでは、接続を管理するための特殊な UI が表示されます。これには、コントロールに接続したり、接続を切断したり、既存の接続の詳細を編集したりする機能が含まれます。  
  
 Web パーツコントロールセットによって提供される UI を使用して接続を管理する機能をユーザーに提供する場合は`<asp:connectionszone>` 、ページのマークアップで要素を宣言する必要があります。 他の種類<xref:System.Web.UI.WebControls.WebParts.WebZone>のゾーンの要素とは異なり、この要素内に他のタグを追加する必要はありません。要素を単独で宣言するだけです。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>モードの使用方法を示しています。  
  
 このコード例には、次の3つの部分があります。  
  
-   接続を形成できるインターフェイスおよびカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールを含むソースファイル。  
  
-   接続 UI を提供し、モードの<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>操作を示す Web ページ。  
  
-   例を実行する方法について説明します。  
  
 コード例の最初の部分は、インターフェイスと、接続できるように設計され<xref:System.Web.UI.WebControls.WebParts.WebPart>た2つのカスタムコントロールを含むソースファイルです。 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 このコード例では、動的コンパイル方法を使用します。 のコンパイル方法を示すチュートリアルについては[、「チュートリアル:カスタム Web サーバーコントロール](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)の開発と使用  
  
 [!code-csharp[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ZipCodeComponent.vb#2)]  
  
 この例の2番目の部分は、カスタムコントロールをホストする Web ページです。 ページのサーバー `<script>`タグ内には、ページの表示モードを使用してドロップダウンリストを設定するいくつかの方法があります。 ユーザーは、ドロップダウンリストからこれらを選択して、ページの表示モードを変更できます。 使用可能な表示モードの1つは、 `<asp:connectionszone>`要素がページのマークアップで宣言されているため、接続表示モードです。 この要素には他の子要素が含まれていないことに注意してください。これは、ユーザーの接続管理 UI を有効にするためだけに存在します。  
  
 この<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>例では、モードは2か所に表示されます。 最初に、 `Page_Init`メソッドでは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>プロパティで参照されるコレクションをコードがループするので、表示モードのドロップダウンリストに接続表示モードが追加されます。 次に、 `Page_PreRender`メソッドはページの現在の表示モードを確認し、現在のモードが<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>の場合は、 <xref:System.Web.UI.WebControls.Label>コントロールにメッセージを表示します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ConnectDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ConnectDisplayModeVB.aspx#1)]  
  
 ブラウザーにページを読み込んだ後、ドロップダウンリストをクリックし、**[接続]** を選択して、ページを接続表示モードに切り替えます。 ページが接続表示モードであることを通知するメッセージが表示されます。 次に、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールのいずれかのタイトルバーにある動詞メニュー (矢印の記号) をクリックし、動詞メニューの **[接続]** をクリックします。 接続 UI が表示されたら、リンクをクリックして接続を作成します。 表示される接続 UI 内のドロップダウンリストを使用して、接続に参加する他のコントロールを選択し、**[接続]** ボタンをクリックします。 接続が確立されます。 **[閉じる]** ボタンをクリックし、ページの上部にあるドロップダウンリストを使用して、表示モードを参照するページを返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web パーツのページ表示モード</related>
      </Docs>
    </Member>
    <Member MemberName="Connections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ Connections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上の現在の接続すべてのコレクションへの参照を取得します。</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> オブジェクトのセットが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>は、ページ上の現在の接続のセットにアクセスする手段を提供します。 コレクション自体は読み取り専用であり、コレクションから特定の接続を操作する開発者は、や<xref:System.Web.UI.WebControls.WebParts.WebPartManager> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>など<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>のメソッドを使用する必要があります。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールの宣言型の使用方法を示しています。  
  
 このコード例には、次の4つの部分があります。  
  
-   Web パーツページの表示モードを変更できるユーザーコントロール。  
  
-   接続できる2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール`<asp:webpartmanager>`と要素を含む Web ページ。  
  
-   2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールとカスタムインターフェイスを含むソースコードファイル。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 次のコードには、例の Web ページ部分のみが含まれています。 また、カスタムユーザーコントロールと、上記で説明したカスタムコントロールのソースコードも必要になります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要の「例」セクションから、これらの2つの項目を取得します。  
  
 次の Web ページコードでは、プログラムで<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>プロパティを使用して、ページ上の現在の接続数を取得する方法を示しています。 `<script>` Tag セクションでは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールの2つのイベントを処理するコードがプロパティに<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>アクセスしてカウントを取得することに注意してください。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 ブラウザーに Web ページを読み込んだ後、**[表示モード]** ドロップダウンリストコントロールをクリックし、**[接続]** を選択してページを接続モードに切り替えます。 Connect モードでは`<asp:connectionszone>` 、要素を使用して、コントロール間の接続を作成できます。 接続モードで、**郵便番号**コントロールのタイトルバーにある下向きの矢印をクリックして動詞メニューをアクティブにし、**[接続]** をクリックします。 接続ユーザーインターフェイス (UI) が表示されたら、**[コンシューマーへの接続の作成]** リンクをクリックします。 ドロップダウンリストコントロールを持つセルが表示されます。 ドロップダウンリストで **[気象制御]** を選択し、**[接続]** をクリックして2つのコントロールの接続を完了します。 **[閉じる]** をクリックし、**[表示モード]** ドロップダウンリストを使用して、ページを通常ブラウズモードに戻します。 ラベルには、接続の数とコントロールの<xref:System.Web.UI.WebControls.WebParts.WebPart>数が表示されることに注意してください。 接続モードに戻り、2つのコントロールを切断した場合、ブラウズモードに戻ると、ラベルの内容が更新され、接続が確立されないようにする必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivated;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivated : EventHandler " Usage="member this.ConnectionsActivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ上の現在の Web パーツ接続すべてが接続され、さらにそれぞれの接続に関係するコンシューマー コントロールとプロバイダー コントロールの間にアクティブなデータの共有が開始された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続のライフサイクルでは、ページが読み込みプロセスを完了した後にこのイベントが発生します。 <xref:System.Web.UI.WebControls.WebParts.WebPart>また、イベントの<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>後にも発生します。これは、特定の接続に関連するまたはサーバーコントロールが正常に接続されていることのみを示します。 1つのページに複数の接続が存在する場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>メソッドは、ページ上のすべての有効な Web パーツ接続がアクティブになり、データを共有できるようになったことを示します。 すべての接続がアクティブであることを把握すると、開発者は、すべての接続の状態をユーザーに通知したり、プロバイダーからのデータを処理および表示するようコンシューマーコントロールに通知したりするなど、任意の数のタスクを実行できます。  
  
 このイベントは、イベントを<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A>発生させ、開発者がイベントのカスタムハンドラーを作成できるようにするメソッドに関連付けられています。  
  
 ページ開発者は、イベントのカスタムハンドラーを作成できます`OnConnectionsActivated` 。そのため`<asp:webpartmanager>`には、ページの要素に属性を追加してから、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivating">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivating As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivating;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivating : EventHandler " Usage="member this.ConnectionsActivating : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上で確立されたすべての Web パーツ接続をアクティブにするプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続のライフサイクルでは、このイベントは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>メソッドが呼び出される直前にページが読み込みプロセスを完了しているときに発生します。 これは、または<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>他のサーバーコントロール間<xref:System.Web.UI.WebControls.WebParts.WebPart>の特定の接続を含むイベントとは異なります。 イベント<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>は、ページ上のすべての可能な接続が接続され、アクティブ化されるときに発生します。  
  
 イベントは、イベントを発生<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>させるメソッドに関連付けられています。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> ページに追加できる接続の種類を拡張するコントロール開発者は、保護さ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>れたメソッドをオーバーライドし、追加の種類の接続をアクティブ化することができます。  
  
 ページ開発者は、イベントのカスタムハンドラーを作成できます`OnConnectionsActivating` 。そのため`<asp:webpartmanager>`には、ページの要素に属性を追加してから、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーン内に存在する 2 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> コントロール (または、接続を構成できるその他のサーバー コントロール) の間に接続を作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>は、接続できる任意の 2 <xref:System.Web.UI.WebControls.WebParts.WebPart>つのコントロール間の接続を形成します。 このメソッドを呼び出して接続を作成する前に、条件チェックで<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>メソッドを呼び出して、コントロールが接続を形成するための要件を満たしていることを確認することもできます。  
  
> [!NOTE]
>  また、コントロールではない<xref:System.Web.UI.WebControls.WebParts.WebPart> 2 つのサーバーコントロール間の接続を作成することもできます。 通常、2つのコントロールは、必要なメンバーを追加できるように、カスタムサーバーコントロール ( <xref:System.Web.UI.WebControls.WebControl>たとえば、または既存の ASP.NET サーバーコントロールから継承するコントロール) である必要があります。 コントロールも、以下に示す要件を満たしている必要があります。  
  
 接続できるようにするには、2つのコントロール間のあらゆる種類の接続シナリオが、次の要件を満たしている必要があります。  
  
-   各コントロールは<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーン内に存在します (同じゾーンである必要はありません)。  
  
-   Web パーツコントロールセットに実装されている場合、接続のプロバイダーコントロールは、プロバイダーへのコールバックとして機能するパブリックメソッドとしてインターフェイス`ConnectionProvider`を実装し、メソッドにメタデータ属性を設定してプロバイダー接続として識別します。視点. プロバイダーの<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>コネクションポイントを取得するメソッドは仮想であるため<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 、派生したコントロールは必ずしも同じメタデータ属性を使用する必要はありません。  
  
-   Web パーツコントロールセットで実装されている場合、接続のコンシューマーコントロールには、プロバイダーのコールバックメソッドで公開されているインターフェイスへの参照を取得できる特殊なメソッドもあります。また`ConnectionConsumer` 、コンシューマーにはメタデータ属性があります。コンシューマー接続ポイントとして識別するメソッド。 コンシューマー接続ポイントを取得する<xref:System.Web.UI.WebControls.WebParts.WebPartManager> メソッドは仮想であるため、派生コントロールは必ずしも同じメタデータ属性を使用する必要はありません。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>  
  
-   コールバックメソッドには、プロバイダーのコールバックメソッドで提供されるインターフェイスの型 (コンシューマーとプロバイダーがデータを直接共有できること) を使用できること、または開発者が<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>オブジェクトを使用してコンシューマーが使用できる形式にプロバイダーのデータを変換します。  
  
    > [!IMPORTANT]
    >  トランスフォーマーが不要な場合は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29>メソッドオーバーロードを使用します。 トランスフォーマーが必要な場合は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29>メソッドオーバーロードを使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">接続されたもう一方のコントロールにデータを提供する役割を持つ <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</param>
        <param name="providerConnectionPoint">接続のコールバック メソッドとして機能するメソッド。 Web パーツ コントロール セットに実装するときに、<paramref name="provider" /> のパブリック メソッドを <see langword="ConnectionProvider" /> メタデータ属性でマークします。</param>
        <param name="consumer"><paramref name="provider" /> からデータを受け取り、それを処理するか表示する役割を持つ <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</param>
        <param name="consumerConnectionPoint"><paramref name="providerConnectionPoint" /> に接続し、接続のデータを受け取るメソッド。 Web パーツ コントロール セットに実装するときに、<paramref name="consumer" /> のパブリック メソッドを <see langword="ConnectionConsumer" /> メタデータ属性でマークします。</param>
        <summary>コントロールへの参照とその指定された <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> オブジェクトだけを使用して、2 つの <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> コントロールまたは <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> コントロールの間に接続を作成します。</summary>
        <returns>接続に必要なプロバイダーとコンシューマーに関するさまざまな情報が格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、接続ポイントが<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>オブジェクトを使用せずに接続できるという十分な互換性がある場合に、コントロールを接続するために使用されます。 メソッドのこのオーバーロードが呼び出されると、メソッドの他のオーバーロードされたバージョンに呼び出しが渡され、オブジェクト`null`を<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>必要とするパラメーターにが渡されます。  
  
 プログラムを使用して2つのコントロールを接続しよう<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>とすると、条件チェックでメソッドを使用して、コントロールを直接接続できるかどうかを判断できます。  
  
   
  
## Examples  
 次のコード例は、このメソッドを使用してプログラムで接続を作成する方法を示しています。 例を実行するために必要な完全なコードについては、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要の「例」セクションを参照してください。 この例では、ページの表示モードを変更できるようにするユーザーコントロールのソースコードと、2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールのソースコードが必要です。  
  
 2つのコントロールをホストする Web ページのコードは、次のようになります。 ページは、 `Register`先頭にディレクティブを使用して、ユーザーコントロールとカスタムコントロールを宣言します。 カスタムコントロールは、 `<asp:webpartzone>`要素内で宣言によって参照されます。 `Button1_Click`メソッドを処理するコードは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>メソッドを使用して、コントロール間の接続を作成します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 ブラウザーでページを読み込んだ後、**[WebPart コントロールの接続]** ボタンをクリックして接続を作成します。 次に、テキストボックスにデータを入力し、**[5 桁の郵便番号を入力]** ボタンをクリックして、コントロールが接続されていることと、1つ目のコントロールに入力されたデータが2番目のコントロールで更新されていることを確認します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">動的接続の <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールのコレクションが読み取り専用です。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection&#xA;override this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">接続されたもう一方のコントロールにデータを提供する役割を持つ <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</param>
        <param name="providerConnectionPoint"><see langword="ConnectionProvider" /> メタデータ属性でマークされ、接続のコールバック メソッドとして機能する、<paramref name="provider" /> のパブリック メソッド。</param>
        <param name="consumer"><paramref name="provider" /> または <paramref name="transformer" /> からデータを受け取り、それを処理するか表示する役割を持つ <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</param>
        <param name="consumerConnectionPoint"><see langword="ConnectionConsumer" /> メタデータ属性でマークされ、<paramref name="consumer" /> と接続して接続のデータを受け取る、<paramref name="providerConnectionPoint" /> のパブリック メソッド。</param>
        <param name="transformer"><paramref name="provider" /> のデータを <paramref name="consumer" /> が処理できる形式に変換することにより、2 つのコントロールを接続できるようにする <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />。</param>
        <summary>コントロールへの参照、指定された <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> オブジェクト、および <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> オブジェクトを使用して、2 つの <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> コントロールまたは <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> コントロール間の接続を作成します。</summary>
        <returns>接続に必要なプロバイダー、コンシューマー、およびトランスフォーマーに関する情報が格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、接続ポイントに互換性がない場合にコントロールを接続するために使用されます。 が接続ポイント`provider`と`consumer`は異なるインターフェイスを実装している場合は、非互換性が発生します。 トランスフォーマーは、によって`consumer`認識できる型にデータを変換します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">接続が既に <see cref="E:System.Web.UI.Control.PreRender" /> でアクティブになっています。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Web.UI.ControlCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーン内にあり、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> コントロールによって管理される、すべての <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロール、サーバー コントロール、またはユーザー コントロールのコレクションを取得します。</summary>
        <value><see cref="T:System.Web.UI.ControlCollection" /> コントロールによって管理されるすべてのコントロールが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> さまざまなゾーンコントロール<xref:System.Web.UI.WebControls.WebParts.EditorPart>やコントロールなど、コントロールによって参照される他のコントロールを参照しません。<xref:System.Web.UI.WebControls.WebParts.CatalogPart> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>  
  
 このプロパティは、Web パーツコントロールセットによって使用されます。ほとんどの開発状況では、コードから呼び出すためのものではありません。 このため、プロパティはパブリックですが、IntelliSense からは非表示になっています。 コントロールで管理されているまた<xref:System.Web.UI.WebControls.WebParts.WebPart>はその他のサーバーコントロールのコレクションにアクセスする<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>開発者は、そのプロパティを使用する必要があります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CopyWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart CopyWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ CopyWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.CopyWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">コピー対象の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロール。</param>
        <summary>Web ページに <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロールを追加するためにこうしたコントロールのコピーを作成する場合に、Web パーツ コントロール セットで使用されます。</summary>
        <returns>ページに追加される <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コードから<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>メソッドを直接呼び出すことはできません。 このメソッドは、新しい動的<xref:System.Web.UI.WebControls.WebParts.WebPartManager> <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールまたはサーバーコントロールをページに追加するプロセスの一部として、コントロールによって内部的に呼び出されます。 動的コントロールは、プログラムまたは Web パーツユーザーインターフェイス (UI) を使用してページに追加されます。たとえば、ページのマークアップで直接宣言されている静的コントロールではなく、コントロールのカタログからコントロールを追加するユーザーがコントロールを追加します。  
  
> [!NOTE]
>  開発者がメソッドを有効にして、追加のコントロールコピーシナリオを処理できるようにする場合は、派生クラスでメソッドをオーバーライドできます。 詳細については、「継承に関する注意事項」セクションを参照してください。  
  
 新しい動的コントロールが追加されると、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールである場合、メソッドは<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>コントロールの新しいインスタンスを返します。 追加されるコントロールが、他の種類のサーバーコントロール (ユーザーコントロール、カスタムコントロール、ASP.NET コントロールなど) である場合、コントロールは Web パーツコントロールセットによって既に<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>オブジェクトでラップされています。 メソッドでコントロールが<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>検出されると、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart>コントロールの新しいインスタンスが返され、子コントロールの新しいインスタンスがラップされます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>  
  
 メソッドは<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> 、を返すコントロールの新しいコピーを作成するときに、すべてのプロパティの値を既定値にリセットします。 パーソナル化できるプロパティの値を保持し、それらを新しいコントロールインスタンスにコピーする場合は、 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A>メソッドを呼び出す必要があることに注意してください。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>メソッドによって実行される最後の手順は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A>メソッドを呼び出して、コントロールの新しい ID を取得することです。  
  
> [!NOTE]
>  メソッドは、コピーされたコントロールに対して新しい ID を取得するため、元の ID によってページに追加される動的コントロールの参照に依存しないようにしてください。 代わりに、メソッドによって返されるコントロールの新しいインスタンスを参照する必要があります。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>メソッドはとして<see langword="virtual" />宣言されているので<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 、開発者はクラスから継承し、メソッドをオーバーライドして、コントロールのコピーを作成できる追加のシナリオを提供できます。 たとえば、メソッドは、必要に応じて、XML ファイルにシリアル化されたコントロールを入力として受け取ることができます。 メソッドは XML を逆シリアル化し (存在する場合)、基本メソッドを呼び出して既存のケースを処理し、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />コントロールの新しいインスタンスを返すことができます。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CreateAvailableTransformers">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAvailableTransformers () As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ CreateAvailableTransformers();" />
      <MemberSignature Language="F#" Value="abstract member CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection&#xA;override this.CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="webPartManager.CreateAvailableTransformers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Web サイトの構成ファイルに指定されているトランスフォーマーのセットを作成し、<see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" /> プロパティで参照されるトランスフォーマーのコレクションにそれを追加します。</summary>
        <returns>Web サイトの構成ファイルで指定されているトランスフォーマーのコレクション。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>このメソッドは、アプリケーションで使用できるその他のトランスフォーマーを追加するためにオーバーライドできます。 たとえば、メソッドを記述して、Web サービスから使用可能なトランスフォーマーの一覧を取得できます。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberSignature Language="F#" Value="override this.CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection" Usage="webPartManager.CreateControlCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Web ページ上の <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールで管理されるすべてのコントロールのコレクションを返します。 このクラスは継承できません。</summary>
        <returns><see cref="T:System.Web.UI.ControlCollection" /> コントロールで管理されるすべてのさまざまな Web パーツ コントロールで構成された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>このメソッドはプロテクトおよびシールされているため、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスを継承するクラスからは参照できますが、オーバーライドすることはできません。</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateDisplayModes">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDisplayModes () As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ CreateDisplayModes();" />
      <MemberSignature Language="F#" Value="abstract member CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection&#xA;override this.CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="webPartManager.CreateDisplayModes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Web パーツ アプリケーションで使用できるすべての表示モードのセットを作成します。</summary>
        <returns>サポートされているすべての表示モードが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、特定のページでサポートされている表示モードだけでなく、使用可能なすべての表示モードの一覧を作成します。 サポートされている表示モードの詳細につい<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>ては、プロパティを参照してください。  
  
 既定では、Web パーツコントロールセットは、Web パーツページで使用される次の一連の表示モードを作成します。  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>  
  
 開発者は、クラス<xref:System.Web.UI.WebControls.WebParts.WebZone>また<xref:System.Web.UI.WebControls.WebParts.ToolZone>はクラスから派生したカスタムゾーンを使用するかどうかにかかわらず、カスタム表示モードを作成できます。 カスタム表示モードを作成するには、 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>クラスから継承し、表示モードをページのサポートされているモードとして追加する必要があります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスを<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>継承し、メソッドをオーバーライドする必要があります。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A>メソッドを使用して表示モードを追加する場合は、ユーザーインターフェイス (UI) コントロール ( <xref:System.Web.UI.WebControls.ListBox>コントロールなど) に表示される順序で、ページの表示モードをユーザーに提供する順番で追加する必要があります。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> メソッドの使用方法を示します。  
  
 このコード例には5つの部分があります。  
  
-   Web パーツページの表示モードを変更できるユーザーコントロール。  
  
-   他のコントロールをホストする Web ページ。  
  
-   Web ページの<xref:System.Web.UI.WebControls.WebParts.WebPartZone>ゾーンに存在するユーザーコントロール。ラベルにテキストを入力して表示できます。  
  
-   2つのコントロールを含むソースコードファイル。 1つはカスタム<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールで、もう1つは、 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>ページの既定の表示モードに追加するカスタムオブジェクトです。  
  
-   2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールとカスタムインターフェイスを含むソースコードファイル。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、 [「チュートリアル:Web パーツページ](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)での表示モードの変更  
  
 この例の2番目の部分は Web ページです。 これには<xref:System.Web.UI.WebControls.WebParts.WebPartZone> 、ユーザーコントロールとカスタム<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールの2つのコントロールが含まれています。 ページの上部にあるディレクティブに注意して、コンパイル済みコントロールのユーザーコントロールと名前空間を参照してください。`Register`  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/createDisplayModeCS.aspx#1)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/createDisplayModeVB.aspx#1)]  
  
 この例の3番目の部分は、テキストを入力および表示するためのユーザーコントロールです。 コントロールを<xref:System.Web.UI.WebControls.MultiView>使用して、UI の複数のビューを作成します。 1つのビューが`Button1`ボタンで表示され、もう一方のビューはありません。 オーバーライド`OnPreRender`されたメソッドで、ページが現在カスタム表示モードになっているかどうかがコードによって確認され、その場合は、ボタンを含むユーザーコントロールの最初のビューが表示されます。 ページがブラウザーモードまたはデザインモードの場合など、ページがカスタム表示モードでない場合、ボタンは非表示になります。  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/TextDisplaycs.ascx#2)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/TextDisplayvb.ascx#2)]  
  
 この例の4番目の部分は、2つのカスタムクラスのソースファイルです。 カスタム<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスは<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>メソッドをオーバーライドし、まず基本メソッドを呼び出してすべての既定の表示モードを追加してから、カスタム表示モードを追加することに注意してください。 カスタム表示モードクラス`InLineEditDisplayMode`は、から<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>継承するだけで、コンストラクターの表示モードの名前を設定し、基本プロパティの数をオーバーライドしてカスタム表示の特性を確立します。  
  
 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 のコンパイル方法を示すチュートリアルについては[、「チュートリアル:カスタム Web サーバーコントロール](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)の開発と使用  
  
 [!code-csharp[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/CustomDisplayMode.cs#3)]
 [!code-vb[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/CustomDisplayMode.vb#3)]  
  
 コード例を実行するには、ブラウザーにページを読み込みます。 ページは現在ブラウズモードであり、ボタンが表示されていないことに注意してください。 **[表示モード]** ドロップダウンリストコントロールを使用して、ページを [**インライン編集] 表示**モードに変更し`Button1`ます。これで、ボタンが下部のユーザーコントロールに表示されることがわかります。 テキストを追加し、ボタンをクリックしてコントロールを更新します。 ページ表示がブラウズモードに戻り、入力したテキストが表示されます。このボタンは、カスタム表示モードではなくなったため、再度非表示になります。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">チュートリアル: Web パーツページでの表示モードの変更</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicConnectionID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicConnectionID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicConnectionID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicConnectionID () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicConnectionID();" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicConnectionID : unit -&gt; string&#xA;override this.CreateDynamicConnectionID : unit -&gt; string" Usage="webPartManager.CreateDynamicConnectionID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>動的接続の ID として使用される一意の値を取得します。</summary>
        <returns>接続に関する一意の ID を含む文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A>は、GUID 値を生成し、接続の一意の ID として機能するように、その値を文字列に変換します。 メソッドは、動的接続が作成されるたびに呼び出されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>開発者は、派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスでこのメソッドをオーバーライドして、一意の ID を生成するための実装を変更できます。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicWebPartID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicWebPartID (Type webPartType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicWebPartID(class System.Type webPartType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicWebPartID (webPartType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicWebPartID(Type ^ webPartType);" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicWebPartID : Type -&gt; string&#xA;override this.CreateDynamicWebPartID : Type -&gt; string" Usage="webPartManager.CreateDynamicWebPartID webPartType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="webPartType">ID の生成対象となるコントロールの <see cref="T:System.Type" />。</param>
        <summary>動的な <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールの一意の ID を生成します。</summary>
        <returns>コントロールの一意の ID が含まれた文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロール<xref:System.Web.UI.WebControls.WebParts.WebPart>が Web ページに追加されると、コントロールは静的な場合があります (つまり、コントロールがページマークアップで宣言されていることを意味します)。または、動的 (プログラムによって追加されることを意味します) です。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールがページに追加する新しい動的コントロールを作成している場合は、このメソッドを呼び出して一意の ID を生成します。  
  
 メソッドは、ID を生成するためのカスタム実装を提供する必要がある場合に、開発者がオーバーライドできるように仮想化されています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartType" /> は <see langword="null" />です。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart(string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateErrorWebPart (originalID As String, originalTypeName As String, originalPath As String, genericWebPartID As String, errorMessage As String) As ErrorWebPart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::ErrorWebPart ^ CreateErrorWebPart(System::String ^ originalID, System::String ^ originalTypeName, System::String ^ originalPath, System::String ^ genericWebPartID, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart&#xA;override this.CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart" Usage="webPartManager.CreateErrorWebPart (originalID, originalTypeName, originalPath, genericWebPartID, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ErrorWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalID" Type="System.String" />
        <Parameter Name="originalTypeName" Type="System.String" />
        <Parameter Name="originalPath" Type="System.String" />
        <Parameter Name="genericWebPartID" Type="System.String" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="originalID">失敗するコントロールの ID を含む文字列。 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> がこの失敗に関係する場合、ID はその子サーバー コントロールの ID です。</param>
        <param name="originalTypeName">失敗したコントロールの <see cref="T:System.Type" /> の名前を示す文字列。 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> がこの失敗に関係する場合、型名はその子サーバー コントロールの型名です。</param>
        <param name="originalPath">子ユーザー コントロールを格納する <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> がこの失敗に関係する場合、ユーザー コントロールへのパスを含む文字列。</param>
        <param name="genericWebPartID">その型のコントロールがコントロールの読み込みまたは作成の失敗に関係する場合、<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> の ID を返す文字列。</param>
        <param name="errorMessage">ページ上に表示するエラー メッセージを含む文字列。</param>
        <summary>動的な <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを読み込むか作成しようとして何らかの理由で失敗したときに、ページに挿入してエンド ユーザーに表示する特別なコントロールを作成します。</summary>
        <returns>読み込みまたは作成に失敗したコントロールの代わりにページに挿入する <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、Web パーツコントロールセットが動的<xref:System.Web.UI.WebControls.WebParts.WebPart>またはサーバーコントロールのインスタンスの読み込みまたは作成を試みたときに呼び出され、何らかの理由で失敗します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> メソッドは、 <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>オブジェクトを作成し、それにエラーメッセージを割り当てて、それを返します。 失敗したコントロールの代わりにコントロールが挿入され、そのエラーメッセージがページに表示されます。<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>  
  
 コードから<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A>メソッドを直接呼び出すことはできません。 ただし、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスを継承し、メソッドを拡張することができます。 詳細については、「継承に関する注意事項」セクションを参照してください。  
  
 エンドユーザーは、通常<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> <xref:System.Web.UI.WebControls.WebParts.WebPart>のコントロールと同じように、ページ内のコントロールを操作できます。 エラーメッセージを削除するには、閉じる動詞をクリックしてコントロールを閉じることができます。その時点で、他<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>の閉じているコントロールと同様に、コントロールがオブジェクトに追加されます。 エンドユーザーが<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>コントロールを削除すると、読み込みに失敗したサーバーコントロールもページから削除されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />コントロールで返される情報をカスタマイズする場合は、 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />メソッドをオーバーライドし、基本メソッドを呼び出して、基本メソッドに渡されるパラメーターに別の値を割り当ててから、結果<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />のを返すことができます。コントロール。 たとえば、エンドユーザーが<paramref name="originalPath" />値を表示しないようにする (ユーザーコントロールの仮想ディレクトリパスを表示する) 場合は、基本メソッドを呼び出すと、そのパラメーターに空の文字列 ("") を渡すことができます。  
  
<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />コントロール自体を継承することによって、コントロール自体の動作をカスタマイズすることもできます。 たとえば、 <see cref="P:System.Web.UI.WebControls.WebParts.Part.Title" />または<see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowMinimize" />プロパティをオーバーライドすることができます。</para></block>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CreatePersonalization">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreatePersonalization () As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ CreatePersonalization();" />
      <MemberSignature Language="F#" Value="abstract member CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization&#xA;override this.CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="webPartManager.CreatePersonalization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の Web ページのユーザーのパーソナル化データを格納するパーソナル化オブジェクトを返します。</summary>
        <returns>ユーザーのパーソナル化データが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>は、現在のページのユーザーのパーソナル化設定を格納および管理するオブジェクトを返します。 コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager>は、このオブジェクトを管理します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100)">Web パーツパーソナル化の概要</related>
      </Docs>
    </Member>
    <Member MemberName="CreateWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::GenericWebPart ^ CreateWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart&#xA;override this.CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.CreateWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control"><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール以外のサーバー コントロール。</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> オブジェクトを持った <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> コントロール以外のサーバー コントロールが Web パーツ機能を備えることができるように、そのコントロールをラップします。</summary>
        <returns><paramref name="control" /> をラップし、真の <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> コントロールとして機能できる <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、コントロールではないサーバーコントロールが<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールと同じ<xref:System.Web.UI.WebControls.WebParts.WebPart>機能を使用できるようにするための主要なメカニズムであり、Web パーツアプリケーションに完全に参加します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> この方法を使用すると、開発者は Web パーツアプリケーションで使用できるサーバーコントロールの数を大幅に拡張します。これは、ほとんどすべての種類のサーバーコントロール (標準 ASP.NET コントロール、ユーザーコントロール、およびカスタムコントロール) を使用できるためです。  
  
 また<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 、このコントロールは、他の2つのシナリオでもこのメソッド<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>を使用して、サーバーコントロールをオブジェクトにラップします。 ユーザーが<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>コントロールを使用してサーバーコントロールをページに追加する場合、インポートされた<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールがコントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>でない場合は、メソッドが呼び出されます。 また、サーバーコントロールが Web ページ<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>上のゾーン内で永続化形式で宣言されている場合、コントロールではない<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールに対してメソッドが呼び出されます。  
  
 サーバーコントロールをプログラムでゾーンに追加する場合、一般的な方法として、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>メソッドを使用し<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>てオブジェクトを使用してコントロールをラップ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>し、次にメソッドを呼び出して、コントロール<xref:System.Web.UI.WebControls.WebParts.WebPart>をすべてのコレクションに追加します。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>プロパティによって参照されるページ上のコントロール。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>メソッドの使用方法を示しています。 では、コントロールをゾーンに追加する前<xref:System.Web.UI.WebControls.Calendar>に、その<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>オブジェクトを使用してコントロールをラップするために、メソッドが呼び出されます。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> `Button2_Click method`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>このメソッドは、Web パーツコントロールセットで提供<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />される基本クラスではなく、派生クラスを使用するようにオーバーライドできます。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWarning">
      <MemberSignature Language="C#" Value="public virtual string DeleteWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeleteWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DeleteWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DeleteWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DeleteWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>エンド ユーザーがコントロールを削除したときにそのユーザーに対して表示するカスタム警告メッセージを取得または設定します。</summary>
        <value>警告メッセージのテキストが含まれる文字列。 既定値は、ローカライズされた警告メッセージです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーがコントロールを<xref:System.Web.UI.WebControls.WebParts.WebPart>削除すると、通常は既定の警告メッセージが表示されます。 コントロールのこのインスタンスが削除されると、削除が永続的であることをユーザーに警告します。 ページ開発者は、コントロールの新しいインスタンスをページに追加する方法をユーザーに提供する場合があります (たとえば、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールのカタログを使用するか、プログラムによる方法を使用します) が、削除されたコントロールの現在のインスタンスは完全に削除されます。 警告を表示するダイアログボックスには、必要に応じてユーザーが削除を取り消すためのボタンが含まれています。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>プロパティを使用すると、開発者は、ユーザーに表示される警告メッセージを設定できます。  
  
 ページ開発者がこのプロパティに空の文字列 ("") 値を割り当てた場合、ユーザーがコントロールを<xref:System.Web.UI.WebControls.WebParts.WebPart>削除しても警告メッセージダイアログボックスは表示されません。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 静的<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールとサーバーコントロールの場合、プロパティは表示されません。 静的コントロールは、Web ページのマークアップで<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーン内で宣言されたサーバーコントロールです。 このようなコントロールは静的であるため、削除することはできません。その場合、削除の警告メッセージが表示されることはありません。 静的コントロールはユーザーが閉じることができますが、閉じられたコントロールは、ユーザーがページに再び追加できるように、ページカタログに追加されます。ただし、削除されたコントロールは回復できません。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>プロパティを宣言およびプログラムによって使用する方法を示しています。  
  
 コード例には、次の4つの部分があります。  
  
-   ページ表示モードを変更できるユーザーコントロール。  
  
-   カスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。  
  
-   Web ページ。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、 [「チュートリアル:Web パーツページ](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)での表示モードの変更  
  
 コード例の2番目の部分は、 <xref:System.Web.UI.WebControls.WebParts.WebPart>カスタムコントロールです。 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 この例では、動的コンパイルの方法を使用します。したがって、この`Assembly`コントロールの`Register`ディレクティブには、Web ページの上部に属性がありません。 のコンパイル方法を示すチュートリアルについては[、「チュートリアル:カスタム Web サーバーコントロール](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)の開発と使用  
  
 [!code-csharp[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/textdisplaywebpart.vb#3)]  
  
 コード例の3番目の部分は、Web ページです。 ページには、 <xref:System.Web.UI.WebControls.WebParts.CatalogZone>ユーザーが実行時に<xref:System.Web.UI.WebControls.WebParts.WebPart>ページに追加できるように、ゾーン内でカスタムコントロールが宣言されたゾーンが含まれています。 ページから削除できるのは、動的コントロール (プログラムによって、またはこのようなカタログからページに追加されるコントロール) だけです。 静的コントロール (ページのマークアップで<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーン内で宣言されたコントロール) は閉じることができますが、削除することはできません。 要素`<asp:webpartmanager>`は、 `DeleteWarning`属性を使用して<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 、プロパティのカスタム値を宣言します。 メソッド`Button1_Click`は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>プロパティに別のカスタム値を割り当てます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/deleteWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/deleteWarningVB.aspx#1)]  
  
 ブラウザーでページを読み込んだ後、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールをページに追加する必要があります。 **表示モード** ドロップダウンリストコントロールを使用して、カタログモード を選択します。 カタログが表示されたら、カスタムコントロールの横にあるチェックボックスをオンにし、**[追加]** をクリックしてページに追加します。次に、**[閉じる]** をクリックして、ページをブラウズモードに戻します。 コントロールが表示されたので、そのコントロールを削除できます。 **表示モード**コントロールを再度使用して、ページをデザインモードに切り替えます (ページがブラウズモードの間はコントロールを削除できません)。 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールのヘッダーの動詞メニュー (矢印の記号) をクリックし、**[削除]** を選択します。 `DeleteWarning`属性に設定した警告が表示されます。 **[キャンセル]** をクリックします。 次に、**[Change Delete Warning]** というラベルのボタンをクリックします。これにより、プログラムでプロパティ値が変更されます。 コントロールの動詞メニューから **[削除]** をもう一度選択します。今度は、もう一方の警告メッセージが表示されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWebPart">
      <MemberSignature Language="C#" Value="public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.DeleteWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DeleteWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">削除するサーバー コントロール。</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールの動的インスタンスを Web ページから完全に削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>は、 `webPart`パラメーターによって表されるコントロールをページから完全に削除します。 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>コントロールに追加され、ページに戻すことができる閉じたコントロールとは異なり、削除されたコントロールのインスタンスをページに再び追加することはできません。  
  
> [!NOTE]
>  Web パーツコントロールセットによって実装されるように、ユーザーが動的<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールを削除する機能は、ユーザーと、コントロールがページに追加されたパーソナル化スコープによって異なります。 ページがアクセス許可を持つユーザーによって共有スコープ内にあるときにコントロールが追加された場合、そのページがユーザースコープにあるときは、個々のユーザーがそのコントロールを削除することはできません。  
  
 削除できるのは動的コントロールだけです。 動的コントロールは、プログラムによって、またはユーザーがカタログからコントロールを追加することによって、ページに追加されます。 静的コントロールは、マークアップまたは永続化形式で宣言によってページに追加されます。 宣言型のタグはマークアップ内に完全に存在するため、スタティックコントロールは削除できませんが、閉じて再度開くことができます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> メソッドの使用方法を示します。 **[カレンダーの追加]** ボタンを初めてクリックすると、イベントハンドラー内のコード<xref:System.Web.UI.WebControls.Calendar>によってコントロールが作成され、それ<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>がオブジェクトとしてゾーンに追加されます。 コントロールはプログラムによって追加されるため、動的コントロールであるため、削除することができます。 ユーザーが [カレンダーの**削除**] ボタンをクリックすると、そのコントロールが存在することが確認され、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>メソッドを呼び出すことで削除されます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="DesignDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DesignDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DesignDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable DesignDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web パーツ コントロールを含む Web ページのレイアウトを変更する場合に使用する表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フィールド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールに<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>よって作成および格納されるカスタムオブジェクトを参照します。 これは静的オブジェクトであるため、コントロールのインスタンスを必要とせ<xref:System.Web.UI.WebControls.WebParts.WebPartManager>ずに、クラスを介して直接参照できます。  
  
 Web パーツコントロールを含むページが最初に読み込まれるとき、既定<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>では (ブラウズモード) になります。 ユーザーがコントロールを別のゾーンまたは現在のゾーンに移動してページのレイアウトを変更する場合は、まずページを ( <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>デザインモード) に切り替える必要があります。 デザインモードでは、さまざまなゾーンのユーザーインターフェイス (UI) が表示され、ユーザーはコントロールをドラッグしてレイアウトを変更できます。  
  
   
  
## Examples  
 次のコード例は、プログラムによって<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>フィールドを操作する方法を示しています。 このコードは、ページのサポートされている表示モードを含むドロップダウンリストを設定します。この例では、参照とデザインが使用されています。 `Page_PreRender`メソッドでは、現在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>のプロパティがに<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>設定されているかどうかがコードによってチェックされることに注意してください。 存在する場合は、 `Label1` が表示され、存在しない場合は非表示になります。`Label1`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/CS/wpmgrDesignDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/VB/wpmgrDesignDisplayModevb.aspx#1)]  
  
 ブラウザーにページを読み込むと、既定でブラウズモードになります。 ページのラベルが非表示になっていることに注意してください。 ドロップダウンリストコントロールを使用して、ページをデザインモードに切り替えます。 `Page_PreRender`メソッドのコードが原因で、ラベルが表示されるようになったことに注意してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web パーツのページ表示モード</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebPart">
      <MemberSignature Language="C#" Value="protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisconnectWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DisconnectWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DisconnectWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">接続を解除する <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</param>
        <summary>終了または削除する <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロールを、それが関係する接続から削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>メソッドは、コントロールがページ上で閉じられたとき、またはページから削除されたときに、Web パーツコントロールセットによって内部的に呼び出されます。 このようなシナリオでは、コンシューマーまたはプロバイダーとして関係するすべての接続からコントロールを削除するために、メソッドが呼び出されます。 コントロールが接続から削除された場合、このメソッドはメソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>も呼び出して、 `webPart`が関係していたすべての接続を終了します。  
  
 メソッドが呼び出されると、イベントが<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>発生します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 通常、このイベントはキャンセルできますが、2つのケースでは取り消すことができません。 1つのケースは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>メソッドが呼び出されたときに、ページへの要求中に発生します。 既存の接続間で競合が発生した<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>場合、メソッドは、競合している接続のいずれかを閉じるために<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>呼び出されます。この場合、競合を解決する必要があるため、イベントを取り消すことはできません。  
  
 もう1つのケースは<xref:System.Web.UI.WebControls.WebParts.WebPart> 、現在接続されているまたはサーバーコントロールが閉じられているか、削除されている場合に発生します。 この場合、コントロールがページから削除されているため、接続も終了する必要があります。したがって、デザイン上、接続を終了するプロセス<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>を中断するためにイベントをキャンセルすることはできません。 詳細については、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントを参照してください。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドの使用方法を示します。 2つの<xref:System.Web.UI.WebControls.WebParts.WebPart>カスタムコントロールを使用すると、ボタンをクリックしてコントロール間の接続を作成できます。また、別のボタンを使用してコントロールを切断することもできます。 ページがブラウズモードであり、コントロールが接続されているときにコントロールのいずれかを閉じると、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>メソッドのオーバーライドによって閉じられたコントロールが切断され、接続が終了し、メッセージが表示されます。  
  
 このコード例には、次の4つの部分があります。  
  
-   表示モードを変更するためのユーザーコントロール。  
  
-   カスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールを含むソースファイルです。  
  
-   コントロールをホストする Web ページ。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、 [「チュートリアル:Web パーツページ](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)での表示モードの変更  
  
 2番目の部分は、接続される2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールとカスタム<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールのソースコードを含むファイルです。 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 この例では動的コンパイルを使用`Register`するので、web ページ内のこれらのコンポーネントを参照するディレクティブは、それに応じて web ページの先頭で宣言されます。 コンパイルオプションを示すチュートリアルについては[、「チュートリアル:カスタム Web サーバーコントロール](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)の開発と使用  
  
 ソースコードで、 `MyWebPartManager` <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>メソッドをオーバーライドする継承されたコントロールを確認します。 このメソッドは<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 、ページ内の各接続を確認し、閉じられているコントロールが接続に参加しているかどうかを確認します。存在する場合は、メソッドを呼び出して接続を終了します。 これは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールのメソッドの基本実装と同じです。 次に、オーバーライドされたメソッドは、メッセージをページに書き込むことによって基本実装をカスタマイズします。  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 コード例の3番目の部分は、Web ページです。 上部の近くには、ユーザーコントロール`Register`を登録するためのディレクティブと、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールと共に動的にコンパイルされたアセンブリが含まれています。 このページには、2つの主要な方法があります。 メソッドは、コントロール間の接続を作成します`Button2_Click`が、メソッドはコントロールを切断します。 `Button1_Click`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 ページを読み込んだ後、**[接続]** ボタンをクリックしてコントロールを接続します。 次に、コントロールの1つ (コントロールのヘッダーの下矢印) で動詞メニューをクリックし、動詞 メニューの **閉じる** をクリックします。 コントロールを終了しようとすると、オーバーライドされたメソッドが呼び出され、接続が終了し、メッセージがページに書き込まれます。 ページをリセットして、終了したコントロールを復元し、その他のオプションを試すには、**[ユーザー状態のリセット]** リンクをクリックしてパーソナル化データを削除し、ページの元の状態を復元します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebParts">
      <MemberSignature Language="C#" Value="public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisconnectWebParts(class System.Web.UI.WebControls.WebParts.WebPartConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DisconnectWebParts (connection As WebPartConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DisconnectWebParts(System::Web::UI::WebControls::WebParts::WebPartConnection ^ connection);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit&#xA;override this.DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit" Usage="webPartManager.DisconnectWebParts connection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Parameters>
      <Docs>
        <param name="connection">サーバー コントロール間の接続を表す <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</param>
        <summary>Web ページ上で接続されたサーバー コントロールの接続を解除するプロセスを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、 `connection`パラメーターを渡すときに、またはサーバー <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール間の接続を終了する完全なプロセスを実行します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>  
  
 このメソッドは、Web ページに`<asp:connectionszone>`要素を配置するときにコントロールを切断するために使用され、接続を管理するためのユーザーインターフェイス (UI) を提供します。 ページが接続表示モード (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>) であり、現在の接続が存在する場合、ユーザーは<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>メソッドを呼び出すボタンをクリックして接続を終了できます。  
  
 また、コードから<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>メソッドを直接呼び出すこともできます。この場合、プログラムによってコントロールを切断したり、 `<asp:connectionszone>`要素をページに追加したりする必要はありません。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドの使用方法を示します。 2つの<xref:System.Web.UI.WebControls.WebParts.WebPart>カスタムコントロールを使用すると、ボタンをクリックしてコントロール間の接続を作成できます。また、別のボタンを使用してコントロールを切断することもできます。  
  
 このコード例には、次の4つの部分があります。  
  
-   表示モードを変更するためのユーザーコントロール。  
  
-   カスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールを含むソースファイルです。  
  
-   コントロールをホストする Web ページ。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、 [「チュートリアル:Web パーツページ](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)での表示モードの変更  
  
 2番目の部分は、接続される2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールのソースコードを含むファイルです。 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 この例では動的コンパイルを使用`Register`するので、web ページ内のこれらのコンポーネントを参照するディレクティブは、それに応じて web ページの先頭で宣言されます。 コンパイルオプションを示すチュートリアルについては[、「チュートリアル:カスタム Web サーバーコントロール](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)の開発と使用  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 コード例の3番目の部分は、Web ページです。 上部の近くには、ユーザーコントロール`Register`と動的<xref:System.Web.UI.WebControls.WebParts.WebPart>にコンパイルされたアセンブリをコントロールと共に登録するためのディレクティブが含まれています。 このページには、2つの主要な方法があります。 メソッド`Button1_Click`は、コントロール間の接続を作成し、 `Button2_Click`メソッドはコントロールを切断します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 ページを読み込んだ後、**[接続]** ボタンをクリックしてコントロールを接続することができます。 テキストボックスコントロールにテキストを入力し、**[enter]** ボタンをクリックすると、接続されたコントロールにテキストが表示されます (コントロールが接続されていない場合は表示されません)。 **[切断]** ボタンをクリックすると、コントロールが切断されます。 コントロールの接続状態を確認するには、**[表示モード]** ドロップダウンリストコントロールを使用して、ページを**接続**モードに切り替えます。 その後、いずれかのコントロールのタイトルバーで動詞メニュー (矢印で表されます) をクリックし、**[Connect]** 項目を選択します。 接続 UI が表示されます。これは、ページで宣言さ`<asp:connectionszone>`れた要素があるために使用できます。 この UI からコントロールに接続したり、コントロールを切断したりすることもできます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connection" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> または<see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> のいずれかに <paramref name="connection" /> が含まれていません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> は読み取り専用です。  
  
- または - 
 <paramref name="connection" /> は既に <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> から接続解除されています。  
  
- または - 
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> は読み取り専用です。  
  
または 
 <paramref name="connection" /> は既に <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> から接続解除されています。</exception>
        <block subset="none" type="overrides"><para>コントロールを切断<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />する<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />ための既定の実装を変更する場合は、メソッドをオーバーライドできます。 メソッドをオーバーライドし、単に実装を既存のメソッドに追加するだけの場合は、独自のコードを実行する前に基本メソッドを呼び出すことができます。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DisplayMode As WebPartDisplayMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DisplayMode { System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ get(); void set(System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web パーツ コントロールが含まれた Web ページのアクティブな表示モードを取得または設定します。</summary>
        <value>ページの表示モードを決定する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web パーツコントロールを含むページは、常にいくつかの表示モードのいずれかにあります。 表示モードの詳細については、「 [Web パーツページ表示モード](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)」を参照してください。  
  
 クラス<xref:System.Web.UI.WebControls.WebParts.WebPartManager>は、Web ページの表示モードを作成します。 コントロールは<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 、基本クラスを使用して、Web パーツコントロールを含むページで使用できる標準表示モードオブジェクトをいくつか作成します。 これらの標準表示モードについて<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>は、クラスの概要に関するページを参照してください。  
  
 コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager>は、Web パーツコントロールを使用するページの表示モードも管理します。 コントロールは<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 、プロパティを使用して、ページ上の現在の表示モードへの参照を保持します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> また、プロパティを使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>して、ページを異なる表示モードに切り替えることもできます。 Web パーツコントロールを使用するページで表示モードを変更する例について[は、「チュートリアル:Web パーツページ](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)での表示モードの変更  
  
 表示モード<xref:System.Web.UI.WebControls.WebParts.WebPartManager>の管理の一環として、コントロールには、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A>メソッドや<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>メソッドなどの表示モードに関連するイベントとイベントハンドラーも用意されています。 これらのメソッドは、ページの動作をカスタマイズするためのメカニズムを提供し、カスタム表示モードを追加するためにも使用できます。  
  
   
  
## Examples  
 次のコード例は、プログラムに<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>よるプロパティの使用方法を示しています。 ブラウザーにページを読み込むと、ページの下部付近にあるボタンを使用して表示モードを切り替えることができます。 ページは、読み込み時に既定でブラウズモードになります。 デザインモードに切り替えると、あるゾーンから別のゾーンにサーバーコントロールをドラッグしたり、1つのゾーン内に2つのコントロールを配置したりすることができます。 編集モードに切り替えると、いずれかのサーバーコントロールのヘッダーで動詞メニューをクリックし、**[編集]** を選択して、提供されている編集ユーザーインターフェイス (UI) を使用してコントロールを編集できます。  
  
> [!NOTE]
>  Web パーツアプリケーションでの表示モードの切り替えは非常に一般的であり、Web パーツコントロールを含むすべてのページで、一貫した再利用可能な方法でこの操作を行うことができます。 表示モードを変更し、多くのページで再利用できるユーザーコントロールの例については[、「チュートリアル:Web パーツページ](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)での表示モードの変更  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/CS/wpmgrDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/VB/wpmgrDisplayModevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">プロパティに割り当てられている <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> オブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">プロパティに割り当てられている <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> オブジェクトが、サポートされている表示モードではありません。  
  
- または - 
プロパティに割り当てられている <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> オブジェクトが無効です。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web パーツのページ表示モード</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">チュートリアル: Web パーツページでの表示モードの変更</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanged As WebPartDisplayModeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventHandler ^ DisplayModeChanged;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " Usage="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web パーツ ページ上の現在の表示モードが変更された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表示モードは Web パーツアプリケーションの不可欠な部分です。 ユーザーが Web ページで別の表示モードに切り替えた場合、新しい表示モードの目的によっては、ページの外観が大きく異なることがよくあります。 表示モードを変更した後、特定のコントロールの表示/非表示、選択した UI 要素の外観の変更など、ユーザーインターフェイス (UI) に特定の変更を加えることができます。  
  
> [!NOTE]
>  表示モードの詳細については、「 [Web パーツページ表示モード](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)」を参照してください。 イベントの使用方法の詳細につい[ては、「方法:Web フォームアプリケーション](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)でイベントを使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanging As WebPartDisplayModeCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventHandler ^ DisplayModeChanging;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " Usage="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上で別の表示モードに変更するプロセスを開始する動詞をユーザーがクリックした後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表示モードは Web パーツアプリケーションの不可欠な部分です。 ユーザーが Web ページで別の表示モードに切り替えた場合、新しい表示モードの目的によっては、ページの外観が大きく異なることがよくあります。 動詞をクリックして新しい表示モードに変更するプロセスをユーザーが開始した後で、 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A>プロパティを使用して新しい表示モードを決定し、さまざまな ui を変更することで、ユーザーインターフェイス (ui) に特定の変更を加えることができます。それに応じて要素を。 これを行う便利な方法は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>メソッドをオーバーライドして UI をカスタマイズすることです。  
  
> [!NOTE]
>  表示モードの詳細については、「 [Web パーツページ表示モード](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)」を参照してください。 イベントの使用方法の詳細につい[ては、「方法:Web フォームアプリケーション](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)でイベントを使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ DisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールに関連付けられたすべての表示モードの読み取り専用のコレクションを取得します。</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> コントロールに関連付けられた <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> オブジェクトのセットが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>は、現在のページで使用可能な表示モード<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> (サポートされている) のみを参照するプロパティとは対照的に、関連付けられているすべての表示モードを参照します。  
  
 指定された2つの表示モード (参照とデザイン) は、常にページでサポートされています。 他の3つの表示モード、編集、カタログ、および接続は、特定の表示モードが動作するために必要な対応する種類のゾーンがページにある場合にのみサポートされます。 たとえば、ページに<xref:System.Web.UI.WebControls.WebParts.EditorZone>ゾーンが含まれていない場合、編集表示モードは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>プロパティによって参照されるコレクションに表示されますが、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>プロパティによって参照されるコレクションには表示されません。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>プロパティのプログラムによる使用方法を示しています。 このコードでは、このプロパティを使用して、Web パーツコントロールセットで使用できるすべての表示モードをリストに設定します。現在のページではサポートされていないすべての表示モードを使用できます。 この場合、対応する必要なゾーンがページ上にないため、カタログと接続の表示モードはサポートされていません。  
  
 その他の3つの表示モード ([参照]、[デザイン]、[編集]) は、ページでサポートされています。 編集モードは、ページにゾーンが含ま<xref:System.Web.UI.WebControls.WebParts.EditorZone>れているのに対してサポートされていますが、ブラウズモードとデザインモードは常にサポートされています。  
  
 ブラウザーにページを読み込むと、ドロップダウンリストコントロールを使用して、ページをブラウズモードからデザインモードに切り替えてから編集モードに切り替えることができます。 編集モードでは、いずれかのサーバーコントロールのヘッダーのドロップダウン動詞メニューをクリックし、**[編集]** を選択してコントロールを編集することができます。 ドロップダウンリストで **[カタログ]** または **[接続]** を選択すると、エラーページが生成されます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/CS/wpmgrDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/VB/wpmgrDisplayModesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web パーツのページ表示モード</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">チュートリアル: Web パーツページでの表示モードの変更</related>
      </Docs>
    </Member>
    <Member MemberName="DynamicConnections">
      <MemberSignature Language="C#" Value="protected internal System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DynamicConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ DynamicConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在 Web ページ上に存在するすべての動的接続のコレクションを取得します。</summary>
        <value>ページ上のすべての動的接続への参照が格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的接続は、静的ではなく、プログラムによって作成される接続です。 静的接続は、Web フォームページのマークアップで宣言することによって作成されます。 動的接続は、プログラムによって、または接続ユーザーインターフェイス (UI) を使用して接続を作成するユーザーによって形成されます。  
  
 コレクション<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>は読み取り専用であり、内容を変更することはできませんが、は、各動的接続オブジェクトにプログラムでアクセスできるようにします。  
  
> [!NOTE]
>  コントロールの接続や<xref:System.Web.UI.WebControls.WebParts.WebPart>切断などの一般的な操作を実行するには、開発者は、接続を直接変更するのではなく、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスのパブリックメソッド ( <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>や<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>など) を使用する必要があります。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>コレクション内のオブジェクト。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="EditDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ EditDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>エンド ユーザーによるサーバー コントロールの編集および変更が可能な表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フィールド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールに<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>よって作成および格納されるカスタムオブジェクトを参照します。 これは静的オブジェクトであるため、コントロールのインスタンスを必要とせ<xref:System.Web.UI.WebControls.WebParts.WebPartManager>ずに、クラスを介して直接参照できます。  
  
 Web パーツコントロールを含むページが最初に読み込まれるとき、既定<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>では (ブラウズモード) になります。 ユーザーがサーバーコントロールを編集または変更する場合は、まずページを (編集<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>モード) に切り替える必要があります。 次に、編集する特定のサーバーコントロールを選択する必要があります。そのためには、そのコントロールのヘッダーの動詞メニューで [編集] 動詞をクリックします。 コントロールが編集モードになると、選択したコントロールを編集するための編集ユーザーインターフェイス (UI) が表示されます。  
  
 ページに対して編集モードを有効にするには、 <xref:System.Web.UI.WebControls.WebParts.EditorZone> <xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart>コントロールやカスタム編集コントロールなど、提供されている1つ以上の編集コントロールを含むゾーンがページに1つ以上含まれている必要があります。  
  
   
  
## Examples  
 次のコード例は、プログラムによって<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>フィールドを操作する方法を示しています。 このコードは、ページのサポートされている表示モードを含むドロップダウンリストを設定します。この例では、参照、デザイン、および編集です。 編集をサポートするため`<asp:EditorZone>`に、要素はページにあります。 `Page_PreRender`メソッドでは、現在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>のプロパティがに<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>設定されているかどうかがコードによってチェックされることに注意してください。 存在する場合は、 `Label1` が表示され、存在しない場合は非表示になります。`Label1`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/CS/wpmgrEditDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/VB/wpmgrEditDisplayModevb.aspx#1)]  
  
 ブラウザーにページを読み込むと、既定でブラウズモードになります。 ページのラベルが非表示になっていることに注意してください。 ドロップダウンリストコントロールを使用して、ページを編集モードに切り替えます。 `Page_PreRender`メソッドのコードが原因で、ラベルが表示されるようになったことに注意してください。 コントロールのいずれかの動詞メニューで **[編集]** 動詞をクリックして、その特定のコントロールの編集を有効にします。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web パーツのページ表示モード</related>
      </Docs>
    </Member>
    <Member MemberName="EnableClientScript">
      <MemberSignature Language="C#" Value="public virtual bool EnableClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableClientScript As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableClientScript { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableClientScript : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールが含まれた Web ページ上でクライアント側スクリプト機能を有効にするかどうかを決定する値を取得または設定します。</summary>
        <value>ページ上でクライアント スクリプトを実行できるかどうかを示すブール値。 既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A>は、開発者がクライアントスクリプトを無効にする方法を提供します。 セキュリティ上の目的でクライアントスクリプトを無効にしたり、異なるブラウザーを使用している場合でも、ページのすべてのユーザーが同様のユーザーエクスペリエンスを持つようにすることができます。  
  
 次の宣言型コード行に示す`EnableClientScript`ように、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Web ページの要素に属性を追加することによって、クライアントスクリプトを無効にすることができます。  
  
 `<asp:webpartmanager id="manager" runat="server"`  
  
 `EnableClientScript="false" />`  
  
 また、開発者は<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスを継承し、既定値をに設定することによって、このプロパティを削除する`false`こともできます。  
  
 Web パーツコントロールセットは、クライアントスクリプトを使用して、いくつかのクライアントユーザーインターフェイス (UI) とパーソナル化機能を提供します。 クライアントスクリプトを無効にしても、Web パーツコントロールは機能しますが、一部の機能は無効になります。 コントロールを異なるゾーンにドラッグできるかどうかは、コントロールのタイトルバーのドロップダウン動詞メニューで動詞をレンダリングする機能と共に使用できなくなります (動詞は、コントロールのタイトルバーにリンクとして表示されます)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableTheming : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上でテーマを使用できることを示す値を取得します。</summary>
        <value>テーマが有効かどうかを示す Boolean 値。 常に <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager>は基本<xref:System.Web.UI.Control.EnableTheming%2A>プロパティをオーバーライドして、常にの`true`値が返されるようにします。 これは、Web パーツコントロールセットでは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールの子コントロールであり、Web ページのユーザーインターフェイス (UI) を形成する Web パーツコントロールを表示するためにテーマを使用する必要があるためです。 たとえば、さまざまな種類のパーツコントロール ( <xref:System.Web.UI.WebControls.WebParts.Part>クラスを継承するコントロール)、ユーザーコントロール、ASP.NET サーバーコントロール、およびカスタムサーバーを含む、さまざまなゾーンと、ゾーン内に存在するコントロールを表示するためにテーマが使用されます。制限.  
  
 オーバーライド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>されたプロパティは、基本プロパティに従って読み取り/書き込みプロパティとして実装されますが、プロパティを設定することはできません。 `true`これは、デザイン上、常にの値を返す必要があるためです。 プロパティを設定しようとすると、 <xref:System.NotSupportedException>例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">プロパティ値を設定しようとしました。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartConnecting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartConnecting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartConnecting ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartConnecting();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartConnecting : unit -&gt; unit&#xA;override this.EndWebPartConnecting : unit -&gt; unit" Usage="webPartManager.EndWebPartConnecting " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>一方の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールをもう一方のコントロールに接続するプロセスを完了させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>は、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールを別のコントロールに接続するプロセスを終了します。 これは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>メソッドに相当します。  
  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>プロパティによって参照されるパーソナル化オブジェクトが変更可能であることを保証します。これは、接続を形成すること自体がパーソナル化の一種であるために必要です。 次に、メソッドは<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>オブジェクトがでない`null`ことを確認し、最後に<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> プロパティによって参照されるコントロールが <see langword="null" /> です。</exception>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />コントロールを拡張する必要がある開発者は、派生クラスでこのメソッドをオーバーライドすることが必要になる場合があります。 1つの方法として、基本メソッドを呼び出して、追加のカスタム処理を追加したり、コントロール間の接続を完了するプロセス全体を完全にカスタマイズしたりすることができます。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartEditing ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartEditing();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartEditing : unit -&gt; unit&#xA;override this.EndWebPartEditing : unit -&gt; unit" Usage="webPartManager.EndWebPartEditing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを編集するプロセスを完了させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>は、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールの編集プロセスを終了します。 これは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>メソッドに相当します。  
  
 メソッドは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>プロパティによって参照されるパーソナル化オブジェクトが変更可能であることを保証します。これは、コントロールの編集が、パーソナル化の変更を必要とするプロセスであるために必要です。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> 次に<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 、メソッドはオブジェクトがではない`null`ことを確認します<xref:System.Web.UI.WebControls.WebParts.WebPart> 。これにより、現在選択され<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>ているコントロールが変更できるようになり、最後にメソッドが呼び出されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> プロパティによって参照されるコントロールが <see langword="null" /> です。</exception>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />コントロールを拡張する必要がある開発者は、派生クラスでこのメソッドをオーバーライドすることが必要になる場合があります。 1つの方法として、基本メソッドを呼び出して、追加のカスタム処理を追加したり、コントロールの編集を完了するプロセス全体を完全にカスタマイズしたりすることができます。 たとえば、override メソッドでは、最初に基本メソッドを呼び出した後、変更内容を確認するコードを追加し、確認のために変更の一覧をエンドユーザーに対して表示します。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="ExportSensitiveDataWarning">
      <MemberSignature Language="C#" Value="public virtual string ExportSensitiveDataWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ExportSensitiveDataWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ExportSensitiveDataWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ExportSensitiveDataWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExportSensitiveDataWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーが <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールから重要な状態情報をエクスポートしようとしたときに表示される警告メッセージのテキストを取得または設定します。</summary>
        <value>警告メッセージが含まれた文字列。 既定のメッセージは、.NET Framework が提供するカルチャ固有の値です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーが<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールから機微な状態データをエクスポートしようとしたときに、エクスポートされているデータのいずれかが、ソースコードで機微とマークされているメンバーから取得された場合、メッセージボックスでユーザーに警告メッセージが表示され、機密データをエクスポートし、エクスポートをキャンセルする機会を提供します。 開発者は、メンバーの`isSensitive` `[Personalizable]`属性のパラメーターをに設定する`true`ことにより、特定のメンバーのデータを機密としてマークできます。 この属性とパラメーターの詳細については、 <xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute>クラスを参照してください。  
  
> [!IMPORTANT]
>  Web パーツのエクスポート機能を使用すると、機密データが承認されていないユーザーにエクスポートされる可能性があります。 この脅威から保護する方法の詳細については、「 [Web パーツページのセキュリティ](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)保護」を参照してください。  
  
 既定のメッセージは、ユーザーがエクスポートを試行するたびに表示されます。 ただし、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>プロパティに値を割り当てることによって、カスタム警告メッセージを指定できます。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>プロパティの宣言型の使用方法を示しています。  
  
 次の Web ページのコードでは、標準<xref:System.Web.UI.WebControls.BulletedList>コントロールを使用して、それをゾーンに配置します。 コントロールは、実行時に<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>コントロールによってラップされます。これにより、コントロールは実際<xref:System.Web.UI.WebControls.WebParts.WebPart>のコントロールとして機能します。 コントロールをエクスポート可能にするため`ExportMode`に、属性が`<asp:bulletedlist>`要素に追加され、属性値がに<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>設定されます。これは、機微なデータと機微でないデータの両方をエクスポートできることを意味します。 また、 `<asp:webpartmanager>`要素`ExportSensitiveDataWarning`には、属性にカスタム値が割り当てられていることにも注意してください。  
  
 コード例を使用するには、web.config ファイルにを追加して、Web パーツ記述ファイルをエクスポートできるようにする必要があることに注意してください。 このコード例の web ページと同じディレクトリに web.config ファイルがあることを確認します。 セクション内に、次のマークアップの`<webParts>`ように、 `enableExport`属性がに`true`設定された要素があることを確認します。 `<system.web>`  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/CS/wpmgrExportSensitiveWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/VB/wpmgrExportSensitiveWarningVB.aspx#1)]  
  
 ブラウザーにページを読み込んだ後、リンクを含むコントロールのタイトルバーにある動詞メニュー (下向きの矢印で表されます) をクリックします。 動詞メニューで **[エクスポート]** を選択すると、カスタム警告と共にメッセージボックスが表示されます。 エクスポートを続行する場合は、**[OK]** をクリックします。これにより、XML 記述ファイルのローカルコピーを、コントロールに関するすべてのデータと共に保存できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="ExportWebPart">
      <MemberSignature Language="C#" Value="public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExportWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExportWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit&#xA;override this.ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit" Usage="webPartManager.ExportWebPart (webPart, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="webPart">データのエクスポート元となるコントロール。</param>
        <param name="writer">エクスポートされたデータを <paramref name="webPart" /> から XML 記述ファイルに書き込む <see cref="T:System.Xml.XmlWriter" />。</param>
        <summary>サーバー コントロールの状態データとプロパティ データが格納された XML 記述ファイルを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>は、さまざまな状態およびプロパティデータ`webPart`をから XML ファイルにアセンブルします。 データには、そのアセンブリ、状態データ、プロパティデータなど、コントロール自体に関する情報が含まれます。 エクスポートを開始するユーザーは、ローカルコンピューターまたはネットワーク上のディスクに XML ファイルを保存できます。 その他のユーザーは、別のページまたは Web サイトに説明ファイルをインポートし、の別の`webPart`インスタンスに状態とプロパティデータを適用できます。 これにより、ユーザーがサーバーコントロールで設定を共有して再利用するための高速で便利な機構が提供されます。また、開発者は、エクスポートおよびインポートされたコントロールの外観と動作を制御することもできます。  
  
 の`webPart`プロパティは、既定ではエクスポートされません。 プロパティのエクスポートを有効にするには、ソースコードの`[Personalizable]`属性を使用してプロパティをマークする必要があります。 必要に応じて、 `isSensitive` `[Personalizable]`属性のパラメーターをに`true`設定して、エクスポート可能なプロパティを機密データを含むものとしてマークすることもできます。 既定では`isSensitive` 、 `false`はです。 開発者は、パラメーターを`true`に設定して、データが機密情報であることを示すことができます。  
  
 有効にする`webPart`開発者の設定をエクスポートするには、その<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>プロパティの値をいずれか<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>(を含む、すべてのパーソナル化できると機微なプロパティです、) または<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.NonSensitiveData>、機微なプロパティを除くすべてをエクスポートします。  
  
> [!IMPORTANT]
>  ユーザーがコントロールからデータをエクスポートしたり、データを他のコントロールにインポートできるようにしたりすると、セキュリティ上のリスクが生じます。 開発者は、上で説明した方法を使用して機密データを保護する必要があります。また、データを完全に公開`webPart`するリスクを回避する必要がある場合は、エクスポートをまったく有効にしないでください。 Web パーツのセキュリティの問題の詳細については、「 [Web パーツページのセキュリティ保護](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="writer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> が、<see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> で参照されるコントロールのコレクションに格納されていません。  
  
または 
<paramref name="webPart" /> の <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" /> プロパティが、<see cref="F:System.Web.UI.WebControls.WebParts.WebPartExportMode.None" /> の値に設定されています。これは、<paramref name="webPart" /> のエクスポートが無効になっていることを示します。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">Web パーツページのセキュリティ保護</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Focus();" />
      <MemberSignature Language="F#" Value="override this.Focus : unit -&gt; unit" Usage="webPartManager.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>オーバーライドして、ユーザー インターフェイス (UI) のない <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールにフォーカスが設定されるのを防ぎます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Focus%2A>は、基本<xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType>メソッドをオーバーライドし、呼び出し元がメソッドを呼び出した場合に例外をスローします。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールには UI がないため、ユーザーには表示されないため、フォーカスをそれ自体に設定することはできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出し元が、UI のないコントロールではサポートされていない <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" /> メソッドを呼び出そうとします。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumerConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ConsumerConnectionPointCollection ^ GetConsumerConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection&#xA;override this.GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" Usage="webPartManager.GetConsumerConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">接続でコンシューマーとして動作するサーバー コントロール。</param>
        <summary>Web パーツ接続内でコンシューマーとして動作するサーバー コントロールから、コネクション ポイントとして機能できる <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" /> オブジェクトのコレクションを取得します。</summary>
        <returns>コンシューマーのすべてのコネクション ポイントが格納された <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web パーツ接続には常に、データのプロバイダーとして機能する2つのコントロールが含まれ、もう1つはデータのコンシューマーとして機能します。 各コントロールには、コネクションポイントとして定義されている1つ以上のメソッドが必要です。 コンシューマーコントロールの場合、その接続ポイントは<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>オブジェクトです。 コンシューマー接続ポイントの取得は、Web パーツ接続を形成するために必要な手順です。  
  
 コンシューマーは、接続を確立するために、少なくとも1つのコネクションポイントを常に持っている必要があります。 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>は、コンシューマーコントロールを確認し、すべての接続ポイントのコレクションを取得します。 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールに接続ポイントがない場合、メソッドは空のコレクションを返します。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> メソッドの使用方法を示します。  
  
 このコード例には、次の4つの部分があります。  
  
-   Web パーツページの表示モードを変更できるユーザーコントロール。  
  
-   接続できる2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール`<asp:webpartmanager>`と要素を含む Web ページ。  
  
-   2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールとカスタムインターフェイスを含むソースコードファイル。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、 [「チュートリアル:Web パーツページ](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)での表示モードの変更  
  
 Web ページの宣言型マークアップに`Register`は、ユーザーコントロールとカスタムコントロールの両方に対するディレクティブが含まれています。 要素、カスタムコントロールを格納する要素、および要素があります。`<asp:connectionszone>` `<asp:webpartzone>` `<asp:webpartmanager>` `Page_Load`メソッドでは、接続が既に存在するかどうかをコードが確認し、存在しない場合はプロバイダー、コンシューマー、およびそれぞれの接続ポイントを定義し、次に、によって参照される静的接続のセットに新しい接続を追加します。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>プロパティ。 メソッドを<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>使用して取得されたオブジェクトをメソッドに渡して、2つのコントロール間の接続を作成できるかどうかを判断することに注意してください。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 この例の3番目の部分は、コントロールのソースコードです。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要の「例」セクションから、このコードとコンパイルの手順を取得できます。  
  
 ブラウザーに Web ページを読み込んだ後、**[表示モード]** ドロップダウンリストコントロールをクリックし、**[接続]** を選択してページを接続モードに切り替えます。 Connect モードでは`<asp:connectionszone>` 、要素を使用して、コントロール間の接続を作成できます。 接続モードで、**郵便番号**コントロールのタイトルバーにある下向きの矢印をクリックして動詞メニューをアクティブにし、**[接続]** をクリックします。 接続ユーザーインターフェイス (UI) が表示されたら、 `Page_Load`メソッドに含まれるコードによって接続が既に作成されていることを確認します。 後のブラウザーセッションでこのページに戻ると、この静的接続は既に確立されているので、ページを読み込むたびに再作成する必要はありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentWebPartManager">
      <MemberSignature Language="C#" Value="public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::WebControls::WebParts::WebPartManager ^ GetCurrentWebPartManager(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="static member GetCurrentWebPartManager : System.Web.UI.Page -&gt; System.Web.UI.WebControls.WebParts.WebPartManager" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> のインスタンスが含まれている Web ページ。</param>
        <summary>ページ上の <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールの現在のインスタンスへの参照を取得します。</summary>
        <returns>ページ上のコントロールの現在のインスタンスを参照する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、現在<xref:System.Web.UI.WebControls.WebParts.WebPartManager>のコントロールへの参照を取得するコンテキストで役立ちます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> この問題が発生する一般的なシナリオは、開発時に認識できないカスタムコントロールを作成する場合です。これ<xref:System.Web.UI.WebControls.WebParts.WebPartManager>は、ページ上のコントロールの ID がどのようになるかということです。  
  
> [!NOTE]
>  メソッドは静的であるため、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールのインスタンスを必要とせずに直接呼び出すことができます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>  
  
 コントロールなどの Web パーツコントロールセット<xref:System.Web.UI.WebControls.WebParts.WebPart>内の一部のコントロールには、現在<xref:System.Web.UI.WebControls.WebParts.WebPartManager>のコントロールへの参照を取得できる<xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A>プロパティがあります。 そのため、このようなコントロールを操作する場合は、このプロパティを使用して参照を取得する必要があります。  
  
 Web ページ内にインラインでコードを記述するなど、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールの id がわかっているコンテキストでコーディングする場合は、その id を使用して<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールを直接参照するのが最も簡単で効率的です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> メソッドの使用方法を示します。 この例には、カスタムサーバーコントロールと、コントロールをホストする Web ページの2つの部分があります。  
  
 カスタム<xref:System.Web.UI.WebControls.Label>コントロールは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>メソッドを使用して、現在の<xref:System.Web.UI.WebControls.WebParts.WebPartManager>ページ上のコントロールの id を取得し、id を表示します。  
  
 [!code-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/MyManagerIDLabel.cs#2)]
 [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/MyManagerIDLabel.vb#2)]  
  
 次のコード例では、 <xref:System.Web.UI.WebControls.WebParts.WebPartZone>ゾーン内のコントロールをホストする Web ページを提供します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/getCurrentWPManagerCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/getcurrentWPManagervb.aspx#1)]  
  
 ブラウザーにページを読み込むと、現在<xref:System.Web.UI.WebControls.WebParts.WebPartManager>のコントロールの ID がカスタム<xref:System.Web.UI.WebControls.Label>コントロール内に表示されていることがわかります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> は <see langword="null" />です。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="GetDisplayTitle">
      <MemberSignature Language="C#" Value="protected internal virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetDisplayTitle(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetDisplayTitle(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string&#xA;override this.GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetDisplayTitle webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">このメソッドが <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> の値を返す対象となるコントロール。</param>
        <summary><see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> コントロールの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> プロパティの値が含まれた文字列を取得します。</summary>
        <returns><paramref name="webPart" /> の <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> の計算された値が格納される文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A> の`webPart`プロパティの計算値を取得します。 開発者が<xref:System.Web.UI.WebControls.WebParts.Part.Title%2A> <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールのプロパティに値を割り当てない場合、このメソッドはタイトルとして表示する値を生成します。 無題のコントロールの計算値は、文字列に付加された数字で構成され、現在のゾーン内のコントロールのシーケンスを示す数値で構成されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> が <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コレクション内にありません。</exception>
        <block subset="none" type="overrides"><para>このメソッドをオーバーライドすると、既定の表示タイトルの計算方法を変更できます。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />
      </Docs>
    </Member>
    <Member MemberName="GetExportUrl">
      <MemberSignature Language="C#" Value="public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetExportUrl(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetExportUrl(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.GetExportUrl : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetExportUrl webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">エクスポートされる <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</param>
        <summary>ユーザーが <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールをエクスポートしようとするときの要求に含まれる相対仮想パスとクエリ文字列を取得します。</summary>
        <returns>コントロールのエクスポート要求を構成する相対仮想パスとクエリ文字列が含まれた文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A>メソッドによって返される値は、コントロールを含むページのサーバーの場所への相対仮想パスと、サーバーに送信されるエクスポート要求を形成するクエリ文字列値が追加されたものです。 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A>は、悪意のあるスクリプトによる攻撃から保護するために、要求の送信を許可する前に文字列をエンコードします。  
  
> [!NOTE]
>  Web パーツアプリケーションのセキュリティ保護の詳細については、「 [Web パーツページのセキュリティ保護](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::GenericWebPart ^ GetGenericWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetGenericWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.GetGenericWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 内に存在し、実行時に <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> の子コントロールとしてラップされるサーバー コントロール。</param>
        <summary>サーバー コントロールが含まれた <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> コントロールのインスタンスへの参照を取得します。</summary>
        <returns><paramref name="control" /> を子コントロールとしてラップする <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />。 このメソッドは、<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> に <paramref name="control" /> が含まれていない場合は <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般に、開発者が Web パーツアプリケーションに参加するための<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーンに配置するコントロールには<xref:System.Web.UI.WebControls.WebParts.WebPart> 、 <xref:System.Web.UI.WebControls.WebParts.WebPart>基本クラスを継承するコントロールと、標準として使用できるその他のサーバーコントロールの2つのカテゴリがあります。ASP.NET コントロール、カスタムコントロール、またはユーザーコントロール。 これらのコントロールのいずれかが<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーンに配置されると、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールの機能が利用されます。 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールには本質的にこの機能がありますが、他の種類のサーバーコントロールにはありません。 他のサーバーコントロールが<xref:System.Web.UI.WebControls.WebParts.WebPart> <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーンに配置されたときにコントロールとして機能するようにするに<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>は、ASP.NET はコントロールでそれらをラップします。 コントロールは<xref:System.Web.UI.WebControls.WebParts.GenericWebPart> <xref:System.Web.UI.WebControls.WebParts.WebPart>クラスから直接継承されるので、子コントロールに真の Web パーツ機能が提供されます。  
  
 多くの場合、ページ開発者は、ゾーン内のいずれかの<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>サーバーコントロールを含むコントロールへの参照を取得する必要があります。 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>は、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart>コントロールへの参照を取得できるようにします。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>メソッドの使用方法を示しています。 このコード例には<xref:System.Web.UI.WebControls.Calendar> 、 <xref:System.Web.UI.WebControls.WebParts.WebPartZone>ゾーン内で宣言されたコントロールが含まれています。 メソッド`Button1_Click`は、まず<xref:System.Web.UI.WebControls.Calendar>コントロールの ID をラベルに出力し、次に<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>メソッドを使用して、カレンダーをラップ<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>するコントロールへの参照を取得します。 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart>コントロールの id と子コントロール ( <xref:System.Web.UI.WebControls.Calendar>コントロール) の id は両方とも2番目のラベルに印刷されます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/CS/getGenericWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/VB/getGenericWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="GetProviderConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ProviderConnectionPointCollection ^ GetProviderConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection&#xA;override this.GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" Usage="webPartManager.GetProviderConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">接続でプロバイダーとして動作するサーバー コントロール。</param>
        <summary>Web パーツ接続内でプロバイダーとして動作するサーバー コントロールから、コネクション ポイントとして機能できる <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" /> オブジェクトのコレクションを取得します。</summary>
        <returns>プロバイダーのすべてのコネクション ポイントが格納された <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web パーツ接続には常に、データのプロバイダーとして機能する2つのコントロールが含まれ、もう1つはデータのコンシューマーとして機能します。 各コントロールには、コネクションポイントとして定義されている1つ以上のメソッドが必要です。 プロバイダーコントロールの場合、そのコネクションポイントは<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>オブジェクトです。  
  
 接続を確立するには、プロバイダーに少なくとも1つのコネクションポイントが必要です。 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>は、プロバイダーコントロールを確認し、すべての接続ポイントのコレクションを取得します。 プロバイダー接続ポイントの取得は、Web パーツ接続を形成するために必要な手順です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> メソッドの使用方法を示します。  
  
 この例には、次の4つの部分があります。  
  
-   Web パーツページの表示モードを変更できるユーザーコントロール。  
  
-   接続できる2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール`<asp:webpartmanager>`と要素を含む Web ページ。  
  
-   2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールとカスタムインターフェイスを含むソースコードファイル。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、 [「チュートリアル:Web パーツページ](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)での表示モードの変更  
  
 Web ページの宣言型マークアップに`Register`は、ユーザーコントロールとカスタムコントロールの両方に対するディレクティブが含まれています。 要素、カスタムコントロールを格納する要素、および要素があります。`<asp:connectionszone>` `<asp:webpartzone>` `<asp:webpartmanager>` `Page_Load`メソッドでは、接続が既に存在するかどうかをコードが確認し、存在しない場合はプロバイダー、コンシューマー、およびそれぞれの接続ポイントを定義し、次に、によって参照される静的接続のセットに新しい接続を追加します。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>プロパティ。 メソッドを<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>使用して取得されたオブジェクトをメソッドに渡して、2つのコントロール間の接続を作成できるかどうかを判断することに注意してください。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 この例の3番目の部分は、コントロールのソースコードです。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要の「例」セクションから、このコードとコンパイルの手順を取得できます。  
  
 ブラウザーに Web ページを読み込んだ後、**[表示モード]** ドロップダウンリストコントロールをクリックし、**[接続]** を選択してページを接続モードに切り替えます。 Connect モードでは`<asp:connectionszone>` 、要素を使用して、コントロール間の接続を作成できます。 接続モードで、**郵便番号**コントロールのタイトルバーにある下向きの矢印をクリックして動詞メニューをアクティブにし、**[接続]** をクリックします。 接続ユーザーインターフェイス (UI) が表示されたら、 `Page_Load`メソッドに含まれるコードによって接続が既に作成されていることを確認します。 後のブラウザーセッションでこのページに戻ると、この静的接続は既に確立されているので、ページを読み込むたびに再作成する必要はありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="ImportWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart ImportWebPart(class System.Xml.XmlReader reader, [out] string&amp; errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportWebPart (reader As XmlReader, ByRef errorMessage As String) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ ImportWebPart(System::Xml::XmlReader ^ reader, [Runtime::InteropServices::Out] System::String ^ % errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member ImportWebPart : System.Xml.XmlReader * string -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.ImportWebPart : System.Xml.XmlReader * string -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.ImportWebPart (reader, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="errorMessage" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="reader">インポート元となる XML 記述ファイルから状態データとプロパティ データを読み取る <see cref="T:System.Xml.XmlReader" />。</param>
        <param name="errorMessage">インポート中にエラーが発生した場合にユーザーに表示される <see cref="T:System.String" />。</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールの状態データとプロパティ データが格納された XML 記述ファイルをインポートし、コントロールにそのデータを適用します。</summary>
        <returns>インポート元となる XML 記述ファイルで参照される <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (または、<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> でラップされ、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> として扱われるサーバー コントロール)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>は、サーバーコントロールの<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>メソッドによって作成された XML 記述ファイルをインポートします。 これはインポートされる実際のサーバーコントロールではなく、コントロールに関する状態とプロパティデータを含む記述ファイルのみです。 説明ファイルで参照されているコントロールとアセンブリは、ユーザーが説明ファイルをインポートしようとしたサーバーで既に使用可能である必要があります。  
  
 コントロールのインポートを有効にするには、インポートが<xref:System.Web.UI.WebControls.WebParts.CatalogZone>有効になるページにコントロールを追加する必要があります。 ゾーン内で、 <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>コントロールを追加する必要があります。 このコントロールには、ユーザーがインポートする説明ファイルを参照および検索できるようにするファイルダイアログボックスが用意されています。  
  
 ユーザーが記述ファイルを見つけてインポートを開始すると、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>メソッドによって説明ファイルが読み取られます。 エラーが発生せず、アセンブリとコントロールが見つかった場合は、サーバーコントロールが<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>コントロール内のカタログに追加され、説明ファイルに指定されているさまざまなプロパティと状態データがコントロールに適用されます。 ユーザーはコントロールを選択し、ページに追加できます。  
  
> [!IMPORTANT]
>  メソッドと同様に、メソッドにはセキュリティ上のリスクの可能性があります。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> Web サイトにデータをインポートする必要があるため、悪意のあるユーザーが、インポートされた説明ファイルに不適切なデータを挿入したり、スクリプトコードを記述したりする可能性があります。 その場合、不適切なデータがページまたはデータベースに表示されるか、または挿入されたスクリプトが実行される可能性があります。 説明ファイルのインポートに関連する潜在的なリスクの概要と、それらのリスクを回避する方法については、「 [Web パーツページのセキュリティ保護](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.EndOfStreamException"><paramref name="reader" /> はこのファイルを読み取ることができませんでした。  
  
- または - 
 <paramref name="reader" /> は、インポート エラー メッセージを表示する必要がありましたが、ファイル内にそれが見つかりませんでした。  
  
- または - 
 <paramref name="reader" /> はファイルの末尾に到達しましたが、エクスポート データが格納された XML 要素が見つかりませんでした。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ImportCatalogPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">Web パーツページのセキュリティ保護</related>
      </Docs>
    </Member>
    <Member MemberName="Internals">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Internals As WebPartManagerInternals" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ Internals { System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Internals : System.Web.UI.WebControls.WebParts.WebPartManagerInternals" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManagerInternals</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>実際には <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> クラスに実装されていても、ほとんどの場合コントロールの開発者に役立つメソッドのセットを構成したり分割したりするために使用する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスへの参照を取得します。</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> が、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> に分割されたさまざまなメソッドを参照できる、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>は、主に拡張機能のケースで使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>されるメソッドのセットを呼び出すための api を公開します。  
  
 これらの内部メソッドを使用するように設計された方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>は、プロパティを使用してアクセスすることです。 プロパティは保護されているので、 <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスから継承することによって、クラスのインスタンス内でのみアクセスし、メソッドを呼び出すことができます。  
  
> [!NOTE]
>  このプロパティは、の IntelliSense で[!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]は非表示になります。 ただし、派生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスでは、プロパティとそのさまざまなメンバーに引き続きアクセスできます。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAuthorized">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールをページに追加できるかどうかを判断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web パーツ機能の柔軟性の一部として、実行時にサーバーコントロールを Web ページに追加する機能があります。 サーバーコントロール (カスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、カスタムサーバーコントロール、ユーザーコントロール、または ASP.NET コントロール) は、いくつかの一般的なシナリオで追加することができます。  
  
 次の一般的なシナリオでは、Web パーツコントロールセットは、サーバーコントロールをページに追加しよう<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>とし、メソッドを呼び出して承認します。  
  
-   サーバーコントロールを追加するときに、 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーン内の Web ページのマークアップでサーバーコントロールを宣言します。  
  
-   サーバーコントロールがプログラムによってゾーンに追加されたとき。  
  
-   ユーザーがコントロールの Web パーツカタログにサーバーコントロールをインポートするとき。  
  
-   既存のサーバーコントロールがパーソナル化データストアから読み込まれたとき。  
  
-   サーバーコントロールを<xref:System.Web.UI.WebControls.WebParts.DeclarativeCatalogPart>コントロールに追加して、サーバーコントロールのカタログで使用できるようにする場合。  
  
 コントロールが追加<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>される各シナリオでは、メソッドを呼び出して、すべての承認条件が満たされていることを確認し、コントロールを追加できるようにします。 コントロールが承認されると、フィルター処理のシナリオが存在しない場合と同様に、通常どおりに追加されます。 コントロールが承認されていない場合、Web パーツコントロールセットは、コンテキストに応じていくつかの方法で応答できます。 コントロールセットは、許可されていない部分の追加 (ユーザーに通知する必要がない場合)、エラーメッセージの表示、または<xref:System.Web.UI.WebControls.WebParts.UnauthorizedWebPart>クラスのインスタンスのプレースホルダーとしての追加をサイレントに失敗させることができます。 このプレースホルダーオブジェクトはページには表示されませんが、承認されていないコントロールが除外されたことを示すためにページソースコードに表示されます。  
  
 コントロールが承認されているかどうかの決定は、承認フィルターです。 承認フィルターは、Web パーツコントロールセットの機能です。この機能を使用すると、開発者は、指定した条件を満たしていないコントロールをページから除外できます。  
  
 フィルター処理のシナリオを作成するには、開発者が2つの作業を行う必要があります。 まず、シナリオで使用する各<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールのプロパティに、文字列値 (値は任意) を割り当てる必要があります。 また、コントロールではない<xref:System.Web.UI.WebControls.WebParts.WebPart>他の種類のサーバーコントロールに対して、このプロパティに値を割り当てることもできます。これは、コントロールがゾーンに<xref:System.Web.UI.WebControls.WebParts.GenericWebPart> <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>配置されている場合、コントロールが実行時にコントロールとしてラップされ、このコントロールはを継承するためです。<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティ。  
  
 フィルター処理のシナリオを作成するために必要な2番目<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>の手順は、メソッドをオーバーライドするか、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>イベントのイベントハンドラーを作成することです。 これらのメソッドでは、開発者は<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティを確認できます`false`。また、コントロールが承認されていないことが値に<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>よって示されている場合は、メソッドが値を返すことを保証します。  
  
> [!NOTE]
>  コード例と、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>メソッドを使用してカスタマイズされたフィルター処理シナリオを設定する方法の説明については、メソッドのオーバーロードに関するトピックを参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAuthorized(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAuthorized(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.IsAuthorized : System.Web.UI.WebControls.WebParts.WebPart -&gt; bool" Usage="webPartManager.IsAuthorized webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">承認をチェックする対象の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロール。</param>
        <summary>ページへのコントロールの追加が承認されているかどうかを判断する最初の手順を実行します。</summary>
        <returns><paramref name="webPart" /> をページに追加できるかどうかを示すブール値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールの承認を確認するために Web パーツコントロールセットによって呼び出される最初のメソッドです。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> これは`webPart` 、パラメーターとしてを受け入れ、コントロールがページに追加されるかどうかを最終的に判断するプロセスを開始します。 特定のコントロールが承認されているかどうかを判断する必要がある場合は、コードからこのメソッドを直接呼び出します。  
  
 このメソッドは、コントロールが<xref:System.Web.UI.WebControls.WebParts.WebPart>クラスから継承<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>されているかどうかを判断する最初のタスクを実行します。また、コントロールである場合は、それに含まれる子コントロールの種類を決定します。 承認のタスクを完了するには、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>オーバーロードメソッドを呼び出します。  
  
   
  
## Examples  
 次のコード例では、コードから<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29>メソッドを呼び出して、コントロールがページに追加されることが許可されているかどうかを判断する方法を示します。  
  
 このコード例には、次の3つの部分があります。  
  
-   メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>を<xref:System.Web.UI.WebControls.WebParts.WebPartManager>オーバーライドするカスタムコントロール。  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールのフィルターを作成する Web ページ。  
  
-   コード例を実行する方法について説明します。  
  
 このコード例では、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>オーバーロードメソッドをオーバーライドするカスタムコントロールを使用して、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティのカスタム処理を提供します。 このコントロールは、の`admin`プロパティ値を確認し、値が存在する場合はコントロールを承認します。 別の値を持つコントロールは許可されていません。プロパティ値のないコントロールも、フィルター処理のシナリオに含まれないと見なされるため、承認されます。  
  
 このコード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 このコード例では、動的コンパイルメソッドを使用します。 のコンパイル方法を示すチュートリアルについては[、「チュートリアル:カスタム Web サーバーコントロール](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)の開発と使用  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 コード例の2番目の部分では、コントロールを除外する可能性があるフィルターを作成します。 次の Web ページには、 `<asp:webpartzone>`要素内の3つの ASP.NET サーバーコントロールが含まれています。 1番目と2番目のコントロール<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>のプロパティがそれぞれ異なる値に設定されており、3番目のコントロールではプロパティが割り当てられていないことに注意してください。 この承認値は実行時に確認でき、フィルターが開発者によって設定された条件に一致する場合は、コントロールをページに追加できます。 また、 `Page_Load`メソッドでは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29>メソッドを呼び出して、各コントロールが承認されているかどうかを判断し、その場合は各コントロール<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>のプロパティを設定します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 コード例を使用するには、web.config ファイルに設定を追加して、Web パーツ記述ファイルのエクスポートを有効にする必要があることに注意してください。 このコード例の web ページと同じディレクトリに web.config ファイルがあることを確認します。 セクション内に、次のマークアップの`<webParts>`ように、 `enableExport`属性がに`true`設定された要素があることを確認します。 `<system.web>`  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 ブラウザーでページを読み込んだ後、最初のコントロールが表示されていることに注意してください。これは、オーバーライドされたメソッドの条件と一致するためです。 2番目のコントロールは、フィルターによって除外されるため、ページには追加されません。 3番目のコントロールも追加されます。これは<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 、プロパティが設定されていないためです。 いずれかのコントロールのタイトルバーで [動詞] メニューアイコンをクリックすると、それぞれ<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>のプロパティ値が割り当てられているため、両方をエクスポートできます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> は <see langword="null" />です。</exception>
        <block subset="none" type="usage"><para>このメソッドは、コードから直接呼び出されます。 承認プロセスをプログラムによって制御できるようにする場合は、 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />オーバーロードメソッドをオーバーライドできます。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAuthorized(class System.Type type, string path, string authorizationFilter, bool isShared) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAuthorized(Type ^ type, System::String ^ path, System::String ^ authorizationFilter, bool isShared);" />
      <MemberSignature Language="F#" Value="abstract member IsAuthorized : Type * string * string * bool -&gt; bool&#xA;override this.IsAuthorized : Type * string * string * bool -&gt; bool" Usage="webPartManager.IsAuthorized (type, path, authorizationFilter, isShared)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="authorizationFilter" Type="System.String" />
        <Parameter Name="isShared" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">承認されているかどうかを確認するコントロールの <see cref="T:System.Type" />。</param>
        <param name="path">コントロールがユーザー コントロールの場合は、承認されるコントロールのソース ファイルへの相対アプリケーション パス。</param>
        <param name="authorizationFilter">コントロールをページに追加できるかどうかを判断して承認するために使用される、<see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" /> コントロールの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> プロパティに割り当てる任意の文字列値。</param>
        <param name="isShared">承認されているかどうかを確認するコントロールが共有コントロール (つまり、アプリケーションの多くのユーザーまたはすべてのユーザーに対して表示され、その <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" /> プロパティ値が <see langword="true" /> に設定されている) かどうかを示します。</param>
        <summary>ページへのコントロールの追加が承認されているかどうかを判断する最後の手順を実行します。</summary>
        <returns>ページへのコントロールの追加が承認されるかどうかを示すブール値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オーバーロード<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>メソッドは、コントロールがページに追加されることが承認されているかどうかを判断する最後の手順を実行します。 メソッドは、が`type`有効な型であること、 `path`およびチェックされるコントロールがユーザーコントロールである場合にのみ値を持つことを保証します。 次に、クリティカル<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>メソッドを呼び出します。これにより、イベントが<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>発生します。  
  
   
  
## Examples  
 次のコード例では、メソッドを<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>オーバーライドして、コントロールがページに追加されることが許可されているかどうかを判断する方法を示します。  
  
 最初の手順では、コントロールを除外する可能性があるフィルターを作成します。 次の Web ページには、 `<asp:webpartzone>`要素内の3つの ASP.NET サーバーコントロールが含まれています。 1番目と2番目のコントロール<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>のプロパティがそれぞれ異なる値に設定されており、3番目のコントロールではプロパティが割り当てられていないことに注意してください。 この承認値は実行時に確認でき、フィルターが開発者によって設定された条件に一致する場合は、コントロールをページに追加できます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 2番目の手順では<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 、メソッドをオーバーライドし、承認フィルターのカスタム処理を作成します。 このコードでは、プロパティが割り当てら<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>れていないコントロールが自動的に追加されるように、プロパティに値があるかどうかを最初に確認することに注意してください。 コントロールにフィルターがある場合、コードはフィルター `true`値がと等しい場合に`admin`のみを返します。 これは、ロールに応じて特定のユーザーに特定のコントロールを表示するために使用できる単純なメカニズムを示しています。 ロールを使用する完全な例はこのトピックでは扱いませんが、このコード例ではオーバーライドされたメソッドと同じロジックを使用できます。ただし、現在のユーザーが承認フィルターの値と一致するロールに存在するかどうかを確認できます。 をクリックし、そのユーザーに対してのみコントロールを追加します。 これにより、一部のユーザーがすべてのコントロールを表示するページを作成できるようになります。また、他のユーザーには選択したコントロールのみが表示されます。 これは、フィルターをチェックするロジックが、ロールを使用したかどうかを確認するためのものです。  
  
```vb  
If Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  
  return True  
Else  
  return False  
End If  
```  
  
```csharp  
if(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  
    return true;  
else  
    return false;  
```  
  
 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 このコード例では、動的コンパイルメソッドを使用します。 のコンパイル方法を示すチュートリアルについては[、「チュートリアル:カスタム Web サーバーコントロール](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)の開発と使用  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 ブラウザーでページを読み込んだ後、最初のコントロールが表示されていることに注意してください。これは、オーバーライドされたメソッドの条件と一致するためです。 2番目のコントロールは、フィルター値が除外されているため、ページに追加されません。 3番目のコントロールが追加されます。これ<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>は、プロパティが設定されていないためです。 2番目のコントロールのプロパティ値を、最初のコントロールと一致するように変更した後、もう一度ページを実行すると、2番目のコントロールも追加されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> がユーザー コントロールで、<paramref name="path" /> が <see langword="null" /> または空の文字列 ("") のいずれかです。  
  
- または - 
 <paramref name="type" /> がユーザー コントロール以外で、<paramref name="path" /> に値が割り当てられています。</exception>
        <block subset="none" type="overrides"><para>このメソッドは、承認を確認するとき<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />に追加の処理を行う場合に、クラスから継承することによってオーバーライドできます。 メソッドをオーバーライドして<paramref name="authorizationFilter" />パラメーター内の特定の値を確認し、値に基づいてコントロールをページに追加するかどうかを決定するブール値を返すことができます。  
  
承認フィルターを確認し、カスタム処理を提供するページ開発者に対しては、.aspx ページまたは分離コードファイルでこのインラインを実行するオプションがあります。クラスを継承する必要はありません。 ページで、 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />コントロールのメソッドの代替イベントハンドラーを宣言できます。 詳細と例については、 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />メソッドを参照してください。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomPersonalizationStateDirty">
      <MemberSignature Language="C#" Value="protected virtual bool IsCustomPersonalizationStateDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsCustomPersonalizationStateDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsCustomPersonalizationStateDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomPersonalizationStateDirty : bool" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールにより制御されるページ レベルのパーソナル化の情報に影響を与えるような、パーソナル化に関する変更が行われたかどうかを示す値を取得します。</summary>
        <value>パーソナル化に関する変更が行われたかどうかを示すブール値。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager>は、プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>を内部的に使用して、管理対象のページレベルのパーソナル化データが変更されたかどうかを追跡します。 パーソナル化データは、コントロールの追加や削除<xref:System.Web.UI.WebControls.WebParts.WebPart> 、コントロールの接続や切断、コントロールの移動によるページのレイアウトの変更など、さまざまなパーソナル化操作をユーザーがページレベルで実行するときに変更されます。  
  
> [!NOTE]
>  ユーザーは、コントロールレベルで個人用設定を実行することもできます。つまり、特定のコントロールに個人用設定の変更が加えられ、変更はそのコントロールにのみ影響します。 たとえば、コントロールを編集したり、タイトルのテキストや背景色を変更したりします。 コントロールレベルのパーソナル化は、コントロールによって<xref:System.Web.UI.WebControls.WebParts.WebPartManager>追跡されるページレベルのパーソナル化データには影響しません。そのため、コントロールレベルのパーソナル化が発生した場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>プロパティ値はに`true`変更されません。  
  
 メソッドは保護されていて、呼び出し元が直接アクセスする<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>ことはできませんが、プロパティには呼び出し元が直接アクセスでき、このプロパティの値が返されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationState.IsDirty" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationState.SetDirty" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal override void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void LoadControlState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="override this.LoadControlState : obj -&gt; unit" Usage="webPartManager.LoadControlState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">読み込む対象となる永続的な状態データを格納します。</param>
        <summary>前回のページ要求で保存され、後続の要求で復元する必要のある、コントロールの状態データを読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、 <xref:System.Web.UI.Control.EnableViewState%2A>プロパティがに`false`設定されている場合でも、ページのポストバック間で永続化する必要があるプロパティデータを復元する場合に便利です。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="savedState" /> は有効な <see cref="P:System.Web.UI.PageStatePersister.ControlState" /> ではありません。</exception>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.LoadCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">読み込む状態データを含む <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />。</param>
        <summary>初期化プロセス中に後で使用するためにパーソナル化オブジェクトによって <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールに渡されたカスタムのパーソナル化データを格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A>は、保存された状態データを<xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary>オブジェクトの形式で提供します。 このデータは、Web パーツコントロールにパーソナル化データを読み込み、その他の初期化タスクを実行するために最終的に使用されます。  
  
> [!NOTE]
>  このメソッドは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A>メソッドが、関連付けられ<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>たオブジェクトを最初に要求して<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールにパーソナル化データを提供するときに開始されるメソッドのシーケンスによって呼び出されます。  
  
 このメソッドをコードから直接呼び出すことはできません。 ただし、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>メソッドを直接呼び出すこともできます。それ自体が<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A>メソッドを呼び出し、パーソナル化データを返します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>開発者は、 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスのメソッドをオーバーライドできます。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="MediumPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MediumPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MediumPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MediumPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MediumPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MediumPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Security.PermissionSet" /> および <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> のアクセス許可のみを付与する <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> オブジェクトを取得します。</summary>
        <value><see cref="T:System.Security.PermissionSet" /> および <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> のアクセス許可のみを付与する <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この<xref:System.Security.PermissionSet>プロパティによって返されるオブジェクトは、型の逆シリアル化のインポート中に使用されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimalPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MinimalPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MinimalPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MinimalPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimalPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Security.PermissionSet" /> および <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> のアクセス許可のみを付与する <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> オブジェクトを取得します。</summary>
        <value><see cref="T:System.Security.PermissionSet" /> および <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> のアクセス許可のみを付与する <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> オブジェクトを取得します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この<xref:System.Security.PermissionSet>プロパティによって返されるオブジェクトは、型の逆シリアル化以外のすべてのインポート中に使用されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveWebPart">
      <MemberSignature Language="C#" Value="public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="abstract member MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit&#xA;override this.MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit" Usage="webPartManager.MoveWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">移動される <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはその他のサーバー コントロール。</param>
        <param name="zone"><paramref name="webPart" /> の移動先の <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</param>
        <param name="zoneIndex"><paramref name="webPart" /> 内の他のコントロールに対する <paramref name="zone" /> の相対インデックスを示す整数。</param>
        <summary>1 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーンから別のゾーンまたは同じゾーン内の新しい位置に、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> コントロールまたはサーバー コントロールを移動します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager>は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>メソッドを使用し`webPart`て、同じゾーン内または別のゾーン内の新しい場所に移動します。 このメソッドは、コードから直接呼び出すことができます。また、ユーザーが Web パーツユーザーインターフェイス (UI) のさまざまなオプションを使用してコントロールを新しい位置に移動したときにも呼び出されます。  
  
 を移動する前に`webPart` 、いくつかの条件を満たす必要があります。これらのほとんどは、このトピックの「例外」セクションに記載されている項目によって示されています。 が`webPart` ゾーン<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>に含まれていない場合は、ゾーンに移動できません。  
  
 条件が満たされたら、次の一連の操作を移動`webPart`します。  
  
1.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> イベントを発生させます。  
  
2.  `webPart`は現在のゾーンから削除され (必要に応じて)、新しいゾーンまたは現在のゾーン内の新しい位置に追加されます。  
  
3.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> イベントを発生させます。  
  
4.  移動`zoneIndex`元と<xref:System.Web.UI.WebControls.WebParts.WebPart>移動先の両方のゾーンのすべてのコントロールのは、移動したコントロールを反映するようにリセットされます。  
  
   
  
## Examples  
 次のコード例は、コードからメソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>を直接呼び出して、あるゾーン<xref:System.Web.UI.WebControls.WebParts.WebPart>から別のゾーンにコントロールを移動する方法を示しています。  
  
 このコード例には、次の3つの部分があります。  
  
-   表示モードを変更するためのユーザーコントロール。  
  
-   コントロールをホストする Web ページ。  
  
-   コード例を実行する方法について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、 [「チュートリアル:Web パーツページ](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)での表示モードの変更  
  
 この例の2番目の部分は、2つのゾーンを含む Web ページで、それぞれに2つのサーバーコントロールが含まれています。 ユーザーがページの **[WebPart を移動]** ボタンをクリックすると、 `Button1_Click`メソッドのコードによって、最初のゾーンから2番目のゾーンの新しい位置にコントロールが移動します。 まず、コードが<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>メソッドを呼び出して、 `list1`コントロールをラップ<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>するオブジェクトを取得する必要があることに注意してください。 これが必要なのは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>メソッドの最初のパラメーターには<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール`list1`が必要であるのに対し、は ASP.NET サーバーコントロールであるためです。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/CS/MoveWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/VB/MoveWebPartVB.aspx#1)]  
  
 ページが読み込まれたら、**[WebPart WebPart]** ボタンをクリックします。リンクを含むコントロールが2番目のゾーンの中央の位置に移動することに注意してください。 このコントロールの移動は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>メソッドを呼び出すことによってプログラムによって行われます。 **[表示モード]** ドロップダウンリストコントロールを使用して、ページをデザインモードに切り替えることもできます。デザインモードでは、コントロールを別のゾーンやゾーン内の別の位置にドラッグすることができます。 このメソッドは、このような<xref:System.Web.UI.WebControls.WebParts.WebPartManager>ユーザーが開始した移動を処理するために、コントロールによって呼び出されることもあります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> が、<see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コントロールの <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コレクションに格納されていません。  
  
または 
 <paramref name="zone" /> が、<see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" /> コントロールの <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コレクションに格納されていません。  
  
- または - 
<paramref name="webPart" /> コントロールの <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.Zone" /> プロパティで参照されるゾーンが <see langword="null" /> です。つまり、現在 <paramref name="webPart" /> がゾーン内にありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> または <paramref name="zone" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="zoneIndex" /> が 0 未満です。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnAuthorizeWebPart">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorizeWebPart(class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAuthorizeWebPart (e As WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthorizeWebPart(System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit&#xA;override this.OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit" Usage="webPartManager.OnAuthorizeWebPart e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" /> イベントを発生させ、イベントのハンドラーが存在する場合はそれを呼び出します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールがページ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>に追加されるかどうかを確認するときに、メソッドによって呼び出されます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> メソッドが呼び出されると、イベントが<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>発生し、イベントのハンドラーメソッドがある場合はハンドラーが呼び出されます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>  
  
 コントロールを承認<xref:System.Web.UI.WebControls.WebParts.WebPart>するプロセスは、重要な Web パーツ機能です。 コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager>によってゾーンに追加されたすべて<xref:System.Web.UI.WebControls.WebParts.WebPart>のまたはサーバーコントロールは、コントロールを追加できるかどうかを判断するために承認プロセスを通過します。 既定では、Web パーツコントロールセットは、コントロールがゾーンに追加されないようにするためのフィルター選択条件を提供しません。 ただし、コントロールセットには、開発者が独自のフィルター条件を作成するために必要なメカニズムが用意されています。 これらのメカニズムを使用すると、カスタムのフィルター処理シナリオを作成できます。 たとえば、フィルターを作成すると、ユーザーが管理者ロールにある場合、ページが表示されたときに特定のコントロールがゾーンに追加され、ユーザーがユーザーロールに含まれていると、それらのコントロールは追加されません。  
  
 承認プロセス中にコントロールをフィルター処理するための<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>機構は<xref:System.Web.UI.WebControls.WebParts.WebPart> 、コントロールの<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 、メソッド、メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 、および<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールのイベントです。  
  
 フィルター処理のシナリオを作成するには、基本的に2つのタスクがあります。 まず、フィルター処理する各<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールのプロパティに文字列を割り当てます。 これらの文字列値には任意の値を指定できますが、フィルター処理に使用する条件を含める必要があります。 たとえば、管理者ユーザーがページを表示している場合にのみ、特定のコントロールをゾーンに追加するには、の`admin`文字列値をプロパティに割り当てることができます。 次に、ASP.NET ロール機能を使用して、サイトのすべてのユーザーを管理者、マネージャー、ユーザーなどのさまざまなロールに追加できます。 ページを読み込んでいるときに、フィルター処理コードはユーザーのロールを確認し、チェックされるコントロールの承認フィルターの値と比較します。ユーザーが管理者ロールにあり、コントロールの<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>値をに設定した場合は、次のようになります。`admin`コントロールを追加できます。  
  
 フィルター処理シナリオを作成するための2番目の手順は、 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>コントロールの<xref:System.Web.UI.WebControls.WebParts.WebPart>プロパティ値をチェックするコードを記述し、各コントロールが承認されてからゾーンに追加されるかどうかを判断することです。 このフィルター処理コードを配置する場所には、2つのオプションがあります。 最初のオプションは、ページ開発者に推奨されるオプションです。 Web ページサーバーのスクリプトコードまたは<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>コード分離ファイルで、イベントを直接処理するメソッドを作成できます。 次のサンプルマークアップコードに示すよう`OnAuthorizeWebPart`に、ページ内の<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールのタグに属性を追加して、メソッドをイベントに関連付けます。  
  
```  
<asp:webpartmanager id="manager1" runat="server"   
   OnAuthorizeWebPart="manager1_AuthorizeWebPart" />  
```  
  
 すべてのカスタムメソッドは、フィルター条件に対し<xref:System.Web.UI.WebControls.WebParts.WebPart>て各コントロールをチェックし、結果に基づいて、 <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs>オブジェクトの<xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A>プロパティにブール値を割り当てて、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールを次のようにすることができるかどうかを示す必要があります。れ. この例のコードでは、この方法を示しています。  
  
 フィルター処理コードを配置する場所の2つ目のオプションは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスから継承し、メソッドをオーバーライドしてフィルター条件をチェックすることです。 これ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType>を行うためにオーバーライドできる2つのメソッドは、メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>またはメソッドです。 どちらの方法も機能しますが、ほとんどの場合、メソッドを<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>オーバーライドすることをお勧めします。これは、認証プロセス全体をプログラムで<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>制御できるようにするためです。一方、メソッドは、特定のタスクを1つだけ実行します。。これは、イベントを発生させ、ハンドラーを確認します。 メソッドを<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> <xref:System.Web.UI.WebControls.WebParts.WebPartManager> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>オーバーライドするカスタムクラスのコード例については、メソッドのオーバーロードに関する記述を参照してください。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>イベントのカスタムイベントハンドラーを設定して、ハンドラーが<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>メソッドのカスタムフィルターコードを提供できるようにする方法を示しています。 この例は、ページ開発者がフィルター処理の<xref:System.Web.UI.WebControls.WebParts.WebPart>シナリオを提供し、ページに追加するコントロールを承認するための一般的な方法です。  
  
 Web ページで、 `<asp:webpartmanager>`要素に、割り当てられているイベントハンドラーの名前を持つ`OnAuthorizeWebPart`属性があることを確認します。 メソッドは、ページ上のコントロールのそれぞれ<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>のプロパティ値がに`admin`設定されているかどうか`true`を確認し、存在する場合はを返します。これは、ページに承認されて追加されることを意味します。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティに値が割り当てられていないコントロールも追加されることに注意してください。これは、フィルター処理のシナリオに含まれないと想定されるためです。 これは、フィルター処理のシナリオにおける一般的な方法です。一部のコントロールはフィルター処理され、他のコントロールはすべてのユーザーが使用できると想定されるため、そうでない場合があります。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ロール内のユーザーの設定はこのトピックの範囲を超えているため、このコード例では、フィルター処理でユーザーロールを確認しません。 ただし、ユーザーロールに基づいてコントロールをフィルター処理するシナリオは、このフィルター処理機能の最も一般的な用途の1つです。 サイトにロールがあり、この方法でコントロールをフィルター処理するためにユーザーロールを確認する場合、メソッドは次のコードブロックのようになります (これは、ロールを使用しない前のコード例の単純なアプローチとは異なります)。  
  
```vb  
Protected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  
  As Object, ByVal e As WebPartAuthorizationEventArgs)  
  
  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  
    If Roles.IsUserInRole(Page.User.Identity.Name, _  
      e.AuthorizationFilter) Then  
  
      e.IsAuthorized = True  
    Else  
      e.IsAuthorized = False  
    End If  
  End If  
  
End Sub  
```  
  
```csharp  
protected void mgr1_AuthorizeWebPart(object sender,   
  WebPartAuthorizationEventArgs e)  
{  
  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  
  {  
    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  
      e.IsAuthorized = true;  
    else  
      e.IsAuthorized = false;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivated : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivated : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>ページとそのコントロールが読み込まれ、ページの接続がアクティブになってデータの共有が開始されることを示す <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A>は、ページ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>が読み込みプロセスを完了した後にイベントを発生させます。 メソッドは、イベントのハンドラーを追加する方法を提供します。  
  
 ページ開発者は、イベントのカスタムハンドラーを追加できます`OnConnectionsActivated` 。そのため`<asp:webpartmanager>`には、ページの要素に属性を追加してから、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>開発者は、 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスのメソッドをオーバーライドできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivating">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivating (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivating(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivating (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivating(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivating : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivating : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>ページとそのコントロールが読み込まれ、接続をアクティブにするプロセスを開始できることを示す <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>イベントを発生させます。これにより、開発者は、接続をアクティブ化するプロセスをプログラムでカスタマイズするためのメカニズムを使用できます。  
  
 ページ開発者は、イベントのカスタムハンドラーを追加できます`OnConnectionsActivating` 。そのため`<asp:webpartmanager>`には、ページの要素に属性を追加してから、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>開発者は、 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスのメソッドをオーバーライドできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanged(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanged (e As WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanged(System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">変更された表示モードに関連付けられたイベント データを格納する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />。</param>
        <summary>Web ページ上で <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" /> コントロールが、ある表示モードから別の表示モードに切り替えるプロセスを完了したことを示す、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基本<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A>フォームのメソッドは、単にイベント<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>を発生させます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />メソッドをオーバーライドできます。 たとえば、表示モードを変更した後で、 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs.OldDisplayMode" />プロパティに含まれている表示モードに応じて、ユーザーインターフェイス (UI) の外観を変更することができます。 または、特定のコンテンツを非表示にしたり、特定のコントロールを表示したりすることもできます。  
  
メソッドをオーバーライドする場合は、通常、オーバーライドされたメソッドの最後の手順として基本メソッドを呼び出す必要があります。これにより、最初にカスタムコードを実行し、最後にイベントを発生させて、モードの変更が完了したことを示します。</para></block>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanging(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanging (e As WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanging(System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">変更中の表示モードに関連付けられたイベント データを格納する <see cref="T:System.EventArgs" />。</param>
        <summary>Web ページ上で <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" /> コントロールが、ある表示モードから別の表示モードに切り替えるプロセスを実行していることを示す、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基本<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>フォームのメソッドは、単にイベント<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>を発生させます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />メソッドをオーバーライドできます。 たとえば、表示モードを変更しているときに、新しい表示モードがどのようになるか ( <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode" />プロパティを使用) を確認したり、新しい表示モードに応じてユーザーインターフェイス (UI) の内容を変更したりすることができます。 カスタム表示モードを使用している場合は、カスタムモードを新しい表示モードにすると、特定のコントロールを表示することができます。  
  
このメソッドをオーバーライドする場合は、通常、オーバーライドされたメソッドの最初のステップとして基本メソッドを呼び出して、表示モードの変更が開始されたことを示すためにイベントが発生するようにする必要があります。 次に、新しい表示モードを実際に表示する前に、カスタムコードでユーザーインターフェイス (UI) を変更できます。</para></block>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="webPartManager.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Web.UI.Control.Init" /> コントロールの有効期間における最初のイベントとして、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A>は、コントロールのイベントを<xref:System.Web.UI.Control.Init>発生させる基本メソッドを呼び出し、ページ上の<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールのインスタンスが1つだけであることを確認するなど、いくつかの準備手順を実行します。パーソナル化データ。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">別の <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールがページ上に存在します。</exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreRender : EventArgs -&gt; unit" Usage="webPartManager.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>Web ページに <see cref="E:System.Web.UI.Control.PreRender" /> コントロールを表示する直前に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender%2A>は、コントロールのイベントを<xref:System.Web.UI.Control.PreRender>発生させる基本メソッドを呼び出し、Web パーツコントロールを含むページに必要な複数のクライアントスクリプトを登録します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanged(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanged (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanged(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> コントロールを新しく選択した後またはその選択を解除した後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>イベントを発生させます。これは通常、開発者がユーザーインターフェイス (UI) の外観を変更する必要がある時点です。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> たとえば、新しい<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールを選択すると、Web パーツコントロールセットによって、新しく選択されたコントロールの表示が変更されます。 コントロールの選択がクリアされると、レンダリングは通常に戻ります。  
  
 ユーザーが編集<xref:System.Web.UI.WebControls.WebParts.WebPart> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>する特定のコントロールを選択すると、メソッドが呼び出されます。 ユーザーがコントロールの編集を終了し、コントロールの選択がクリア<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>されると、メソッドが再度呼び出されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />イベントに関連するいくつかのオプションを使用すると、選択したコントロールが変更された後に発生する表示を開発者がカスタマイズできます。 宣言型コードでは、 <see langword="&lt;asp:webpartmanager&gt;" />要素内で<see langword="OnSelectedWebPartChanged" />属性を設定し、それにカスタムメソッドの名前を割り当てることができます。 カスタムメソッドでは、イベントが発生したときに、選択したコントロールの表示を変更できます。 もう1つの方法は、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスから継承し、メソッドをオーバーライドすることです。 3番目のオプションは、ゾーンレベルでレンダリングをカスタマイズすることです。たとえば、 <see cref="T:System.Web.UI.WebControls.WebParts.EditorZoneBase" />クラスから継承し、その<see cref="M:System.Web.UI.WebControls.WebParts.EditorZoneBase.OnSelectedWebPartChanged(System.Object,System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />メソッドをオーバーライドして、編集プロセス中に選択およびクリアされたコントロールのレンダリングをカスタマイズできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanging(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanging (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanging(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>現在選択されている <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" /> コントロールから選択を他に変更するプロセスを実行しているときに発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>は、現在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>選択されている<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールを変更するプロセスの間に発生するイベントを発生させます。  
  
 コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager>は、このメソッドと関連付けられたイベントを使用して、選択されたコントロールが変更されているプロセスをキャンセルする機会を提供します。 たとえば、メソッドはメソッド内<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>で呼び出され、メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>内で呼び出されてプロセスをキャンセルすることができます。 編集中のコントロールに対してユーザーがキャンセル動詞をクリックすると、コントロールは選択されなくなり、編集の変更は保存され<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>ません。これは、メソッドによって編集の変更が取り消される可能性があるためです。  
  
> [!NOTE]
>  メソッドは、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールを別のコントロールに接続するプロセスを開始および終了するメソッドの実行中にも呼び出され、そのプロセスをキャンセルできるようにします。  
  
 ページ開発者は、宣言ページマークアップ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>の`<asp:webpartmanager>`要素に`OnSelectedWebPartChanging`属性を追加し、その属性にカスタムメソッドの名前を割り当てることによって、イベントのカスタムハンドラーを作成できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnUnload : EventArgs -&gt; unit" Usage="webPartManager.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">コントロールの削除に関連付けられたイベント データ。</param>
        <summary><see cref="E:System.Web.UI.Control.Unload" /> 基本イベントを発生させ、Web ページから <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> インスタンスを削除します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdded(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdded (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdded(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" /> コントロールがページに追加された後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール (または<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーンに追加された他のサーバーコントロール) をページに追加する処理中に呼び出されます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>  
  
 ページ開発者は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> `OnWebPartAdded`属性を`<asp:webpartmanager>`要素に追加し、カスタムメソッド名を属性に割り当てることによって、イベントのカスタムハンドラーを作成できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdding">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdding(class System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdding (e As WebPartAddingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdding(System::Web::UI::WebControls::WebParts::WebPartAddingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit&#xA;override this.OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) を <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーンに追加するプロセスを実行しているときに発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>が追加されていることを示すために、イベントを発生させます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> メソッドには、追加プロセスをキャンセルするオプションも用意されています。 コントロールが正常に追加された<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>場合、イベントは次のようになります。  
  
 ページ開発者は、関連付けられているイベントのカスタム`OnWebPartAdding`ハンドラーを指定`<asp:webpartmanager>`できます。そのためには、Web ページ上の要素に属性を追加してから、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスを作成する開発者は<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" /> 、メソッドをオーバーライドしてイベント処理をカスタマイズできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosed(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosed (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosed(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>コントロールがページから削除されたことを通知する <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>は、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> (またはその他のサーバーまたはユーザーコントロール) がページ上で正常に閉じられたことを示すために、イベントを発生させます。  
  
 コントロールを<xref:System.Web.UI.WebControls.WebParts.WebPart>閉じるには、表示されないようにページから削除し、ページカタログと呼ばれる特別な保持オブジェクトに配置することもできます。 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>コントロールに対応するページカタログは、各ページの閉じら<xref:System.Web.UI.WebControls.WebParts.WebPart>れたコントロールへの参照を保持します。 コントロールが<xref:System.Web.UI.WebControls.WebParts.CatalogZone>ゾーン内のページで宣言されている場合、ユーザーはページをカタログ表示モードに切り替えて、以前に閉じられたコントロールをページに戻すことができます。 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>  
  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>は、開発者が<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>イベントのカスタムハンドラーを作成する機会を提供します。 ページ開発者は、イベントのカスタムハンドラーを追加できます`OnWebPartClosed` 。そのため`<asp:webpartmanager>`には、ページの要素に属性を追加してから、カスタムメソッド名を属性に割り当てます。 開発者がこのメソッドで実行する便利なタスクの1つは、終了したコントロールの代わりにプレースホルダーを表示し、コントロールをページに戻す方法をユーザーに通知するツールヒントを使用して完了することです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosing(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosing (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosing(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>ページから <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" /> コントロールまたはサーバー コントロールを削除するプロセスを実行しているときに発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>がページから閉じたり削除されたりしていることを示すために、イベントを発生させます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> メソッドには、終了プロセスをキャンセルするオプションも用意されています。 コントロールがページから正常に削除された場合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 、イベントは次のようになります。  
  
 ページ開発者は、関連付けられているイベントのカスタム`OnWebPartClosing`ハンドラーを指定`<asp:webpartmanager>`できます。そのためには、Web ページ上の要素に属性を追加してから、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスを作成する開発者は<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> 、メソッドをオーバーライドしてイベント処理をカスタマイズできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleted(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleted (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleted(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" /> コントロールがページから完全に削除された後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、ページからコントロール (または<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーン<xref:System.Web.UI.WebControls.WebParts.WebPart>に追加された他のサーバーコントロール) を削除する処理中に呼び出されます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A>  
  
 ページ開発者は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> `OnWebPartDeleted`属性を`<asp:webpartmanager>`要素に追加し、カスタムメソッド名を属性に割り当てることによって、イベントのカスタムハンドラーを作成できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleting(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleting (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleting(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>動的な <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" /> コントロール (または、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーンに配置されたサーバー コントロールまたはユーザー コントロール) を削除するプロセスを実行していることを示す、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールのみを削除できます。コントロールが削除されると、コントロールインスタンスがページから完全に削除され、復元できなくなります。 ダイナミック<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールとは、Web ページのマークアップで宣言された静的コントロールではなく、プログラムによって、または Web パーツカタログから追加されるコントロールです。  
  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A>は、コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>がゾーンから完全に削除されていることを示すために、イベントを発生させます。 メソッドでは、削除プロセスをキャンセルすることもできます。 コントロールがページから正常に削除された場合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> 、イベントは次のようになります。  
  
 ページ開発者は、関連付けられているイベントのカスタム`OnWebPartDeleting`ハンドラーを指定`<asp:webpartmanager>`できます。そのためには、Web ページ上の要素に属性を追加してから、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスを作成する開発者は<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> 、メソッドをオーバーライドしてイベント処理をカスタマイズできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoved(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoved (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoved(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" /> コントロールがページ上の別の位置に移動された後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>の最後にイベントを発生させます。これにより、イベントハンドラー内のコードが実行される前に、コントロールの移動プロセスが確実に完了します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>イベントは、コントロールが現在のゾーン内または別のゾーン内で移動されたときに発生します。また、移動がプログラムによって行われるか、またはコントロールをドラッグすることによって実行されるかは関係ありません。  
  
 ページ開発者は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> `OnWebPartMoved`属性を`<asp:webpartmanager>`要素に追加し、カスタムメソッド名を属性に割り当てることによって、イベントのカスタムハンドラーを作成できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoving(class System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoving (e As WebPartMovingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoving(System::Web::UI::WebControls::WebParts::WebPartMovingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit&#xA;override this.OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoving e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" /> ゾーン内の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) を移動するプロセスを実行していることを示す、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、 <xref:System.Web.UI.WebControls.WebParts.WebPart>また<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>は他のサーバーコントロールがそのゾーン内または別のゾーン内で移動されるときに発生するイベントを発生させます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> メソッドは、移動プロセスをキャンセルする機会も提供します。 移動が正常に完了した場合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 、イベントは次のようになります。  
  
 ページ開発者は、関連付けられているイベントのカスタム`OnWebPartMoving`ハンドラーを指定`<asp:webpartmanager>`できます。そのためには、Web ページ上の要素に属性を追加してから、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスを作成する開発者は<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" /> 、メソッドをオーバーライドしてイベント処理をカスタマイズできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" /> コントロールの間に接続が確立された後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A>は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>メソッドの最後に対応するイベントを発生させます。これにより、イベントハンドラー内のコードが実行される前に、2つのコントロールを接続するために必要な手順が完了します。  
  
 メソッドを使用すると、接続の作成プロセスをプログラムで制御できます。関連イベントは、ユーザーインターフェイス (UI) を更新したり、接続が確立されたことをユーザーに通知したりするのに便利なポイントです。  
  
 ページ開発者は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> `OnWebPartsConnected`属性を`<asp:webpartmanager>`要素に追加し、カスタムメソッド名を属性に割り当てることによって、イベントのカスタムハンドラーを作成できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" /> ゾーンに配置されている 2 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) の間に接続を確立するプロセスを実行しているときに発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A>は、2 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>つのコントロールが接続を確立しようとしたときに発生するイベントを発生させます。 メソッドは、接続試行をキャンセルする機会を提供します。 接続に成功した場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>イベントは次のようになります。  
  
 ページ開発者は、関連付けられているイベントのカスタム`OnWebPartsConnecting`ハンドラーを指定`<asp:webpartmanager>`できます。そのためには、Web ページ上の要素に属性を追加してから、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスを作成する開発者は<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> 、メソッドをオーバーライドしてイベント処理をカスタマイズできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" /> コントロール間の接続が終了した後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A>は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>メソッドの最後に対応するイベントを発生させます。これにより、2つのコントロール間の接続を終了するプロセスが実行されます。  
  
 メソッドは、接続を終了するプロセスをプログラムで制御することにより、開発者がユーザーに通知したり、ユーザーインターフェイス (UI) に変更を加えたり、アプリケーションにその他の変更を加えたりできるようにします。  
  
 ページ開発者は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> `OnWebPartsDisconnected`属性を`<asp:webpartmanager>`要素に追加し、カスタムメソッド名を属性に割り当てることによって、イベントのカスタムハンドラーを作成できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" /> ゾーン内の 2 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) の接続を終了するプロセスを実行していることを示す、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A>は、2 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>つのコントロールが接続を終了するときに発生するイベントを発生させます。 メソッドは、切断プロセスを取り消す機会を提供します。 接続が正常に削除された<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>場合、イベントは次のようになります。  
  
 ページ開発者は、関連付けられているイベントのカスタム`OnWebPartsDisconnecting`ハンドラーを指定`<asp:webpartmanager>`できます。そのためには、Web ページ上の要素に属性を追加してから、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスを作成する開発者は<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> 、メソッドをオーバーライドしてイベント処理をカスタマイズできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="Personalization">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Personalization As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ Personalization { System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Personalization : System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページのパーソナル化データが格納されたオブジェクトへの参照を取得します。</summary>
        <value>パーソナル化データが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールを介してページ<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>に関連付けられているオブジェクトにアクセスする方法を提供します。 このプロパティを使用すると、パーソナル化オブジェクトのさまざまなメンバーにアクセスできます。 たとえば、 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>メソッドを使用して、ページのパーソナル化スコープを共有からユーザースコープ (またはその逆) に切り替えることができます。 また、ページの現在のパーソナル化スコープ、ページで個人用設定が有効になっているかどうか、パーソナル化データで使用されているプロバイダーなどを確認することもできます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>プロパティによって参照されるデータは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールによって追跡されるページレベルのパーソナル化データのみであることに注意してください。 コントロールのパーソナル化できるプロパティ<xref:System.Web.UI.WebControls.WebParts.WebPart>の値など、コントロール固有のパーソナル化データは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>プロパティの一部ではありません。  
  
> [!NOTE]
>  Web パーツパーソナル化の詳細については、「 [Web パーツパーソナル化の概要](https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100))」を参照してください。  
  
   
  
## Examples  
 次のコード例は、プログラムで<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>プロパティを使用する方法を示しています。  
  
 次の Web ページでは、ユーザーが編集モードに入り、 <xref:System.Web.UI.WebControls.Calendar>コントロールの特定の要素を編集することができます。 **[スコープの切り替え]** ボタンをクリックすると、ページがユーザーまたは共有のパーソナル化スコープに切り替わります。 **[編集モード]** ボタンと **[ブラウズモード]** ボタンを選択すると、ページが適切な表示モードに切り替わります。 ファイルの`<script>` tag セクションで、イベントを処理する2つのメソッドは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>プロパティを使用して、基になるオブジェクトの有用なメンバーにアクセスすることに注意してください。 具体的には、これらの<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>メソッドは、 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>プロパティを通じてアクセスされるオブジェクトのメソッドとプロパティを使用します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Personalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/CS/wpmgrPersonalizationCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Personalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/VB/wpmgrPersonalizationVB.aspx#1)]  
  
 コード例を実行するには、ユーザーが共有スコープのページを個人用に設定できるようにする必要もあります。 次のマークアップのように、セクション内の`<system.web>` web.config ファイルにエントリを追加します。  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow  
        users="[Replace the text and brackets with a user name or   
           group.]"  
        roles="admin"   
        verbs="enterSharedScope"  />  
    </authorization>  
  </personalization>  
</webParts>   
```  
  
 ブラウザーでページを読み込んだ後、**[スコープの切り替え]** ボタンをクリックすると、スコープが共有されていることがわかります。 **[編集モード]** をクリックして表示モードを変更し、表示されているコントロールの動詞メニューをクリックして、メニューから **[編集]** を選択します。 両方の編集コントロールのユーザーインターフェイス (UI) が表示されていることに注意してください。 次に、**[参照モード]** をクリックして、通常のブラウズに戻ります。 ページが共有スコープ内にあると表示されている場合は、**[スコープの切り替え]** をもう一度クリックして、ページがユーザースコープにあることを確認します。 次に、同じ手順に従ってコントロールをもう一度編集しますが、編集 UI <xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart>ではコントロールが表示されないことに注意してください。 これは、このコントロールが、ページが共有パーソナル化スコープ内にある場合にのみ機能するためです。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100)">Web パーツパーソナル化の概要</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScript">
      <MemberSignature Language="C#" Value="protected virtual void RegisterClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RegisterClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RegisterClientScript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RegisterClientScript();" />
      <MemberSignature Language="F#" Value="abstract member RegisterClientScript : unit -&gt; unit&#xA;override this.RegisterClientScript : unit -&gt; unit" Usage="webPartManager.RegisterClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールで、Web ページ内における <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールのドラッグなど、さまざまなパーソナル化機能に使用するクライアント側スクリプトを生成できるようにします。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="webPartManager.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">ページに書き込むコントロールの内容を受け取る <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>オーバーライドして、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールが何らかの内容を表示するのを防ぎます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal override object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Object ^ SaveControlState();" />
      <MemberSignature Language="F#" Value="override this.SaveControlState : unit -&gt; obj" Usage="webPartManager.SaveControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールの状態データを保存し、今後このコントロールが含まれた Web ページを要求されたときにそのデータを復元できるようにします。</summary>
        <returns>コントロールの保存した状態データを格納する <see cref="T:System.Object" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>は、 <xref:System.Web.UI.Control.EnableViewState%2A>プロパティがに`false`設定されている場合でも、ページポストバック間で永続化する必要があるプロパティの状態データを保存します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SaveCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SaveCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SaveCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.SaveCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">読み込む状態データを含む <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />。</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールによって管理されるカスタムのパーソナル化状態データを保存します。これにより、ページの再読み込みを行うたびにこのデータを読み込めるようになります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>メソッドは、パーソナル化されたユーザー設定を今後のブラウザーセッション用に保存してページにアクセスできるようにするため、個人用設定のプロセスにおいて重要です。 メソッドは、カスタムのパーソナル化状態データを保存します。これには<xref:System.Web.UI.WebControls.WebParts.WebPart> 、ページに追加された、またはページから削除された動的またはサーバーコントロール、ページ上で移動されたコントロール、および作成または削除されました。  
  
 このメソッドをコードから直接呼び出すことはできません。 ただし、メソッドを呼び出すこと<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>もできます。このメソッド自体がこのメソッドを呼び出して、パーソナル化データを保存します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>開発者は、派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスでこのメソッドをオーバーライドして、パーソナル化データを保存するプロセスをカスタマイズできます。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedWebPart As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ SelectedWebPart { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>別のコントロールとの接続を編集または作成するために現在選択されている <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールへの参照を取得します。</summary>
        <value>接続の編集または接続の構成のために現在選択されている <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>は、 <xref:System.Web.UI.WebControls.WebParts.WebPart>または他のコントロールとの接続を作成するために現在選択されているまたは他のサーバーコントロールへの参照を返します。  
  
 コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager>には、コントロールを選択するプロセスを処理するための便利なメソッドとイベントがいくつか用意されています。 イベント<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>は、コントロールが選択された直後で、変更が行われる前に発生します。 コントロールを選択した後に操作を実行するには、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>メソッドをオーバーライドします。 たとえば、選択されていてもまだ変更されていないコントロールの外観を変更して、どのコントロールが選択されているかを視覚的に強調することができます。  
  
 イベント<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>は、選択したコントロールが変更された直後に発生します。 コントロールの変更後に操作を実行するには、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>メソッドをオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanged As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ SelectedWebPartChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールの選択を変更して Web ページ上の別のコントロールに移動した後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントを<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>メソッドと組み合わせて使用すると、選択したコントロールのユーザーインターフェイス (UI) を変更できます。 たとえば、ユーザーがページをデザインモード (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>) に切り替えてから、新しい位置にドラッグすることを目的としてコントロールを<xref:System.Web.UI.WebControls.WebParts.WebPart>選択した場合、そのコントロールの色を変更するなど、選択したコントロールの表示を変更するのが一般的です。選択されている間の境界または背景。  
  
> [!NOTE]
>  イベントの使用方法の詳細につい[ては、「方法:Web フォームアプリケーション](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)でイベントを使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanging As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ SelectedWebPartChanging;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上で現在選択されている <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロールの変更プロセス中に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>メソッドと組み合わせて使用できます。 ページ開発者は、ページ内の`OnSelectedWebPartChanging` `<asp:webpartmanager>`要素に属性を追加し、そのイベントを処理するカスタムメソッドの名前に属性の値を設定することにより、コード内にイベントハンドラーを作成できます。  
  
 このイベントは、コントロール間の接続を開始または終了するプロセス、およびコントロールの編集を開始および終了する処理中に発生します。 詳細については<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 、メソッドを参照してください。  
  
 通常、選択し<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>たコントロールを変更するユーザーのアクションの直接的な結果としてイベントが発生すると、そのイベントを取り消すことができます。 ただし、イベントを取り消すことができないシナリオもあります。 コントロールが削除された場合<xref:System.Web.UI.WebControls.WebParts.WebPart> 、それに含まれるコントロールはすべて閉じられている必要があります。それ以外の場合は、孤立します。 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> この場合<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 、コントロールはユーザーで<xref:System.Web.UI.WebControls.WebParts.WebPart>はなくコントロールを閉じ、現在選択されているコントロールを判断し、中断することなく選択範囲を変更するタイミングを決定して、クリーンアッププロセスを完了できるようにする必要があります。すべてのコントロール。 このため、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>このシナリオではメソッドをキャンセルできません。 キャンセルできる関連イベントについては、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>イベントを参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="SetPersonalizationDirty">
      <MemberSignature Language="C#" Value="protected void SetPersonalizationDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetPersonalizationDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetPersonalizationDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetPersonalizationDirty();" />
      <MemberSignature Language="F#" Value="member this.SetPersonalizationDirty : unit -&gt; unit" Usage="webPartManager.SetPersonalizationDirty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールのカスタムのパーソナル化データが変更されたことを示すフラグを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>は、最終的に Web パーツコントロールセット内のパーソナル化コンポーネントが更新されたパーソナル化データを保存するフラグを設定します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールによって追跡されるパーソナル化データの変更を引き起こす可能性のあるシナリオの詳細に<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>ついては、プロパティを参照してください。  
  
 メソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>は、コードから直接呼び出すことはできません。このメソッドは、Web パーツパーソナル化機能の一部として Web パーツコントロールセットによって内部的に使用されるため、オーバーライドすることはできません。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>メソッドは、派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスによって呼び出すことができます。 これは、Web パーツコントロールセットのパーソナル化コンポーネントをカスタマイズする必要があるため、パーソナル化データのフラグを設定するプロセスを制御する必要がある場合に便利です。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="SetSelectedWebPart">
      <MemberSignature Language="C#" Value="protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetSelectedWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetSelectedWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.SetSelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.SetSelectedWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">選択されている <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロール。</param>
        <summary>現在選択されている <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> コントロールまたはサーバー コントロールと同じ <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> プロパティ値を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、 `webPart`パラメーターによって指定されたコントロールの編集を開始または終了するプロセスと、を含む`webPart`接続を開始または終了するプロセスの間に呼び出されます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A>  
  
 編集および接続プロセスの開始時に、 `webPart`は編集対象として選択されたコントロール、または接続を入力するために選択されたコントロールです。  
  
 編集および接続プロセスが終了すると、 `null`が<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A>メソッドに渡されます。これにより、現在選択されているコントロールが選択されなくなります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SkinID : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールにスキンを適用できないように、空の文字列 ("") を取得または設定します。</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールへのスキンの割り当てができないようにする空の文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>は、継承<xref:System.Web.UI.Control.SkinID%2A?displayProperty=nameWithType>されたプロパティを<xref:System.Web.UI.WebControls.WebParts.WebPartManager>オーバーライドして、スキンを使用することによって非表示のコントロールであるコントロールを防止します。 プロパティを実装すると、常に`get`アクセサーから空の文字列を返すことによってスキンが割り当てられなくなり、 `set`アクセサーに値を設定しようとすると常に例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">プロパティ値を設定しようとしました。</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ StaticConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StaticConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上の静的接続として定義されているすべての <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> オブジェクトのコレクションへの参照を取得します。</summary>
        <value>ページ上のすべての静的接続が格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは、ページ上の<xref:System.Web.UI.WebControls.WebParts.WebPartManager>すべての静的接続を追跡および管理するためにコントロールによって使用されます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> 静的接続は、動的接続とは対照的に、ページが表示されるたびにページに追加する必要はありません。  
  
 このプロパティによって参照されるコレクションには、ページ上に存在するすべての静的接続が含まれます。 `<asp:webpartconnection>`これらの接続は、プログラムによって作成されるか、ページのマークアップの要素で指定されます。  
  
   
  
## Examples  
 次のコード例は、プログラムに<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>よるプロパティの使用方法を示しています。  
  
 このコード例には、次の4つの部分があります。  
  
-   Web パーツページの表示モードを変更できるユーザーコントロール。  
  
-   2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールとカスタムインターフェイスを含むソースコードファイル。  
  
-   接続できる2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール`<asp:webpartmanager>`と要素を含む Web ページ。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 次のコードには、例の Web ページ部分のみが含まれています。 また、この例の最初の2つの部分 (カスタムユーザーコントロールとカスタムコントロールおよびインターフェイスのソースコード) を取得する必要もあります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要に関するセクションのセクションを参照してください。 また、 <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールをコンパイルするためのオプションについても説明します。  
  
 コード例の3番目の部分は、Web ページです。 ページの宣言型マークアップに`Register`は、ユーザーコントロールとカスタムコントロールの両方に対するディレクティブが含まれています。 要素、カスタムコントロールを格納する要素、および要素があります。`<asp:connectionszone>` `<asp:webpartzone>` `<asp:webpartmanager>` `Page_Load`メソッドでは、接続が既に存在するかどうかをコードが確認し、存在しない場合はプロバイダー、コンシューマー、およびそれぞれの接続ポイントを定義し、次に、によって参照される静的接続のセットに新しい接続を追加します。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>プロパティ。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 ブラウザーに Web ページを読み込んだ後、**[表示モード]** ドロップダウンリストコントロールをクリックし、**[接続]** を選択してページを接続モードに切り替えます。 Connect モードでは`<asp:connectionszone>` 、要素を使用して、コントロール間の接続を作成できます。 接続モードで、**郵便番号**コントロールのタイトルバーにある下向きの矢印をクリックして動詞メニューをアクティブにし、**[接続]** をクリックします。 接続ユーザーインターフェイス (UI) が表示されたら、 `Page_Load`メソッドに含まれるコードによって接続が既に作成されていることを確認します。 後のブラウザーセッションでこのページに戻ると、この静的接続は既に確立されているので、ページを読み込むたびに再作成する必要はありません。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="SupportedDisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportedDisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ SupportedDisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportedDisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の Web ページ上で使用できるすべての表示モードの読み取り専用のコレクションを取得します。</summary>
        <value>特定の Web ページ上で使用できる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> オブジェクトのセットが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>は、ページ上に存在するゾーンコントロールの種類に応じて、ページで実際に使用可能な表示モードのみを格納します。  
  
> [!NOTE]
>  表示モードは無効にすることができます。表示モードが無効になっていると<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 、その表示モードをサポートしている対応する種類のゾーンがページ上に存在していても、コレクションには追加されません。  
  
 ブラウズモードとデザインモードは常にサポートされています。 表示モードは、編集、カタログ、および接続モードによって異なります。 これらの表示モードはそれぞれ、特定の<xref:System.Web.UI.WebControls.WebParts.ToolZone>種類のコントロールに関連付けられています。 Web ページに特別に型指定されたゾーンが存在するので、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>プロパティによって参照されるコレクションに特定の表示モードが追加されます。 たとえば、Web ページにゾーンが含まれ<xref:System.Web.UI.WebControls.WebParts.EditorZone>ているが<xref:System.Web.UI.WebControls.WebParts.CatalogZone>ゾーンではない場合、編集表示モードは、そのページでサポートされているモードの1つですが、カタログ表示モードはサポートされていません。  
  
> [!NOTE]
>  プロパティは、現在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager>のコントロールで使用可能なすべての表示モードを含むコレクションを参照するプロパティとは異なり、特定のページではサポートされていない表示モードも含まれます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>プロパティのプログラムによる使用方法を示しています。 このコードでは、このプロパティを使用して、現在の Web ページで使用可能な表示モードのみを一覧に設定します。  
  
 このページには、[参照]、[デザイン]、[編集] という3つのサポートされている表示モードがあります。 最初の2つは常に使用可能であり、このコード例では、このページには<xref:System.Web.UI.WebControls.WebParts.EditorZone>コントロールが含まれているので、編集モードを使用できます。 対応するゾーンがこのページにないため、カタログと接続の表示モードは表示されません。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/CS/wpmgrSuppDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/VB/wpmgrSuppDisplayModesvb.aspx#1)]  
  
 ブラウザーにページを読み込むと、ドロップダウンリストコントロールを使用して、ページをブラウズモードからデザインモードに切り替えてから編集モードに切り替えることができます。 編集モードでは、いずれかのサーバーコントロールのヘッダーのドロップダウン動詞メニューをクリックし、**[編集]** を選択してコントロールを編集することができます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web パーツのページ表示モード</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty">
      <MemberSignature Language="C#" Value="bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsDirty As Boolean Implements IPersonalizable.IsDirty" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::WebControls::WebParts::IPersonalizable::IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールによって管理されているカスタムのパーソナル化状態データが Web ページ上で変更されたかどうかを示す値を取得します。</summary>
        <value>パーソナル化状態データが変更されたかどうかを示すブール値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールによって管理されるパーソナル化状態データが変更されたかどうかを呼び出し元が判断するための方法を提供します。 ページレイアウトの変更、接続の作成または削除、コントロールの<xref:System.Web.UI.WebControls.WebParts.WebPartManager>追加や削除などによってページレベルの詳細をカスタマイズすると、コントロールによって管理されるパーソナル化データが変更されます。 これは、呼び出し元が、呼び出し元が直接アクセスできない protected <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>プロパティの値を呼び出し元に返すパススルーメソッドです。  
  
> [!NOTE]
>  プロパティは、パーソナル化できるプロパティ値、または個々<xref:System.Web.UI.WebControls.WebParts.WebPart>のコントロールの外観に影響を与える個々のプロパティが変更されたかどうかを示すものではありません。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> コントロールレベルのパーソナル化は、各コントロールに対して個別に追跡されます。 プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>は、ページレベルで、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールによって管理されているパーソナル化データが変更されたかどうかのみを示します。  
  
 次の一覧では、プロパティが<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>の値を返すようにする、パーソナル化の一般的なインスタンスについて説明します。これにより、コントロールに<xref:System.Web.UI.WebControls.WebParts.WebPartManager>いくつかの`true`パーソナル化データがあることが示されます。  
  
-   ページ上の<xref:System.Web.UI.WebControls.WebParts.WebPart>静的コントロール (またはサーバーコントロールまたはユーザーコントロール) を閉じる。  
  
-   ページカタログからページ<xref:System.Web.UI.WebControls.WebParts.WebPart>に戻る閉じた静的コントロールを復元する。  
  
-   ゾーン内または別のゾーン内の任意のコントロールを移動します。  
  
-   またはサーバーコントロールのカタログから<xref:System.Web.UI.WebControls.WebParts.WebPart>のコントロールの追加、またはプログラムによるコントロールの追加。  
  
-   プログラムによって、 <xref:System.Web.UI.WebControls.WebParts.WebPart>または接続ユーザーインターフェイス (UI) を使用して、2つのコントロール間の接続を作成します。  
  
-   プログラムによって、 <xref:System.Web.UI.WebControls.WebParts.WebPart>または接続 UI を使用して、2つのコントロール間の接続を削除します。  
  
 このプロパティ値にアクセスするには、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールインスタンスを<xref:System.Web.UI.WebControls.WebParts.IPersonalizable>インターフェイスにキャストする必要があります。 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A>その後、プロパティ値を読み取ることができます。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>プロパティの簡単な使用方法を示しています。これは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールのパーソナル化データが変更される原因となる一般的なページパーソナル化インスタンスを示しています。  
  
 このコード例には、次の4つの部分があります。  
  
-   Web パーツコントロールを含むページの表示モードを変更できるユーザーコントロール。  
  
-   接続可能な2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールのコードと、インターフェイスを含むソースファイル。  
  
-   すべてのコントロールをホストする Web ページ。  
  
-   コード例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については[、「チュートリアル:Web パーツページ](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)での表示モードの変更  
  
 この例の2番目の部分は、カスタムコントロールとインターフェイスを含むソースファイルです。 インターフェイスが`IZipCode` 1 つのメソッドを公開しており、カスタム`ZipCodeWebPart`コントロールに実装されているこのメソッドが、接続`ZipCodeWebPart`シナリオでをプロバイダーとして機能させるためのコールバックメソッドとして機能することに注意してください。 もう1つの`WeatherWebPart`コントロールは、接続のコンシューマーコントロールとして機能します。は、によっ`ZipCodeWebPart`て提供される特定のインターフェイスを使用できます。 実際のアプリケーションでは`WeatherWebPart` 、プロバイダーからパーソナライズされた郵便番号の値を使用して、ユーザーに気象情報をグラフィカルに提供することができます。  
  
 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 このコード例では、動的コンパイルを使用します。このため、Web ページ`Register`の上部にあるこのコンポーネントのディレクティブには`Assembly`属性と`Namespace`属性`TagPrefix`のみが含まれていることに注意してください。 のコンパイル方法を示すチュートリアルについては[、「チュートリアル:カスタム Web サーバーコントロール](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)の開発と使用  
  
 [!code-csharp[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/ZipCodeComponent.vb#2)]  
  
 コード例の3番目の部分は、Web ページです。 2つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPartZone> <xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールを含む2つのゾーンが含まれていることに注意してください。 また、 <xref:System.Web.UI.WebControls.WebParts.CatalogZone>ゾーンもあります。これには<xref:System.Web.UI.WebControls.Calendar> 、ユーザーがページに追加できる標準コントロールが含まれています。 要素`<asp:connectionszone>`には、ユーザーがコントロール間の接続を作成するための接続 UI が用意されています。 メソッドで、パーソナル化データが変更されたかどうかを確認し、存在する場合はの`Label1`テキストを更新することに注意してください。 `Page_PreRender`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/wpmgrIsDirtyCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/wpmgrIsDirtyVB.aspx#1)]  
  
 ブラウザーでページを読み込んだ後、このトピックの「解説」に記載されているいくつかのシナリオを作成して、パーソナル化データを変更してみてください。 さまざまな変更を行うときに、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールによって追跡されるパーソナル化シナリオの1つが変更されると、パーソナル化データが変更されたことを示す`Label1`コントロールのテキストが表示されます。 たとえば、次のように操作できます。  
  
-   **[WebPart コントロールの接続]** ボタンをクリックして、コントロール間の接続を作成します。  
  
-   **[表示モード]** ドロップダウンリストコントロールを使用して、ページをカタログモードに切り替え、 **[マイカレンダー** ] コントロールを<xref:System.Web.UI.WebControls.WebParts.WebPartZone> 2 番目のゾーンに追加します。  
  
-   ページをブラウズモードに戻して、**[マイカレンダー]** コントロールの動詞メニュー (タイトルバーに矢印の記号が表示されます) をクリックし、**[閉じる]** をクリックして閉じ、ページカタログに追加します。  
  
-   ページをカタログモードに戻し、ページに **[My Calendar** ] コントロールを追加します。  
  
-   **[表示モード]** コントロールを使用して、ページをデザインモードに切り替え、コントロールのレイアウトを別のゾーンまたは同じゾーン内の別の位置にドラッグして配置を変更します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Load">
      <MemberSignature Language="C#" Value="void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Load (state As PersonalizationDictionary) Implements IPersonalizable.Load" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Load;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">読み込む状態データを含む <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />。</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールに読み込む必要がある、以前に保存したカスタムのパーソナル化状態データを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=nameWithType>メソッドの実装です。これにより、Web パーツコントロールセットがプロテクト<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=nameWithType>メソッドに直接アクセスできるようになります。 このメソッドが呼び出されると、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールによって管理され、以前は初期化プロセスで使用するために永続的なデータストアに保存されたカスタム個人用データが格納されます。  
  
> [!NOTE]
>  ほとんどの場合、ページおよびコントロールの開発者コードは、このメソッドを呼び出す必要はありません。これは、主にパーソナル化データを取得するための機構として Web パーツコントロールセットによって使用されるためです。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>開発者がこのメソッドを使用するシナリオの1つは、Web パーツコントロールセットによって提供されるものの代わりに使用するカスタムパーソナル化フレームワークを開発している場合です。 このような場合、開発者は<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスを継承し、 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />メソッドをオーバーライドして、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />オブジェクトのカスタム実装を返すことができます。 カスタムオブジェクトは、適切なタイミングで<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />メソッドの実装を呼び出して、カスタムパーソナル化データを読み込みます。 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /></para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Save">
      <MemberSignature Language="C#" Value="void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Save (state As PersonalizationDictionary) Implements IPersonalizable.Save" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Save;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">保存する状態データを格納する <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />。</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールで管理されるカスタムのパーソナル化状態データを保存します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=nameWithType>メソッドの実装です。これにより、Web パーツコントロールセットがプロテクト<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=nameWithType>メソッドに直接アクセスできるようになります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> このメソッドが呼び出されると、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールによって管理されているすべての個人用データが、Web パーツアプリケーション用に構成された永続的なデータストアに保存されます。  
  
> [!NOTE]
>  ほとんどの場合、ページおよびコントロールの開発者コードは、このメソッドを呼び出す必要はありません。これは、パーソナル化データを保存するためのメカニズムとして、主に Web パーツコントロールセットによって使用されるためです。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>開発者がこのメソッドを使用するシナリオの1つとして、Web パーツコントロールセットによって提供されるものの代わりに使用するカスタムパーソナル化フレームワークを開発する場合があります。 このような場合、開発者は<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスを継承し、 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />メソッドをオーバーライドして、 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />オブジェクトのカスタム実装を返すことができます。 カスタムオブジェクトは、適切なタイミングで<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />メソッドの実装を呼び出して、カスタムのパーソナル化データを保存します。 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /></para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberSignature Language="F#" Value="override this.TrackViewState : unit -&gt; unit" Usage="webPartManager.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>パーソナル化状態データを <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールに適用し、基本メソッドを呼び出してコントロールのビューステート データに対する変更を追跡できるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビューステートデータへの変更は、 <xref:System.Web.UI.StateBag>オブジェクトに格納され、コントロールの<xref:System.Web.UI.Control.ViewState%2A>プロパティを使用してアクセスできます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>子コントロールを表示できるようにする値を取得します。</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールおよびその子コントロールが表示されるかどうかを示す Boolean 値。 常に <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager>は、基本<xref:System.Web.UI.Control.Visible%2A?displayProperty=nameWithType>プロパティをオーバーライドして、 `true`常に<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>プロパティの値を返します。 コントロール自体が表示されていない場合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>でも、すべての子`true`コントロールが既定で表示されるように、プロパティをに設定する必要があります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>プロパティの値を設定しようとすると、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールが基本プロパティの動作をオーバーライドし、プロパティに値を割り当てられないため、常にエラーが生成されます。  
  
 このプロパティは、ビジュアルデザイナーではバインドできませんが、実行時にバインドできます。 詳細については、「<xref:System.ComponentModel.BindableAttribute>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このプロパティに値を割り当てようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdded">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdded As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartAdded;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的な <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールを <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンに追加した後に発生し、そのコントロールが正常に追加されたことを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>イベントは、動的コントロール (ページマークアップで宣言されているのではなく、プログラムによって追加されたコントロール) がゾーンに正常に追加されたことを示すために役立ちます。 このイベントは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>メソッドと共に、ユーザーインターフェイス (UI) を更新したり、コントロールが正常に追加されたことをユーザーに通知したりする方法を開発者に提供します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdding">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdding As WebPartAddingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAddingEventHandler ^ WebPartAdding;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " Usage="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的な <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールを <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンに追加するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントは、コントロールをゾーン<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A>に追加するプロセスが開始された後に、メソッドによって発生します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> このイベントは、プロセスが完了する前にキャンセルする機会を提供します。 追加プロセスが成功した場合、このイベントの<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>後にイベントが続きます。  
  
 ページ開発者は、ページ内の`OnWebPartAdding` `<asp:webpartmanager>`要素に属性を追加し、カスタムメソッド名を属性に割り当てることによって、イベントのカスタムハンドラーを提供できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosed">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosed As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartClosed;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) をページから削除すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>は、ユーザーまたはプログラムによってコントロールが正常に閉じられたことを示します。 コントロールを<xref:System.Web.UI.WebControls.WebParts.WebPart>閉じるには、表示されないようにページから削除し、ページカタログと呼ばれる特別な保持オブジェクトに配置することもできます。 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>コントロールに対応するページカタログは、各ページの閉じら<xref:System.Web.UI.WebControls.WebParts.WebPart>れたコントロールへの参照を保持します。 コントロールが<xref:System.Web.UI.WebControls.WebParts.CatalogZone>ゾーン内のページで宣言されている場合、ユーザーはページをカタログ表示モードに切り替えて、以前に閉じられたコントロールをページに戻すことができます。 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>  
  
 イベントは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>メソッドに関連付けられています。このメソッドは、イベントを発生させ、ハンドラーを提供します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>  
  
 ページ開発者は、イベントのカスタムハンドラーを追加できます`OnWebPartClosed` 。そのため`<asp:webpartmanager>`には、ページの要素に属性を追加してから、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosing">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosing As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartClosing;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) をページから削除するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>イベントは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールが<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A>コントロールを閉じる処理を行っているときに、メソッドによって発生します。 コントロールの削除が成功した場合、このイベントの<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>後にイベントが続きます。  
  
 ページ開発者は、ページ内の`OnWebPartClosed` `<asp:webpartmanager>`要素に属性を追加し、カスタムメソッド名を属性に割り当てることによって、イベントのカスタムハンドラーを提供できます。  
  
 通常、ユーザーが<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>コントロールを<xref:System.Web.UI.WebControls.WebParts.WebPart>終了した結果としてイベントが発生した場合は、イベントを取り消すことができます。 ただし、イベントを取り消すことができないシナリオもあります。 コントロールが削除された場合<xref:System.Web.UI.WebControls.WebParts.WebPart> 、それに含まれるコントロールはすべて閉じられている必要があります。それ以外の場合は、孤立します。 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> この場合<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 、コントロールはユーザーで<xref:System.Web.UI.WebControls.WebParts.WebPart>はなく、コントロールを閉じます。 また、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールが、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>各コントロールを閉じるために<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>メソッドを呼び出しているときに、イベントが発生した場合、は<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クリーンアップのタスクを完了する必要があるため、イベントを取り消すことはできません。すべてのゾーンのコントロール。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleted">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleted As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartDeleted;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールを <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンから削除した後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>イベントは、動的コントロール (ページマークアップで宣言されているのではなく、プログラムによって追加されたコントロール) がゾーンから正常に削除されたことを示すために役立ちます。 このイベントは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A>メソッドと共に、ユーザーインターフェイス (UI) を更新したり、コントロールが正常に削除されたことをユーザーに通知したりする方法を開発者に提供します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleting As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartDeleting;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的な <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールのインスタンスを <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンから完全に削除するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントは、動的コントロール ( <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A>プログラムによって追加された、またはユーザーによって Web パーツユーザーインターフェイスによって追加された) を削除する処理中に、メソッドによって発生します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> イベントは、処理が完了する前にプロセスを取り消す機会を提供します。 削除プロセスが正常に完了した場合、このイベントの<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>後にイベントが続きます。  
  
 ページ開発者は、ページ内の`OnWebPartDeleting` `<asp:webpartmanager>`要素に属性を追加し、カスタムメソッド名を属性に割り当てることによって、イベントのカスタムハンドラーを提供できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartMoved">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoved As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartMoved;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロールを、Web ページ上の別の位置に移動した後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、静的 (Web ページのマークアップで宣言) と動的コントロールの両方に適用されます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>メソッドに関連付けられています。 イベントは移動の完了後に発生するため、開発者はイベントハンドラーを追加して、ユーザーに通知を提供したり、検証を行ったり、その他の操作を行ったりすることができます。 イベントハンドラーを追加するには、ページ内`OnWebPartMoved`の`<asp:webpartmanager>`要素に属性を追加し、カスタムメソッドの名前を属性に割り当てることができます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoving">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoving As WebPartMovingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartMovingEventHandler ^ WebPartMoving;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " Usage="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーンに配置されている <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> コントロールまたはその他のサーバー コントロールを移動するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 またはその他のサーバーコントロールが自身のゾーン内または別のゾーン内で移動されている<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>ときに、イベントが発生します。 <xref:System.Web.UI.WebControls.WebParts.WebPart> これは、ユーザーがコントロールをドラッグしたときと、プログラムによる移動があるときに発生する可能性があります。  
  
 イベントは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A>メソッドによって発生し、移動プロセスを完了する前にキャンセルする機会を提供します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 移動が完了し、コントロールが新しい位置に配置された場合、このイベントの<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>後にイベントが続きます。  
  
 ページ開発者は、 `OnWebPartMoving`属性を`<asp:webpartmanager>`要素に追加し、カスタムメソッド名を属性に割り当てることによって、イベントのカスタムハンドラーを作成できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartCollection WebParts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebParts As WebPartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartCollection ^ WebParts { System::Web::UI::WebControls::WebParts::WebPartCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebParts : System.Web.UI.WebControls.WebParts.WebPartCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールで追跡されるすべての <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールへの参照を取得します。</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartCollection" /> コントロールのセットへの参照が格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは、ページ上の<xref:System.Web.UI.WebControls.WebParts.WebPartManager>ゾーン内<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>に含ま<xref:System.Web.UI.WebControls.WebParts.WebPart>れるすべてのコントロールを追跡するために、コントロールによって使用されます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> コレクションは読み取り専用ですが、コレクションを通じて個々<xref:System.Web.UI.WebControls.WebParts.WebPart>のコントロールにアクセスし、プログラムで変更を加えることができます。  
  
> [!NOTE]
>  コントロールが<xref:System.Web.UI.WebControls.WebParts.WebPartZone>ゾーン外のページ<xref:System.Web.UI.WebControls.WebParts.WebPart>に配置されている場合は、コントロールがコントロールによって<xref:System.Web.UI.WebControls.WebParts.WebPartManager>追跡されないか、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>コレクション内で参照されていない可能性があります。 ただし、ゾーン外でコントロールを<xref:System.Web.UI.WebControls.WebParts.WebPart>使用する理由はほとんどありません。そのため、Web パーツ機能を失い、通常のサーバーコントロールとして機能します。  
  
 カスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、標準 ASP.NET コントロール、ユーザーコントロール、またはカスタムサーバーコントロールを、実行時に<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールとして扱うことができる、ゾーンに配置できる任意の種類のコントロール。 コントロール<xref:System.Web.UI.WebControls.WebParts.WebPart> <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> <xref:System.Web.UI.WebControls.WebParts.WebPart>ではないコントロールがゾーンに配置されている場合、実行時にASP.NETはオブジェクトを使用してコントロールをラップするため、コントロールは真のコントロールとして動作することができます。<xref:System.Web.UI.WebControls.WebParts.WebPartZone> したがって、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>プロパティを使用すると<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 、コントロールは、 <xref:System.Web.UI.WebControls.WebParts.WebPart>クラスから派生したかどうかに関係なく、任意の型のサーバーコントロールを追跡できます。  
  
   
  
## Examples  
 次のコード例は、プログラムで<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>プロパティを使用して個々<xref:System.Web.UI.WebControls.WebParts.WebPart>のコントロールにアクセスする方法を示しています。 Web ページの宣言型マークアップでは、 `<asp:webpartzone>`要素内に2つの標準 ASP.NET サーバーコントロールがあります。 これらは<xref:System.Web.UI.WebControls.WebParts.WebPart>クラスから継承されませんが、これらはゾーン内にあるため、実行時<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>にオブジェクトと共にラップされるため、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>プロパティによって参照されるコレクションに含まれます。 このゾーンにカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、ユーザーコントロール、またはカスタムサーバーコントロールを追加することもできます。これらのコントロールは同じように処理されます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_WebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/CS/wpmgrWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_WebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/VB/wpmgrWebPartsVB.aspx#1)]  
  
 コード例を使用するには、web.config ファイルに設定を追加して、Web パーツ記述ファイルのエクスポートを有効にする必要があることに注意してください。 このコード例の web ページと同じディレクトリに web.config ファイルがあることを確認します。 セクション内に、次のマークアップの`<webParts>`ように、 `enableExport`属性がに`true`設定された要素があることを確認します。 `<system.web>`  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 ブラウザーにページを読み込んだ後、**[WebPart count]** ボタンをクリックすると、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>プロパティを使用してコレクション内のコントロールの数が返されます。 **[予定表のタイトルを隠す]** ボタンをクリックすると、コードによってカレンダーが変更され、タイトルではなく、境界線だけが表示されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsConnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) の間に特定の接続が確立された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A>メソッドに関連付けられています。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> イベントは、接続が完了したことを確認した後に、ユーザーに通知したり、ページのユーザーインターフェイス (UI) を変更したりすることができます。 たとえば、2つのコントロール間の接続が成功したことを示すグラフィックイメージを表示したり、簡単なメッセージを表示したり、ページ表示モードをブラウズモードに戻したりすることができます。  
  
 ページ開発者は、このイベントにカスタムイベントハンドラーを関連付けること`OnWebPartsConnected`ができます`<asp:webpartmanager>` 。そのためには、ページの要素に属性を追加し、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsConnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (または、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンに配置されたサーバー コントロールまたはユーザー コントロール) の間に接続を作成するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントは<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A>メソッドによって発生し、接続プロセスが開始されたことを通知します (たとえば、ユーザーがコントロールを選択し、connect 動詞をクリックした場合など)。ただし、まだ完了していません。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> イベントは、完了前に接続を取り消す機会を提供します。 接続が正常に完了した場合、このイベントの<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>後にイベントが続きます。  
  
 ページ開発者は、 `OnWebPartsConnecting`属性を`<asp:webpartmanager>`要素に追加し、カスタムメソッド名を属性に割り当てることによって、イベントのカスタムハンドラーを追加できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsDisconnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロール間の接続が終了した後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントは、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A>メソッドに関連付けられています。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> イベントは、接続が終了したことがわかった後に、ユーザーに通知したり、コードでクリーンアップ操作を実行したり、ユーザーインターフェイス (UI) で他の変更を加えたりすることができます。  
  
 ページ開発者は、このイベントにカスタムイベントハンドラーを関連付けること`OnWebPartsDisConnected`ができます`<asp:webpartmanager>` 。そのためには、ページの要素に属性を追加し、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsDisconnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以前に接続した <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロール間の接続を終了するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントは<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A>メソッドによって発生し、ユーザーが<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>切断動詞をクリックしたこと、またはメソッドが呼び出されていることを通知します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントは、接続が完了する前に終了プロセスをキャンセルする機会を提供します。 接続が正常に終了した場合、このイベントの<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>後にイベントが続きます。  
  
 ページ開発者は、 `OnWebPartsDisconnecting`属性を`<asp:webpartmanager>`要素に追加し、カスタムメソッド名を属性に割り当てることによって、イベントのカスタムハンドラーを追加できます。  
  
 通常、接続を<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>終了するユーザーのアクションの直接的な結果としてイベントが発生した場合は、イベントを取り消すことができます。 ただし、イベントを取り消すことができないシナリオがいくつかあります。 最初のシナリオでは、 <xref:System.Web.UI.WebControls.WebParts.WebPartZone>コントロールが削除<xref:System.Web.UI.WebControls.WebParts.WebPart>されると、それに含まれるコントロールがすべて閉じられる必要があります。それ以外の場合は、孤立します。 この場合<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 、コントロールはユーザーで<xref:System.Web.UI.WebControls.WebParts.WebPart>はなくコントロールを閉じます。また、接続されているコントロールの接続を中断せずに終了できるようにする必要もあります。これにより、クリーンアップと終了のプロセスを完了できます。すべてのコントロール。 このため、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>このシナリオではメソッドをキャンセルできません。 キャンセルできる関連イベントについては、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>イベントを参照してください。  
  
 2つ目のシナリオで<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>は、イベントを取り消すことが<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>できません。メソッドが呼び出されたとき (たとえば、ページへの要求のたびに呼び出された場合)、ページ上の既存の接続で何らかの競合が発生した場合です。 たとえば、ユーザーがコントロール x をコントロール y に接続しているにもかかわらず、共有ユーザーがコントロール x をコントロール z に接続していても、コントロール x は複数の接続を形成することが許可されていません。 この場合、接続に対する個々のユーザーの設定が優先され、コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager>は、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>メソッドを呼び出し、特定のユーザーの x と z の間の接続を終了することで競合を解決します。 この切断は競合の解決に不可欠であるため、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>このシナリオではイベントを取り消すことができません。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>メソッドを取り消すことができない3番目のシナリオは<xref:System.Web.UI.WebControls.WebParts.WebPart> 、現在接続されているコントロールまたはサーバーコントロールが削除されたか、閉じられた場合です。 コントロールはページから確実に削除されるため、接続を削除することが論理的に必要になります。 したがって、コントロール<xref:System.Web.UI.WebControls.WebParts.WebPartManager>が<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>メソッドを呼び出し、そのメソッドが<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>イベントを発生させる場合、設計上、イベントをキャンセルすることはできません。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="Zones">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Zones As WebPartZoneCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ Zones { System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Zones : System.Web.UI.WebControls.WebParts.WebPartZoneCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartZoneCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上のすべての <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンのコレクションへの参照を取得します。</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneCollection" /> ゾーンのセットを参照する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティは、Web ページ上<xref:System.Web.UI.WebControls.WebParts.WebPartManager>の<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーンを追跡するためにコントロールによって使用されます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> プロパティでは、すべての種類のゾーンが参照されないことに注意してください。このクラスは<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 、ゾーンを含む<xref:System.Web.UI.WebControls.WebParts.WebPartZone> 、クラスから派生したゾーンのみを参照します。  
  
 プロパティによって参照されるコレクションは読み取り専用ですが、コレクション内の個々のオブジェクトにアクセスしてプログラムで操作することができます。  
  
   
  
## Examples  
 次のコード例は、プログラムで<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>プロパティを使用して個々<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>のゾーンコントロールにアクセスする方法を示しています。 Web ページの宣言型マークアップには、それぞれサーバーコントロールを`<asp:webpartzone>`含む2つの要素があります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>ページの`<script>`セクションでは、プロパティを使用して個々のゾーンにアクセスし、すべてのゾーン id を一覧表示してから、2番目のゾーンの背景色を変更します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Zones#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/CS/wpmgrzonescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Zones#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/VB/wpmgrzonesvb.aspx#1)]  
  
 コード例を使用するには、web.config ファイルに設定を追加して、Web パーツ記述ファイルのエクスポートを有効にする必要があることに注意してください。 このコード例の web ページと同じディレクトリに web.config ファイルがあることを確認します。 セクション内に、次のマークアップの`<webParts>`ように、 `enableExport`属性がに`true`設定された要素があることを確認します。 `<system.web>`  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 ブラウザーにページを読み込むと、**[ゾーン id の一覧表示]** ボタンをクリックしたときに、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>プロパティを使用してコレクション内のすべてのゾーンの id が一覧表示されます。 [ゾーンの背景の**変更**] ボタンをクリックすると、コードによって2番目のゾーンの背景色が変更されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
