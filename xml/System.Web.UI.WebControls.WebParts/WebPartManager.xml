<Type Name="WebPartManager" FullName="System.Web.UI.WebControls.WebParts.WebPartManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="39878b0a58d88077e3f60f42a8b9f566fd421748" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30601306" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartManager extends System.Web.UI.Control implements class System.Web.UI.INamingContainer, class System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartManager&#xA;Inherits Control&#xA;Implements INamingContainer, IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartManager : System::Web::UI::Control, System::Web::UI::INamingContainer, System::Web::UI::WebControls::WebParts::IPersonalizable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.WebControls.WebParts.IPersonalizable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ViewStateModeById</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Web パーツのコントロール、機能、および Web ページ上で発生するイベントのすべてを管理する、Web パーツ コントロール セットの中心的なクラスとして機能します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールは、ハブまたはコントロール センターの Web パーツ アプリケーションとして機能します。 必要があります--を 1 つ--<xref:System.Web.UI.WebControls.WebParts.WebPartManager> Web パーツ コントロールを使用するすべてのページにコントロールのインスタンス。 Web パーツのアプリケーションのほとんどの側面と同様、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールは認証されたユーザーでのみ機能します。 さらに、その機能を継承する Web パーツ ゾーン内に存在するサーバー コントロールのほとんどすべてが、<xref:System.Web.UI.WebControls.WebParts.WebZone>クラスです。 これらのゾーンの外部でページ上に存在するサーバー コントロールは、ほとんどの Web パーツ機能またはとの対話を持つことができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。  
  
 ハブのページでは、Web パーツ機能として、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールでは、次の表で説明したタスクの種類を実行します。  
  
|タスク カテゴリ|どのようなコントロールを使用してください。|  
|-------------------|---------------------------|  
|Web パーツ コントロールの追跡|など、Web パーツの機能を提供するページ上のコントロールのさまざまな種類の追跡<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、接続、ゾーン、およびその他のユーザーです。|  
|追加して、Web パーツ コントロールを削除します。|追加、削除、および終了のメソッドを提供<xref:System.Web.UI.WebControls.WebParts.WebPart>ページ上のコントロールです。|  
|接続の管理|コントロール間の接続を作成し、接続性を追加してそれらを削除するプロセスを監視します。|  
|コントロールとページのカスタマイズ|ページでは、別の場所にコントロールを移動することができ、外観、プロパティ、およびコントロールの動作のユーザーが編集ビューを起動します。 各ページ上のユーザーに固有の個人用設定を保持します。|  
|別のページ ビューの切り替え|ユーザーがページ レイアウトの変更やコントロールの編集などの特定のタスクを実行できるように、ページの異なる特殊なビュー間のページに切り替えます。|  
|Web パーツのライフ サイクル イベントを発生させる|発生し、およびとコントロールの追加、移動、接続されている、または削除などの Web パーツ コントロールのライフ サイクル イベントを処理するすれば、開発者に定義します。|  
|コントロールのインポートとエクスポートを有効にします。|プロパティの状態を格納する XML ストリームをエクスポート<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、およびその他のページまたはサイト内の複雑なコントロールのカスタマイズで利便性のためのファイルをインポートすることができます。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスには、大規模な一連のプロパティです。 一貫性のある、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>他のコントロールの追跡のロール、Web パーツ コントロールまたはその他の特別な Web パーツのオブジェクトのいずれかのコレクションを参照するプロパティの数があります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>、および<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>プロパティは、すべてのコレクションで使用される、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>の追跡と他の管理タスクを制御します。  
  
 プロパティの別のグループには、Web パーツ アプリケーションで発生する特定の状況で適用されるカスタマイズ可能な警告が含まれています。 ように、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>、および<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>プロパティです。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスは、多くの Web サーバー コントロールで使用される基本の継承されたプロパティの一部をオーバーライドします。 ように、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>、および<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>プロパティです。  
  
 さらに、プロパティのグループ、アプリケーションの現在の状態にアクセスするために役立ちます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>プロパティ ページでは、現在の表示モードを示します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A>プロパティでは、ユーザーのブラウザーは異なる機能を持つまたはになっているスクリプトがある可能性がありますの状況に関連するクライアント側スクリプトを表示するために、コントロールが許可されているかどうかを示します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>プロパティがいくつかの機能拡張の場合に使用される重要なの Web パーツ メソッドへの呼び出しを含むユーティリティ クラスを参照するのに役立ちます。 別のクラスでこれらのメソッドへの呼び出しを非表示にして (、<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>クラス) では、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの API が簡素化されます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>プロパティはユーザーの個人用設定を保存して、永続ストレージにデータを保持するパーソナル化オブジェクトへのアクセスを提供します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>プロパティかを示します<xref:System.Web.UI.WebControls.WebParts.WebPart>ページ上のコントロールは、ユーザーまたはアプリケーションが現在選択されています。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>プロパティを示すかどうかのカスタムのパーソナル化データ、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールが変更されました。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールでは、5 つ含まれている組み込みの表示モード、または Web ページのビューです。 開発者はこの機能を拡張できるように型を拡張することによってカスタムの表示モードの作成、<xref:System.Web.UI.WebControls.WebParts.WebZone>クラスまたは<xref:System.Web.UI.WebControls.WebParts.ToolZone>クラスです。 ユーザーは、する適切な種類の特定の表示モードに対応するコントロールがページ上に存在、さまざまな表示モードにページを切り替えることができます。  
  
> [!NOTE]
>  できるように、ユーザーが、しなくても、ページ上のゾーンに対応するカスタム表示モードに切り替えることができます、この機能を拡張することができます。 ただし、既定の動作は、表示モードがゾーンに対応することはできます。  
  
 標準の表示モードがのパブリック フィールドで表される、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスです。 次の表に、フィールドとを参照している表示モードを示します。 ページの現在の表示モード、上に示したように常にで参照される、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>プロパティ、および特定のページは、ページ上に存在するゾーンの種類を指定された使用可能な表示モードのセットに含まれる、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>プロパティです。  
  
|フィールド|モードの詳細を表示|  
|-----------|--------------------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|Web ページの通常のユーザーのビュー既定値と最も一般的な表示モード。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|ユーザーが再配置またはページ レイアウトを変更するコントロールを削除するビューです。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|編集のユーザー インターフェイス (UI) が表示されるビューユーザーには、外観、プロパティ、および通常のブラウズ モードで表示されるコントロールの動作を編集できます。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|カタログの UI が表示されるビューユーザーは、使用可能なコントロールのカタログからのページにコントロールを追加できます。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|接続の UI が表示されるビューユーザーは、接続、管理、またはコントロール間の接続を切断できます。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールには、複数の Web パーツ ページおよびコントロールのライフ サイクルで重要なイベントも含まれています。 これらのイベントは、Web パーツ コントロールの動作を正確にプログラムによる制御を提供します。 ほとんどのメソッドは直接関係<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール (またはその他のサーバーまたはユーザー コントロールに配置されている<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>として動作できるようにゾーン<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール)。 ただし、いくつかのイベントは、ページまたはページ上の接続の状態に関連します。 次の表は、使用可能なイベントとその用途をまとめたものです。  
  
> [!NOTE]
>  「コントロール」という単語を指す次の表に常に、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールまたはゾーン内に存在しでラップされます。 サーバー コントロール、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>実行時にオブジェクト。  
  
|event|説明|  
|-----------|-----------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|権限があることを確認する ページにコントロールを追加する前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|ページ上のすべての接続がアクティブ化された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|ページ上のすべての接続をアクティブ化するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|ページの現在の表示モードが変更された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|ページの表示モードを変更する処理の直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|コントロールの選択が取り消された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|コントロールの選択を解除のプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|コントロールがゾーンに追加した後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|ゾーンにコントロールを追加する処理の直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|(ページから削除される)、コントロールが閉じられた後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|コントロールの終了のプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|(1 つがプログラムによって作成されたか、カタログから追加される) 動的コントロールのインスタンスが完全に削除された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|ダイナミック コントロールを削除する処理の直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|そのゾーン内または別のゾーンにコントロールが移動した後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|コントロールを移動するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|接続の参加を選択した 2 つのコントロールの接続が確立した後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|2 つのコントロールを接続するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|2 つの接続されているコントロールが切断された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|2 つのコントロールを切断する処理の直前に発生します。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールに Web パーツ ページを管理するための多数のメソッドがあります。 ここでは、表示されていない、メソッドの大規模なセットは、メソッドの名前を持つが On の形式を取る*EventName*です。 これらのメソッドは通常、関連付けられたイベントを発生させるし、種類のハンドラーにイベントを提供<xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>です。 継承する開発者がこれらのメソッドのほとんどをオーバーライドすることができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスです。 また、ページの開発者は、これらのメソッドに関連付けられているイベントのカスタム ハンドラーを指定できます。 たとえばの場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>イベント、ページの開発者の追加でした、`OnWebPartAdded`属性を`<asp:webpartmanager>`カスタム メソッド名は、属性、イベントのカスタム処理を提供する Web ページと、割り当てのマークアップ内の要素。 属性に対応して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>メソッド、およびイベント処理のほとんどの Web パーツのイベントとその関連するメソッドのしくみの基本的なパターンです。  
  
 さらに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールに管理するためのタスクに固有のメソッドがある<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール (として使用されるサーバーまたはユーザー コントロールと<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール)。 これらのメソッドを含める<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>、および<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>です。  
  
 別の一連のメソッドは、接続に特化します。 などのメソッドが含まれます<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>、および<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>です。  
  
 最後に、いくつか<xref:System.Web.UI.WebControls.WebParts.WebPartManager>メソッドは、パーソナル化の機能に注目します。 これらを含める<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>、および<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>です。  
  
 その他の詳細については<xref:System.Web.UI.WebControls.WebParts.WebPartManager>経由でアクセスできるメソッド、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>プロパティ、ドキュメントを参照して、<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>クラスです。  
  
   
  
## Examples  
 次のコード例に示しますの宣言とプログラムの両方を使用して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。  
  
 このコード例では、4 つの部分があります。  
  
-   ユーザー コントロールを Web パーツ ページの表示モードを変更することができます。  
  
-   2 つのカスタムを含む Web ページ<xref:System.Web.UI.WebControls.WebParts.WebPart>接続可能なコントロールと`<asp:webpartmanager>`要素。  
  
-   2 つのカスタムを含むソース コード ファイル<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、およびカスタム インターフェイスです。  
  
-   ブラウザーでの例の動作についての説明。  
  
 ユーザー コントロールには、ページでは、ページ上に存在する Web パーツ コントロールの指定可能な表示モードを表示するドロップダウン リスト コントロールがあります。 すぐ下でこのコード例の Web ページで、このユーザー コントロールが宣言されている、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>ページのマークアップ内の要素があると、`Register`コントロールを登録する Web ページの上部にあるディレクティブです。 詳細については、このコントロールでモードと、ソース コードの説明を表示を参照してください[チュートリアル: Web パーツ ページの表示モードの変更](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)です。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/DisplayModeMenuVB.ascx#6)]  
  
 Web ページの宣言型マークアップを含む`Register`ユーザー コントロールとカスタム コントロールの両方のディレクティブ。 `<asp:webpartmanager>`要素、`<asp:webpartzone>`カスタム コントロールを追加する要素と`<asp:connectionszone>`要素。 ページにもいくつかの接続に関連するイベントを処理するインライン コードが含まれています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。 接続して、コントロールを切断すると、このコードの効果を確認できます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 例では、3 番目の部分では、コントロールのソース コードを示します。 という名前のインターフェイスがあることに注意してください`IZipCode`でこのインターフェイスを実装し、`ZipCodeWebPart`クラスです。 このクラスは、という名前の特殊なコールバック メソッドを持つ`ProvideIZipCode`プロバイダーとして機能します。 他の種類、名前付き`WeatherWebPart`、という名前の特殊なメソッドにも実装されています`GetIZipCode`、他のコントロールのコンシューマーとして機能するコントロールを有効にします。  
  
 コード例を実行するには、このソース コードをコンパイルする必要があります。 コンパイルするには明示的にし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに結果として得られるアセンブリを配置できます。 またはを動的にコンパイルされる実行時に、サイトの App_Code フォルダー内のソース コードを配置することができます。 このコード例では、アセンブリに、ソースをコンパイルして、 `Register` Web ページ ディレクティブが、アセンブリ名を参照します。 コンパイルする方法について説明するチュートリアルでは、次を参照してください。[チュートリアル: カスタム Web サーバー コントロールの開発と](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)です。  
  
 [!code-csharp[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/ZipCodeComponent.vb#2)]  
  
 ブラウザーで Web ページが読み込まれた後にをクリックして、**表示モード**ドロップダウン リスト コントロールと選択**接続**接続モードをページに切り替えます。 接続モードでは使用、`<asp:connectionszone>`要素を使用すると、コントロール間の接続を作成します。 接続モードのタイトル バーの下向き矢印をクリックして、**郵便**の動詞メニューをアクティブに制御し、をクリックして**接続**です。 接続の UI が表示されたら、クリックして、**コンシューマーへの接続を作成する**リンクします。 ドロップダウン リスト コントロールを含むセルが表示されます。 選択**気象コントロール**をクリックしてドロップダウン リスト**接続**2 つのコントロールの接続を完了します。 をクリックして**閉じる**、しを使用して、**表示モード**ドロップダウン リストに、ページを通常のブラウズ モードに戻ります。 ZIP コードを入力して、コンシューマーのコントロールが入力した値で更新されます。 `ZipCode`プロパティとして設定されていた、`Personalizable`ソース コードでこのプロパティの値の属性がブラウザー セッション間で保持されますので、ユーザーが入力した値を保存します。 高度なコンシューマー コントロールでは、郵便番号の情報を受け取る、コードに基づく天気情報を検索、およびユーザーに表示でした。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>
        <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />コントロールが拡張するように設計されています。 いくつか特定の型を拡張または Web パーツ コントロール セットの多くの場合で制御するときに、Web パーツ アプリケーションの中心を拡張する必要がありますもようになっているため、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />にいくつかのプロパティまたはために必要なメソッドを持つ可能性があるため、クラス カスタム型は、Web パーツ アプリケーションのコンテキストで動作します。 ドキュメントを参照して、Web パーツ (を参照してください<see cref="N:System.Web.UI.WebControls.WebParts" />) Web パーツを拡張する方法について説明する入力と、頻繁に拡張するために必要な参照投稿、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />同様に、クラスのコード例では拡張する方法を示しています。</para>
    </block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.%23ctor%2A>コンス トラクターで使用されるいくつかの重要な変数を初期化します、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。 すべての Web パーツ ページに直接影響を与える 1 つの割り当ては既定のページの表示モードは、ブラウズ モードに設定されているファクト (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateConnections">
      <MemberSignature Language="C#" Value="protected virtual void ActivateConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ActivateConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ActivateConnections ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ActivateConnections();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Web ページ上で現在アクティブでないすべての接続をアクティブにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>要求ごとに、ページ間の既存の接続をアクティブ化するメソッドが呼び出さ<xref:System.Web.UI.WebControls.WebParts.WebPart>内に存在する他のサーバー コントロールと<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーンです。 場合によっては、インスタンスがある場合、競合との接続にアクティブ化して、このメソッドに呼び出しに対する、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>メソッドを問題のある接続を終了します。 切断処理中に、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>イベントが発生します。 通常開発者がこのイベントを取り消すことができますが、大文字と小文字のためが取り消されることはできませんと接続の間で競合する、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールは、接続をアクティブ化するプロセスを完了するために、競合を解決する必要があります。 詳細については、「<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>イベント。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPart AddWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPart ^ AddWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">Web ページに追加するか、ページ上で開く <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (あるいは、サーバー コントロールまたはユーザー コントロール)。</param>
        <param name="zone">
          <c>webPart</c> の追加先となる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</param>
        <param name="zoneIndex">
          <c>zone</c> 内の他のコントロールに対して <c>zone</c> 内で <c>webPart</c> が占める序数位置を表す整数。</param>
        <summary>Web ページにプログラムで <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを追加する標準メソッドを提供します。</summary>
        <returns>ページに追加された <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>メソッドを使用して新しい動的を追加する両方<xref:System.Web.UI.WebControls.WebParts.WebPart>以前ページで閉じられている静的または動的のコントロールを再度開くには、ページを制御します。 実際にで参照されているコントロールのコピーを作成、新しいコントロールを追加するメソッドが呼び出されると、`webPart`パラメーター。 コントロールのコピーの新しい ID が生成される開発者が参照する必要がありますので、<xref:System.Web.UI.WebControls.WebParts.WebPart>新しい ID 値を取得するメソッドから制御が返されます。 によって参照される、コントロールへの直接参照を返しますそれ以前に閉じられたコントロールを再度開くには、メソッドが呼び出されると、`webPart`パラメーター。  
  
> [!IMPORTANT]
>  常に使用する必要があります、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>メソッドではなく、<xref:System.Web.UI.ControlCollection.Add%2A>によって参照されるコントロールのコレクションのメソッド、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=nameWithType>プロパティを追加する<xref:System.Web.UI.WebControls.WebParts.WebPart>にコントロールをプログラムによって、ページを使用しているため、<xref:System.Web.UI.ControlCollection.Add%2A>メソッドが例外をスローします。 はないコントロールを追加する、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール (言い換えるでラップされるサーバー コントロールを<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>実行時にコントロール)、最初に呼び出す必要があります、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>コントロールを作成し、呼び出すメソッド、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>コントロールを追加するメソッドをします。 この方法の例については、例」のセクションを参照してください。  
  
   
  
## Examples  
 次のコード例は、の使用を示します、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>ページにプログラムでサーバー コントロールを追加します。 ページのマークアップを含む、空`<asp:webpartzone>`要素、および`<asp:webpartmanager>`要素。 初めて、**予定表の追加**ボタンがクリックされた、コードは、イベント ハンドラーを作成、<xref:System.Web.UI.WebControls.Calendar>制御、およびとゾーンに追加、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>オブジェクトを呼び出す、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>メソッドです。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" />です。  
  
 \- または  
  
 <paramref name="zone" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="zone" /> が、ゾーンの <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールのコレクションに登録されていません。  
  
 \- または  
  
 <paramref name="webPart" /> は、既に <paramref name="zone" /> にあります。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="zoneIndex" /> の値が 0 未満です。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AuthorizeWebPart">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AuthorizeWebPart As WebPartAuthorizationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventHandler ^ AuthorizeWebPart;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" /> メソッドを呼び出すと発生し、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロールをページに追加できるかどうかを判断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>イベントが発生するたびに、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールがページに追加されています。 いくつかの一般的なシナリオがページにコントロールを追加できます。 これらの詳細については、「解説」セクションを参照してください、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>メソッドです。 コントロールを追加する場合を参照してくださいチェック必要があるかどうか、<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティが設定されている、必要な場合は、かどうか、コントロールが承認されると、ページに追加します。  
  
 開発者用のイベント ハンドラーを作成できます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>イベントに、コントロールのフィルター処理を実行します。 コントロールの場合、<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティの値は、イベント ハンドラーのコードで条件を満たしていない、コントロールがないページに追加します。  
  
   
  
## Examples  
 次のコード例は、カスタム イベント ハンドラーを設定する方法を示します、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>イベントで、既定値が自動的に上書き<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>メソッドです。  
  
 内のコード、`mgr1_AuthorizeWebPart`メソッドでは、ページ上のコントロールが対応するかどうかをチェック<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティの値に設定`user`し、必要な場合を返します`true`、ことが承認され、ページに追加することを意味します。 これは、既定のアプローチは、ユーザーのパーソナル化スコープ内のページにコントロールを表示できるようにすると仮定します。 注意してください、ただし、あるコントロールのいずれかの例ではその<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティ値に設定`admin`です。 開発者は、管理ユーザーのみに表示用に設計された特殊なコントロールにこのフィルターをかける場合があります。 このコントロールの中に承認チェックが失敗、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>イベント、およびは表示されません。 プロパティの設定がないコントロールが同様に表示されることに注意してください。フィルター処理の一部にするためにしないしたと見なされます、<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティが設定されていません。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
      </Docs>
    </Member>
    <Member MemberName="AvailableTransformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableTransformers As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ AvailableTransformers { System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールの間に Web パーツ接続を作成する場合に使用できる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> オブジェクトのコレクションを取得します。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.TransformerTypeCollection" /> オブジェクトのセットが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>メソッドをコレクションを作成します。 既定では、アプリケーション構成ファイルから使用可能なトランスフォーマーを読み取ります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartConnecting(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartConnecting(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">接続を構成するコントロール。</param>
        <summary>2 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを接続するプロセスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>メソッドが存在できるように、コントロール間の接続を形成するプロセスは、接続のプロセスより詳細に制御を開発者に提供、独立した段階で実行できます。 メソッドは、一連のことを確認する初期チェックを実行`webPart`が、接続が作成することができます正当な状態にします。 場合`webPart`すべてのチェックに合格し、現在選択されているコントロールとして設定されている (を参照してください、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>プロパティ)、および接続の処理を続行できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">ページ上の現在の表示モードが <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" /> ではありません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> は閉じています。  
  
 \- または  
  
 <paramref name="webPart" /> が <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コレクションの一部ではありません。  
  
 または  
  
 <paramref name="webPart" /> と <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> コントロールが等価です。</exception>
        <block subset="none" type="overrides">
          <para>拡張する必要がある開発者、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />コントロールが派生クラスでは、このメソッドをオーバーライドする可能性があります。 1 つの方法は、基本メソッドを呼び出し、いくつか追加のカスタム処理を追加することまたは、コントロール間の接続を開始するプロセスを完全にカスタマイズすることがあります。 たとえば、接続を作成する前に、特定のデータが使用できることを確認することができます。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartEditing(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartEditing(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">編集対象のコントロール。</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを編集するプロセスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>メソッドが存在できるように、コントロールの編集のプロセスは、プロセスをより詳細に制御を開発者に提供、独立した段階で実行できます。 メソッドは、一連のことを確認する初期チェックを実行`webPart`が編集できる状態にします。 場合`webPart`すべてのチェックに合格し、現在選択されているコントロールとして設定されている (を参照してください、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>プロパティ)、および編集の処理を続行できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">ページ上の現在の表示モードが <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" /> ではありません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> は閉じています。  
  
 \- または  
  
 <paramref name="webPart" /> が <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コレクションの一部ではありません。  
  
 または  
  
 <paramref name="webPart" /> と <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> コントロールが等価です。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      </Docs>
    </Member>
    <Member MemberName="BrowseDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BrowseDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ BrowseDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web パーツ コントロールが含まれたページの既定の表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>フィールドが参照するカスタム<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>が作成されに含まれているオブジェクト、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。 これは、静的オブジェクトであるためを参照できます、経由で直接、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>しなくても、コントロールのインスタンスのクラスです。  
  
 Web パーツを含むページは、最初に読み込まれるを制御するときに<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>(ブラウズ モード) 既定でします。 参照するときのユーザーは単に通常の Web ページの場合し、ページはブラウズ モードのままです。 使用できる特殊な表示モードのいずれかに、ページを切り替える必要がありますユーザーがページのレイアウト、コントロール、外観、または動作をカスタマイズする場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>プロパティです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>プログラムでフィールドです。 コードでは、参照と設計をここでは、サポートされている表示モードのドロップダウン リストを生成します。 いることを確認、`Page_PreRender`メソッドは、コードのチェックするかどうか、現在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>プロパティに設定されている<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>です。 場合は、 `Label1` 、表示される、存在しない場合`Label1`は表示されません。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/CS/wpmgrBrowseDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/VB/wpmgrBrowseDisplayModevb.aspx#1)]  
  
 ブラウザーでページを読み込んだ後は、既定ではブラウズ モードでは。 ブラウズ モードであることを示します、ページ上のラベルに注意してください。 ドロップダウン リスト コントロールを使用して、ページをデザイン モードに切り替えます。 内のコードによりいることを確認、`Page_PreRender`メソッド、ラベルが非表示します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続に関係する <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールをチェックし、こうしたコントロールを接続できるかどうかを判断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>メソッドを使用して 2 つあるかどうかを判断<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールを接続することができます。 メソッドが呼び出しの前に、条件の確認として使用は、通常、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>メソッドです。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>メソッドは、2 つのコントロールが接続を構成する前に満たす必要がある条件の数をチェックします。 次の一覧は、接続を行うための主な条件をまとめたものです。 メソッドを返しますのかどうかは、これらすべての条件 (およびその他の内部条件) が満たされて、`true`コントロールが接続することを意味します。  
  
-   プロバイダーとコンシューマーのコントロールですることはできません`null`、によって参照されるコントロールのコレクション内に含まれる必要があります、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>プロパティです。  
  
-   プロバイダーとコンシューマーは、同じコントロールをすることはできません。 つまり、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール自体に接続することはできません。  
  
-   <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint>コンシューマーとプロバイダーの両方のオブジェクト (接続ポイント) にすることはできません`null`です。  
  
-   プロバイダーおよびコンシューマーを閉じることができません (どちらのコントロールの<xref:System.Web.UI.WebControls.WebParts.WebPart.IsClosed%2A>プロパティを指定できます`true`)。  
  
-   <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ControlType%2A>接続ポイントのコントロールのプロパティがコンシューマーおよびプロバイダーの両方のコントロールの種類と一致する必要があります。  
  
-   接続ポイントを共に有効にする必要があります (その<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.GetEnabled%2A>両方メソッド`true`)。  
  
-   各接続ポイントが、独自に指定する内容よりも多くの接続を作成するしようとする必要がありますいない<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A>プロパティです。  
  
-   場合、<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>は、オブジェクト (transformer) が互換性のないコントロールを接続に必要なことはできません`null`です。 ただし場合、コントロールは、互換性のあるは既に、トランスフォーマーあります`null`です。  
  
-   参照する必要があります (使用する場合)、(トランスフォーマーを)、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>コレクション。  
  
-   トランスフォーマー (使用する場合) には、2 つのコントロールの間でデータを変換できるように、プロバイダーとコンシューマーと互換性のあるインターフェイスが必要です。 コンシューマーおよびプロバイダーのセカンダリ インターフェイスも互換性がある場合があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">コントロールを接続したときに、<c>コンシューマー</c>にデータを提供するコントロール。</param>
        <param name="providerConnectionPoint">
          <c>プロバイダー</c>が接続に関与できるようにする <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />。</param>
        <param name="consumer">コントロールを接続したときに、<c>プロバイダー</c>からデータを受け取るコントロール。</param>
        <param name="consumerConnectionPoint">
          <c>コンシューマー</c>が接続に関与できるように、コールバック メソッドとして機能する <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />。</param>
        <summary>コンシューマー コントロールとプロバイダー コントロールが互換性のあるインターフェイスを持ち、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> オブジェクトが不要な場合に、接続に関係する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> コントロールをチェックし、こうしたコントロールを接続できるかどうかを判断します。</summary>
        <returns>
          <paramref name="provider" /> と <paramref name="consumer" /> を接続できるかどうかを示すブール値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは接続に使用`provider`と`consumer`両方のコントロール ポイントの種類、互換性のある接続しているときにできるように、<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>オブジェクトは必要ありません。 このメソッドを使用して、2 つのコントロールを呼び出す前に接続できることを確認する<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>プログラムによる接続を作成します。  
  
 このオーバー ロードと同じ実装を使用して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29>トランスフォーマーがこのオーバー ロードに必要としないことをする唯一の例外で、メソッドのオーバー ロードします。  
  
   
  
## Examples  
 次のコード例では、このメソッドを使用する方法を示します。  
  
 このコード例では、4 つの部分があります。  
  
-   ユーザー コントロールを Web パーツ ページの表示モードを変更することができます。  
  
-   2 つのカスタムを含む Web ページ<xref:System.Web.UI.WebControls.WebParts.WebPart>、接続できるコントロール、`<asp:webpartmanager>`要素、および一部のイベント処理コードを使用して接続を作成する、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>メソッドです。  
  
-   2 つのカスタムを含むソース コード ファイル<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、およびカスタム インターフェイスです。  
  
-   ブラウザーでの例の動作についての説明。  
  
 コード例の最初の部分は、ユーザー コントロールの表示モードを変更するためです。 セクションの例からユーザー コントロールのソース コードを取得することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要です。 表示モードとユーザー コントロールの動作方法の詳細については、次を参照してください。[チュートリアル: Web パーツ ページの表示モードの変更](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)です。  
  
 Web ページの宣言型マークアップを含む`Register`ユーザー コントロールとカスタム コントロールの両方のディレクティブ。 `<asp:webpartmanager>`要素、`<asp:webpartzone>`カスタム コントロールを追加する要素と`<asp:connectionszone>`要素。 注意、`Page_Load`メソッド、コードをチェックするかどうか、接続にできるし場合は、プロバイダー、コンシューマーと、それぞれのコネクション ポイントを定義し、によって参照される静的な接続のセットに新しい接続を追加し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>プロパティです。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 例では、3 番目の部分では、コントロールのソース コードを示します。 インターフェイスと 2 つのカスタムが含まれている<xref:System.Web.UI.WebControls.WebParts.WebPart>には、プロバイダー、およびコンシューマーとして、その他の役割を果たす 1 です。 互換性のある接続ポイントがあるため (それらの両方を認識、`IZipCode`インターフェイス)、トランスフォーマーは接続を確立する必要はありません。 コード例を実行するには、このソース コードをコンパイルする必要があります。 コンパイルするには明示的にし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに結果として得られるアセンブリを配置できます。 またはを動的にコンパイルされる実行時に、サイトの App_Code フォルダー内のソース コードを配置することができます。 コンパイルする方法について説明するチュートリアルでは、次を参照してください。[チュートリアル: カスタム Web サーバー コントロールの開発と](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)です。  
  
 [!code-csharp[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/ZipCodeComponent.vb#2)]  
  
 ブラウザーで Web ページが読み込まれた後にをクリックして、**表示モード**ドロップダウン リスト コントロールと選択**接続**接続モードをページに切り替えます。 接続モードでは使用、`<asp:connectionszone>`要素を使用すると、コントロール間の接続を作成します。 接続モードのタイトル バーの下向き矢印をクリックして、**郵便**の動詞メニューをアクティブに制御し、をクリックして**接続**です。 接続のユーザー インターフェイス (UI) が表示されたらに含まれているコードによって、接続を作成されていることに注意してください、`Page_Load`メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">コントロールを接続したときに、<c>コンシューマー</c>にデータを提供するコントロール。</param>
        <param name="providerConnectionPoint">
          <c>プロバイダー</c>が接続に関与できるように、コールバック メソッドとして機能する <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />。</param>
        <param name="consumer">コントロールを接続したときに、<c>プロバイダー</c>からデータを受け取るコントロール。</param>
        <param name="consumerConnectionPoint">
          <c>コンシューマー</c>が接続に関与できるように、コールバック メソッドとして機能する <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />。</param>
        <param name="transformer">互換性のない<c>プロバイダー</c>と<c>コンシューマー</c>の接続を可能にする <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />。</param>
        <summary>接続に関係する <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールをチェックして、こうしたコントロールが接続可能かどうかを判断し、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> オブジェクトを使用して互換性のないコンシューマーとプロバイダーの間に接続を作成します。</summary>
        <returns>
          <paramref name="provider" /> と <paramref name="consumer" /> で接続を構成できるかどうかを示すブール値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは接続に使用`provider`と`consumer`両方のコントロール ポイントの種類、互換性のない接続しているときにできるように、<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>オブジェクトが必要です。 このメソッドを使用して、2 つのコントロールを呼び出す前に接続できることを確認する<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>プログラムによる接続を作成します。  
  
 このオーバー ロードと同じ実装を使用して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29>トランスフォーマーを必要とするこのオーバー ロードされている唯一の例外で、メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CatalogDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ CatalogDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのカタログから Web ページにサーバー コントロールを追加する場合に使用する表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>フィールドが参照するカスタム<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>が作成されに含まれているオブジェクト、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。 これは、静的オブジェクトであるためを参照できます、経由で直接、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>しなくても、コントロールのインスタンスのクラスです。  
  
 ページを切り替えることがユーザーは、サーバー コントロールのカタログが使用可能な場合は、ページにコントロールを追加する場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> (カタログ モード)、およびカタログのユーザー インターフェイス (UI) が表示されます。 Web パーツのカタログの UI がによって提供される、<xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase>ゾーンのコントロールです。 開発者は、デザイン時に、ページにこのゾーンを追加し、ユーザーが実行時に、ページへのそれらのコントロールを追加できるように、サーバー コントロールをゾーンに追加します。 開発者がこれらのコントロールを追加後カタログ モードを有効にするために必要なコントロールがあるためカタログ モード ページでサポートされている表示モードになります。  
  
 ときに切り替えた場合、モード、ゾーン、および、表示されることに追加されたすべてのサーバー コントロールのカタログ ページと、ユーザーは、ページを追加またはコントロールをページから削除するカタログからコントロールを選択することができます。 コントロールをページに追加した後、は、通常のブラウズ モードで表示され、ページが更新されました。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>プログラムでフィールドです。 コードでは、参照、設計、およびカタログをここでは、ページのサポートされている表示モードのドロップダウン リストを生成します。 カタログのモードがのために使用できる、`<asp:CatalogZone>`要素とその子要素の Web ページ。 いることを確認、`Page_PreRender`メソッドは、コードのチェックするかどうか、現在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>プロパティに設定されている<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>です。 場合は、 `Label1` 、表示される、存在しない場合`Label1`は表示されません。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/CS/wpmgrCatalogDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/VB/wpmgrCatalogDisplayModevb.aspx#1)]  
  
 ブラウザーでページを読み込んだ後は、既定ではブラウズ モードでは。 ページ上のラベルが非表示になっていることを確認します。 ドロップダウン リスト コントロールを使用して、ページをカタログ モードに切り替えます。 内のコードによりいることを確認、`Page_PreRender`メソッドをラベルが表示されるようになりました。 カタログでコントロールを選択でき、ページ上の 2 つのゾーンのいずれかに追加することができます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="CheckRenderClientScript">
      <MemberSignature Language="C#" Value="protected virtual bool CheckRenderClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckRenderClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CheckRenderClientScript () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckRenderClientScript();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ブラウザーから要求を行う機能および <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" /> プロパティの値をチェックし、クライアント スクリプトを表示するかどうかを判断します。</summary>
        <returns>クライアント スクリプトを表示するかどうかを示すブール値。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      </Docs>
    </Member>
    <Member MemberName="CloseProviderWarning">
      <MemberSignature Language="C#" Value="public virtual string CloseProviderWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CloseProviderWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CloseProviderWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CloseProviderWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>接続で他のコントロールに対するプロバイダーとして動作しているコントロールをユーザーが終了すると表示される警告を取得または設定します。</summary>
        <value>警告メッセージが含まれた文字列。 既定値は、.NET Framework が提供するカルチャ固有のメッセージです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーが閉じるとき、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールを通常メッセージは表示されません。 コントロールを終了する意味の詳細については、次を参照してください。、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>メソッドです。  
  
 ただし、コントロールは、別のコントロールに接続されているし、その他のコントロールへのデータ プロバイダーとして機能している、ときに、既定の警告メッセージが表示されます、ユーザーがコントロールを終了しようとしたとき。 メッセージは、プロバイダーのコントロールがある、閉じようを制御することを意味は、コンシューマーは、任意のデータを使用するようにこのプロバイダーに接続されているをユーザーに指示します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>プロパティにより、開発者は、ユーザーに表示される警告メッセージをカスタマイズします。  
  
 場合はページの開発者には、このプロパティを空または null の文字列値が割り当てられ、警告メッセージ ボックスは表示されませんユーザーが閉じたときに、<xref:System.Web.UI.WebControls.WebParts.WebPart>プロバイダーであるコントロールです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>プロパティをユーザーにカスタム警告を表示します。  
  
 このコード例では、4 つの部分があります。  
  
-   ユーザー コントロールを Web パーツ ページの表示モードを変更することができます。  
  
-   2 つのカスタムを含むソース コード ファイル<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールとカスタム インターフェイスです。  
  
-   2 つのカスタムを含む Web ページ<xref:System.Web.UI.WebControls.WebParts.WebPart>接続可能なコントロールと`<asp:webpartmanager>`要素。  
  
-   ブラウザーでの例の動作についての説明。  
  
 次のコードには、例の Web ページの部分のみが含まれています。 上記で説明したカスタム コントロールのソース コードとカスタム ユーザー コントロールも必要になります。 使用例」セクションから 2 つの項目を取得、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要です。  
  
 次の Web ページ コードをカスタム警告メッセージを割り当てる方法を示します、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>プロパティの宣言型マークアップに、`<asp:webpartmanager>`要素。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 ブラウザーで Web ページが読み込まれた後にをクリックして、**表示モード**ドロップダウン リスト コントロールと選択**接続**接続モードをページに切り替えます。 接続モードでは使用、`<asp:connectionszone>`要素を使用すると、コントロール間の接続を作成します。 接続モードのタイトル バーの下向き矢印をクリックして、**郵便**の動詞メニューをアクティブに制御し、をクリックして**接続**です。 接続のユーザー インターフェイス (UI) が表示されたら、クリックして、**コンシューマーへの接続を作成する**リンクします。 ドロップダウン リスト コントロールを含むセルが表示されます。 選択**気象コントロール**でクリックしてドロップダウン リストで**接続**2 つのコントロールの接続を完了します。 をクリックして**閉じる**、しを使用して、**表示モード**ドロップダウン リストに、ページを通常のブラウズ モードに戻ります。 最後に、動詞メニューをクリックして、**郵便**して (これはプロバイダー コントロールここでは) コントロールを選択**閉じる**です。 カスタム メッセージに割り当てられている、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>プロパティが表示されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseWebPart">
      <MemberSignature Language="C#" Value="public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 内の終了する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> コントロールまたはサーバー コントロール。</param>
        <summary>Web ページ上に表示されなくても再度開くことができる方法で <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>メソッドの削除、<xref:System.Web.UI.WebControls.WebParts.WebPart>またはその他のサーバー制御できるように、最初に含まれている Web ページではレンダリングされません。 閉じたコントロールを追加、<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>オブジェクトでは、閉じたコントロールへの参照を保持し、ページを復元するコントロールできるようになります。 閉じた<xref:System.Web.UI.WebControls.WebParts.WebPart>によって参照されるコレクションにコントロールが表示されたまま、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>プロパティです。  
  
 コントロールの終了は、削除すると異なります。 閉じたコントロールは、ページを復元するには使用できますが、削除されたコントロールのインスタンスは完全に削除しは復元できません。 かどうかに関係なく、<xref:System.Web.UI.WebControls.WebParts.WebPart>またはサーバー コントロールが (ページのマークアップで宣言) 静的または動的な (追加のページにプログラムから、またはユーザーが Web パーツのカタログから)、閉じられたし、ページで再度開くことができます。  
  
 通常、ユーザーが閉じることができます、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール動詞メニューをクリックして閉じる動詞を選択します。 直接呼び出すことにより、コントロールを終了することも、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>メソッドへの参照を渡すと`webPart`です。  
  
 ページ上、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール閉じられている、開発者が宣言する場合、`<asp:catalogzone>`要素、内に追加し、`<asp:pagecatalogpart>`要素、シンプルなユーザー インターフェイス (UI) を閉じたコントロールをページに実行時に復元するユーザーに提供します。 ユーザーを使用して、ページをカタログの表示モードに切り替えることができ、ページ カタログ内では閉じたコントロールが表示されます。 ユーザーは閉じたコントロールを選択して、それらを追加の任意の位置はページに戻ると、選択したコントロールは、ページを復元し、通常どおり表示されます。  
  
 ときに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>メソッドが呼び出されると、いくつかのイベントを発生させます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> (場合がある複数のコントロールを)、および<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>(接続されているコントロールがある) 場合。 通常開発者がこれらのイベントを取り消すことができますが、場合によってはキャンセルすることです。 詳細については、ドキュメントを参照して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>、および<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>イベント。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> メソッドの使用方法を示します。  
  
 このコード例では、4 つの部分があります。  
  
-   ユーザー コントロールをページの表示モードを変更することができます。  
  
-   カスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。  
  
-   Web ページです。  
  
-   ブラウザーでの例の動作についての説明。  
  
 コード例の最初の部分は、ユーザー コントロールの表示モードを変更するためです。 セクションの例からユーザー コントロールのソース コードを取得することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要です。 表示モードとユーザー コントロールの動作方法の詳細については、次を参照してください。[チュートリアル: Web パーツ ページの表示モードの変更](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)です。  
  
 コード例の 2 番目の部分は、カスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。 コード例を実行するには、このソース コードをコンパイルする必要があります。 コンパイルするには明示的にし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに結果として得られるアセンブリを配置できます。 またはを動的にコンパイルされる実行時に、サイトの App_Code フォルダー内のソース コードを配置することができます。 この例は、動的コンパイルのアプローチを使用してください。したがってがありますいない`Assembly`属性、 `Register` Web ページの上部にあるこのコントロールのディレクティブ。 コンパイルする方法について説明するチュートリアルでは、次を参照してください。[チュートリアル: カスタム Web サーバー コントロールの開発と](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)です。  
  
 [!code-csharp[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/textdisplaywebpart.vb#3)]  
  
 コード例の 3 番目の部分は、Web ページです。 ページが含まれています、<xref:System.Web.UI.WebControls.WebParts.CatalogZone>ゾーンで、<`asp:pagecatalogpart>`内に要素が宣言されています。 これは、閉じた内容<xref:System.Web.UI.WebControls.WebParts.WebPart>を制御し、ユーザーのページに追加できるようにします。 `Button1_Click`メソッドを直接呼び出す、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>カスタムを閉じます<xref:System.Web.UI.WebControls.WebParts.WebPart>動詞メニューを使用してコントロールを閉じることも、ユーザーを制御します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/closeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/closeWebPartVB.aspx#1)]  
  
 ブラウザーでページを読み込むと、閉じる、カスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>、コントロールのヘッダーの動詞メニュー (矢印) をクリックしてコントロール**閉じる**です。 これでページを変更するカタログ モードを選択して**カタログ**で、**表示モード**ドロップダウン リスト コントロール。 終了したコントロールがページ カタログが表示されます。 終了したコントロールの横にあるチェック ボックスを選択し、をクリックして**追加**、ページに追加し、をクリックする**閉じる**ブラウズ モードをページに戻します。 コントロールがページに復元されます。 今すぐ閉じて、再度 をクリックして、 **WebPart を閉じる**ボタンをクリックします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> が <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コレクション内にありません。  
  
 \- または  
  
 <paramref name="webPart" /> は共有コントロールで、別のユーザーによって既に終了されています。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowClose" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
      </Docs>
    </Member>
    <Member MemberName="ConnectDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ConnectDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ ConnectDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーが <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール間の接続を管理するための特殊なユーザー インターフェイス (UI) を表示する場合に使用する表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>フィールドが参照するカスタム<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>が作成されに含まれているオブジェクト、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。 これは、静的オブジェクトであるためを参照できます、経由で直接、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>しなくても、コントロールのインスタンスのクラスです。  
  
 ユーザーがの間の接続を管理する<xref:System.Web.UI.WebControls.WebParts.WebPart>されている場合、Web ページ上の制御、<xref:System.Web.UI.WebControls.WebParts.ConnectionsZone>ゾーン ページで宣言されていますが、それらにページを切り替えることができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>モード。 接続の表示モードには、接続するか、コントロールを切断し、既存の接続の詳細を編集する機能があります、接続を管理するための特別な UI が表示されます。  
  
 Web パーツ コントロール セットによって提供される UI を使用した接続を管理する権限をユーザーに提供するかどうかは、宣言する必要あります、`<asp:connectionszone>`ページのマークアップ内の要素。 他の種類の要素とは異なり<xref:System.Web.UI.WebControls.WebParts.WebZone>ゾーンでは、この要素内の他のすべてのタグを追加する必要はありません以外の場合はそれ自体で要素を宣言するだけです。  
  
   
  
## Examples  
 次のコード例は、の使用法を示しています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>モード。  
  
 このコード例では、3 つの部分があります。  
  
-   インターフェイスとユーザー設定を含むソース ファイル<xref:System.Web.UI.WebControls.WebParts.WebPart>接続を構成するコントロール。  
  
-   Web ページを UI の接続を提供し、操作を示しています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>モード。  
  
-   この例を実行する方法の説明。  
  
 このコード例の最初の部分は、インターフェイスと 2 つのカスタムを含むソース ファイル<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールを接続できるように設計されています。 コード例を実行するには、このソース コードをコンパイルする必要があります。 コンパイルするには明示的にし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに結果として得られるアセンブリを配置できます。 またはを動的にコンパイルされる実行時に、サイトの App_Code フォルダー内のソース コードを配置することができます。 このコード例では、動的コンパイルのアプローチを使用します。 コンパイルする方法について説明するチュートリアルでは、次を参照してください。[チュートリアル: カスタム Web サーバー コントロールの開発と](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)です。  
  
 [!code-csharp[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ZipCodeComponent.vb#2)]  
  
 例の 2 番目の部分は、カスタム コントロールをホストする Web ページです。 サーバー内で`<script>` ページでのタグは、ページで使用可能な表示モードのドロップダウン リストに設定するいくつかの方法です。 ユーザーは、これらのページの表示モードを変更するドロップダウン リストから選択できます。 使用可能な表示モードのいずれかでは、表示モードの接続、`<asp:connectionszone>`要素はページのマークアップで宣言されています。 この要素に、その他の子要素が含まれていないことに注意してください。ユーザーの接続の管理 UI を有効にする場合にのみ存在します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>モードは、この例では、2 つの場所が表示されます。 最初に、`Page_Init`メソッド、接続の表示モードとしてに追加、表示モードのドロップダウン リストで参照されるコレクションをループ処理、コード、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>プロパティです。 2 番目、`Page_PreRender`メソッド チェック ページで、現在の表示モードであり、現在のモードは<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>でメッセージが表示されます、<xref:System.Web.UI.WebControls.Label>コントロール。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ConnectDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ConnectDisplayModeVB.aspx#1)]  
  
 ドロップダウン リストをクリックし、選択、ブラウザーでページを読み込んだ後**接続**接続表示モードに切り替えるにします。 メッセージが表示し、ページが、該当する接続の表示モードを示すことがわかります。 1 つのタイトル バーの動詞メニュー (矢印) をクリックして、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、およびクリック**接続**動詞メニューにします。 接続を作成するリンクをクリックして、接続された後で、UI が表示されます。 接続に表示される UI 内でのドロップダウン リストを使用して、その他のコントロールは、接続に参加しをクリックしてを選択、**接続**ボタンをクリックします。 接続を確立します。 クリックして、**閉じる**ボタンをクリックし、表示モードを参照するページを返すため、ページの上部にあるドロップダウン リストを使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="Connections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ Connections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上の現在の接続すべてのコレクションへの参照を取得します。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> オブジェクトのセットが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>プロパティはページ上の接続の現在のセットにアクセスする手段を提供します。 コレクション自体は読み取り専用コレクションから特定の接続を操作する開発者向けを使用して<xref:System.Web.UI.WebControls.WebParts.WebPartManager>などのメソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>と<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>です。  
  
   
  
## Examples  
 次のコード例に示しますの宣言とプログラムを使用して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。  
  
 このコード例では、4 つの部分があります。  
  
-   ユーザー コントロールを Web パーツ ページの表示モードを変更することができます。  
  
-   2 つのカスタムを含む Web ページ<xref:System.Web.UI.WebControls.WebParts.WebPart>接続可能なコントロールと`<asp:webpartmanager>`要素。  
  
-   2 つのカスタムを含むソース コード ファイル<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールとカスタム インターフェイスです。  
  
-   ブラウザーでの例の動作についての説明。  
  
 次のコードには、例の Web ページの部分のみが含まれています。 上記で説明したカスタム コントロールのソース コードとカスタム ユーザー コントロールも必要になります。 使用例」セクションから 2 つの項目を取得、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要です。  
  
 次の Web ページ コードを使用する方法を示しています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>ページ上の現在の接続の数を取得するには、プログラムによってプロパティです。 において、`<script>`タグに関するセクションの 2 つのイベントを処理するコード、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>へのアクセスを制御、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>カウントを取得するプロパティです。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 ブラウザーで Web ページが読み込まれた後にをクリックして、**表示モード**ドロップダウン リスト コントロールと選択**接続**接続モードをページに切り替えます。 接続モードでは使用、`<asp:connectionszone>`要素を使用すると、コントロール間の接続を作成します。 接続モードのタイトル バーの下向き矢印をクリックして、**郵便**の動詞メニューをアクティブに制御し、をクリックして**接続**です。 接続のユーザー インターフェイス (UI) が表示されたら、クリックして、**コンシューマーへの接続を作成する**リンクします。 ドロップダウン リスト コントロールを含むセルが表示されます。 選択**気象コントロール**でクリックしてドロップダウン リストで**接続**2 つのコントロールの接続を完了します。 をクリックして**閉じる**、しを使用して、**表示モード**ドロップダウン リストに、ページを通常のブラウズ モードに戻ります。 ラベルは、接続の数と数のようになりましたが表示されるに注意してください<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。 今すぐに接続モードと、2 つの接続を切断するコントロールをブラウズ モードに戻るときに返される場合は、ラベルのコンテンツを更新する必要があり、接続ことはありません。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ上の現在の Web パーツ接続すべてが接続され、さらにそれぞれの接続に関係するコンシューマー コントロールとプロバイダー コントロールの間にアクティブなデータの共有が開始された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続のライフ サイクルでは、このイベントは、ページの読み込みプロセスの完了後に発生します。 後にも発生、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>イベントで、ことを示すだけ、<xref:System.Web.UI.WebControls.WebParts.WebPart>または特定の接続に関係するサーバー コントロールが正常に接続されています。 場合、ページ上の複数の接続がある場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>メソッドでは、ページ上のすべての有効な Web パーツ接続が現在アクティブなとデータを共有することを示します。 すべての接続がアクティブである理解していれば、開発者を実行できます任意の数を含むすべての接続の状態のユーザーへの通知タスクの処理をプロバイダーからデータを表示しへのコントロールのコンシューマーに通知します。  
  
 このイベントに関連付けられている、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A>メソッドは、イベントを発生させるイベントのカスタム ハンドラーを作成できるようにします。  
  
 ページの開発者は、追加することで、カスタム イベントのハンドラーを作成することができます、`OnConnectionsActivated`属性を`<asp:webpartmanager>`属性にカスタム メソッドの名前を割り当て、ページにある要素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivating">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivating As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivating;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上で確立されたすべての Web パーツ接続をアクティブにするプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ページを完了して、読み込みプロセスでは、直前に、接続のライフ サイクルでこのイベントは発生、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>メソッドが呼び出されます。 異なる、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>間の特定の接続が行われるイベント<xref:System.Web.UI.WebControls.WebParts.WebPart>またはその他のサーバー コントロールです。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>イベント ページで使用可能なすべての接続が接続されたアクティブ化しようとしているときに発生します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>イベントに関連付けられている、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>メソッドで、イベントを発生させます。 ページに追加できる接続の種類を拡張するコントロールの開発者は、保護されたオーバーライドでした<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>メソッドおよびその他の種類の接続をアクティブ化します。  
  
 ページの開発者は、追加することで、カスタム イベントのハンドラーを作成することができます、`OnConnectionsActivating`属性を`<asp:webpartmanager>`属性にカスタム メソッドの名前を割り当て、ページにある要素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーン内に存在する 2 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> コントロール (または、接続を構成できるその他のサーバー コントロール) の間に接続を作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>メソッドが任意の 2 つの間の接続をフォーム<xref:System.Web.UI.WebControls.WebParts.WebPart>接続できるコントロールです。 接続を作成するには、このメソッドを呼び出す前にすることもを呼び出して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>コントロールが接続を形成するための要件を満たしていることを確認する条件の確認方法。  
  
> [!NOTE]
>  2 つのサーバー コントロールの間の接続を作成することも<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。 一般に、2 つある必要がありますサーバーのカスタム コントロール (から継承するコントロールなど、<xref:System.Web.UI.WebControls.WebControl>または既存の ASP.NET サーバー コントロール)、必要なメンバーを追加することができるようにします。 コントロールは、以下で指定した要件を満たすことも必要があります。  
  
 任意の型の 2 つのコントロール間の接続シナリオでは、接続するのには、次の要件を満たす必要があります。  
  
-   各コントロールが存在する、<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーン (同じゾーンするは必要ありません)。  
  
-   接続のプロバイダーのコントロールがインターフェイスを実装する、プロバイダーにコールバックとして機能を持つパブリック メソッドとして、Web パーツ コントロール セットに実装された、`ConnectionProvider`プロバイダー接続として識別するメソッドのメタデータ属性ポイントです。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>取得プロバイダー接続ポイントが仮想であるメソッドは、派生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールとは限りませんが、同じメタデータ属性を使用します。  
  
-   実装されると、Web パーツ コントロール セットで、接続のコンシューマー コントロールも、プロバイダーのコールバック メソッドで公開されているインターフェイスへの参照を取得できるようにする特殊なメソッドがあり、コンシューマー、`ConnectionConsumer`のメタデータ属性コンシューマー接続として識別するメソッドをポイントします。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>取得コンシューマー接続ポイントが仮想であるメソッドは、派生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールとは限りませんが、同じメタデータ属性を使用します。  
  
-   コールバック メソッドは互換性があるかする必要があります、プロバイダーのコールバック メソッドが (つまり、あるコンシューマーおよびプロバイダー データを共有できます直接)、または開発者に提供されているインターフェイスを使用する必要がありますが、コンシューマーの種類を使用できます、<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>オブジェクトをプロバイダーからのデータをコンシューマーが使用できる形式に変換します。  
  
    > [!IMPORTANT]
    >  トランスフォーマーを使用する必要はありません、ときに使用して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29>メソッドのオーバー ロードします。 トランスフォーマーを必要なときに使用して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29>メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">接続されたもう一方のコントロールにデータを提供する役割を持つ <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</param>
        <param name="providerConnectionPoint">接続のコールバック メソッドとして機能するメソッド。 Web パーツ コントロール セットに実装するときに、<c>プロバイダー</c>のパブリック メソッドを <see langword="ConnectionProvider" /> メタデータ属性でマークします。</param>
        <param name="consumer">
          <c>プロバイダー</c>からデータを受け取り、それを処理するか表示する役割を持つ <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</param>
        <param name="consumerConnectionPoint">
          <c>providerConnectionPoint</c> に接続し、接続のデータを受け取るメソッド。 Web パーツ コントロール セットに実装するときに、<c>コンシューマー</c>のパブリック メソッドを <see langword="ConnectionConsumer" /> メタデータ属性でマークします。</param>
        <summary>コントロールへの参照とその指定された <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> オブジェクトだけを使用して、2 つの <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> コントロールまたは <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> コントロールの間に接続を作成します。</summary>
        <returns>接続に必要なプロバイダーとコンシューマーに関するさまざまな情報が格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードは、接続ポイントがなくを使用して接続できることを十分に互換性がある場合にコントロールの接続に使用する<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>オブジェクト。 このメソッドのオーバー ロードが呼び出されると、単に渡し、メソッドの他のオーバー ロードされたバージョンへの呼び出し、渡します`null`を必要とするパラメーター、<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>オブジェクト。  
  
 2 つのコントロールをプログラムで接続しようとしたときに行うこともできます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>コントロールは直接接続するかどうかを決定する条件の確認方法。  
  
   
  
## Examples  
 次のコード例では、このメソッドを使用してプログラムで接続を作成する方法を示します。 例を実行するために必要な完全なコードのセクションの例を参照してください、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要です。 例から必要があります ページで、表示モードを変更できるユーザー コントロールのソース コードとソース コードの 2 つのカスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。  
  
 2 つをホストする Web ページのコードでは、次の手順を制御します。 ページを使用して`Register`上部にあるディレクティブは、ユーザー コントロールとカスタム コントロールを宣言します。 カスタム コントロールは、参照されている宣言内で、`<asp:webpartzone>`要素。 処理するコード、`Button1_Click`メソッドを使用して、コントロール間の接続を作成、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>メソッドです。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 ブラウザーでページを読み込んだ後、 **web パーツ コントロールの接続**接続をフォームにボタンをクリックします。 テキスト ボックスで、一部のデータを入力し、をクリックして、 **5 桁の郵便番号を入力**を接続しているコントロールを最初のコントロールに入力されたデータは、2 番目の更新を示すためにボタンをクリックします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">動的接続の <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールのコレクションが読み取り専用です。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      </Docs>
    </Member>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">接続されたもう一方のコントロールにデータを提供する役割を持つ <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</param>
        <param name="providerConnectionPoint">
          <see langword="ConnectionProvider" /> メタデータ属性でマークされ、接続のコールバック メソッドとして機能する、<c>プロバイダー</c>のパブリック メソッド。</param>
        <param name="consumer">
          <c>プロバイダー</c>または<c>トランスフォーマー</c>からデータを受け取り、それを処理するか表示する役割を持つ <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</param>
        <param name="consumerConnectionPoint">
          <see langword="ConnectionConsumer" /> メタデータ属性でマークされ、<c>providerConnectionPoint</c> と接続して接続のデータを受け取る、<c>コンシューマー</c>のパブリック メソッド。</param>
        <param name="transformer">
          <c>プロバイダー</c>のデータを<c>コンシューマー</c>が処理できる形式に変換することにより、2 つのコントロールを接続できるようにする <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />。</param>
        <summary>コントロールへの参照、指定された <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> オブジェクト、および <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> オブジェクトを使用して、2 つの <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> コントロールまたは <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> コントロール間の接続を作成します。</summary>
        <returns>接続に必要なプロバイダー、コンシューマー、およびトランスフォーマーに関する情報が格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して、その接続ポイントは互換性がない場合は、コントロールを接続します。 非互換性が発生したときに`consumer`よりも別のインターフェイスを実装する`provider`の接続ポイントとして。 によって認識できる型にデータをトランスフォーマー`consumer`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">接続が既に <see cref="E:System.Web.UI.Control.PreRender" /> でアクティブになっています。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーン内にあり、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> コントロールによって管理される、すべての <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロール、サーバー コントロール、またはユーザー コントロールのコレクションを取得します。</summary>
        <value>
          <see cref="T:System.Web.UI.ControlCollection" /> コントロールによって管理されるすべてのコントロールが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>プロパティによって参照されているその他のコントロールを参照していません、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>を制御するなど、さまざまなゾーン コントロール、<xref:System.Web.UI.WebControls.WebParts.EditorPart>または<xref:System.Web.UI.WebControls.WebParts.CatalogPart>コントロール、およびその他のユーザーです。  
  
 このプロパティは、Web パーツ コントロール セットをコードから呼び出されるものではありません、ほとんどの開発状況に使用されます。 このため、プロパティがパブリックでは非表示にされて IntelliSense からです。 コレクションにアクセスする開発者向け<xref:System.Web.UI.WebControls.WebParts.WebPart>またはその他のサーバー コントロールによって管理される、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールを使用してその<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>プロパティです。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      </Docs>
    </Member>
    <Member MemberName="CopyWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart CopyWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ CopyWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">コピー対象の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロール。</param>
        <summary>Web ページに <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロールを追加するためにこうしたコントロールのコピーを作成する場合に、Web パーツ コントロール セットで使用されます。</summary>
        <returns>ページに追加される <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことはできません、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>コードから直接メソッドです。 このメソッドは内部で、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>新しい動的なを追加するプロセスの一部としてコントロール<xref:System.Web.UI.WebControls.WebParts.WebPart>またはサーバー コントロールをページにします。 ダイナミック コントロールがページに追加プログラムまたは Web パーツのユーザー インターフェイス (UI) などが静的なコントロール、ページのマークアップで直接宣言ではなく、コントロールのカタログからコントロールを追加するユーザーがします。  
  
> [!NOTE]
>  メソッドは、開発者がその他のコントロールのシナリオのコピーを処理するメソッドを有効にする場合、派生クラスでオーバーライドできます。 詳細については、継承元のセクションの注意を参照してください。  
  
 ときに、新しい動的コントロールである場合、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>メソッドは、コントロールの新しいインスタンスを返します。 追加するコントロールが (ユーザー コントロール、カスタム コントロールを ASP.NET コントロールなど) のサーバー コントロールの他のいくつかの型の場合は、コントロールは既にラッピングされていると、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Web パーツ コントロール セットのオブジェクト。 ときに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>メソッド検出すると、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>の新しいインスタンスを返しますが、コントロール、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>内にラップした子コントロールの新しいインスタンスを持つコントロール。  
  
 ときに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>メソッドが返されるコントロールの新しいコピーを作成しもすべてのプロパティの値が既定値にリセットします。 、いて、パーソナル化可能なプロパティの値を保持する場合、新しいコントロールのインスタンスにコピーして、呼び出す必要がありますに注意してください、<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A>メソッドもします。 によって実行される最後の手順、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>メソッドが呼び出されて、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A>コントロールの新しい ID を取得します。  
  
> [!NOTE]
>  メソッドは、コピーしたコントロールの新しい ID を取得、されるために依存しないように、元の ID によってページに追加する動的コントロールを参照します。 代わりに、メソッドによって返されるコントロールの新しいインスタンスを参照する必要があります。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>メソッドとして宣言されて<see langword="virtual" />開発者でしたから継承できるように、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラス、メソッドをオーバーライドおよびその他のシナリオでは、コントロールのコピーを作成、でしたを提供します。 たとえば、メソッド必要に応じてを受け取ることが入力として XML ファイルにシリアル化されたコントロール。 メソッドが (存在する場合)、XML を逆シリアル化し、既存のケースを処理しの新しいインスタンスを返すには、基本メソッドを呼び出すでした、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />コントロール。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CreateAvailableTransformers">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAvailableTransformers () As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ CreateAvailableTransformers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Web サイトの構成ファイルに指定されているトランスフォーマーのセットを作成し、<see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" /> プロパティで参照されるトランスフォーマーのコレクションにそれを追加します。</summary>
        <returns>Web サイトの構成ファイルで指定されているトランスフォーマーのコレクション。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>このメソッドをオーバーライドして、アプリケーションで使用できるその他のトランスフォーマーを追加します。 たとえば、Web サービスから使用可能なトランスフォーマーの一覧を取得する、メソッドを記述できます。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Web ページ上の <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールで管理されるすべてのコントロールのコレクションを返します。 このクラスは継承できません。</summary>
        <returns>
          <see cref="T:System.Web.UI.ControlCollection" /> コントロールで管理されるすべてのさまざまな Web パーツ コントロールで構成された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>継承するクラスを表示されているため、このメソッドは保護されており、封印されて、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスが、それをオーバーライドすることはできません。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateDisplayModes">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDisplayModes () As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ CreateDisplayModes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Web パーツ アプリケーションで使用できるすべての表示モードのセットを作成します。</summary>
        <returns>サポートされているすべての表示モードが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、特定のページにサポートされている表示モードだけでなく、すべての可能な表示モードの一覧を作成します。 サポートされている表示モードの詳細については、次を参照してください。、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>プロパティです。  
  
 既定では、Web パーツ コントロール セットには、次の Web パーツ ページを使用する表示モードのセットが作成されます。  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>  
  
 またはのいずれかから派生するカスタムのゾーンに付属することがなく、開発者はカスタムの表示モードを作成できます、<xref:System.Web.UI.WebControls.WebParts.WebZone>または<xref:System.Web.UI.WebControls.WebParts.ToolZone>クラスです。 カスタム表示モードを作成するにはから継承する必要があります、<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>クラス、およびページのモードのサポートされていると、表示モードを追加するにはから継承する必要があります、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスし、オーバーライド、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>メソッドです。  
  
 表示モードを使用して追加すると、<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A>メソッド、する必要がありますに追加するすべてのユーザー インターフェイス (UI) コントロールに表示される順序で (など、<xref:System.Web.UI.WebControls.ListBox>コントロール) をユーザーに提供可能な表示モード、ページ上。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> メソッドの使用方法を示します。  
  
 このコード例では、5 つの部分があります。  
  
-   ユーザー コントロールを Web パーツ ページの表示モードを変更することができます。  
  
-   その他のコントロールをホストする Web ページです。  
  
-   ユーザー コントロール内にある、 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> Web ページ上のゾーンを入力し、ラベルのテキストを表示することができます。  
  
-   2 つのコントロールを含むソース コード ファイル。 1 つは、カスタム<xref:System.Web.UI.WebControls.WebParts.WebPartManager>制御、およびその他は、カスタム<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>ページの既定の表示モードに追加するオブジェクト。  
  
-   2 つのカスタムを含むソース コード ファイル<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、およびカスタム インターフェイスです。  
  
-   ブラウザーでの例の動作についての説明。  
  
 コード例の最初の部分は、ユーザー コントロールの表示モードを変更するためです。 セクションの例からユーザー コントロールのソース コードを取得することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要です。 表示モードとユーザー コントロールの動作方法の詳細については、次を参照してください。[チュートリアル: Web パーツ ページの表示モードの変更](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)です。  
  
 この例の 2 番目の部分は、Web ページです。 2 つが含まれている<xref:System.Web.UI.WebControls.WebParts.WebPartZone>ユーザー コントロール、およびカスタムの両方を制御<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。 通知、`Register`ユーザー コントロールとコンパイル済みのコントロールの名前空間を参照するページの上部にあるディレクティブです。  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/createDisplayModeCS.aspx#1)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/createDisplayModeVB.aspx#1)]  
  
 例では、3 番目の部分は、ユーザー コントロールの入力テキストの表示です。 使用して、<xref:System.Web.UI.WebControls.MultiView>コントロールを UI の複数のビューを作成します。 1 つのビューが表示されます、`Button1`せず、他のボタンです。 いることを確認、オーバーライドされた`OnPreRender`メソッド、コードを確認するかどうか、ページ、カスタムの表示モードでは現在し場合は、ボタンを含むユーザー コントロールの最初のビューが表示されます。 ページのページは、参照 または デザイン モードの場合などは、カスタムの表示モードでない場合は、ボタンは表示されません。  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/TextDisplaycs.ascx#2)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/TextDisplayvb.ascx#2)]  
  
 例の 4 番目の部分は、次の 2 つのカスタム クラスのソース ファイルです。 注意して、カスタム<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスのオーバーライド、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>メソッド、および、まず、既定の表示モードを追加する基本メソッドを呼び出し、カスタム表示モードを追加します。 カスタムの表示モード クラス`InLineEditDisplayMode`、単に継承<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>コンス トラクターで、表示モードの名前を設定、およびさまざまなカスタムの表示の特性を確立するために基本プロパティをオーバーライドします。  
  
 コード例を実行するには、このソース コードをコンパイルする必要があります。 コンパイルするには明示的にし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに結果として得られるアセンブリを配置できます。 またはを動的にコンパイルされる実行時に、サイトの App_Code フォルダー内のソース コードを配置することができます。 コンパイルする方法について説明するチュートリアルでは、次を参照してください。[チュートリアル: カスタム Web サーバー コントロールの開発と](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)です。  
  
 [!code-csharp[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/CustomDisplayMode.cs#3)]
 [!code-vb[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/CustomDisplayMode.vb#3)]  
  
 コード例を実行するには、ブラウザーでページを読み込みます。 ブラウズ モードでページは、現在とボタンが表示されていないことに注意してください。 使用して、**表示モード**ドロップダウン リスト コントロールをページの変更は、**インライン編集表示**モード、および通知されている、`Button1`ボタンは、下位のユーザー コントロールで表示します。 いくつかのテキストを追加し、コントロールを更新 ボタンをクリックします。 ページの表示は、ブラウズ モードに返される、入力したテキストが表示されます、ページが、カスタムの表示モードではなくなったため、ボタンが再び非表示に注意してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicConnectionID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicConnectionID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicConnectionID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicConnectionID () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicConnectionID();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>動的接続の ID として使用される一意の値を取得します。</summary>
        <returns>接続に関する一意の ID を含む文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A>メソッドは、GUID 値を生成し、接続の一意の ID として使用する文字列に変換します。 メソッドは、動的な接続が作成されるたびに呼び出されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開発者は、派生では、このメソッドをオーバーライドできます<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />一意の ID を生成するための実装を変更するクラス</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicWebPartID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicWebPartID (Type webPartType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicWebPartID(class System.Type webPartType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicWebPartID (webPartType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicWebPartID(Type ^ webPartType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="webPartType">ID の生成対象となるコントロールの <see cref="T:System.Type" />。</param>
        <summary>動的な <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールの一意の ID を生成します。</summary>
        <returns>コントロールの一意の ID が含まれた文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに<xref:System.Web.UI.WebControls.WebParts.WebPart>Web ページにコントロールを追加、可能性がある (つまり、コントロールがページのマークアップで宣言) 静的または動的な (つまりプログラムで追加されます)。 どのシナリオでもここで、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>一意の ID を生成するには、このメソッドを呼び出す、ページに追加する新しい動的コントロールがコントロールの作成  
  
 メソッドが仮想の開発者は ID を生成するためのカスタム実装を提供する場合はオーバーライドことにできるようにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartType" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart(string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateErrorWebPart (originalID As String, originalTypeName As String, originalPath As String, genericWebPartID As String, errorMessage As String) As ErrorWebPart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::ErrorWebPart ^ CreateErrorWebPart(System::String ^ originalID, System::String ^ originalTypeName, System::String ^ originalPath, System::String ^ genericWebPartID, System::String ^ errorMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ErrorWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalID" Type="System.String" />
        <Parameter Name="originalTypeName" Type="System.String" />
        <Parameter Name="originalPath" Type="System.String" />
        <Parameter Name="genericWebPartID" Type="System.String" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="originalID">失敗するコントロールの ID を含む文字列。 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> がこの失敗に関係する場合、ID はその子サーバー コントロールの ID です。</param>
        <param name="originalTypeName">失敗したコントロールの <see cref="T:System.Type" /> の名前を示す文字列。 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> がこの失敗に関係する場合、型名はその子サーバー コントロールの型名です。</param>
        <param name="originalPath">子ユーザー コントロールを格納する <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> がこの失敗に関係する場合、ユーザー コントロールへのパスを含む文字列。</param>
        <param name="genericWebPartID">その型のコントロールがコントロールの読み込みまたは作成の失敗に関係する場合、<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> の ID を返す文字列。</param>
        <param name="errorMessage">ページ上に表示するエラー メッセージを含む文字列。</param>
        <summary>動的な <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを読み込むか作成しようとして何らかの理由で失敗したときに、ページに挿入してエンド ユーザーに表示する特別なコントロールを作成します。</summary>
        <returns>読み込みまたは作成に失敗したコントロールの代わりにページに挿入する <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> Web パーツ コントロール セットの試行を読み込むか、動的なのインスタンスを作成するときに、メソッドは呼び出される<xref:System.Web.UI.WebControls.WebParts.WebPart>またはサーバー コントロールと、何らかの理由により失敗した場合します。 このメソッドを作成、<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>オブジェクトをエラー メッセージを代入し、それを取得します。 <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>コントロールが、失敗したコントロールの代わりに挿入され、ページにそのエラー メッセージが表示されます。  
  
 呼び出すことはできません、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A>コードから直接メソッドです。 ただしから継承することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスおよびメソッドを拡張します。 詳細については、継承元のセクションのノートを参照してください。  
  
 最後のユーザーが操作できる、<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>で制御ページ大部分は、通常の場合と同じように<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。 削除するには、エラー メッセージに、コントロールを追加する時点で、閉じる動詞 をクリックしてコントロールを閉じることができます、<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>閉じられた他のコントロールと同様のオブジェクト。 エンド ユーザーを削除した場合、<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>コントロールを読み込めませんでした。 サーバー コントロールは、ページからも削除されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>返される情報をカスタマイズするかどうか、<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />オーバーライドすることができます、コントロール、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />基本メソッドを呼び出し、基本メソッドに渡されるパラメーターに異なる値を割り当てるおよび結果として得られるを返すメソッド、<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />コントロール。 たとえば、エンド ユーザーに表示したくない場合、 <paramref name="originalPath" /> (値は、ユーザー コントロールの仮想ディレクトリのパスを表示)、基本メソッドを呼び出すと、空の文字列を渡す可能性があります ("") パラメーターにします。  
  
 動作をカスタマイズすることも、<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />自体から継承することで制御します。 オーバーライドするなど、その<see cref="P:System.Web.UI.WebControls.WebParts.Part.Title" />または<see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowMinimize" />プロパティです。</para>
        </block>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePersonalization">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreatePersonalization () As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ CreatePersonalization();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の Web ページのユーザーのパーソナル化データを格納するパーソナル化オブジェクトを返します。</summary>
        <returns>ユーザーのパーソナル化データが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>メソッドを含めるし、現在のページのユーザーの個人用設定を管理するオブジェクトを返します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールは、このオブジェクトを管理します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::GenericWebPart ^ CreateWebPart(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール以外のサーバー コントロール。</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> オブジェクトを持った <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> コントロール以外のサーバー コントロールが Web パーツ機能を備えることができるように、そのコントロールをラップします。</summary>
        <returns>
          <paramref name="control" /> をラップし、真の <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> コントロールとして機能できる <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法はメインのメカニズムがないサーバー コントロールを有効にするため<xref:System.Web.UI.WebControls.WebParts.WebPart>と同じ機能へのコントロール、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、およびこのインターフェイスの Web パーツのアプリケーションに完全に参加します。 開発者は、このメソッドを大幅を使用して Web パーツ アプリケーションで使用できるサーバー コントロールの数を増やす、標準の ASP.NET コントロール、ユーザー コントロール、およびカスタム コントロールというを使用できますので、事実上すべてのサーバー コントロールの種類します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールもこのメソッドを使用して他の 2 つのシナリオでのサーバー コントロールをラップする<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>オブジェクト。 ユーザー コントロールを追加とサーバー ページを使用して、<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>制御、インポートされたコントロールがない場合、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>メソッドが呼び出されます。 内の永続化の形式でサーバー コントロールが宣言されている場合も、 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 、Web ページ上のゾーン、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>メソッドはありませんが、コントロールの<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。  
  
 一般的なアプローチを使用してゾーンに、サーバー コントロールをプログラムで追加するときに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>コントロールをラップするメソッド、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>オブジェクト、およびを呼び出す、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>すべてのコレクションにコントロールを追加するメソッドを<xref:System.Web.UI.WebControls.WebParts.WebPart>によって参照されていると、ページ上のコントロール、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>プロパティです。  
  
   
  
## Examples  
 次のコード例に示しますの使用、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>メソッドです。 `Button2_Click method`、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>をラップするメソッドが呼び出された、<xref:System.Web.UI.WebControls.Calendar>と制御、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>をゾーンに追加する前にオブジェクト。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>このメソッドをオーバーライドして派生を使用して<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />クラス代わりに、Web パーツで提供される基本クラスのセットを制御します。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteWarning">
      <MemberSignature Language="C#" Value="public virtual string DeleteWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeleteWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DeleteWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DeleteWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>エンド ユーザーがコントロールを削除したときにそのユーザーに対して表示するカスタム警告メッセージを取得または設定します。</summary>
        <value>警告メッセージのテキストが含まれる文字列。 既定値は、ローカライズされた警告メッセージです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーを削除すると、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールを通常、既定の警告メッセージが表示されます。 ユーザーに警告するコントロールのこのインスタンスが削除されると、削除は恒久的です。 ページの開発者は、ページにコントロールの新しいインスタンスを追加する方法をユーザーに提供可能性があります (などのカタログを<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、または一部のプログラムによる方法で) が完全に削除されるコントロールの現在のインスタンスは削除されません。 警告が表示されるダイアログ ボックスには、必要な場合は、ユーザーが、削除をキャンセルするためのボタンが含まれます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>プロパティにより、開発者は、ユーザーに表示される警告メッセージを設定します。  
  
 ページの開発者には、空の文字列が割り当てられる場合 ("")、ユーザーを削除するとこのプロパティのない警告 ダイアログ ボックスの値を表示する、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>プロパティは、静的の場合は表示されません<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールおよびサーバー コントロールです。 静的なコントロールは、サーバー内で宣言されている、 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Web ページのマークアップ内のゾーンです。 このようなコントロールは、静的であるため、削除できません、削除の警告メッセージがその場合は表示しないようにします。 スタティック コントロールは、ユーザーが閉じることができますが、クローズドのコントロールが元となる、追加できますのページに戻る、ユーザーによって削除されたコントロールを回復しないことができますが、ページのカタログに追加します。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>プロパティをプログラムで宣言します。  
  
 これには、コード例に 4 つの部分があります。  
  
-   ユーザー コントロールをページの表示モードを変更することができます。  
  
-   カスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。  
  
-   Web ページです。  
  
-   ブラウザーでの例の動作についての説明。  
  
 コード例の最初の部分は、ユーザー コントロールの表示モードを変更するためです。 セクションの例からユーザー コントロールのソース コードを取得することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要です。 表示モードとユーザー コントロールの動作方法の詳細については、次を参照してください。[チュートリアル: Web パーツ ページの表示モードの変更](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)です。  
  
 コード例の 2 番目の部分は、カスタム<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。 コード例を実行するには、このソース コードをコンパイルする必要があります。 コンパイルするには明示的にし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに結果として得られるアセンブリを配置できます。 またはを動的にコンパイルされる実行時に、サイトの App_Code フォルダー内のソース コードを配置することができます。 この例は、動的コンパイルのアプローチを使用してください。したがってがありますいない`Assembly`属性、 `Register` Web ページの上部にあるこのコントロールのディレクティブ。 コンパイルする方法について説明するチュートリアルでは、次を参照してください。[チュートリアル: カスタム Web サーバー コントロールの開発と](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)です。  
  
 [!code-csharp[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/textdisplaywebpart.vb#3)]  
  
 コード例の 3 番目の部分は、Web ページです。 ページが含まれています、<xref:System.Web.UI.WebControls.WebParts.CatalogZone>をカスタムのゾーン<xref:System.Web.UI.WebControls.WebParts.WebPart>ユーザー追加できるように、ページに実行時に、コントロールが、ゾーンで宣言します。 ページからのみ動的コントロール (プログラムから、またはこのようなカタログからのページに追加される) を削除することができますに注意してください。 スタティック コントロール (内で宣言されているコントロール、<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ページのマークアップ内のゾーン) できますが閉じている場合は削除されません。 `<asp:webpartmanager>`要素宣言をカスタム値、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>プロパティを使用して、`DeleteWarning`属性。 `Button1_Click`メソッドに別のカスタム値を割り当てます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>プロパティです。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/deleteWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/deleteWarningVB.aspx#1)]  
  
 ブラウザーでページを読み込んだ後に追加する必要があります、<xref:System.Web.UI.WebControls.WebParts.WebPart>ページを制御します。 使用して、**表示モード**ドロップダウン リスト コントロール、カタログの選択モード。 カタログが表示されたら、カスタム コントロールの横にあるチェック ボックスを選択し、をクリックして**追加**、ページに追加し、をクリックする**閉じる**ブラウズ モードをページに戻します。 コントロールが表示されるようになりましたを削除することができます。 使用して、**表示モード**もう一度コントロールをページに切り替えます (コントロールを削除できません、ページが参照モード) のデザイン モードにします。 動詞メニュー (矢印) のヘッダーをクリックして、<xref:System.Web.UI.WebControls.WebParts.WebPart>制御、および選択**削除**です。 警告を設定するが、`DeleteWarning`属性が表示されます。 をクリックして**キャンセル**です。 ボタンをクリックして**変更削除警告**プロパティの値をプログラムで変更します。 コントロールの動詞メニューから選択**削除**もう一度、今度は、その他の警告メッセージが表示されていることに気付きました。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteWebPart">
      <MemberSignature Language="C#" Value="public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">削除するサーバー コントロール。</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールの動的インスタンスを Web ページから完全に削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>メソッドによって表されるコントロールを完全に削除する、`webPart`ページからのパラメーターです。 追加が終了したコントロールとは異なり、<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>を制御し、追加できますページに移動して、削除したコントロールのインスタンスは、ページに戻ることはありません追加できます。  
  
> [!NOTE]
>  Web パーツ コントロールにより実装されている設定、ユーザーに、動的なを削除する機能<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールは、ユーザーと、ページに追加したコントロールのパーソナル化スコープによって異なります。 コントロールを追加した場合、ページが共有のスコープ内に (アクセス許可を持つユーザー)、し、コントロールは削除できません個々 のユーザーがページがユーザーのスコープ内にある場合。  
  
 ダイナミック コントロールのみを削除することができます。 ダイナミック コントロールは、プログラムまたはユーザー カタログからコントロールを追加して、ページに追加されます。 スタティック コントロールは、マークアップまたは永続化の形式で宣言によってページに追加されます。 宣言型のタグは、マークアップで永続的に存在であるため、スタティック コントロールが削除されることはありませんが、閉じ、再度開くことができます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> メソッドの使用方法を示します。 最初に、**予定表の追加**ボタンがクリックされた、コードは、イベント ハンドラーを作成、<xref:System.Web.UI.WebControls.Calendar>制御、およびとゾーンを追加、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>オブジェクト。 ダイナミック コントロールにコントロールがプログラムによって追加されるため、削除ため。 ユーザーがクリックしたとき、**削除予定表**ボタン コードにより、コントロールが存在し、呼び出すことによって、削除、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>メソッドです。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
      </Docs>
    </Member>
    <Member MemberName="DesignDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DesignDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DesignDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web パーツ コントロールを含む Web ページのレイアウトを変更する場合に使用する表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>フィールドが参照するカスタム<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>が作成されに含まれているオブジェクト、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。 これは、静的オブジェクトであるためを参照できます、経由で直接、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>しなくても、コントロールのインスタンスのクラスです。  
  
 Web パーツを含むページは、最初に読み込まれるを制御するときに<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>(ブラウズ モード) 既定でします。 ページを最初にする必要があります切り替えますユーザーは、別のゾーンまたは現在ゾーン内でコントロールを移動することによって、ページのレイアウトを変更する場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> (デザイン モード)。 デザイン モードでのさまざまなゾーンのユーザー インターフェイス (UI) 表示され、ユーザーは、レイアウトを変更するコントロールをドラッグできます。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>プログラムでフィールドです。 コードでは、参照と設計をここでは、ページのサポートされている表示モードのドロップダウン リストを生成します。 いることを確認、`Page_PreRender`メソッドは、コードのチェックするかどうか、現在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>プロパティに設定されている<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>です。 場合は、 `Label1` 、表示される、存在しない場合`Label1`は表示されません。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/CS/wpmgrDesignDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/VB/wpmgrDesignDisplayModevb.aspx#1)]  
  
 ブラウザーでページを読み込んだ後は、既定ではブラウズ モードでは。 ページ上のラベルが非表示になっていることを確認します。 ドロップダウン リスト コントロールを使用して、ページをデザイン モードに切り替えます。 内のコードによりいることを確認、`Page_PreRender`メソッドをラベルが表示されるようになりました。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebPart">
      <MemberSignature Language="C#" Value="protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisconnectWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DisconnectWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">接続を解除する <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</param>
        <summary>終了または削除する <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロールを、それが関係する接続から削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>メソッドは、コントロールがページで閉じられましたか、ページから削除されたときに設定する Web パーツ コントロールによって内部的に呼び出されます。 このようなシナリオでは、メソッドがすべての接続からコントロールを削除するコンシューマーまたはプロバイダーとして関与しています。 任意の接続からコントロールを削除する場合、このメソッドも呼び出します、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>メソッドでのすべての接続を終了する`webPart`深入りしました。  
  
 ときに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>メソッドが呼び出されると、発生、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>イベント。 通常このイベントは取り消すことができますが、2 つのケースで取り消すことができません。 1 つのケースが、ページを要求中に発生したときに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>メソッドが呼び出されます。 既存の接続の間に競合がある場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>メソッドが呼び出されがこのインスタンスと、競合している接続のいずれかを閉じる、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>競合を解決する必要があるため、イベントを取り消すことはできません。  
  
 その他のケースが発生するときに、<xref:System.Web.UI.WebControls.WebParts.WebPart>か、現在接続しているサーバー コントロールが閉じられたか削除します。 この場合、コントロールによりが削除されるページで、デザインをキャンセルすることはできません、同様に、したがって終了するには、その接続必要、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>接続を終了プロセスを中断するイベントです。 詳細については、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントを参照してください。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドの使用方法を示します。 2 つのカスタムを使用して<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、Web ページを有効にすると、別のボタンを使用すると、コントロールを切断中に、ボタンをクリックするコントロール間の接続を作成します。 閉じた場合、コントロールのいずれかのページは、ブラウズ モードを接続しているコントロールのオーバーライド、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>メソッドが終了したコントロールの接続が切断、接続を終了し、メッセージが表示されます。  
  
 このコード例では、4 つの部分があります。  
  
-   表示モードを変更するユーザー コントロールです。  
  
-   ユーザー設定を含むソース ファイル<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。  
  
-   コントロールをホストする Web ページです。  
  
-   ブラウザーでの例の動作についての説明。  
  
 コード例の最初の部分は、ユーザー コントロールの表示モードを変更するためです。 セクションの例からユーザー コントロールのソース コードを取得することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要です。 表示モードとユーザー コントロールの動作方法の詳細については、次を参照してください。[チュートリアル: Web パーツ ページの表示モードの変更](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)です。  
  
 2 番目の部分は、2 つのカスタムのソース コードを含むファイル<xref:System.Web.UI.WebControls.WebParts.WebPart>が接続される、コントロールとカスタム<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。 コード例を実行するには、このソース コードをコンパイルする必要があります。 コンパイルするには明示的にし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに結果として得られるアセンブリを配置できます。 またはを動的にコンパイルされる実行時に、サイトの App_Code フォルダー内のソース コードを配置することができます。 この例は、動的なコンパイルを使用してため、 `Register` Web ページでこれらのコンポーネントを参照するディレクティブがそれに従って宣言されている Web ページの上部にあります。 コンパイル オプションについて説明するチュートリアルでは、次を参照してください。[チュートリアル: カスタム Web サーバー コントロールの開発と](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)です。  
  
 ソース コードで、継承されたコントロールに注意してください。`MyWebPartManager`をオーバーライドする、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>メソッドです。 このメソッドをチェックするかどうか閉じられているコントロールが、接続に参加して、呼び出しの場合を参照してください ページ内の各接続、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>メソッド接続を終了します。 これは、メソッドの基本実装と同じ、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。 オーバーライドされたメソッドは、ページにメッセージを記述して、基底の実装をカスタマイズします。  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 コード例の 3 番目の部分は、Web ページです。 先頭付近にあるが含まれていることを確認`Register`ユーザー コントロールとで動的にコンパイルされたアセンブリを登録するディレクティブ、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。 ページには、2 つの主なメソッドがあります。 `Button1_Click`メソッドは、コントロール間の接続を作成中に、`Button2_Click`メソッドは、コントロールを切断します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 ページを読み込んだ後、**接続**コントロールを接続するボタンをクリックします。 コントロール (ヘッダー コントロールの下向きの矢印) のいずれかの動詞メニューをクリックし、選択**閉じる**動詞メニュー。 コントロールを終了しようとすると、オーバーライドしたメソッドが呼び出され、接続が終了するとのページに、メッセージが書き込まれます。 閉じたコントロールを復元し、なその他のオプションを試し、ページをリセットする場合、**ユーザー状態のリセット**リンク パーソナル化データを削除し、ページの元の状態を復元します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebParts">
      <MemberSignature Language="C#" Value="public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisconnectWebParts(class System.Web.UI.WebControls.WebParts.WebPartConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DisconnectWebParts (connection As WebPartConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DisconnectWebParts(System::Web::UI::WebControls::WebParts::WebPartConnection ^ connection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Parameters>
      <Docs>
        <param name="connection">サーバー コントロール間の接続を表す <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</param>
        <summary>Web ページ上で接続されたサーバー コントロールの接続を解除するプロセスを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>メソッドは、完全なプロセスの間の接続を終了<xref:System.Web.UI.WebControls.WebParts.WebPart>またはサーバー コントロールを渡すときに、`connection`パラメーター。  
  
 このメソッドは、配置するときにコントロールを切断するのには使用、`<asp:connectionszone>`接続を管理するユーザー インターフェイス (UI) を提供する、Web ページ内の要素。 ページでは、接続の表示モード (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>)、現在の接続が存在して、ユーザーを呼び出すボタンをクリックして、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>メソッド接続を終了します。  
  
 呼び出すことも、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>メソッドをプログラムで必要とせずに追加するコントロールを切断する場合、コードから直接、`<asp:connectionszone>`要素をページにします。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドの使用方法を示します。 2 つのカスタムを使用して<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、Web ページを有効にすると、別のボタンを使用すると、コントロールを切断中に、ボタンをクリックするコントロール間の接続を作成します。  
  
 このコード例では、4 つの部分があります。  
  
-   表示モードを変更するユーザー コントロールです。  
  
-   ユーザー設定を含むソース ファイル<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。  
  
-   コントロールをホストする Web ページです。  
  
-   ブラウザーでの例の動作についての説明。  
  
 コード例の最初の部分は、ユーザー コントロールの表示モードを変更するためです。 セクションの例からユーザー コントロールのソース コードを取得することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要です。 表示モードとユーザー コントロールの動作方法の詳細については、次を参照してください。[チュートリアル: Web パーツ ページの表示モードの変更](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)です。  
  
 2 番目の部分は、2 つのカスタムのソース コードを含むファイル<xref:System.Web.UI.WebControls.WebParts.WebPart>接続されるコントロールです。 コード例を実行するには、このソース コードをコンパイルする必要があります。 コンパイルするには明示的にし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに結果として得られるアセンブリを配置できます。 またはを動的にコンパイルされる実行時に、サイトの App_Code フォルダー内のソース コードを配置することができます。 この例は、動的なコンパイルを使用してため、 `Register` Web ページでこれらのコンポーネントを参照するディレクティブがそれに従って宣言されている Web ページの上部にあります。 コンパイル オプションについて説明するチュートリアルでは、次を参照してください。[チュートリアル: カスタム Web サーバー コントロールの開発と](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)です。  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 コード例の 3 番目の部分は、Web ページです。 先頭付近にあるが含まれていることを確認`Register`ユーザー コントロールとで動的にコンパイルされたアセンブリを登録するディレクティブ、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。 ページには、2 つの主なメソッドがあります。 `Button1_Click`メソッドは、コントロール間の接続を作成し、`Button2_Click`メソッドは、コントロールを切断します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 クリックすることができます、ページを読み込んだ後、**接続**コントロールを接続するボタンをクリックします。 テキスト ボックス コントロールで、いくつかのテキストを入力し、をクリックして、 **Enter**ボタン (これが表示されない場合は、コントロールの接続が切断された) 接続されているコントロールのテキストが表示されます。 クリックした場合、**切断**ボタン コントロールは切断されます。 使用して、コントロールの接続の状態を確認することができます、**表示モード**ドロップダウン リスト コントロールをページに切り替えます**接続**モード。 実行後は、コントロールのいずれかのタイトル バーに (が矢印で表される) の動詞メニューをクリックし、選択、**接続**項目。 接続の UI が表示されます。使用可能になるため、`<asp:connectionszone>`ページに要素が宣言されています。 接続し、この UI からコントロールを切断することもできます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connection" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> または<see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> のいずれかに <paramref name="connection" /> が含まれていません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> は読み取り専用です。  
  
 \- または  
  
 <paramref name="connection" /> は既に <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> から接続解除されています。  
  
 \- または  
  
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> は読み取り専用です。  
  
 \- または  
  
 <paramref name="connection" /> は既に <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> から接続解除されています。</exception>
        <block subset="none" type="overrides">
          <para>オーバーライドすることができます、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />切断の既定の実装を変更する場合、メソッド<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />コントロール。 場合は、メソッドをオーバーライドして、既存のメソッドに何らかの実装を追加するだけで、独自のコードを実行する前に、基本メソッドを呼び出すことができます。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DisplayMode As WebPartDisplayMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DisplayMode { System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ get(); void set(System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web パーツ コントロールが含まれた Web ページのアクティブな表示モードを取得または設定します。</summary>
        <value>ページの表示モードを決定する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web パーツ コントロールを含むページがいくつかの可能な表示モードのいずれかでは常にします。 表示モードの詳細については、「 [Web パーツ ページの表示モード](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)です。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスは、Web ページの表示モードを作成します。 ベースの<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>クラス、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールは、Web パーツ コントロールを含むページで使用できるいくつかの標準の表示モードのオブジェクトを作成します。 これらの標準の表示モード」に記載されて、<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>クラスの概要です。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールも Web パーツ コントロールを使用しているページ表示モードを管理します。 使用して、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 、プロパティ、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールがページに現在の表示モードへの参照を保持します。 使用することも、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>ページをさまざまな表示モードに切り替えるにはプロパティです。 Web パーツ コントロールを使用するページに表示モードの変更の例は、次を参照してください。[チュートリアル: Web パーツ ページの表示モードの変更](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)です。  
  
 表示モードを管理するための一部として、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールは、イベント、および表示モードなどに関連するイベント ハンドラーにも提供、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A>メソッドおよび<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>メソッドです。 これらのメソッドは、ページの動作をカスタマイズし、カスタムの表示モードを追加するためでもメカニズムを提供します。  
  
   
  
## Examples  
 次のコード例に示しますをプログラムで使用、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>プロパティです。 ブラウザーでページを読み込んだ後に、表示モードを切り替えるには、ページの下部付近にあるボタンを使用できます。 ページは、読み込み時に、既定ではブラウズ モードでです。 デザイン モードに切り替えた場合、1 つのゾーンからサーバー コントロールをドラッグしたり、1 つのゾーン内の 2 つのコントロールを配置できます。 編集モードに切り替えると場合、は、サーバー コントロールの選択のいずれかのヘッダーの動詞メニューをクリックすることができます**編集**、および指定された編集のユーザー インターフェイス (UI) を使用して、コントロールを編集します。  
  
> [!NOTE]
>  非常に一般的な Web パーツ アプリケーションでの表示モードの切り替えはあり、これを行う Web パーツ コントロールを含むすべてのページの一貫性があり、再利用可能な方法を提供することができます。 モードとする変更が表示されるユーザー コントロールの例は、多くのページで再利用できるを参照してください[チュートリアル: Web パーツ ページの表示モードの変更](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)です。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/CS/wpmgrDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/VB/wpmgrDisplayModevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">プロパティに割り当てられている <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> オブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">プロパティに割り当てられている <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> オブジェクトが、サポートされている表示モードではありません。  
  
 \- または  
  
 プロパティに割り当てられている <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> オブジェクトが無効です。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanged As WebPartDisplayModeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventHandler ^ DisplayModeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web パーツ ページ上の現在の表示モードが変更された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表示モードは、Web パーツ アプリケーションの不可欠な部分です。 ユーザーが Web ページ上のさまざまな表示モードに切り替えるときに多くの場合、新しい表示モードの目的によっては、まったく異なる外観でページを実行します。 表示モードの変更後に、可能性があるユーザー インターフェイス (UI) で特定の変更など、特定のコントロールを表示または非選択の UI 要素の外観の変更および表示します。  
  
> [!NOTE]
>  表示モードの詳細については、次を参照してください。 [Web パーツ ページの表示モード](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)です。 イベントの使用の詳細については、次を参照してください。[する方法: Web フォーム アプリケーションでのイベントの消費](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanging As WebPartDisplayModeCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventHandler ^ DisplayModeChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上で別の表示モードに変更するプロセスを開始する動詞をユーザーがクリックした後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表示モードは、Web パーツ アプリケーションの不可欠な部分です。 ユーザーが Web ページ上のさまざまな表示モードに切り替えるときに多くの場合、新しい表示モードの目的によっては、まったく異なる外観でページを実行します。 ユーザーは、動詞をクリックして新しい表示モードを変更するプロセスを開始後、は、ユーザー インターフェイス (UI) で特定の変更を使用して実行することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A>プロパティをどのような新しい表示モード、およびそれに応じてさまざまな UI 要素を変更します。 これを行う便利な方法がオーバーライドするには、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> UI をカスタマイズする方法です。  
  
> [!NOTE]
>  表示モードの詳細については、次を参照してください。 [Web パーツ ページの表示モード](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)です。 イベントの使用の詳細については、次を参照してください。[する方法: Web フォーム アプリケーションでのイベントの消費](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ DisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールに関連付けられたすべての表示モードの読み取り専用のコレクションを取得します。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> コントロールに関連付けられた <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> オブジェクトのセットが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>と対照的に関連付けられているすべての表示モード、プロパティの参照、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> (サポートされている) 現在のページで利用できる表示モードのみを参照するプロパティです。  
  
 ページの 2 つの指定された表示モード、参照およびデザイン、常にサポートされます。 ページが動作する特定の表示モードに必要なゾーンの対応する型を持つ場合にのみ、その他の 3 つの表示モード、編集、カタログ、および接続はサポートされてます。 たとえば、ページが含まれていない場合、<xref:System.Web.UI.WebControls.WebParts.EditorZone>ゾーンを編集表示モードは、によって参照されるコレクションに表示する、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>プロパティ、によって参照されるコレクションには表示されませんが、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>プロパティです。  
  
   
  
## Examples  
 次のコード例は、のプログラムによる使用を示しています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>プロパティです。 コードは、Web パーツ コントロール セットの使用可能なすべての表示モードの一覧を作成し、現在のページではサポートされていないを含め、このプロパティを使用します。 この場合、カタログと接続モードはサポートされず、表示ゾーンがページにないために必要な対応するためです。  
  
 他の 3 つの表示モード--ページで [参照]、デザイン、および編集--をサポートします。 編集モードは、ページが含まれているため、<xref:System.Web.UI.WebControls.WebParts.EditorZone>参照中に、ゾーンし、デザイン モードが常にサポートされています。  
  
 ブラウズ モードからページをデザイン モードに切り替えるには、ドロップダウン リスト コントロールを使用するには、ブラウザーでページを読み込んだ後し編集モードにします。 編集モードでサーバー コントロールのいずれかのヘッダーの動詞のドロップダウン メニューをクリックして選択できます**編集**コントロールを編集します。 選択する場合は、**カタログ**または**接続**ドロップダウン リストでエラー ページが生成されます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/CS/wpmgrDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/VB/wpmgrDisplayModesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="DynamicConnections">
      <MemberSignature Language="C#" Value="protected internal System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DynamicConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ DynamicConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在 Web ページ上に存在するすべての動的接続のコレクションを取得します。</summary>
        <value>ページ上のすべての動的接続への参照が格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的な接続は、静的にする場合とは異なり、プログラムによって作成される接続です。 静的な接続を作成するには、Web フォーム ページのマークアップで宣言します。 動的接続は、プログラム、または接続のユーザー インターフェイス (UI) を使用して接続を作成するユーザーによって形成されます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>コレクションは読み取り専用もとその内容を変更することはできませんは、動的な接続オブジェクトごとにプログラムでアクセスを提供します。  
  
> [!NOTE]
>  接続または切断などの一般的な操作を実行する<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、開発者は、使用のパブリック メソッドで、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスなど<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>と<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>、直接の接続オブジェクトを変更しようとしてではなく、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>コレクション。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      </Docs>
    </Member>
    <Member MemberName="EditDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ EditDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>エンド ユーザーによるサーバー コントロールの編集および変更が可能な表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>フィールドが参照するカスタム<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>が作成されに含まれているオブジェクト、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。 これは、静的オブジェクトであるためを参照できます、経由で直接、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>しなくても、コントロールのインスタンスのクラスです。  
  
 Web パーツを含むページは、最初に読み込まれるを制御するときに<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>(ブラウズ モード) 既定でします。 ページを最初にする必要があります切り替えますユーザーは、編集、またはサーバー コントロールを変更する場合、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> (編集モード)。 第二に、編集、そのコントロールのヘッダーの動詞メニューの編集 をクリックして特定のサーバー コントロールを選択して、必要があります。 コントロールが編集モードでは、選択したコントロールを編集するため、編集のユーザー インターフェイス (UI) が表示されます。  
  
 ページの編集モードを有効にするページ含める必要がありますには、少なくとも 1 つ<xref:System.Web.UI.WebControls.WebParts.EditorZone>などの 1 つまたは複数の指定された編集を含むゾーン コントロール、<xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart>コントロール、またはカスタムの編集コントロール。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>プログラムでフィールドです。 コードでは、ここでは、参照、設計、および編集するページのサポートされている表示モードのドロップダウン リストを生成します。 編集をサポートするために、`<asp:EditorZone>`要素はページです。 いることを確認、`Page_PreRender`メソッドは、コードのチェックするかどうか、現在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>プロパティに設定されている<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>です。 場合は、 `Label1` 、表示される、存在しない場合`Label1`は表示されません。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/CS/wpmgrEditDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/VB/wpmgrEditDisplayModevb.aspx#1)]  
  
 ブラウザーでページを読み込んだ後は、既定ではブラウズ モードでは。 ページ上のラベルが非表示に注意してください。 ページを編集モードを切り替えるには、ドロップダウン リスト コントロールを使用します。 内のコードによりいることを確認、`Page_PreRender`メソッドをラベルが表示されるようになりました。 クリックして、**編集**の動詞をその特定のコントロールの編集を有効にする、コントロールのいずれかの動詞メニューにします。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="EnableClientScript">
      <MemberSignature Language="C#" Value="public virtual bool EnableClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableClientScript As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableClientScript { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールが含まれた Web ページ上でクライアント側スクリプト機能を有効にするかどうかを決定する値を取得または設定します。</summary>
        <value>ページ上でクライアント スクリプトを実行できるかどうかを示すブール値。 既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A>プロパティは、開発者がクライアント スクリプトを無効にする方法を提供します。 クライアントのセキュリティのために、スクリプトを無効にするか、さまざまなブラウザーを使用している場合でも、ページのすべてのユーザーが、同様のユーザー エクスペリエンスを持つことを確認することができます。  
  
 クライアントを追加してスクリプトを無効にすることができます、`EnableClientScript`属性を<xref:System.Web.UI.WebControls.WebParts.WebPartManager>宣言コードの次の行と同様に、Web ページ上の要素。  
  
 `<asp:webpartmanager id="manager" runat="server"`  
  
 `EnableClientScript="false" />`  
  
 また、開発者このプロパティを継承して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスと、既定の設定値を`false`です。  
  
 Web パーツ コントロール セットは、クライアントのユーザー インターフェイス (UI) や個人用設定機能は、クライアントの一部を提供するスクリプトを使用します。 クライアントを無効にした場合、Web パーツをスクリプト コントロール機能しますが、一部の機能は無効になります。 (動詞は、コントロールのタイトル バー内のリンクとして代わりに表示されます)、コントロールのタイトル バーにドロップダウン動詞メニューに動詞を表示する機能と共に、別のゾーンにコントロールをドラッグする機能は無効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上でテーマを使用できることを示す値を取得します。</summary>
        <value>テーマが有効かどうかを示す Boolean 値。 常に <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>制御オーバーライド ベース<xref:System.Web.UI.Control.EnableTheming%2A>プロパティの値が常に返されることを確認してくださいを`true`です。 これは、コントロールのセットは、Web パーツを表示するためにテーマの使用を制御する必要があります Web パーツは、子コントロールのため、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>制御し、Web ページのユーザー インターフェイス (UI) を形成します。 たとえば、テーマをさまざまなゾーンを表示するために使用しのさまざまな種類を含め、ゾーン内に存在するコントロールのコントロールの一部 (から継承するコントロール、<xref:System.Web.UI.WebControls.WebParts.Part>クラス)、ユーザー コントロール、ASP.NET サーバー コントロール、およびカスタム サーバー コントロールです。  
  
 ただし、オーバーライドされた<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>プロパティは、基本プロパティに従って読み取り/書き込みプロパティとして実装、仕様を値は常に返す必要があるため、プロパティを設定することはできません`true`です。 プロパティを設定しようとする場合、<xref:System.NotSupportedException>例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">プロパティ値を設定しようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartConnecting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartConnecting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartConnecting ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartConnecting();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>一方の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールをもう一方のコントロールに接続するプロセスを完了させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>メソッドに接続するプロセスが完了すると、<xref:System.Web.UI.WebControls.WebParts.WebPart>別のコントロールを制御します。 対応することが、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>メソッドです。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>メソッドはパーソナル化オブジェクトが参照されていることを確認、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>プロパティは変更できますが、パーソナル化の型自体が接続を形成するために必要です。 メソッド、確実に、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>オブジェクトではありません`null`、し、最後に呼び出され、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> プロパティによって参照されるコントロールが <see langword="null" /> です。</exception>
        <block subset="none" type="overrides">
          <para>拡張する必要がある開発者、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />コントロールが派生クラスでは、このメソッドをオーバーライドする可能性があります。 1 つの方法は、基本メソッドを呼び出し、いくつか追加のカスタム処理を追加することや、コントロール間の接続を完了するのプロセス全体を完全にカスタマイズすることがあります。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="EndWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartEditing ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartEditing();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを編集するプロセスを完了させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>メソッドの編集のプロセスが完了すると、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。 対応することが、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>メソッドです。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>メソッドはパーソナル化オブジェクトが参照されていることを確認、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>プロパティは変更できますが、コントロールの編集は、個人的な変更を必要とする処理に必要です。 メソッド、確実に、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>オブジェクトではありません`null`いるため、現在選択されている<xref:System.Web.UI.WebControls.WebParts.WebPart>とコントロールが変更できます。 最後に呼び出され、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> プロパティによって参照されるコントロールが <see langword="null" /> です。</exception>
        <block subset="none" type="overrides">
          <para>拡張する必要がある開発者、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />コントロールが派生クラスでは、このメソッドをオーバーライドする可能性があります。 1 つの方法は、基本メソッドを呼び出し、いくつか追加のカスタム処理を追加することや、コントロールの編集を完了するプロセス全体を完全にカスタマイズすることがあります。 たとえば、オーバーライド メソッドで、最初に、基本メソッドを呼び出すし、いくつかを判断するコード編集の変更点、および確認のため、エンドユーザーにバックアップする変更の一覧が表示されますを追加する可能性があります。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="ExportSensitiveDataWarning">
      <MemberSignature Language="C#" Value="public virtual string ExportSensitiveDataWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ExportSensitiveDataWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ExportSensitiveDataWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ExportSensitiveDataWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーが <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールから重要な状態情報をエクスポートしようとしたときに表示される警告メッセージのテキストを取得または設定します。</summary>
        <value>警告メッセージが含まれた文字列。 既定のメッセージは、.NET Framework が提供するカルチャ固有の値です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーが機密性の高い状態データをエクスポートしようとしたときに、<xref:System.Web.UI.WebControls.WebParts.WebPart>制御、機密データをエクスポートすることを指示して、エクスポートをキャンセルする機会を提供する、メッセージ ボックスにユーザーに警告メッセージが表示されます、ソース コードで「機微」とマークされたメンバーからエクスポートされるデータのいずれかの場合、します。 開発者は設定して機密情報として、特定のメンバーのデータをマークすることができます、`isSensitive`のパラメーター、`[Personalizable]`属性を`true`メンバーにします。 この属性およびパラメーターの詳細については、次を参照してください。、<xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute>クラスです。  
  
> [!IMPORTANT]
>  Web パーツのエクスポート機能を使用するときに、機密性の高いデータは未承認のユーザーにエクスポートすることが可能性があります。 このような脅威から保護する方法の詳細については、「 [Web パーツ ページのセキュリティで保護する](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)です。  
  
 ユーザーをエクスポートするときに、既定のメッセージが表示されます。 ただしで、値を割り当てる、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>プロパティ、カスタムの警告メッセージを指定することができます。  
  
   
  
## Examples  
 次のコード例に示しますの宣言を使用して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>プロパティです。  
  
 次の Web ページのコードは、標準を使用して<xref:System.Web.UI.WebControls.BulletedList>を制御し、ゾーンに配置します。 コントロールが折り返される、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>真として機能できるように、実行時にコントロール<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。 コントロールをエクスポート可能にする、`ExportMode`属性が追加、`<asp:bulletedlist>`要素、および属性値に設定されている<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>、つまり、その機密情報および非機密データをエクスポートすることができます。 なおで、`<asp:webpartmanager>`要素、`ExportSensitiveDataWarning`属性には、カスタムの値が割り当てられます。  
  
 コード例を使用する設定があること、Web パーツの記述ファイルをエクスポートできるようにするために Web.config ファイルに追加する必要がありますに注意してください。 このコード例の Web ページと同じディレクトリ内の Web.config ファイルがあることを確認します。 内で、`<system.web>`セクションであることを確認、`<webParts>`を持つ要素が`enableExport`属性に設定`true`マークアップを次のように、します。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/CS/wpmgrExportSensitiveWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/VB/wpmgrExportSensitiveWarningVB.aspx#1)]  
  
 ブラウザーでページを読み込んだ後は、リンクが含まれているコントロールのタイトル バーに (下向きの矢印で表される) の動詞メニューをクリックします。 動詞メニューで、次のように選択します。**エクスポート**、およびカスタム警告と共に、メッセージ ボックスが表示されるに注意してください。 エクスポートを継続する場合は、クリックして**OK**、コントロールに関するすべてのデータと XML の記述ファイルのローカル コピーを保存することができます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ExportWebPart">
      <MemberSignature Language="C#" Value="public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExportWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExportWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="webPart">データのエクスポート元となるコントロール。</param>
        <param name="writer">エクスポートされたデータを <c>webPart</c> から XML 記述ファイルに書き込む <see cref="T:System.Xml.XmlWriter" />。</param>
        <summary>サーバー コントロールの状態データとプロパティ データが格納された XML 記述ファイルを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>メソッドからさまざまな状態とプロパティのデータのアセンブル`webPart`が XML ファイルにします。 データには、そのアセンブリ、状態データ、およびプロパティのデータを含め、コントロール自体に関する情報が含まれます。 エクスポートを開始したユーザーは、ローカル コンピューターまたはネットワーク上、XML ファイルをディスクに保存できます。 他のユーザーを別のページまたは Web サイトの説明ファイルをインポートし、状態とプロパティのデータの別のインスタンスに適用`webPart`です。 これを共有し、サーバー コントロールで、設定を再利用のユーザーの高速かつ便利な機構を提供し、エクスポートおよびインポートされたコントロールの動作と外観を制御するための手段を開発者にも提供します。  
  
 プロパティを`webPart`既定ではエクスポートされません。 プロパティのエクスポートを有効にするを使用してマークする必要があります、`[Personalizable]`ソース コード内の属性です。 また、必要に応じて、エクスポート可能なプロパティを設定して、デリケートなデータを含むようをマークすることができます、`isSensitive`のパラメーター、`[Personalizable]`属性を`true`です。 既定では、`isSensitive`は`false`します。 開発者がパラメーターを設定できる`true`データが機密性の高いであることを示します。  
  
 有効にする`webPart`開発者の設定をエクスポート、<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>プロパティの値をいずれかの<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>(を含むすべてのパーソナライズできると機微なプロパティ) をまたはに<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.NonSensitiveData>、機微なプロパティを除くすべてをエクスポートします。  
  
> [!IMPORTANT]
>  コントロールからデータをエクスポートし、その他のコントロールにデータをインポートできるように、いくつかのセキュリティ リスクが伴います。 開発者は、機密データを保護する上で説明した方法を使用する必要があり、完全にデータを公開するリスクを回避する場合が有効にしないでくださいエクスポート`webPart`まったくです。 Web パーツのセキュリティの問題の詳細については、「 [Web パーツ ページのセキュリティで保護する](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" />です。  
  
 \- または  
  
 <paramref name="writer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> が、<see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> で参照されるコントロールのコレクションに格納されていません。  
  
 \- または  
  
 <paramref name="webPart" /> の <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" /> プロパティが、<see cref="F:System.Web.UI.WebControls.WebParts.WebPartExportMode.None" /> の値に設定されています。これは、<paramref name="webPart" /> のエクスポートが無効になっていることを示します。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Focus();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>オーバーライドして、ユーザー インターフェイス (UI) のない <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールにフォーカスが設定されるのを防ぎます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Focus%2A>メソッドは、ベース<xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType>メソッドを呼び出し元がメソッドを呼び出した場合に例外をスローします。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>フォーカスをそれ自体で設定できることはありません、コントロールが UI を持たないされ、ユーザーに表示されることはありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出し元が、UI のないコントロールではサポートされていない <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" /> メソッドを呼び出そうとします。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumerConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ConsumerConnectionPointCollection ^ GetConsumerConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">接続でコンシューマーとして動作するサーバー コントロール。</param>
        <summary>Web パーツ接続内でコンシューマーとして動作するサーバー コントロールから、コネクション ポイントとして機能できる <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" /> オブジェクトのコレクションを取得します。</summary>
        <returns>コンシューマーのすべてのコネクション ポイントが格納された <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 常に Web パーツの接続には、データのコンシューマーとして、データ プロバイダーとして機能する 1 つ、2 つのコントロールが含まれます。 各コントロールの接続ポイントとして定義されている 1 つまたは複数のメソッドが必要です。 接続ポイントは、の場合は、コンシューマー コントロール<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>オブジェクト。 Web パーツ接続の構成に必要な手順は、コンシューマー接続ポイントを取得します。  
  
 コンシューマーには、接続を確立できるようにするには、少なくとも 1 つの接続ポイントが常に必要です。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>メソッドは、コンシューマーのコントロールをチェックし、そのすべてのコネクション ポイントのコレクションを取得します。 場合、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールには、接続ポイントがない、空のコレクションが返されます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> メソッドの使用方法を示します。  
  
 このコード例では、4 つの部分があります。  
  
-   ユーザー コントロールを Web パーツ ページの表示モードを変更することができます。  
  
-   2 つのカスタムを含む Web ページ<xref:System.Web.UI.WebControls.WebParts.WebPart>接続可能なコントロールと`<asp:webpartmanager>`要素。  
  
-   2 つのカスタムを含むソース コード ファイル<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールとカスタム インターフェイスです。  
  
-   ブラウザーでの例の動作についての説明。  
  
 コード例の最初の部分は、ユーザー コントロールの表示モードを変更するためです。 セクションの例からユーザー コントロールのソース コードを取得することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要です。 表示モードとユーザー コントロールの動作方法の詳細については、トピックを参照してください。[チュートリアル: Web パーツ ページの表示モードの変更](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)です。  
  
 Web ページの宣言型マークアップを含む`Register`ユーザー コントロールとカスタム コントロールの両方のディレクティブ。 `<asp:webpartmanager>`要素、`<asp:webpartzone>`カスタム コントロールを追加する要素と`<asp:connectionszone>`要素。 注意、`Page_Load`メソッド、コードを確認するかどうかの接続を既に存在し、いない場合は、プロバイダー、定義、コンシューマーがそれぞれのコネクション ポイントと、によって参照される静的な接続のセットに新しい接続を追加します<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>プロパティです。 なお、<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection>を使用して取得するオブジェクト、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>メソッドに渡され、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 2 つのコントロール間の接続を作成できるかどうかを決定するメソッド。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 例では、3 番目の部分では、コントロールのソース コードを示します。 このコードとのセクションの例から、コンパイルするための手順を取得することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要です。  
  
 ブラウザーで Web ページが読み込まれた後にをクリックして、**表示モード**ドロップダウン リスト コントロールと選択**接続**接続モードをページに切り替えます。 接続モードでは使用、`<asp:connectionszone>`要素を使用すると、コントロール間の接続を作成します。 接続モードのタイトル バーの下向き矢印をクリックして、**郵便**の動詞メニューをアクティブに制御し、をクリックして**接続**です。 接続のユーザー インターフェイス (UI) が表示されたらに含まれているコードによって、接続を作成されていることに注意してください、`Page_Load`メソッドです。 以降のブラウザー セッションでこのページに戻り、この静的な接続は既に確立され、ページが読み込まれるたびに再作成する必要はありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentWebPartManager">
      <MemberSignature Language="C#" Value="public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::WebControls::WebParts::WebPartManager ^ GetCurrentWebPartManager(System::Web::UI::Page ^ page);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> のインスタンスが含まれている Web ページ。</param>
        <summary>ページ上の <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールの現在のインスタンスへの参照を取得します。</summary>
        <returns>ページ上のコントロールの現在のインスタンスを参照する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>メソッドは現在への参照を取得するコンテキストで役に立ちます<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。 これが発生する一般的なシナリオは、カスタム コントロールがで認識できない開発中の ID を作成するかどうか、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>そのページ上のコントロールになります。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>メソッドは静的なのインスタンスを必要とせずに直接呼び出すことができますので、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。  
  
 Web パーツの一部のコントロールなど、セットの制御<xref:System.Web.UI.WebControls.WebParts.WebPart>、コントロールが、<xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A>現在への参照を取得するプロパティ<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。 そのため、このようなコントロールを使用する場合は、このプロパティを使用して、その参照を取得する必要があります。  
  
 ID を確認するコンテキストをコーディングするかどうか、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>制御など、Web ページ内でインライン コードを記述するには、単純に直接参照する最も効率的な<xref:System.Web.UI.WebControls.WebParts.WebPartManager>その ID を使用するコントロール  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> メソッドの使用方法を示します。 この例は、2 つの部分: カスタム サーバー コントロールおよびコントロールをホストする Web ページ。  
  
 カスタム<xref:System.Web.UI.WebControls.Label>コントロール、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>の ID を取得する方法を<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールを現在のページとし、ID が表示されます  
  
 [!code-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/MyManagerIDLabel.cs#2)]
 [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/MyManagerIDLabel.vb#2)]  
  
 次のコード例でコントロールをホストする Web ページが用意されています、<xref:System.Web.UI.WebControls.WebParts.WebPartZone>ゾーンです。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/getCurrentWPManagerCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/getcurrentWPManagervb.aspx#1)]  
  
 ブラウザーでページを読み込むことに注意して、現在の ID<xref:System.Web.UI.WebControls.WebParts.WebPartManager>カスタム内でコントロールが表示される<xref:System.Web.UI.WebControls.Label>コントロール。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="page" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDisplayTitle">
      <MemberSignature Language="C#" Value="protected internal virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetDisplayTitle(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetDisplayTitle(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">このメソッドが <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> の値を返す対象となるコントロール。</param>
        <summary>
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> コントロールの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> プロパティの値が含まれた文字列を取得します。</summary>
        <returns>
          <paramref name="webPart" /> の <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> の計算された値が格納される文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 計算値を取得、<xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A>プロパティ`webPart`です。 ときに開発者を割り当てないでください値を<xref:System.Web.UI.WebControls.WebParts.Part.Title%2A>のプロパティ、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、このメソッドは、タイトルとして表示する値を生成します。 タイトルのないコントロールの計算値は、示す現在のゾーン内のコントロールのシーケンス番号が付加された文字列、数値で構成されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> が <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コレクション内にありません。</exception>
        <block subset="none" type="overrides">
          <para>このメソッドをオーバーライドすると、既定の表示タイトルを計算する方法を変更します。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />
      </Docs>
    </Member>
    <Member MemberName="GetExportUrl">
      <MemberSignature Language="C#" Value="public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetExportUrl(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetExportUrl(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">エクスポートされる <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</param>
        <summary>ユーザーが <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールをエクスポートしようとするときの要求に含まれる相対仮想パスとクエリ文字列を取得します。</summary>
        <returns>コントロールのエクスポート要求を構成する相対仮想パスとクエリ文字列が含まれた文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 によって返される値、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A>メソッドは、コントロールが含まれているページのサーバーの場所への相対仮想パスとエクスポート要求を形成する、追加したクエリ文字列の値をサーバーに送信します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A>メソッドが要求を送信する、悪意のあるスクリプト攻撃に対する保護を許可する前に、文字列をエンコードします。  
  
> [!NOTE]
>  Web パーツ アプリケーションのセキュリティ保護に関する詳細については、次を参照してください。 [Web パーツ ページのセキュリティで保護する](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::GenericWebPart ^ GetGenericWebPart(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 内に存在し、実行時に <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> の子コントロールとしてラップされるサーバー コントロール。</param>
        <summary>サーバー コントロールが含まれた <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> コントロールのインスタンスへの参照を取得します。</summary>
        <returns>
          <paramref name="control" /> を子コントロールとしてラップする <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />。 このメソッドは、<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> に <paramref name="control" /> が含まれていない場合は <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般に、開発者に配置されるコントロールの 2 つのカテゴリがある<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>Web パーツのアプリケーションに参加するゾーン:<xref:System.Web.UI.WebControls.WebParts.WebPart>から継承される、コントロール、<xref:System.Web.UI.WebControls.WebParts.WebPart>基本クラス、およびその他のサーバー コントロール、標準の ASP.NET コントロール、カスタム コントロール、またはユーザー コントロールを指定できます。 配置するとこれらのコントロールのいずれかが、<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>の機能にかかる、ゾーン、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。 A<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールが本質的に、この機能を持つが、サーバー コントロールの他の種類がありません。 として機能する他のサーバー コントロールを有効にする<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールに配置されるときに、<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーン、ASP.NET にラップ、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>コントロール。 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart>コントロールがから直接継承、<xref:System.Web.UI.WebControls.WebParts.WebPart>クラス、その提供の子コントロールは true。 Web パーツ機能します。  
  
 多くの場合、実行時にページを開発することもへの参照を取得、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>ゾーン内のサーバー コントロールのいずれかが含まれるコントロール。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>への参照を取得することにより、メソッド、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>コントロール。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>メソッドです。 このコード例が含まれています、<xref:System.Web.UI.WebControls.Calendar>内で宣言されているコントロール、<xref:System.Web.UI.WebControls.WebParts.WebPartZone>ゾーンです。 `Button1_Click`メソッドは、最初の ID を出力、<xref:System.Web.UI.WebControls.Calendar>コントロール ラベル、および、使用、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>への参照を取得する方法を<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>カレンダーをラップするコントロール。 ID、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>制御、およびその子コントロールの ID (これは、<xref:System.Web.UI.WebControls.Calendar>コントロール)、両方が 2 番目のラベルを印刷します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/CS/getGenericWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/VB/getGenericWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ProviderConnectionPointCollection ^ GetProviderConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">接続でプロバイダーとして動作するサーバー コントロール。</param>
        <summary>Web パーツ接続内でプロバイダーとして動作するサーバー コントロールから、コネクション ポイントとして機能できる <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" /> オブジェクトのコレクションを取得します。</summary>
        <returns>プロバイダーのすべてのコネクション ポイントが格納された <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 常に Web パーツの接続には、データのコンシューマーとして、データ プロバイダーとして機能する 1 つ、2 つのコントロールが含まれます。 各コントロールの接続ポイントとして定義されている 1 つまたは複数のメソッドが必要です。 接続ポイントは、の場合は、プロバイダー コントロール<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>オブジェクト。  
  
 プロバイダーには、接続を確立できるようにするには、少なくとも 1 つの接続ポイントが常に必要です。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>メソッドは、プロバイダーのコントロールをチェックし、そのすべてのコネクション ポイントのコレクションを取得します。 Web パーツ接続の構成に必要な手順は、プロバイダー接続ポイントを取得します。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> メソッドの使用方法を示します。  
  
 この例では、4 つの部分があります。  
  
-   ユーザー コントロールを Web パーツ ページの表示モードを変更することができます。  
  
-   2 つのカスタムを含む Web ページ<xref:System.Web.UI.WebControls.WebParts.WebPart>接続可能なコントロールと`<asp:webpartmanager>`要素。  
  
-   2 つのカスタムを含むソース コード ファイル<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールとカスタム インターフェイスです。  
  
-   ブラウザーでの例の動作についての説明。  
  
 コード例の最初の部分は、ユーザー コントロールの表示モードを変更するためです。 セクションの例からユーザー コントロールのソース コードを取得することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要です。 表示モードとユーザー コントロールの動作方法の詳細については、次を参照してください。[チュートリアル: Web パーツ ページの表示モードの変更](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)です。  
  
 Web ページの宣言型マークアップを含む`Register`ユーザー コントロールとカスタム コントロールの両方のディレクティブ。 `<asp:webpartmanager>`要素、`<asp:webpartzone>`カスタム コントロールを追加する要素と`<asp:connectionszone>`要素。 注意、`Page_Load`メソッド、コードを確認するかどうかの接続を既に存在し、いない場合は、プロバイダー、定義、コンシューマーがそれぞれのコネクション ポイントと、によって参照される静的な接続のセットに新しい接続を追加します<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>プロパティです。 なお、<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection>を使用して取得するオブジェクト、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>メソッドに渡され、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 2 つのコントロール間の接続を作成できるかどうかを決定するメソッド。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 例では、3 番目の部分では、コントロールのソース コードを示します。 このコードとのセクションの例から、コンパイルするための手順を取得することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要です。  
  
 ブラウザーで Web ページが読み込まれた後にをクリックして、**表示モード**ドロップダウン リスト コントロールと選択**接続**接続モードをページに切り替えます。 接続モードでは使用、`<asp:connectionszone>`要素を使用すると、コントロール間の接続を作成します。 接続モードのタイトル バーの下向き矢印をクリックして、**郵便**の動詞メニューをアクティブに制御し、をクリックして**接続**です。 接続のユーザー インターフェイス (UI) が表示されたらに含まれているコードによって、接続を作成されていることに注意してください、`Page_Load`メソッドです。 以降のブラウザー セッションでこのページに戻り、この静的な接続は既に確立され、ページが読み込まれるたびに再作成する必要はありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="ImportWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart ImportWebPart(class System.Xml.XmlReader reader, [out] string&amp; errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportWebPart (reader As XmlReader, ByRef errorMessage As String) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ ImportWebPart(System::Xml::XmlReader ^ reader, [Runtime::InteropServices::Out] System::String ^ % errorMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="errorMessage" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="reader">インポート元となる XML 記述ファイルから状態データとプロパティ データを読み取る <see cref="T:System.Xml.XmlReader" />。</param>
        <param name="errorMessage">インポート中にエラーが発生した場合にユーザーに表示される <see cref="T:System.String" />。</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールの状態データとプロパティ データが格納された XML 記述ファイルをインポートし、コントロールにそのデータを適用します。</summary>
        <returns>インポート元となる XML 記述ファイルで参照される <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (または、<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> でラップされ、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> として扱われるサーバー コントロール)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>メソッドによって作成された XML の記述ファイルをインポートする、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>サーバー コントロールのメソッドです。 できませんが、インポートされると、実際のサーバー コントロール、コントロールに関する状態とプロパティのデータを含む description ファイルのみ。 コントロールと description ファイルで参照されるアセンブリは、ユーザーが記述ファイルをインポートしようとした、サーバーで使用できるおく必要があります。  
  
 コントロールをインポートするのには、開発者は追加する必要があります、<xref:System.Web.UI.WebControls.WebParts.CatalogZone>インポートを有効にする場所 ページで制御します。 ゾーン内で、<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>コントロールを追加する必要があります。 このコントロールを参照して、インポートする説明ファイルを検索できるファイル ダイアログ ボックスを提供します。  
  
 記述ファイルを読み取るユーザー インポートを開始、記述ファイルを検索して、後に、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>メソッドです。 エラーがないと、サーバー コントロールが内でカタログに追加したアセンブリとコントロールが見つからない場合は、<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>制御、および description ファイルで指定されたさまざまなプロパティおよび状態データをコントロールに適用されます。 ユーザーは、コントロールを選択し、ページに追加します。  
  
> [!IMPORTANT]
>  同様に、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> 、メソッド、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>メソッドのセキュリティ リスクの可能性があります。 Web サイトにデータをインポートすることでは、悪意のあるユーザーでしたインポートされる description ファイルに不適切なデータやスクリプト コードを挿入しようとします。 ページ、またはデータベースでは、不適切なデータを表示し、または挿入されたスクリプトが実行可能性があります。 インポートの説明ファイル、およびこれらのリスクを回避する方法に関連する潜在的なリスクの詳細については、次を参照してください。 [Web パーツ ページのセキュリティで保護する](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.EndOfStreamException">
          <paramref name="reader" /> はこのファイルを読み取ることができませんでした。  
  
 \- または  
  
 <paramref name="reader" /> は、インポート エラー メッセージを表示する必要がありましたが、ファイル内にそれが見つかりませんでした。  
  
 \- または  
  
 <paramref name="reader" /> はファイルの末尾に到達しましたが、エクスポート データが格納された XML 要素が見つかりませんでした。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ImportCatalogPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Internals">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Internals As WebPartManagerInternals" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ Internals { System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManagerInternals</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>実際には <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> クラスに実装されていても、ほとんどの場合コントロールの開発者に役立つメソッドのセットを構成したり分割したりするために使用する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスへの参照を取得します。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> が、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> に分割されたさまざまなメソッドを参照できる、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>プロパティのセットへの呼び出しを Api を公開する<xref:System.Web.UI.WebControls.WebParts.WebPartManager>機能拡張の場合も多くの場合に使用されるメソッド。  
  
 これらの内部メソッドを使用するための設計方法からそれらにアクセスする、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>プロパティです。 プロパティが保護されているためだけにアクセスしてのインスタンス内のメソッドを呼び出して、<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>クラスから継承することによって、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスです。  
  
> [!NOTE]
>  このプロパティは IntelliSense から非表示に[!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]です。 ただしでは、派生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラス、プロパティとそのさまざまなメンバーにアクセスできます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAuthorized">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールをページに追加できるかどうかを判断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web パーツの機能の柔軟性の一部は、実行時に Web ページにサーバー コントロールを追加する機能です。 さまざまなサーバーを制御するための一般的なシナリオがあります (カスタムできる<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、カスタム サーバー コントロール、ユーザー コントロール、または ASP.NET コントロール) を追加できます。  
  
 次の一般的なシナリオで Web パーツ コントロール セットに ページでは、サーバー コントロールを追加しようと<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>メソッドは、それらを承認するために呼び出されます。  
  
-   内の Web ページのマークアップで宣言することにより、サーバー コントロールが追加されたとき、<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーンです。  
  
-   ときに、サーバー コントロールは、ゾーンにプログラムで追加されます。  
  
-   ときに、ユーザーはサーバー コントロールをコントロールの Web パーツのカタログにインポートします。  
  
-   既存のサーバー コントロールは、パーソナル化データ ストアから読み込まれます。  
  
-   サーバー コントロールを追加するときに、<xref:System.Web.UI.WebControls.WebParts.DeclarativeCatalogPart>サーバー コントロールのカタログで使用できるようにするコントロール。  
  
 コントロールが追加された各シナリオでは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>を追加するコントロールを許可するすべての承認条件が満たされていることを確認するメソッドが呼び出されます。 コントロールが承認されるは、フィルター処理がないかどうかになりますと正常に追加されます。 コントロールが許可されていないときは、Web パーツ コントロール セットが、状況に応じて、いくつかの方法で応答できます。 コントロール セットを (ユーザーに通知する必要はありません) の場合は、承認されていない部分を追加できないことがサイレント モードで、エラー メッセージを表示できるまたはのインスタンスを追加できます、<xref:System.Web.UI.WebControls.WebParts.UnauthorizedWebPart>プレース ホルダーとしてクラスです。 このプレース ホルダー オブジェクトは ページで、表示されませんが、許可されていないコントロールが除外されたことを示すために、ページのソース コードに表示されます。  
  
 コントロールが承認されているかどうかの決定は、承認フィルターです。 承認フィルターは、開発者は、指定した条件を満たしていないすべてのコントロールをページから除外する Web パーツ コントロール セットの機能です。  
  
 フィルター処理を作成するには、開発者は、次の 2 つを行う必要があります。 (値は任意で指定できます) を文字列値を割り当てる必要があります最初に、<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>の各プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール シナリオで使用する予定です。 他の種類がないサーバー コントロールのこのプロパティに値を割り当てることも、<xref:System.Web.UI.WebControls.WebParts.WebPart>を制御するために配置される場合<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーンでは、このようなコントロールでラップされて、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 、実行時に制御し、このコントロールの継承<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティです。  
  
 フィルター処理を作成するために必要な 2 番目の手順は、いずれかにオーバーライド、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>メソッド、またはイベント ハンドラーを作成、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>イベント。 これらのメソッドで、開発者が確認できます、<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティの値がコントロールを承認されていないことを示している場合、開発者ことを確認して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>メソッドの値を返します`false`です。  
  
> [!NOTE]
>  コード例とカスタマイズされたフィルタ リングのシナリオを使用して、設定する方法の説明、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>メソッド、メソッドのオーバー ロードのトピックを参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAuthorized(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAuthorized(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">承認をチェックする対象の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロール。</param>
        <summary>ページへのコントロールの追加が承認されているかどうかを判断する最初の手順を実行します。</summary>
        <returns>
          <paramref name="webPart" /> をページに追加できるかどうかを示すブール値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>メソッドは、Web パーツ コントロール セットの承認をチェックするによって呼び出される最初のメソッド、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。 受け取って`webPart`をパラメーターとして最終的には、コントロールをページに追加するかどうかを決定するプロセスを開始します。 このメソッド コードから直接呼び出す特定の制御が承認されているかどうかを確認する必要がある場合。  
  
 このメソッドは、コントロールがから継承するかどうかを判断する初期のタスクを実行、<xref:System.Web.UI.WebControls.WebParts.WebPart>クラスかが、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>制御し、必要な場合は、子の種類の制御が含まれています。 呼び出しの承認のタスクを完了するには<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>メソッドをオーバー ロードします。  
  
   
  
## Examples  
 次のコード例を呼び出す方法を示しています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29>ページに追加する、コントロールが承認されるかどうかを決定するコードからメソッドです。  
  
 このコード例では、3 つの部分があります。  
  
-   カスタム<xref:System.Web.UI.WebControls.WebParts.WebPartManager>オーバーライド コントロール、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>メソッドです。  
  
-   フィルターを作成する Web ページ、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。  
  
-   コード例を実行する方法の説明。  
  
 このコード例を使用するカスタム<xref:System.Web.UI.WebControls.WebParts.WebPartManager>オーバーライド コントロール、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>のカスタム処理を提供するメソッドをオーバー ロード、<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティです。 このコントロールのプロパティの値をチェック`admin`と、値が存在する場合は、コントロールを承認します。 コントロールに別の値がある場合は、許可されていません。プロパティ値を持たないコントロールは、フィルター処理シナリオに含めることが想定されていると同様に、承認されます。  
  
 このコード例を実行するには、このソース コードをコンパイルする必要があります。 コンパイルするには明示的にし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに結果として得られるアセンブリを配置できます。 またはを動的にコンパイルされる実行時に、サイトの App_Code フォルダー内のソース コードを配置することができます。 このコード例では、動的コンパイル メソッドを使用します。 コンパイルする方法について説明するチュートリアルでは、次を参照してください。[チュートリアル: カスタム Web サーバー コントロールの開発と](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)です。  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 コード例の 2 番目の部分では、コントロールを除外できるフィルターを作成します。 次の Web ページにはで、次の 3 つの ASP.NET サーバー コントロールが含まれています、`<asp:webpartzone>`要素。 最初と 2 番目のコントロールがあることを確認、<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティが別の値に設定され、3 つ目は、プロパティを割り当てません。 この承認値は、実行時にチェックすることができ、フィルター開発者によって設定される条件に一致する場合は、ページにコントロールを追加できます。 注意も、`Page_Load`メソッドを呼び出し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29>かどうか、コントロールの各が承認されていると、かどうか各コントロールのため、その設定を判断するメソッド<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>プロパティです。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 コード例を実行する必要があります設定を追加する Web パーツの記述ファイルをエクスポートできるようにするために Web.config ファイルに注意してください。 このコード例の Web ページと同じディレクトリ内の Web.config ファイルがあることを確認します。 内で、`<system.web>`セクションであることを確認、`<webParts>`を持つ要素が`enableExport`属性に設定`true`マークアップを次のように、します。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 ブラウザーでページを読み込んだ後に注意してください、最初のコントロールが表示されているオーバーライド メソッドで条件に一致するためです。 フィルターによって除外されるため、2 つ目のコントロールは、ページに追加されません。 ないため、3 番目のコントロールを追加またはその<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティ セットです。 エクスポートことのいずれかのコントロールのタイトル バーに動詞メニューのアイコンをクリックした場合、両方が可能に注意してください、それぞれ<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>プロパティ値が割り当てられます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> は <see langword="null" />です。</exception>
        <block subset="none" type="usage">
          <para>このメソッドは、コードから直接呼び出されます。 承認プロセスを細かくのプログラムで制御する場合は、上書き、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />メソッドをオーバー ロードします。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAuthorized(class System.Type type, string path, string authorizationFilter, bool isShared) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAuthorized(Type ^ type, System::String ^ path, System::String ^ authorizationFilter, bool isShared);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="authorizationFilter" Type="System.String" />
        <Parameter Name="isShared" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">承認されているかどうかを確認するコントロールの <see cref="T:System.Type" />。</param>
        <param name="path">コントロールがユーザー コントロールの場合は、承認されるコントロールのソース ファイルへの相対アプリケーション パス。</param>
        <param name="authorizationFilter">コントロールをページに追加できるかどうかを判断して承認するために使用される、<see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" /> コントロールの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> プロパティに割り当てる任意の文字列値。</param>
        <param name="isShared">承認されているかどうかを確認するコントロールが共有コントロール (つまり、アプリケーションの多くのユーザーまたはすべてのユーザーに対して表示され、その <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" /> プロパティ値が <see langword="true" /> に設定されている) かどうかを示します。</param>
        <summary>ページへのコントロールの追加が承認されているかどうかを判断する最後の手順を実行します。</summary>
        <returns>ページへのコントロールの追加が承認されるかどうかを示すブール値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>オーバー ロード メソッドは、コントロールがページに追加する承認されるかどうかを決定する最終手順を実行します。 メソッドにより`type`は有効な型とする`path`がチェックされる、コントロールがユーザー コントロールである場合にのみ値を持ちます。 重要なことは呼び出して<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>を生成するメソッド、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>イベント。  
  
   
  
## Examples  
 次のコード例をオーバーライドする方法を示しています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>ページに追加する、コントロールが承認されるかどうかを調べます。  
  
 最初の手順では、コントロールを除外できるフィルターを作成します。 次の Web ページにはで、次の 3 つの ASP.NET サーバー コントロールが含まれています、`<asp:webpartzone>`要素。 最初と 2 番目のコントロールがあることを確認、<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティが別の値に設定され、3 つ目は、プロパティを割り当てません。 この承認値は、実行時にチェックすることができ、フィルター開発者によって設定される条件に一致する場合は、ページにコントロールを追加できます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 2 番目の手順は、オーバーライドする、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>メソッド、カスタム承認フィルターの処理を作成します。 コードは、最初が検査するプロパティが値を持つかどうかを制御できるようにメモを割り当てない、<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティは自動的に追加されます。 コントロールしているかどうか、フィルター、コードを返します`true`フィルターの値が等しい場合にのみ`admin`です。 これは、ロールによって、特定のユーザーに特定のコントロールを表示するために使用する単純なメカニズムを示します。 ロールを使用して完全な例は、このトピックの範囲外ですが、でしたとして使用するのと同じロジックこのコード例では、オーバーライドしたメソッドが、現在のユーザーが、承認フィルター値に一致するロールにかどうかをチェックする可能性があります。、し、そのユーザーにのみ、コントロールを追加します。 これにより、一部のユーザーは、すべてのコントロールを参照してくださいおよび他のユーザーが選択したコントロールのみを表示、ページを作成できます。 これは、フィルターを確認するロジックが検索する方法の役割を使用した場合です。  
  
```vb  
If Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  
  return True  
Else  
  return False  
End If  
```  
  
```csharp  
if(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  
    return true;  
else  
    return false;  
```  
  
 コード例を実行するには、このソース コードをコンパイルする必要があります。 コンパイルするには明示的にし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに結果として得られるアセンブリを配置できます。 またはを動的にコンパイルされる実行時に、サイトの App_Code フォルダー内のソース コードを配置することができます。 このコード例では、動的コンパイル メソッドを使用します。 コンパイルする方法について説明するチュートリアルでは、次を参照してください。[チュートリアル: カスタム Web サーバー コントロールの開発と](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)です。  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 ブラウザーでページを読み込んだ後に注意してください、最初のコントロールが表示されているオーバーライド メソッドで条件に一致するためです。 そのフィルター値が除外されているために、2 つ目のコントロールは、ページに追加されません。 ないために、3 番目のコントロールが追加されたその<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティ セットです。 最初のコントロールと一致し、ページを再度実行する 2 つ目のコントロールのプロパティ値を変更すると、2 つ目のコントロールがも追加されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> がユーザー コントロールで、<paramref name="path" /> が <see langword="null" /> または空の文字列 ("") のいずれかです。  
  
 \- または  
  
 <paramref name="type" /> がユーザー コントロール以外で、<paramref name="path" /> に値が割り当てられています。</exception>
        <block subset="none" type="overrides">
          <para>継承することで、このメソッドをオーバーライドすることができます、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラス、承認をチェックするときに、追加の処理を提供する場合。 特定の値をチェックするメソッドをオーバーライドすることができます、<paramref name="authorizationFilter" />パラメーター値に基づき、コントロールをページに追加するかどうかを判断するブール値を返すとします。  
  
 ページする開発者向けも承認フィルターを確認して、カスタム処理を提供する、すべてのクラスから継承することがなく、.aspx ページ、または分離コード ファイルでは、このインラインを行うためのオプションがあります。 ページで代替のイベント ハンドラーを宣言することができます、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />のメソッド、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />コントロール。 詳細および例に、次を参照してください。、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />メソッドです。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsCustomPersonalizationStateDirty">
      <MemberSignature Language="C#" Value="protected virtual bool IsCustomPersonalizationStateDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsCustomPersonalizationStateDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsCustomPersonalizationStateDirty { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールにより制御されるページ レベルのパーソナル化の情報に影響を与えるような、パーソナル化に関する変更が行われたかどうかを示す値を取得します。</summary>
        <value>パーソナル化に関する変更が行われたかどうかを示すブール値。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>かどうかを管理するページ レベルのパーソナル化データのいずれかを追跡するために内部的にプロパティが変更されました。 ユーザーが追加や削除など、ページ レベルでのさまざまなパーソナル化操作を実行時に、パーソナル化データが変更された<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、接続または切断コントロール、コントロール、およびその他のアクションを移動することによって、ページのレイアウトを変更します。  
  
> [!NOTE]
>  ユーザーが特定のコントロールに個人的な変更を行えることを意味する制御レベルでのパーソナル化を実行しても、変更のみを制御するには影響します。 例は、コントロールを編集とそのタイトルのテキストまたはその背景色を変更するとします。 コントロール レベルのパーソナル化ではによって追跡されるページ レベルのパーソナル化データには影響しません、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール、ため、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>にプロパティ値が変更されない`true`コントロール レベルのパーソナル化が発生したとき。  
  
 メソッドが保護されているし、呼び出し元が直接アクセスすることはできませんが、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>プロパティに、呼び出し元によって直接アクセスして、このプロパティの値を返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationState.IsDirty" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationState.SetDirty" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal override void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void LoadControlState(System::Object ^ savedState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">読み込む対象となる永続的な状態データを格納します。</param>
        <summary>前回のページ要求で保存され、後続の要求で復元する必要のある、コントロールの状態データを読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>メソッドは、ページのポストバック間で永続化するプロパティのデータを復元するための便利な場合でも、<xref:System.Web.UI.Control.EnableViewState%2A>プロパティに設定されている`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="savedState" /> は有効な <see cref="P:System.Web.UI.PageStatePersister.ControlState" /> ではありません。</exception>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">読み込む状態データを含む <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />。</param>
        <summary>初期化プロセス中に後で使用するためにパーソナル化オブジェクトによって <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールに渡されたカスタムのパーソナル化データを格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A>メソッドの形式で保存された状態データを提供する、<xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary>オブジェクト。 このデータは Web パーツ コントロールにパーソナル化データを読み込むと、その他の初期化タスクを実行する最終的に使用されます。  
  
> [!NOTE]
>  このメソッドは、ときに開始するメソッドのシーケンス、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A>メソッドを最初に、関連付けられている要求<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>パーソナル化データを提供するオブジェクト、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。  
  
 このメソッドは、コードから直接呼び出すことはできません。 直接呼び出すことができます、ただし、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>自体メソッドの呼び出し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A>メソッドとパーソナル化データを返します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開発者、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />派生メソッド<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスです。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="MediumPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MediumPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MediumPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MediumPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MediumPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Security.PermissionSet" /> および <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> のアクセス許可のみを付与する <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> オブジェクトを取得します。</summary>
        <value>
          <see cref="T:System.Security.PermissionSet" /> および <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> のアクセス許可のみを付与する <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet>このプロパティによって返されるオブジェクトは型の逆シリアル化のインポート中に使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimalPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MinimalPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MinimalPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MinimalPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Security.PermissionSet" /> および <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> のアクセス許可のみを付与する <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> オブジェクトを取得します。</summary>
        <value>
          <see cref="T:System.Security.PermissionSet" /> および <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> のアクセス許可のみを付与する <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> オブジェクトを取得します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet>逆シリアル化を入力する点を除いてすべてのインポート中にこのプロパティによって返されるオブジェクトを使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveWebPart">
      <MemberSignature Language="C#" Value="public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">移動される <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはその他のサーバー コントロール。</param>
        <param name="zone">
          <c>webPart</c> の移動先の <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</param>
        <param name="zoneIndex">
          <c>ゾーン</c>内の他のコントロールに対する <c>webPart</c> の相対インデックスを示す整数。</param>
        <summary>1 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーンから別のゾーンまたは同じゾーン内の新しい位置に、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> コントロールまたはサーバー コントロールを移動します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>メソッドに移動する`webPart`を新しい場所が同じゾーンまたはゾーンが異なる。 このメソッドは、コードから直接呼び出すことができ、ユーザー コントロールを Web パーツのユーザー インターフェイス (UI) でさまざまなオプションを使用して新しい位置に移動するときにも呼び出されます。  
  
 前に、さまざまな条件を満たす必要がある`webPart`、移動することができ、これらのほとんどは、このトピックの例外セクションに表示される項目で示されます。 場合`webPart`に含まれていない、<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーン、ゾーンに最初に、移動することはできません。  
  
 移動する、次の一連の操作が発生する条件が満たされると後、 `webPart`:  
  
1.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> イベントを発生させます。  
  
2.  `webPart` 現在のゾーン (必要な場合) から削除され、新しいゾーンまたは現在のゾーン内の新しい位置に追加します。  
  
3.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> イベントを発生させます。  
  
4.  `zoneIndex`の各<xref:System.Web.UI.WebControls.WebParts.WebPart>送信元と送信先の両方のゾーンでのコントロールは移動を反映するようにリセットします。  
  
   
  
## Examples  
 次のコード例を呼び出す方法を示しています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>メソッドに移動するコードから直接、 <xref:System.Web.UI.WebControls.WebParts.WebPart> 1 つのゾーンから別のコントロールです。  
  
 このコード例では、3 つの部分があります。  
  
-   表示モードを変更するユーザー コントロールです。  
  
-   コントロールをホストする Web ページです。  
  
-   コード例を実行する方法の説明。  
  
 コード例の最初の部分は、ユーザー コントロールの表示モードを変更するためです。 セクションの例からユーザー コントロールのソース コードを取得することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要です。 表示モードとユーザー コントロールの動作方法の詳細については、次を参照してください。[チュートリアル: Web パーツ ページの表示モードの変更](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)です。  
  
 例では、2 番目の部分は、2 つのサーバー コントロールを含む 2 つのゾーンを含む Web ページです。 ユーザーがクリックしたとき、 **web パーツの移動** ページで、コードで、ボタン、`Button1_Click`メソッドは、コントロールを最初にゾーンから 2 番目のゾーン内の新しい位置に移動します。 まず、コードを呼び出す必要がありますに注意してください、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>を取得する方法、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>をラップするオブジェクト、`list1`コントロール。 これが必要なの最初のパラメーター、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>メソッドが必要な<xref:System.Web.UI.WebControls.WebParts.WebPart>を制御する一方`list1`ASP.NET サーバー コントロールです。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/CS/MoveWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/VB/MoveWebPartVB.aspx#1)]  
  
 ページが読み込まれると、クリックして、 **web パーツの移動** ボタン、およびリンクが含まれているコントロールが 2 番目のゾーンで中央の位置に移動します。 この移動コントロールのためにはプログラムで呼び出すことによって、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>メソッドです。 使用することも、**表示モード**ドロップダウン リスト コントロールのデザイン モードにし、デザイン モードでページを切り替えるには別のゾーンまたはゾーン内の別の位置にコントロールをドラッグすることができます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 、メソッドを呼び出しても、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>このようなユーザーによるを処理するコントロールが移動します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> が、<see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コントロールの <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コレクションに格納されていません。  
  
 \- または  
  
 <paramref name="zone" /> が、<see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" /> コントロールの <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コレクションに格納されていません。  
  
 \- または  
  
 <paramref name="webPart" /> コントロールの <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.Zone" /> プロパティで参照されるゾーンが <see langword="null" /> です。つまり、現在 <paramref name="webPart" /> がゾーン内にありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> または <paramref name="zone" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="zoneIndex" /> が 0 未満です。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnAuthorizeWebPart">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorizeWebPart(class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAuthorizeWebPart (e As WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthorizeWebPart(System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />。</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" /> イベントを発生させ、イベントのハンドラーが存在する場合はそれを呼び出します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>メソッドによって呼び出されます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>メソッド、ときに、<xref:System.Web.UI.WebControls.WebParts.WebPart>ページに追加する承認のコントロールをチェックしています。 ときに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>メソッドが呼び出されると、発生、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>イベント、ハンドラーが呼び出されますが、イベント ハンドラー メソッドがある場合とします。  
  
 承認する処理の<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールは、Web パーツの重要な機能です。 各<xref:System.Web.UI.WebControls.WebParts.WebPart>またはサーバー コントロールでのゾーンに追加される、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールがコントロールを追加できるかどうかを決定する承認プロセスを通過します。 既定では、Web パーツ コントロール セットには、コントロールがゾーンに追加されないようにするためのフィルター条件は提供されません。 コントロールのセットは開発者が独自のフィルター条件を作成するために必要なメカニズムを提供します。 これらのメカニズムを使用すると、カスタムのフィルター処理シナリオを作成できます。 たとえば、されるため、ゾーンに特定のコントロールを追加すると場合、ユーザーは、管理者ロールには、ページが表示され、それらのコントロールを追加しない場合は、ユーザーは、ユーザー ロールでは、ときに、フィルターを作成します。  
  
 承認プロセス中にフィルター処理コントロール機構を<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティを<xref:System.Web.UI.WebControls.WebParts.WebPart>、コントロール、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>と<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>メソッド、および<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>でイベントを<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。  
  
 フィルター処理を作成するには、基本的に 2 つのタスクです。 最初に、文字列を割り当てる、<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>の各プロパティ<xref:System.Web.UI.WebControls.WebParts.WebPart>フィルターを適用するコントロール。 これらの文字列値を任意で指定できますが、フィルターを適用する条件を含める必要があります。 たとえば、特定のコントロールの場合、管理者の場合にのみゾーンに追加するユーザーが、ページを表示しの文字列値を割り当てることができます`admin`プロパティにします。 でした、ASP.NET のロール機能を使用し、管理者、マネージャー、およびユーザーなどのさまざまなロールには、サイトのすべてのユーザーを追加します。 フィルター処理、コードがユーザーのロールを確認、チェック対象のコントロールの承認フィルター値と比較、ページの読み込み時に、ユーザーが管理者ロールには (たとえば) コントロールの設定した場合、および<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>値`admin`コントロールを追加できませんでした。  
  
 フィルタ リングのシナリオを作成する 2 番目の手順は、チェックするコードを記述する、<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティの値について<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、およびそのゾーンに追加される前に、各コントロールが承認されるかどうかを判断します。 このフィルター処理のコードを配置する場所の 2 つのオプションがあります。 最初のオプションは、ページの開発者向けの推奨されるオプションです。 処理するメソッドを作成することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>イベント、Web ページ サーバー スクリプト コードで直接、または分離コード ファイルにします。 イベントに追加することで、メソッドを関連付ける、`OnAuthorizeWebPart`属性のタグを<xref:System.Web.UI.WebControls.WebParts.WebPartManager>マークアップ コードの例を次に示すように ページで、制御します。  
  
```  
<asp:webpartmanager id="manager1" runat="server"   
   OnAuthorizeWebPart="manager1_AuthorizeWebPart" />  
```  
  
 各チェックを行うには、カスタムのメソッドにはすべてが<xref:System.Web.UI.WebControls.WebParts.WebPart>、フィルター処理条件を制御し、次に、ブール値を割り当てる、結果に基づき、<xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A>のプロパティ、<xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs>を示すためにオブジェクトかどうか、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールを追加することができます。 使用例」のコードでは、これを行う方法を示します。  
  
 フィルター処理、コードを配置する場所の 2 番目のオプションはから継承する、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラス、およびフィルターの条件をチェックするメソッドをオーバーライドします。 2 つのメソッドはオーバーライドすることができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType>メソッドまたは<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>メソッドです。 ほとんどの場合をオーバーライドするよりも適していますが、いずれかの方法は機能しますが、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>メソッドでは、全体の承認のプロセスが細かくプログラムによる制御があるため、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>メソッドでは、イベントとハンドラー用のチェックを生成するのには、1 つだけの特定のタスクです。 カスタムのコード例については<xref:System.Web.UI.WebControls.WebParts.WebPartManager>をオーバーライドするクラス、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>メソッドを参照してください、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType>メソッドのオーバー ロードします。  
  
   
  
## Examples  
 次のコード例は、カスタム イベント ハンドラーを設定する方法を示します、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 、イベント ハンドラー用のカスタムのフィルタ リング コードを提供できるように、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>メソッドです。 この例にはページ開発者がフィルター処理シナリオとの承認を提供するための一般的な方法があります<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールをページに追加します。  
  
 Web ページのことに注意して、`<asp:webpartmanager>`要素には、`OnAuthorizeWebPart`属性に割り当てられているイベント ハンドラーの名前に置き換えます。 メソッドでは、ページ上のコントロールが対応するかどうかをチェック<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>プロパティの値に設定`admin`し、必要な場合を返します`true`、ことが承認され、ページに追加することを意味します。  
  
> [!NOTE]
>  コントロールをメモに割り当てられている任意の値がない、<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>と判断されませんフィルター処理の一部であるために、プロパティが同様に、追加します。 フィルター処理シナリオで一般的な方法になります。 いくつかのコントロールは、フィルター処理されると、他のユーザーは、ためできませんのすべてのユーザーに利用できるものとみなされます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ロールのユーザーの設定は、このトピックの範囲外ですが、ために、このコード例は、フィルター処理でのユーザー ロールを確認できません。 ただし、ユーザーの役割に基づいてコントロールのフィルター処理シナリオは、このフィルター処理機能の最も一般的な用途の 1 つをする可能性があります。 サイトの役割があるコントロールのフィルター処理するためには、このメソッドのユーザー ロールを確認する場合は、メソッドは次のコード ブロックではなく、単純なアプローチ前のコードの例は、ロールを使用しない) のようにします。  
  
```vb  
Protected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  
  As Object, ByVal e As WebPartAuthorizationEventArgs)  
  
  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  
    If Roles.IsUserInRole(Page.User.Identity.Name, _  
      e.AuthorizationFilter) Then  
  
      e.IsAuthorized = True  
    Else  
      e.IsAuthorized = False  
    End If  
  End If  
  
End Sub  
```  
  
```csharp  
protected void mgr1_AuthorizeWebPart(object sender,   
  WebPartAuthorizationEventArgs e)  
{  
  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  
  {  
    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  
      e.IsAuthorized = true;  
    else  
      e.IsAuthorized = false;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>ページとそのコントロールが読み込まれ、ページの接続がアクティブになってデータの共有が開始されることを示す <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A>メソッドが発生し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>ページには、読み込みプロセスが完了した後のイベントです。 メソッドは、イベントのハンドラーを追加する方法を提供します。  
  
 ページの開発者は追加して、カスタム イベントのハンドラーを追加することができます、`OnConnectionsActivated`属性を`<asp:webpartmanager>`属性にカスタム メソッドの名前を割り当て、ページにある要素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開発者、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />派生メソッド<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスです。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivating">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivating (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivating(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivating (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivating(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>ページとそのコントロールが読み込まれ、接続をアクティブにするプロセスを開始できることを示す <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>メソッドが発生し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>イベントで、プログラムで接続をアクティブ化するプロセスをカスタマイズするためのメカニズムが用意されています。  
  
 ページの開発者は追加して、カスタム イベントのハンドラーを追加することができます、`OnConnectionsActivating`属性を`<asp:webpartmanager>`属性にカスタム メソッドの名前を割り当て、ページにある要素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開発者、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />派生メソッド<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスです。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanged(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanged (e As WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanged(System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">変更された表示モードに関連付けられたイベント データを格納する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />。</param>
        <summary>Web ページ上で <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" /> コントロールが、ある表示モードから別の表示モードに切り替えるプロセスを完了したことを示す、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A>そのベースのメソッドにフォームを発生させるだけ、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>イベント。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドすることができます、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />メソッドです。 たとえば、表示モードの変更後たいにどのディスプレイによってはモードが含まれている、ユーザー インターフェイス (UI) の外観の一部を変更、<see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs.OldDisplayMode" />プロパティです。 または、特定のコンテンツを非表示または特定のコントロールを表示することができます。  
  
 メソッドをオーバーライドするときに必要があります通常メソッドを呼び出す基本オーバーライドされたメソッドの最後の手順として、カスタム コードを最初に、実行して、イベントが最後に、発生ようにモードの変更が完了したことを示すです。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanging(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanging (e As WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanging(System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">変更中の表示モードに関連付けられたイベント データを格納する <see cref="T:System.EventArgs" />。</param>
        <summary>Web ページ上で <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" /> コントロールが、ある表示モードから別の表示モードに切り替えるプロセスを実行していることを示す、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>そのベースのメソッドにフォームを発生させるだけ、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>イベント。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドすることができます、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />メソッドです。 たとえば、表示モードを変更する可能性がありますをすること、新しい表示モードがどのようになるかを確認 (を使用して、<see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode" />プロパティ) と新しい表示モードがどのようになるかに基づいて、ユーザー インターフェイス (UI) で何か変更します。 カスタム表示モードがある場合は、カスタムのモードは、新しい表示モードになる場合、特定のコントロールを表示することができます。  
  
 このメソッドをオーバーライドするときに表示モードは、変更を開始を示すために、イベントが発生するように、オーバーライドされたメソッドの最初のステップとして基本メソッドを通常どおり呼び出す必要があります。 次に、カスタム コードで行った変更ユーザー インターフェイス (UI) 新しい表示モードが実際に表示される前にします。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>
          <see cref="E:System.Web.UI.Control.Init" /> コントロールの有効期間における最初のイベントとして、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A>メソッドを生成する基本のメソッドを呼び出す、<xref:System.Web.UI.Control.Init>制御、および、1 つのみのインスタンスが存在するなど、いくつかの準備手順が実行用のイベント、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>ページでは、制御し、パーソナル化データを読み込んでいます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">別の <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールがページ上に存在します。</exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>Web ページに <see cref="E:System.Web.UI.Control.PreRender" /> コントロールを表示する直前に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender%2A>メソッドを生成する基本のメソッドを呼び出す、<xref:System.Web.UI.Control.PreRender>制御、および、レジスタのイベントは、Web パーツを含むページに必要ないくつかのクライアント スクリプトを制御します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanged(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanged (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanged(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> コントロールを新しく選択した後またはその選択を解除した後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>メソッドが発生し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>イベント、通常は、ポイント、時間、開発者可能性がある、ユーザー インターフェイス (UI) の外観を変更します。 たとえば、新しい<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールが選択されている場合、Web パーツ コントロール セットを新しく選択したコントロールのレンダリングが変更されます。 コントロールの選択を解除すると、レンダリングが正常に返されます。  
  
 ユーザーに選択し、特定<xref:System.Web.UI.WebControls.WebParts.WebPart>、編集のためのコントロール、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>メソッドが呼び出されます。 ユーザーがコントロールを編集が完了すると、コントロールの選択がオフになっている結果が閉じるときに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>メソッドが再度呼び出されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>関連するいくつかのオプション、<see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />イベントを開発者に、選択したコントロールが変更された後に発生する表示をカスタマイズできるようにします。 宣言型コードで内で、<see langword="&lt;asp:webpartmanager&gt;" />要素を設定、<see langword="OnSelectedWebPartChanged" />属性があり、カスタム メソッドの名前を割り当てます。 メソッドでは、カスタム、イベントが発生したときに、選択したコントロールのレンダリングを変更する可能性があります。 継承することもできます、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスし、メソッドをオーバーライドします。 3 番目のオプションは、ゾーン レベルの表示をカスタマイズするには継承するなど、<see cref="T:System.Web.UI.WebControls.WebParts.EditorZoneBase" />クラス、およびオーバーライドその<see cref="M:System.Web.UI.WebControls.WebParts.EditorZoneBase.OnSelectedWebPartChanged(System.Object,System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />メソッドを選択し、編集の処理中に消去のコントロールの表示をカスタマイズします。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanging(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanging (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanging(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>現在選択されている <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" /> コントロールから選択を他に変更するプロセスを実行しているときに発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>メソッドが発生し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>の変更の処理中に発生するイベント<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールが現在選択されています。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールは、選択したコントロールを変更するプロセスをキャンセルする機会を与えるのため、このメソッドと関連のイベントを使用します。 内でメソッドを呼び出すなど、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>メソッド、および内、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>メソッドは、プロセスをキャンセルする方法を提供します。 ユーザーには、編集されているコントロールの cancel 動詞がクリックすると、コントロールが選択されていないと、ため、編集して変更は保存されませんが、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>メソッドでは、編集の変更をキャンセルすることです。  
  
> [!NOTE]
>  同様にメソッドが開始および接続するプロセスを終了すると、メソッドの中に、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールをそのプロセスをキャンセルを有効にする、別のコントロールです。  
  
 ページの開発者のカスタム ハンドラーを作成できます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>イベントを追加することによって、`OnSelectedWebPartChanging`属性を`<asp:webpartmanager>`宣言ページ マークアップ、およびカスタム メソッドの名前を属性に割り当てる内の要素。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">コントロールの削除に関連付けられたイベント データ。</param>
        <summary>
          <see cref="E:System.Web.UI.Control.Unload" /> 基本イベントを発生させ、Web ページから <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> インスタンスを削除します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdded(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdded (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdded(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" /> コントロールがページに追加された後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>メソッドは追加の処理中に、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール (またはその他のサーバー コントロールに追加される、<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーン) ページにします。  
  
 ページの開発者のカスタム ハンドラーを作成できます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>イベントを追加することによって、`OnWebPartAdded`属性を <`asp:webpartmanager>`要素、および属性にカスタム メソッドの名前を割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdding">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdding(class System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdding (e As WebPartAddingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdding(System::Web::UI::WebControls::WebParts::WebPartAddingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />。</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) を <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーンに追加するプロセスを実行しているときに発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A>メソッドが発生し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>コントロールが追加されていることを示すイベント。 メソッドには、追加の処理をキャンセルするオプションも用意されています。 コントロールが正しく追加された場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>イベントに依存します。  
  
 ページの開発者は追加することで、関連イベントのカスタム ハンドラーを指定することができます、`OnWebPartAdding`属性を`<asp:webpartmanager>`Web ページ、および属性にカスタム メソッドの名前を割り当てる要素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生を作成する開発者<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスをオーバーライドして、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />イベントの処理をカスタマイズする方法です。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosed(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosed (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosed(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>コントロールがページから削除されたことを通知する <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>メソッドが発生し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>ことを示すイベント、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール (またはその他のサーバーまたはユーザー コントロール) が正常に閉じられたページにします。  
  
 閉じるには、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールは表示されず、およびも特別なに配置するオブジェクトを保持するいると呼ばれるページ カタログようににページから削除することを意味します。 対応するページ カタログ、<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>コントロールを終了への参照を保持<xref:System.Web.UI.WebControls.WebParts.WebPart>の各ページのコントロールです。 場合、<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>コントロールがページ内で宣言されている、<xref:System.Web.UI.WebControls.WebParts.CatalogZone>ゾーン、ユーザーは、カタログの表示モードに切り替えるし、ページに戻るは既に閉じられているコントロールを追加します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>メソッドのカスタム ハンドラーを作成する開発者向けの機会を提供する、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>イベント。 ページの開発者は追加して、カスタム イベントのハンドラーを追加することができます、`OnWebPartClosed`属性を`<asp:webpartmanager>`属性にカスタム メソッドの名前を割り当て、ページにある要素。 1 つの有用なタスクが、開発者がこのメソッドで実行可能性がありますでは、終了したコントロールの代わりに、プレース ホルダーを表示するのには、コントロールをページに追加する方法をユーザーに通知するためのヒントが完了します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosing(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosing (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosing(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>ページから <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" /> コントロールまたはサーバー コントロールを削除するプロセスを実行しているときに発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A>メソッドが発生し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>コントロールが閉じられたか、ページから削除されている処理を行っていることを示すイベント。 メソッドには、終了プロセスをキャンセルするオプションも用意されています。 コントロールがページで、正常に削除された場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>イベントに依存します。  
  
 ページの開発者は追加することで、関連イベントのカスタム ハンドラーを指定することができます、`OnWebPartClosinging`属性を`<asp:webpartmanager>`Web ページ、および属性にカスタム メソッドの名前を割り当てる要素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生を作成する開発者<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスをオーバーライドして、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />イベントの処理をカスタマイズする方法です。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleted(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleted (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleted(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" /> コントロールがページから完全に削除された後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A>の削除処理中にメソッドが呼び出されます、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール (またはその他のサーバー コントロールに追加される、<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーン) ページからです。  
  
 ページの開発者のカスタム ハンドラーを作成できます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>イベントを追加することによって、`OnWebPartDeleted`属性を <`asp:webpartmanager>`要素、および属性にカスタム メソッドの名前を割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleting(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleting (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleting(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>動的な <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" /> コントロール (または、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーンに配置されたサーバー コントロールまたはユーザー コントロール) を削除するプロセスを実行していることを示す、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ダイナミック<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールを削除することができます、およびコントロールが削除されると、コントロールのインスタンスは、ページから完全に削除は復元できません。 動的<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールは、プログラムによって追加される、Web パーツのカタログからスタティック コントロールとは対照的ですがで宣言されたや Web ページのマークアップ。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A>メソッドが発生し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>コントロールはそのゾーンから完全に削除されていることを示すイベント。 メソッドには、削除プロセスをキャンセルすることも用意されています。 コントロールがページで、正常に削除された場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>イベントに依存します。  
  
 ページの開発者は追加することで、関連イベントのカスタム ハンドラーを指定することができます、`OnWebPartDeleting`属性を`<asp:webpartmanager>`Web ページ、および属性にカスタム メソッドの名前を割り当てる要素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生を作成する開発者<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスをオーバーライドして、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />イベントの処理をカスタマイズする方法です。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoved(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoved (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoved(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" /> コントロールがページ上の別の位置に移動された後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>メソッドが発生し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>の最後にイベント、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>メソッドで、コードのイベント ハンドラーを実行する前に、コントロールを移動するプロセスが完了したことを確認します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>イベントは現在のゾーン内か、別のゾーンにコントロールを移動し、プログラムまたはユーザー コントロールをドラッグして、移動が完了するかどうかは関係ありません。  
  
 ページの開発者のカスタム ハンドラーを作成できます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>イベントを追加することによって、`OnWebPartMoved`属性を <`asp:webpartmanager>`要素、および属性にカスタム メソッドの名前を割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoving(class System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoving (e As WebPartMovingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoving(System::Web::UI::WebControls::WebParts::WebPartMovingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />。</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" /> ゾーン内の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) を移動するプロセスを実行していることを示す、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A>メソッドを発生させます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>イベントが発生時に、<xref:System.Web.UI.WebControls.WebParts.WebPart>かそのゾーン内または別のゾーンにその他のサーバー コントロールが移動されています。 メソッドには、移動プロセスをキャンセルする機会も用意されています。 移動が正常に完了すると場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>イベントに依存します。  
  
 ページの開発者は追加することで、関連イベントのカスタム ハンドラーを指定することができます、`OnWebPartMoving`属性を`<asp:webpartmanager>`Web ページ、および属性にカスタム メソッドの名前を割り当てる要素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生を作成する開発者<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスをオーバーライドして、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />イベントの処理をカスタマイズする方法です。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />。</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" /> コントロールの間に接続が確立された後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A>メソッドの最後に、対応するイベントを発生させる、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>メソッド、イベント ハンドラーでコードが実行する前に、2 つのコントロールの接続に必要な手順が完了したことを実行できるようにします。  
  
 メソッドは、接続の作成のプロセスをプログラムで制御を提供し、関連のイベントは、ユーザー インターフェイス (UI) を更新するか、または接続が確立されているユーザーを通知する位置を示す便利な点です。  
  
 ページの開発者のカスタム ハンドラーを作成できます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>イベントを追加することによって、`OnWebPartsConnected`属性を <`asp:webpartmanager>`要素、および属性にカスタム メソッドの名前を割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />。</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" /> ゾーンに配置されている 2 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) の間に接続を確立するプロセスを実行しているときに発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A>メソッドが発生し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>イベントで、2 つのコントロールの接続を確立しようとするときに発生します。 メソッドは、接続試行をキャンセルする機会を提供します。 接続が成功した場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>イベントに依存します。  
  
 ページの開発者は追加することで、関連イベントのカスタム ハンドラーを指定することができます、`OnWebPartsConnecting`属性を`<asp:webpartmanager>`Web ページ、および属性にカスタム メソッドの名前を割り当てる要素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生を作成する開発者<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスをオーバーライドして、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />イベントの処理をカスタマイズする方法です。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />。</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" /> コントロール間の接続が終了した後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A>メソッドの最後に、対応するイベントを発生させる、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>メソッドで、2 つのコントロール間の接続を終了するプロセスを実行します。  
  
 開発者がユーザーに通知できるように、ユーザー インターフェイス (UI) に変更を加える変更を加えたり他のアプリケーションに、メソッドは、接続を終了するプロセスをプログラムで制御を提供します。  
  
 ページの開発者のカスタム ハンドラーを作成できます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>イベントを追加することによって、`OnWebPartsDisconnected`属性を <`asp:webpartmanager>`要素、および属性にカスタム メソッドの名前を割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />。</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" /> ゾーン内の 2 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) の接続を終了するプロセスを実行していることを示す、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A>メソッドが発生し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>イベント。 2 つのコントロールは、接続を終了するときに発生します。 メソッドは、切断されたときのプロセスをキャンセルする機会を提供します。 接続が正常に削除すると場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>イベントに依存します。  
  
 ページの開発者は追加することで、関連イベントのカスタム ハンドラーを指定することができます、`OnWebPartsDisconnecting`属性を`<asp:webpartmanager>`Web ページ、および属性にカスタム メソッドの名前を割り当てる要素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生を作成する開発者<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスをオーバーライドして、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />イベントの処理をカスタマイズする方法です。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="Personalization">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Personalization As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ Personalization { System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページのパーソナル化データが格納されたオブジェクトへの参照を取得します。</summary>
        <value>パーソナル化データが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>プロパティにアクセスする方法を提供する、<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>をページに関連付けられているオブジェクト、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。 このプロパティを使用して、パーソナル化オブジェクトのさまざまなメンバーにアクセスすることができます。 たとえば、使用することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>メソッドからのページのパーソナル化スコープを切り替えるにはユーザーのスコープ、またはその逆を共有します。 わかります、ページの現在のパーソナル化スコープ ページで、パーソナル化データおよび複数のプロバイダーが使用されている個人用設定が有効かどうか。  
  
 によって参照されるデータを<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>プロパティは、によって追跡されたページ レベルのパーソナル化データのみ、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール。 パーソナル化可能なプロパティの値などのコントロールに固有のパーソナル化データ<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールがの一部ではなく、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>プロパティです。  
  
> [!NOTE]
>  Web パーツのパーソナル化の詳細については、次を参照してください。 [Web パーツのパーソナル化の概要](http://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320)です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>プロパティ プログラムでします。  
  
 次の Web ページでは、ユーザーが編集モードの特定の側面を入力する、<xref:System.Web.UI.WebControls.Calendar>コントロール。 **トグル スコープ**ボタンは、ユーザーまたは共有パーソナル化スコープにページを切り替えます。 **編集モードの**と**Browse Mode**各ボタンでは、適切な表示モードに切り替えます。 注意、`<script>`イベントの使用を処理するメソッドの 2 つのファイルのセクションにタグ付け、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>基になるオブジェクトのメンバーを便利にアクセスするプロパティです。 具体的には、これらのメソッドを使用して、<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>メソッドおよび<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A>プロパティを介してアクセスするオブジェクトを<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>プロパティです。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Personalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/CS/wpmgrPersonalizationCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Personalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/VB/wpmgrPersonalizationVB.aspx#1)]  
  
 コード例を実行するには、また必要があります有効にする共有のスコープ内のページをカスタマイズするには、ユーザーまたはユーザーです。 内の Web.config ファイルにエントリを追加、`<system.web>`セクションで、次のマークアップのようになります。  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow  
        users="[Replace the text and brackets with a user name or   
           group.]"  
        roles="admin"   
        verbs="enterSharedScope"  />  
    </authorization>  
  </personalization>  
</webParts>   
```  
  
 ブラウザーでページを読み込んだ後、**トグル スコープ** ボタン、およびこれで、ページでは、スコープの共有と表示されているに注意してください。 をクリックして**編集モードの**表示モードを変更するに、表示コントロールの動詞メニューをクリックし、選択**編集** メニューからです。 両方の編集コントロールのユーザー インターフェイス (UI) が表示されることに注意してください。 クリックし、 **Browse Mode**を通常の参照を返します。 共有のスコープ内にあるページに表示をクリックして**トグル スコープ**ページがユーザーのスコープを確認してもう一度にします。 次に、コントロールを再度、編集が、UI では、編集、するようになりましたことを確認するには、同じ手順に従います、<xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart>コントロールは表示されません。 このコントロールは、ページが共有パーソナル化スコープにする場合にのみ機能するためです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScript">
      <MemberSignature Language="C#" Value="protected virtual void RegisterClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RegisterClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RegisterClientScript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RegisterClientScript();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールで、Web ページ内における <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールのドラッグなど、さまざまなパーソナル化機能に使用するクライアント側スクリプトを生成できるようにします。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">ページに書き込むコントロールの内容を受け取る <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>オーバーライドして、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールが何らかの内容を表示するのを防ぎます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal override object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Object ^ SaveControlState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールの状態データを保存し、今後このコントロールが含まれた Web ページを要求されたときにそのデータを復元できるようにします。</summary>
        <returns>コントロールの保存した状態データを格納する <see cref="T:System.Object" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>メソッド ページ ポストバック間で永続化するプロパティの状態データを保存する場合でも、<xref:System.Web.UI.Control.EnableViewState%2A>プロパティに設定されている`false`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SaveCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SaveCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SaveCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">読み込む状態データを含む <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />。</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールによって管理されるカスタムのパーソナル化状態データを保存します。これにより、ページの再読み込みを行うたびにこのデータを読み込めるようになります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>を今後のブラウザー セッションを格納するユーザーの個人用設定を有効にし、ページの閲覧されるため、メソッドは、パーソナル化処理を行って重要です。 メソッドは、次などの項目を含むカスタムのパーソナル化状態データを保存します。 動的<xref:System.Web.UI.WebControls.WebParts.WebPart>またはサーバー コントロールがページに追加するかのページ以外の場合は、ページに移動されたコントロールと動的な接続を作成または削除された削除されています。  
  
 このメソッドは、コードから直接呼び出すことはできません。 ただし、呼び出すことができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>自体メソッドは、パーソナル化データを保存するには、このメソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開発者は、派生では、このメソッドをオーバーライドできます<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />パーソナル化データを保存するプロセスをカスタマイズするクラス。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedWebPart As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ SelectedWebPart { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>別のコントロールとの接続を編集または作成するために現在選択されている <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールへの参照を取得します。</summary>
        <value>接続の編集または接続の構成のために現在選択されている <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>プロパティへの参照を返します、<xref:System.Web.UI.WebControls.WebParts.WebPart>またはその他のサーバー コントロールを編集するため、または別のコントロールでの接続を作成するために現在選択されています。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールのコントロールを選択した場合のプロセスを処理するためのいくつかの便利なメソッドとイベントの提供します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>イベントは、コントロールが選択された直後後、変更を加える前に発生します。 を実行するコントロールに対するいくつかのアクションを選択した後は、上書き、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>メソッドです。 たとえば、コントロールが選択されているがまだ変更していない、視覚的に強調するコントロールが選択されているの外観を変更することができます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>イベント、選択したコントロールが変更された直後に発生します。 変更された後、コントロールで何らかの操作を実行して、上書き、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanged As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ SelectedWebPartChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールの選択を変更して Web ページ上の別のコントロールに移動した後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントを組み合わせて使用することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>選択コントロールのユーザー インターフェイス (UI) を変更するメソッド。 たとえば、ユーザーがページをデザイン モードに切り替える場合 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>)、し、選択、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールの新しい位置にドラッグすることの目的ではなどの境界線の色を変更することで、選択したコントロールのレンダリングを変更または背景が選択されている間に共通します。  
  
> [!NOTE]
>  イベントの使用の詳細については、次を参照してください。[する方法: Web フォーム アプリケーションでのイベントの消費](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanging As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ SelectedWebPartChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上で現在選択されている <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロールの変更プロセス中に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントを組み合わせて使用することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>メソッドです。 ページの開発者は追加することで、コードでイベント ハンドラーを作成することができます、`OnSelectedWebPartChanging`属性を`<asp:webpartmanager>`ページ、およびカスタム メソッドの名前に、属性の値を設定内の要素は、イベントを処理します。  
  
 このイベントは、開始または終了と開始とコントロールの編集を終了するときに、コントロール間の接続プロセス中に発生します。 詳細については、次を参照してください。、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>メソッドです。  
  
 通常、ときに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>イベントは、選択したコントロールを変更するユーザーのアクションの直接の結果として、発生イベントをキャンセルできます。 ただし、イベントをキャンセルできないシナリオがあります。 場合、<xref:System.Web.UI.WebControls.WebParts.WebPartZone>コントロールが削除されると、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールが含まれている必要がありますすべて閉じられます、それ以外の場合が孤立しています。 この場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>閉じの制御、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、されません、ユーザー、およびその必要がありますを決定どのコントロールが現在選択されていると、中断された可能性は一切選択を変更するときにすべてのコントロールのクリーンアップのプロセスを完了するようにします。 そのため、デザインによって、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>メソッドは、このシナリオではキャンセルできません。 キャンセルできる、関連するイベントを参照してください、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>イベント。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SetPersonalizationDirty">
      <MemberSignature Language="C#" Value="protected void SetPersonalizationDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetPersonalizationDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetPersonalizationDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetPersonalizationDirty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールのカスタムのパーソナル化データが変更されたことを示すフラグを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>メソッドが最終的には、Web パーツ コントロールが更新されたパーソナル化データを保存する設定で、パーソナル化コンポーネントが発生するフラグを設定します。 によって追跡パーソナル化データの変更を引き起こす可能性のあるシナリオの詳細については、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>を制御しを参照してください、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>プロパティです。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>メソッドは、コードから直接呼び出すことはできませんし、Web パーツのパーソナル化機能の一部として設定、Web パーツ コントロールによって内部的に使用されるため、オーバーライドすることはできません。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>メソッドを呼び出すことができる派生によって<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスです。 Web パーツ コントロールのコンポーネント セットし、パーソナル化データのフラグを設定するプロセスを制御するために必要なパーソナル化をカスタマイズする場合に便利になります。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="SetSelectedWebPart">
      <MemberSignature Language="C#" Value="protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetSelectedWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetSelectedWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">選択されている <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロール。</param>
        <summary>現在選択されている <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> コントロールまたはサーバー コントロールと同じ <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> プロパティ値を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A>開始日またはで指定されたコントロールの編集を終了するプロセス中にメソッドが呼び出された、`webPart`パラメーター、および先頭または末尾を含む接続される`webPart`です。  
  
 編集し、接続のプロセスの開始時`webPart`コントロールが選択されている接続を開始するかを編集することです。  
  
 編集し、接続のプロセスの最後に`null`に渡される、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A>メソッドは、その結果、現在選択されているコントロールが選択されていません。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールにスキンを適用できないように、空の文字列 ("") を取得または設定します。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールへのスキンの割り当てができないようにする空の文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>プロパティを継承したオーバーライド<xref:System.Web.UI.Control.SkinID%2A?displayProperty=nameWithType>ようにするプロパティ、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>スキンを使用してから、非表示のコントロールにあるコントロールです。 プロパティの実装を防止スキンから空の文字列を常に返すことによって割り当てられる、`get`アクセサー、および常に値を設定しようとした場合に例外をスロー、`set`アクセサー。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">プロパティ値を設定しようとしました。</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ StaticConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上の静的接続として定義されているすべての <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> オブジェクトのコレクションへの参照を取得します。</summary>
        <value>ページ上のすべての静的接続が格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>プロパティを使って、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールを追跡し、ページ上のすべての静的な接続を管理します。 動的接続とは異なり、静的な接続は、ページが表示されるたびに、ページに追加する必要はありません。  
  
 このプロパティによって参照されるコレクションには、プログラムによって作成またはで指定されるかどうか、ページ上に存在するすべての静的な接続が含まれています、`<asp:webpartconnection>`ページのマークアップ内の要素。  
  
   
  
## Examples  
 次のコード例に示しますをプログラムで使用、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>プロパティです。  
  
 このコード例では、4 つの部分があります。  
  
-   ユーザー コントロールを Web パーツ ページの表示モードを変更することができます。  
  
-   2 つのカスタムを含むソース コード ファイル<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールとカスタム インターフェイスです。  
  
-   2 つのカスタムを含む Web ページ<xref:System.Web.UI.WebControls.WebParts.WebPart>接続可能なコントロールと`<asp:webpartmanager>`要素。  
  
-   ブラウザーでの例の動作についての説明。  
  
 次のコードには、例の Web ページの部分のみが含まれています。 セクションの例から--カスタム ユーザー コントロールとカスタム コントロールおよびインターフェイスのソース コードの例の最初の 2 つの部分を取得する必要があります、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要です。 このトピックでは、コンパイルするためのオプションもについて説明します。、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。  
  
 コード例の 3 番目の部分は、Web ページです。 ページの宣言型マークアップを含む`Register`ユーザー コントロールとカスタム コントロールの両方のディレクティブ。 `<asp:webpartmanager>`要素、`<asp:webpartzone>`カスタム コントロールを追加する要素と`<asp:connectionszone>`要素。 注意、`Page_Load`メソッド、コードを確認するかどうかの接続を既に存在し、いない場合は、プロバイダー、定義、コンシューマーがそれぞれのコネクション ポイントと、によって参照される静的な接続のセットに新しい接続を追加します<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>プロパティです。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 ブラウザーで Web ページが読み込まれた後にをクリックして、**表示モード**ドロップダウン リスト コントロールと選択**接続**接続モードをページに切り替えます。 接続モードでは使用、`<asp:connectionszone>`要素を使用すると、コントロール間の接続を作成します。 接続モードのタイトル バーの下向き矢印をクリックして、**郵便**の動詞メニューをアクティブに制御し、をクリックして**接続**です。 接続のユーザー インターフェイス (UI) が表示されたらに含まれているコードによって、接続を作成されていることに注意してください、`Page_Load`メソッドです。 以降のブラウザー セッションでこのページに戻り、この静的な接続は既に確立され、ページが読み込まれるたびに再作成する必要はありません。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Docs>
    </Member>
    <Member MemberName="SupportedDisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportedDisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ SupportedDisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の Web ページ上で使用できるすべての表示モードの読み取り専用のコレクションを取得します。</summary>
        <value>特定の Web ページ上で使用できる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> オブジェクトのセットが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>プロパティには、ページ上に存在のゾーン コントロールの種類を指定し、ページで実際に使用できる表示モードのみが含まれています。  
  
> [!NOTE]
>  表示モードを無効にすることができますとに追加されていない表示モードが無効になっているときに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>その表示モードをサポートするゾーンの対応する型が、ページに存在するときでも、コレクション。  
  
 ブラウズ モードとデザイン モードは常にサポートされます。 表示モードが異なることができますが、編集、カタログ、および接続モードです。 これらの各表示モードは、特定の種類に関連付けられて<xref:System.Web.UI.WebControls.WebParts.ToolZone>コントロール。 によって参照されるコレクションに追加する特定の表示モードの原因となる Web ページ上の特別な型指定されたそのゾーンが存在するが、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>プロパティです。 たとえば、Web ページが含まれている場合、<xref:System.Web.UI.WebControls.WebParts.EditorZone>ゾーンはなく、<xref:System.Web.UI.WebControls.WebParts.CatalogZone>ゾーンを編集表示モードは、そのページでサポートされているモードのいずれかが、カタログの表示モードはサポートされていません。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>プロパティと異なります、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>プロパティで、現在使用可能なすべての表示モードを含むコレクションを参照<xref:System.Web.UI.WebControls.WebParts.WebPartManager>特定のページでサポートされていないものも制御します。  
  
   
  
## Examples  
 次のコード例は、のプログラムによる使用を示しています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>プロパティです。 コードでは、このプロパティを使用して、現在の Web ページで使用できる表示モードのみを使用してリストを設定します。  
  
 このページでサポートされている 3 つの表示モードがある: 参照、設計、および編集します。 最初の 2 つ常に利用可能なおよびが編集モードはこのコード例では、ページが含まれているため、<xref:System.Web.UI.WebControls.WebParts.EditorZone>コントロール。 カタログと接続モードは表示されませんが、表示対応するゾーンがこのページではないためです。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/CS/wpmgrSuppDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/VB/wpmgrSuppDisplayModesvb.aspx#1)]  
  
 ブラウズ モードからページをデザイン モードに切り替えるには、ドロップダウン リスト コントロールを使用するには、ブラウザーでページを読み込んだ後し編集モードにします。 編集モードでサーバー コントロールのいずれかのヘッダーの動詞のドロップダウン メニューをクリックして選択できます**編集**コントロールを編集します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty">
      <MemberSignature Language="C#" Value="bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsDirty As Boolean Implements IPersonalizable.IsDirty" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールによって管理されているカスタムのパーソナル化状態データが Web ページ上で変更されたかどうかを示す値を取得します。</summary>
        <value>パーソナル化状態データが変更されたかどうかを示すブール値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>プロパティは、呼び出し元を決定するための手段を提供します。 パーソナル化状態で管理されているデータであるかどうか、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールが変更されました。 ユーザー パーソナル化ページ レベルの詳細については、たとえばをページ レイアウトの変更、作成するか、接続を削除してによってパーソナル化データを管理、追加やコントロールを削除したり、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>変更を制御します。 これは、パススルー メソッドの呼び出し元の値を返すプロテクト<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>プロパティで、呼び出し元が直接アクセスできることはできません。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>プロパティは示しませんかどうかパーソナル化可能なプロパティの値、または個々 の外観に影響するプロパティを個別<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールが変更されました。 コントロール レベルのパーソナル化は、コントロールごとに個別に追跡されます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>プロパティを示しますのみかどうかのパーソナル化データをページ レベルで管理されて、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールが変更されました。  
  
 次の一覧には、一般的な原因となるパーソナル化の複数のインスタンスがについて説明します、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>プロパティの値を返すを`true`ことを示すこと、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールが変更されたパーソナル化データの一部。  
  
-   静的なを閉じる<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール (またはサーバーまたはユーザー コントロール) ページ。  
  
-   閉じられた、静的なを復元する<xref:System.Web.UI.WebControls.WebParts.WebPart>ページ カタログからコントロールをページに戻る。  
  
-   そのゾーン内または別のゾーンには、任意のコントロールを移動します。  
  
-   カタログからコントロールを追加する<xref:System.Web.UI.WebControls.WebParts.WebPart>サーバー、またはコントロールのプログラムで追加します。  
  
-   2 つの間の接続を作成する<xref:System.Web.UI.WebControls.WebParts.WebPart>プログラムまたは接続のユーザー インターフェイス (UI) を使用して、制御します。  
  
-   2 つの間の接続を削除する<xref:System.Web.UI.WebControls.WebParts.WebPart>プログラム、または接続の UI を使用して、制御します。  
  
 このプロパティの値にアクセスするにキャストする必要があります、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールのインスタンスを<xref:System.Web.UI.WebControls.WebParts.IPersonalizable>インターフェイス以外の場合は、読み取り場合があります、<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A>プロパティの値。  
  
   
  
## Examples  
 次のコード例は、の単純な使用法を示します、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>プロパティのいくつかの一般的なページの個人用設定を示すために、その原因をインスタンス化、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールのパーソナル化データを変更します。  
  
 このコード例では、4 つの部分があります。  
  
-   ユーザー コントロールを Web パーツ コントロールを含むページに表示モードを変更することができます。  
  
-   2 つのカスタムのコードを含むソース ファイル<xref:System.Web.UI.WebControls.WebParts.WebPart>接続可能なコントロールとインターフェイスします。  
  
-   すべてのコントロールをホストする Web ページ。  
  
-   コード例の動作についての説明。  
  
 コード例の最初の部分は、ユーザー コントロールの表示モードを変更するためです。 セクションの例からユーザー コントロールのソース コードを取得することができます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>クラスの概要です。 表示モードとユーザー コントロールの動作方法については、次を参照してください。[チュートリアル: Web パーツ ページの表示モードの変更](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)です。  
  
 この例の 2 番目の部分は、カスタム コントロールとインターフェイスを持つソース ファイルです。 注意して、`IZipCode`インターフェイスが 1 つのメソッドを公開して、カスタムとして、このメソッドが実装されている`ZipCodeWebPart`コントロールが有効にするコールバック メソッドとして機能`ZipCodeWebPart`接続シナリオでのプロバイダーとして機能します。 その他のコントロール`WeatherWebPart`、接続では、コンシューマーとして機能を制御; によって提供される特定のインターフェイスを利用できる`ZipCodeWebPart`です。 実際のアプリケーションで`WeatherWebPart`でした、プロバイダーから個人用に設定された ZIP コードの値を使用して、ユーザーにグラフィカル気象情報を提供します。  
  
 コード例を実行するには、このソース コードをコンパイルする必要があります。 コンパイルするには明示的にし、Web サイトの Bin フォルダーまたはグローバル アセンブリ キャッシュに結果として得られるアセンブリを配置できます。 またはを動的にコンパイルされる実行時に、サイトの App_Code フォルダー内のソース コードを配置することができます。 このコード例は、動的なコンパイルを使用します。したがって、ことに注意して、`Register`のみ Web ページの上部にあるこのコンポーネントのディレクティブが含まれています`TagPrefix`と`Namespace`せず、属性、`Assembly`属性。 コンパイルする方法について説明するチュートリアルでは、次を参照してください。[チュートリアル: カスタム Web サーバー コントロールの開発と](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)です。  
  
 [!code-csharp[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/ZipCodeComponent.vb#2)]  
  
 コード例の 3 番目の部分は、Web ページです。 2 つが含まれている通知<xref:System.Web.UI.WebControls.WebParts.WebPartZone>が最初のものを含む 2 つのカスタムのゾーン<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。 <xref:System.Web.UI.WebControls.WebParts.CatalogZone>標準を含まれているゾーン<xref:System.Web.UI.WebControls.Calendar>コントロールをページにユーザーを追加できます。 `<asp:connectionszone>`要素は、接続をユーザー コントロール間の接続を作成するための UI を提供します。 `Page_PreRender`メソッドに必要な場合とパーソナル化データが変更されたかどうかを確認する通知のテキストを更新する`Label1`です。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/wpmgrIsDirtyCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/wpmgrIsDirtyVB.aspx#1)]  
  
 ブラウザーでページを読み込んだ後は、パーソナル化データを変更できるこのトピックの「解説」セクションで説明したシナリオの一部を作成してみます。 によって追跡パーソナル化のシナリオのいずれかの変更が含まれている場合、さまざまな変更を行うと、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>のテキストを制御する、`Label1`パーソナル化データが変更されたことを示すためにコントロールが表示されます。 たとえば、次のように操作できます。  
  
-   クリックしてコントロール間の接続を作成、 **web パーツ コントロールの接続**ボタンをクリックします。  
  
-   使用して、**表示モード**ページをモードに切り替えるカタログを追加するドロップダウン リスト コントロール、**個人用の予定表**が 2 番目の制御<xref:System.Web.UI.WebControls.WebParts.WebPartZone>ゾーンです。  
  
-   ページに戻るモードを参照するメニューの 動詞 (タイトル バーの矢印記号で表示) の変更、**個人用の予定表**を制御して、選択**閉じる**を閉じ、ページ カタログに追加します。  
  
-   カタログ モード、ページを返すし、追加、**個人用の予定表**コントロール、ページに戻ります。  
  
-   使用して、**表示モード**ページをデザイン モードに切り替えるには制御し、別のゾーンまたはゾーンが同じで別の位置に、それらの 1 つ以上をドラッグして、コントロールのレイアウトを再配置します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Load">
      <MemberSignature Language="C#" Value="void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Load (state As PersonalizationDictionary) Implements IPersonalizable.Load" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Load;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">読み込む状態データを含む <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />。</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールに読み込む必要がある、以前に保存したカスタムのパーソナル化状態データを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、実装の<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=nameWithType>、Web パーツ コントロール セットに直接アクセスする、保護対象の手段を提供するメソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=nameWithType>メソッドです。 このメソッドが呼び出されるで管理されているカスタムの個人用に設定されたデータを格納、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>制御、およびを以前に保存した後で、初期化プロセスで使用する永続的なデータ ストアにします。  
  
> [!NOTE]
>  ほとんどの場合、ページおよびコントロール開発者はコード必要はありません、このメソッドを呼び出す Web パーツ コントロール セットによりパーソナル化データを取得するためのメカニズムとして、主に使用されているため。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開発者がこのメソッドを使用、1 つのシナリオは、Web パーツ コントロール セットによって、1 つの代わりに使用するカスタムのパーソナル化フレームワークを開発する場合提供されます。 このような場合、開発者がから継承でした、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスし、オーバーライド、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />のカスタム実装を返すメソッドを<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />オブジェクト。 カスタム<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />オブジェクトでの実装を呼び出すと、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />カスタムのパーソナル化データを読み込む適切な時点でのメソッドです。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Save">
      <MemberSignature Language="C#" Value="void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Save (state As PersonalizationDictionary) Implements IPersonalizable.Save" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Save;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">保存する状態データを格納する <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />。</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールで管理されるカスタムのパーソナル化状態データを保存します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>メソッドの実装は、 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=nameWithType> 、Web パーツ コントロール セットに直接アクセスする、保護対象の手段を提供するメソッド<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=nameWithType>メソッドです。 このメソッドが呼び出されるで管理されているすべての個人用設定のデータを保存、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Web パーツ アプリケーション用に構成された永続的なデータ ストアを制御します。  
  
> [!NOTE]
>  ほとんどの場合、ページおよびコントロール開発者はコード必要はありません、このメソッドを呼び出す Web パーツ コントロール セットによりパーソナル化データを保存するためのメカニズムとして、主に使用されているため。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>開発者はこのメソッドを使用して作業を 1 つのシナリオは、Web パーツ コントロール セットによって、1 つの代わりに使用するカスタムのパーソナル化フレームワークを開発する場合提供されます。 このような場合、開発者がから継承でした、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />クラスし、オーバーライド、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />のカスタム実装を返すメソッドを<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />オブジェクト。 カスタム<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />オブジェクトでの実装を呼び出すと、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />カスタムのパーソナル化データを保存する適切な時点でのメソッドです。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>パーソナル化状態データを <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールに適用し、基本メソッドを呼び出してコントロールのビューステート データに対する変更を追跡できるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビュー状態データへの変更が格納されている、<xref:System.Web.UI.StateBag>オブジェクト、およびコントロールの経由でアクセスできる<xref:System.Web.UI.Control.ViewState%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>子コントロールを表示できるようにする値を取得します。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールおよびその子コントロールが表示されるかどうかを示す Boolean 値。 常に <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>制御オーバーライド ベース<xref:System.Web.UI.Control.Visible%2A?displayProperty=nameWithType>プロパティの値を常に返すを`true`の<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>プロパティです。 場合でも、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロール自体が表示されない、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>プロパティに設定する必要があります`true`すべての子コントロールが既定で表示されるようにします。  
  
 値を設定しようとする場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>プロパティが常にエラーが発生、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールの基本プロパティの動作がオーバーライドし、プロパティに任意の値を割り当てることを防止します。  
  
 このプロパティは、ビジュアル デザイナーでバインドできるではありませんが実行時にバインドします。 詳細については、「<xref:System.ComponentModel.BindableAttribute>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このプロパティに値を割り当てようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdded">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdded As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartAdded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的な <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールを <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンに追加した後に発生し、そのコントロールが正常に追加されたことを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>イベントは、ゾーンにダイナミック コントロール (ページのマークアップで宣言されているのではなく、プログラムによって追加されたコントロール) が正しく追加されたことを示すのに役立ちます。 組み合わせて、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>メソッド、ユーザー インターフェイス (UI) を更新またはコントロールが正常に追加するユーザーをそれ以外の場合に通知する方法を開発者に提供するイベントです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      </Docs>
    </Member>
    <Member MemberName="WebPartAdding">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdding As WebPartAddingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAddingEventHandler ^ WebPartAdding;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的な <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールを <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンに追加するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>によってイベントが発生した、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A>ゾーンにコントロールを追加するプロセスが開始された後のメソッドです。 このイベントは、完了する前に、プロセスをキャンセルする機会を提供します。 このイベントが続く場合は追加の処理が成功すると、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>イベント。  
  
 ページの開発者は、イベントのカスタム ハンドラーを追加することで提供できます、`OnWebPartAdding`属性を`<asp:webpartmanager>`ページ、および属性にカスタム メソッドの名前を割り当てる要素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      </Docs>
    </Member>
    <Member MemberName="WebPartClosed">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosed As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartClosed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) をページから削除すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>イベントは、コントロールが閉じられたことが正常に、ユーザー、またはプログラムによってを示します。 閉じるには、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールは表示されず、およびも特別なに配置するオブジェクトを保持するいると呼ばれるページ カタログようににページから削除することを意味します。 対応するページ カタログ、<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>コントロールを終了への参照を保持<xref:System.Web.UI.WebControls.WebParts.WebPart>の各ページのコントロールです。 場合、<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>コントロールがページ内で宣言されている、<xref:System.Web.UI.WebControls.WebParts.CatalogZone>ゾーン、ユーザーが、カタログの表示モードに切り替えるし、ページに戻るは既に閉じられているコントロールを追加します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>イベントに関連付けられている、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>メソッドは、両方のイベントを発生させることのハンドラーを提供します。  
  
 ページの開発者は追加して、カスタム イベントのハンドラーを追加することができます、`OnWebPartClosed`属性を`<asp:webpartmanager>`属性にカスタム メソッドの名前を割り当て、ページにある要素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartClosing">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosing As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) をページから削除するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>によってイベントが発生した、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A>メソッドと、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールがコントロールの終了処理を行っています。 コントロールの削除が成功した場合は、このイベントが続く、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>イベント。  
  
 ページの開発者は追加することによって、イベントのカスタム ハンドラーを指定することができます、`OnWebPartClosed`属性を <`asp:webpartmanager>`ページ、および属性にカスタム メソッドの名前を割り当てる要素。  
  
 通常、ときに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>終了のユーザーの直接の結果としてイベントが発生した、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、イベントを取り消すことができます。 ただし、イベントをキャンセルできないシナリオがあります。 場合、<xref:System.Web.UI.WebControls.WebParts.WebPartZone>コントロールが削除されると、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールが含まれている必要がありますすべて閉じられます、それ以外の場合が孤立しています。 ここでは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>閉じの制御、<xref:System.Web.UI.WebControls.WebParts.WebPart>を制御するユーザーではありません。 タイミング、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールの呼び出し中に、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>メソッドを各コントロールを閉じると、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>イベントは、デザインでイベントをキャンセルできません、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>ゾーンのすべてのコントロールのクリーンアップのタスクを完了する必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleted">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleted As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartDeleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールを <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンから削除した後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>イベントがダイナミック コントロール (ページのマークアップで宣言されているのではなく、プログラムによって追加されたコントロール) が、ゾーンから正常に削除されたことを示すに役立ちます。 組み合わせて、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A>メソッド、ユーザー インターフェイス (UI) を更新またはコントロールが正常に削除するユーザーをそれ以外の場合に通知する方法を開発者に提供するイベントです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleting As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartDeleting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的な <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールのインスタンスを <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンから完全に削除するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>によってイベントが発生した、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> (プログラムまたは Web パーツのユーザー インターフェイスを使用してユーザーによって追加されたもの) 動的コントロールの削除のプロセス中のメソッドです。 イベントが終わる前に、プロセスをキャンセルする機会を提供します。 このイベントが続く場合は、削除プロセスが正常に完了しました、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>イベント。  
  
 ページの開発者は、イベントのカスタム ハンドラーを追加することで提供できます、`OnWebPartDeleting`属性を`<asp:webpartmanager>`ページ、および属性にカスタム メソッドの名前を割り当てる要素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoved">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoved As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartMoved;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロールを、Web ページ上の別の位置に移動した後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、静的 (Web ページのマークアップで宣言) とダイナミック コントロールの両方に適用されます。 関連付けられていること、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>メソッドです。 イベントが発生した場合に、移動が完了したら、開発者は、ユーザー、いくつかの検証またはその他のいくつかの操作をいくつかの通知を提供するイベント ハンドラーを含めることができます。 イベント ハンドラーを追加することができますを追加する、`OnWebPartMoved`属性を`<asp:webpartmanager>`内の要素 ページで、および属性にカスタム メソッドの名前を割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoving">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoving As WebPartMovingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartMovingEventHandler ^ WebPartMoving;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーンに配置されている <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> コントロールまたはその他のサーバー コントロールを移動するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>イベントが発生したときに、<xref:System.Web.UI.WebControls.WebParts.WebPart>か他のサーバー コントロールが、自身のゾーン内または別のゾーンに移動されます。 これは、ユーザー コントロールをドラッグしたときとプログラムで移動がある場合に発生します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>によってイベントが発生した、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A>メソッド、およびそれが完了する前に、移行プロセスをキャンセルする機会を提供します。 移動が完了し、コントロールでは、新しい位置に配置される、このイベントが続く場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>イベント。  
  
 ページの開発者は、追加することで、カスタム イベントのハンドラーを作成することができます、`OnWebPartMoving`属性を`<asp:webpartmanager>`要素、および属性にカスタム メソッドの名前を割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartCollection WebParts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebParts As WebPartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartCollection ^ WebParts { System::Web::UI::WebControls::WebParts::WebPartCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールで追跡されるすべての <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールへの参照を取得します。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCollection" /> コントロールのセットへの参照が格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>プロパティを使用、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールすべてを追跡する<xref:System.Web.UI.WebControls.WebParts.WebPart>内に含まれるコントロール<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ページの領域。 コレクションは読み取り専用では、アクセスできる個別<xref:System.Web.UI.WebControls.WebParts.WebPart>コレクションに変更を加えることを通じてプログラムで制御します。  
  
> [!NOTE]
>  可能であれば、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、ページの外部に配置されます、<xref:System.Web.UI.WebControls.WebParts.WebPartZone>によって追跡されていないコントロールの結果、ゾーン、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>制御またはで参照されているその<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>コレクション。 ただし、使用する理由はほとんどは、<xref:System.Web.UI.WebControls.WebParts.WebPart>次にその Web パーツの機能を失うし、通常のサーバー コントロールとして機能するために、ゾーンの外部で制御します。  
  
 任意の型かどうか、カスタム ゾーンで、配置可能なコントロールの<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、標準の ASP.NET コントロール、ユーザー コントロール、またはカスタム サーバー コントロール扱うことができます、<xref:System.Web.UI.WebControls.WebParts.WebPart>実行時に制御します。 コントロールではないときに、<xref:System.Web.UI.WebControls.WebParts.WebPart>でコントロールが配置される、 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> ASP.NET のコントロールをラップする実行時に、ゾーン、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>オブジェクトをコントロールとして動作できるように<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。 使用して、そのため、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>プロパティ、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールは、任意の型から派生しているかどうかに関係なく、サーバー コントロールを追跡できます、<xref:System.Web.UI.WebControls.WebParts.WebPart>クラスです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>プロパティ個々 のアクセスをプログラムで<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール。 いることを確認 Web ページの宣言型マークアップ内で、`<asp:webpartzone>`存在要素が 2 つの標準の ASP.NET サーバー コントロールです。 これらから継承していないが、<xref:System.Web.UI.WebControls.WebParts.WebPart>クラスとが折り返されるゾーンに属しているため、 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 、実行時にオブジェクトをそのため、によって参照されるコレクションに含まれます、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>プロパティです。 ユーザー設定を追加することも<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、ユーザー コントロール、またはカスタム サーバーをこのゾーンの制御し、同じ方法を処理するとします。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_WebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/CS/wpmgrWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_WebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/VB/wpmgrWebPartsVB.aspx#1)]  
  
 コード例を実行する必要があります設定を追加する Web パーツの記述ファイルをエクスポートできるようにするために Web.config ファイルに注意してください。 このコード例の Web ページと同じディレクトリ内の Web.config ファイルがあることを確認します。 内で、`<system.web>`セクションであることを確認、`<webParts>`を持つ要素が`enableExport`属性に設定`true`マークアップを次のように、します。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 クリックした場合、ブラウザーにページを読み込んだ後、 **WebPart カウント**ボタン コードを使用して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>コレクション内のコントロールの数を返すプロパティ。 クリックした場合、**予定表のタイトルを非表示に**のみ境界線とタイトルではなくにレンダリングするよう、ボタン、コードがカレンダーを変更します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsConnected;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) の間に特定の接続が確立された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>イベントに関連付けられている、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A>メソッドです。 イベントは、接続が完了したことを確認した後、ページのユーザー インターフェイス (UI) を変更したり、ファクトをユーザーに通知をする可能性がありますので便利です。 2 つのコントロール間の接続に成功を示すグラフィック イメージを表示するなど、簡単なメッセージの表示と変更ページの表示モード ブラウズ モードに戻します。  
  
 ページの開発者は、このイベントにカスタム イベント ハンドラーを追加することで関連付けることができます、`OnWebPartsConnected`属性を`<asp:webpartmanager>`属性にカスタム メソッド名の割り当て ページにある要素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsConnecting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (または、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンに配置されたサーバー コントロールまたはユーザー コントロール) の間に接続を作成するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>によってイベントが発生した、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A>メソッド、し、接続プロセスが開始したことを通知に (たとえば、ユーザーがコントロールを選択および connect 動詞がクリックされた) がまだ完了していません。 イベントは、完了する前に、接続をキャンセルする機会を提供します。 このイベントが続く場合は、接続が正常に完了しました、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>イベント。  
  
 ページの開発者は追加して、カスタム イベントのハンドラーを追加することができます、`OnWebPartsConnecting`属性を`<asp:webpartmanager>`要素、および属性にカスタム メソッドの名前を割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsDisconnected;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロール間の接続が終了した後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>イベントに関連付けられている、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A>メソッドです。 イベントは、接続が終了したことを確認した後をユーザーに通知、コードでは、一部のクリーンアップ操作を実行またはユーザー インターフェイス (UI) で他の変更を加える可能性があるために便利です。  
  
 ページの開発者は、このイベントにカスタム イベント ハンドラーを追加することで関連付けることができます、`OnWebPartsDisConnected`属性を`<asp:webpartmanager>`属性にカスタム メソッド名の割り当て ページにある要素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsDisconnecting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以前に接続した <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロール間の接続を終了するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>によってイベントが発生した、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A>メソッド、およびその事実を通知します。 ユーザーによって切断動詞がクリックしたこと、または<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>メソッドが呼び出されたそれ以外の場合。 イベントは、完了する前に、接続を終了するプロセスをキャンセルする機会を提供します。 接続が正常に終了した場合、このイベントが続いて、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>イベント。  
  
 ページの開発者は追加して、カスタム イベントのハンドラーを追加することができます、`OnWebPartsDisconnecting`属性を`<asp:webpartmanager>`要素、および属性にカスタム メソッドの名前を割り当てます。  
  
 通常、ときに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>イベントは、接続を終了するユーザーのアクションの直接の結果として、発生イベントをキャンセルできます。 ただし、これにはイベントをキャンセルできないいくつかのシナリオがあります。 場合、最初のシナリオでは、<xref:System.Web.UI.WebControls.WebParts.WebPartZone>コントロールが削除されると、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロールが含まれている必要がありますすべて閉じられます、それ以外の場合が孤立しています。 この場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>閉じの制御、<xref:System.Web.UI.WebControls.WebParts.WebPart>コントロール、されません、ユーザー、およびそのできる必要がありますも、中断することがなく接続されているコントロールの接続を終了するクリーンアップして、すべてのコントロールを終了するプロセスを完了するようにします。 そのため、デザインによって、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>メソッドは、このシナリオではキャンセルできません。 キャンセルできる、関連するイベントを参照してください、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>イベント。  
  
 2 番目のシナリオ、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>イベントをキャンセルできない場合は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>メソッドを呼び出す (これはたとえば、ページに、各要求中に呼び出されます) と、いくつかの種類のページ上の既存の接続に競合があります。 たとえば、おそらくに接続すると制御 x コントロール y が、共有ユーザーがコントロールをコントロール z x を接続し、まだコントロール x は、複数の接続を形成することはできません。 この場合、接続の個々 のユーザーの設定が優先され、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールは、呼び出すことによって、競合を解決、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>メソッドとの間の接続を終了 x および特定のユーザーの z。 この接続解除することは不可欠デザインして、競合を解決するため、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>イベントは、このシナリオで取り消すことはできません。  
  
 3 番目のシナリオで、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>メソッドはキャンセルできない場合は、<xref:System.Web.UI.WebControls.WebParts.WebPart>現在接続しているサーバー コントロールが削除か閉じるか。 コントロールが確実にためページから削除するは、必然的にその接続を削除します。 したがって、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールを呼び出す、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>を生成させるメソッド、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>デザインがありますが、イベントのイベントをキャンセルする可能性がします。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="Zones">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Zones As WebPartZoneCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ Zones { System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartZoneCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上のすべての <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンのコレクションへの参照を取得します。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneCollection" /> ゾーンのセットを参照する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>プロパティを使用、<xref:System.Web.UI.WebControls.WebParts.WebPartManager>コントロールを追跡する、 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Web ページの領域。 プロパティが、すべての種類のゾーンを参照しないことに注意してください。派生するゾーンのみを参照して、<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>クラスを含む<xref:System.Web.UI.WebControls.WebParts.WebPartZone>ゾーンです。  
  
 プロパティによって参照されるコレクションは読み取り専用では、コレクション内の個々 のオブジェクトにアクセスし、プログラムで操作を使用します。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>プロパティ個々 のアクセスをプログラムで<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>ゾーン コントロール。 Web ページの宣言型のマークアップが含まれている 2 つ`<asp:webpartzone>`サーバー コントロールを含む要素です。 `<script>`コードは、ページのセクションで、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>すべてのゾーンの Id を一覧表示して、2 番目のゾーンの背景色を変更する個別のゾーンにアクセスするプロパティです。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Zones#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/CS/wpmgrzonescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Zones#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/VB/wpmgrzonesvb.aspx#1)]  
  
 コード例を実行する必要があります設定を追加する Web パーツの記述ファイルをエクスポートできるようにするために Web.config ファイルに注意してください。 このコード例の Web ページと同じディレクトリ内の Web.config ファイルがあることを確認します。 内で、`<system.web>`セクションであることを確認、`<webParts>`を持つ要素が`enableExport`属性に設定`true`マークアップを次のように、します。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 をクリックすると、ブラウザーにページを読み込んだ後、**一覧ゾーン Id**ボタン コードを使用して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>コレクション内のすべてのゾーンの Id を一覧表示するプロパティです。 クリックした場合、**変更ゾーン BackColor**ボタン、コードは、2 番目のゾーンの背景色を変更します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>