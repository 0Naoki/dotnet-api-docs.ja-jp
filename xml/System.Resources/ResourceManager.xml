<Type Name="ResourceManager" FullName="System.Resources.ResourceManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a0604beca350dee3c9ad9f1eb2d9f351e0be0b67" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51907598" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ResourceManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ResourceManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ResourceManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceManager" />
  <TypeSignature Language="F#" Value="type ResourceManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>実行時にカルチャ固有のリソースにアクセスする便利な手段を提供するリソース マネージャーを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-class-note](~/includes/untrusted-data-class-note.md)]

 <xref:System.Resources.ResourceManager>クラスをアセンブリに埋め込まれているバイナリ .resources ファイルまたはスタンドアロンの .resources ファイルからリソースを取得します。 ローカライズされたアプリとでローカライズされたリソースが配置されている場合[サテライト アセンブリ](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)カルチャに固有のリソースを検索する、ローカライズされたリソースが存在しないと、リソースをサポートしているときにフォールバック リソースを提供しています。シリアル化します。  
  
 デスクトップ アプリでのリソース作成および管理の詳細については、[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリは、次のセクションを参照してください。  
  
-   [デスクトップ アプリ](#desktop)  
  
    -   [リソースの作成](#creating_resources)  
  
    -   [ResourceManager オブジェクトをインスタンス化します。](#instantiating)  
  
    -   [ResourceManager およびカルチャ固有のリソース](#CultureSpecific)  
  
    -   [リソースの取得](#retrieving)  
  
    -   [MissingManifestResourceException および MissingSatelliteAssemblyException 例外の処理](#exception)  
  
    -   [リソースのバージョン管理](#versioning)  
  
    -   [\<satelliteassemblies > 構成ファイルのノード](#config)  
  
-   [Windows ストア アプリ](#ws)  
  
<a name="desktop"></a>   
## <a name="desktop-apps"></a>デスクトップ アプリ  
 デスクトップ アプリの場合、<xref:System.Resources.ResourceManager>クラスは、バイナリ リソース (.resources) ファイルからリソースを取得します。 言語コンパイラでは通常、または[アセンブリ リンカー (AL.exe)](~/docs/framework/tools/al-exe-assembly-linker.md)をアセンブリにこれらのリソース ファイルを埋め込みます。 使用することも、<xref:System.Resources.ResourceManager>リソースを呼び出すことによって、アセンブリに埋め込まれていない .resources ファイルから直接取得するオブジェクト、<xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A>メソッド。  
  
> [!CAUTION]
>  によって明示的にリリースされるまで、リソースがロックされたままであるために、xcopy による配置では、ASP.NET アプリで、スタンドアロン .resources ファイルを使用して中断されます、<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>メソッド。 ASP.NET アプリケーションでリソースをデプロイする場合は、サテライト アセンブリに .resources ファイルをコンパイルする必要があります。  
  
 リソース ベースのアプリでは、1 つの .resources ファイルには、カルチャに固有のリソースが見つからない場合に使われるリソースの既定のカルチャのリソースが含まれています。 たとえば、アプリの既定のカルチャが英語 (en) の場合は、英語リソースは英語 (米国) (EN-US) またはフランス語 (フランス) (FR-FR) などの特定のカルチャのローカライズされたリソースが見つからないときに使用されます。 通常、既定のカルチャのリソースは、メイン アプリケーション アセンブリに埋め込まれているし、他のカルチャのローカライズされたリソースがサテライト アセンブリに埋め込まれています。 サテライト アセンブリには、リソースのみが含まれます。 メインのアセンブリとの拡張機能として、同じルート ファイル名がある。 resources.dll します。 アプリのアセンブリがグローバル アセンブリ キャッシュに登録されていない場合は、サテライト アセンブリは、アセンブリのカルチャに対応する名前のアプリのサブディレクトリに格納されます。  
  
<a name="creating_resources"></a>   
### <a name="creating-resources"></a>リソースの作成  
 リソース ベースのアプリを開発する際に、テキスト ファイル (拡張子が .txt または .restext ファイル) または XML ファイル (.resx 拡張子を持つファイル) でリソース情報を格納します。 テキストまたは使用する XML ファイルをコンパイルし、[リソース ファイル ジェネレーター (Resgen.exe)](~/docs/framework/tools/resgen-exe-resource-file-generator.md)バイナリ .resources ファイルを作成します。 コンパイラ オプションを使用して、実行可能ファイルまたはライブラリで、結果として得られる .resources ファイルを埋め込むことができますし、`/resources`の c# および Visual Basic コンパイラ、またはを埋め込むことができますをサテライト アセンブリを使用して、します。 Visual Studio プロジェクトに .resx ファイルを含めると、Visual Studio は、コンパイル、および既定の埋め込みを処理し、ビルド プロセスの一部として自動的にローカライズされたリソース。  
  
 理想的がアプリを作成するすべての言語のリソースをサポートするか、少なくとも意味のある各言語のサブセットの。 バイナリ .resources ファイルの名前が名前付け規則に従う*basename*.*cultureName*.resources、場所*basename*はアプリの名前または詳細のレベルに応じて、クラスの名前。 <xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType>プロパティの使用を判断*cultureName*します。 アプリの既定のカルチャのリソースに名前を付ける*basename*.resources します。  
  
 たとえば、いくつかのリソースのアセンブリは MyResources ベースの名前を持つリソース ファイルがあるとします。 これらのリソース ファイルが日本 (日本語) のカルチャをドイツのカルチャでは、簡体字中国語カルチャの MyResources.zh-CHS.resources MyResources.de.resources の MyResources.ja JP.resources などの名前とMyResources.fr BE.resources のフランス語 (ベルギー) のカルチャ。 既定のリソース ファイルは、MyResources.resources を名前必要があります。 カルチャ固有のリソース ファイルは、各カルチャのサテライト アセンブリに通常パッケージ化されます。 既定のリソース ファイルは、アプリのメイン アセンブリに埋め込まれる必要があります。  
  
 プライベートとしてマークするリソースを利用できるは常にそれらをマークするパブリックとして他のアセンブリによってアクセスできるようにできます。 (サテライト アセンブリにコードが含まれていないためプライベートとしてマークされているリソースは任意のメカニズムを通じてアプリで使用します。)  
  
 作成の詳細については、パッケージ化、および、リソースのデプロイ記事を参照して、[リソース ファイルの作成](~/docs/framework/resources/creating-resource-files-for-desktop-apps.md)、[サテライト アセンブリの作成](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)、および[パッケージ化と配置リソース](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)します。  
  
<a name="instantiating"></a>   
### <a name="instantiating-a-resourcemanager-object"></a>ResourceManager オブジェクトをインスタンス化します。  
 インスタンス化する、<xref:System.Resources.ResourceManager>埋め込みの .resources ファイルからそのクラス コンス トラクターのオーバー ロードの 1 つを呼び出してリソースを取得するオブジェクトです。 これを密に結合を<xref:System.Resources.ResourceManager>ローカライズされたサテライト アセンブリに .resources ファイルの特定の .resources ファイルと、関連付けられたすべてのオブジェクト。  
  
 2 つの最もよく呼び出されたコンス トラクターは次のとおりです。  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> 2 つの指定した情報に基づいてリソースを検索する: .resources ファイル、および既定の .resources ファイルが存在するアセンブリの基本名。 ベース名には、そのカルチャまたは拡張機能のない、.resources ファイルの名前空間とルート名が含まれています。 Visual Studio 環境で作成した .resources ファイルの操作を行いますが、通常、コマンドラインからコンパイルされる .resources ファイルには、名前空間の名前が含まれていないことに注意してください。 たとえば、MyCompany.StringResources.resources という名前のリソース ファイルは、<xref:System.Resources.ResourceManager>という名前の静的メソッドからコンス トラクターが呼び出されます`Example.Main`、次のコードをインスタンス化します、<xref:System.Resources.ResourceManager>からリソースを取得できます。リソース ファイル:  
  
     [!code-csharp[Conceptual.Resources.Retrieving#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#1)]
     [!code-vb[Conceptual.Resources.Retrieving#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#1)]  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> 型のオブジェクトからの情報に基づいて、サテライト アセンブリにリソースを検索します。 型の完全修飾名は、ファイル名拡張子なしの .resources ファイルのベース名に対応します。 Visual Studio リソース デザイナーを使用して作成されたデスクトップ アプリでは、Visual Studio は、の完全修飾名は .resources ファイルのルート名と同じラッパー クラスを作成します。 MyCompany.StringResources.resources という名前のリソース ファイルは、という名前のラッパー クラスがある場合など`MyCompany.StringResources`、次のコードをインスタンス化、 <xref:System.Resources.ResourceManager> .resources ファイルからリソースを取得できるオブジェクト。  
  
     [!code-csharp[Conceptual.Resources.Retrieving#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#2)]
     [!code-vb[Conceptual.Resources.Retrieving#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#2)]  
  
 コンス トラクターの呼び出しを作成し、有効な場合は、適切なリソースが見つからない<xref:System.Resources.ResourceManager>オブジェクト。 ただし、リソースを取得しようとするがスローされます、<xref:System.Resources.MissingManifestResourceException>例外。 例外に対処する方法については、次を参照してください。、 [MissingManifestResourceException の処理と MissingSatelliteAssembly 例外](#exception)この記事で後述する「します。  
  
 次の例では、インスタンス化する方法を示しています、<xref:System.Resources.ResourceManager>オブジェクト。 実行可能ファイル ShowTime.exe という名前のソース コードが含まれています。 次のテキスト ファイルを 1 つの文字列リソースを含む Strings.txt という名前も含まれています`TimeHeader`:。  
  
```  
TimeHeader=The current time is  
```  
  
 バッチ ファイルを使用するには、リソース ファイルを生成し、実行可能ファイルに埋め込むことです。 C# コンパイラを使用して、実行可能ファイルを生成するバッチ ファイルを次に示します。  
  
```  
  
resgen strings.txt  
csc ShowTime.cs /resource:strings.resources  
  
```  
  
 Visual Basic コンパイラでは、次のバッチ ファイルを使用できます。  
  
```  
  
resgen strings.txt  
vbc ShowTime.vb /resource:strings.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showtime.cs#1)]
 [!code-vb[System.Resources.ResourceManager.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showtime.vb#1)]  
  
<a name="CultureSpecific"></a>   
### <a name="resourcemanager-and-culture-specific-resources"></a>ResourceManager およびカルチャ固有のリソース  
 この記事で説明したようにローカライズされたアプリにデプロイするリソースが必要です[Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)します。 取得する対象のリソースは、現在のスレッドに基づくアセンブリが正しく構成されている場合、resource manager を決定します<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ。 (そのプロパティも返されます、現在のスレッド UI カルチャ)。たとえば、アプリをコンパイルした場合は、既定で 2 つのサテライト アセンブリでは、フランス語とロシア語の言語リソースを使用して、メイン アセンブリで英語の言語リソースと<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>FR-FR に設定されて、リソース マネージャーの取得、フランス語リソース。  
  
 設定することができます、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>プロパティ明示的または暗黙的にします。 設定する方法を決定する方法、<xref:System.Resources.ResourceManager>オブジェクトのカルチャに基づいてリソースを取得します。  
  
-   明示的に設定する場合、<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ、リソース マネージャーを常に特定のカルチャをユーザーのブラウザーまたはオペレーティング システムの言語に関係なく、そのカルチャのリソースを取得します。 既定の言語の英語リソースでコンパイルされるアプリと英語 (米国)、フランス語 (フランス)、およびロシア語 (ロシア) リソースを含む 3 つのサテライト アセンブリを検討してください。 場合、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>プロパティが、FR-FR、<xref:System.Resources.ResourceManager>オブジェクトは常にフランス語 (フランス) リソースを取得、場合でも、ユーザーのオペレーティング システムの言語がフランス語ではありません。 プロパティを明示的に設定する前に、目的の動作は、このことを確認します。  
  
     、ASP.NET アプリで設定する必要があります、<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>プロパティを明示的になっていないため、サーバーの設定が着信クライアント要求を一致する可能性があります。 ASP.NET アプリを設定できる、<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ、ユーザーのブラウザーを明示的に使用する言語。  
  
     明示的に設定、<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>プロパティは、そのスレッドの現在の UI カルチャを定義します。 アプリで他のスレッドの現在の UI カルチャには影響しません。  
  
-   アプリケーション ドメイン内のすべてのスレッド UI カルチャを設定するには割り当てることで、 <xref:System.Globalization.CultureInfo> 、静的なカルチャを表すオブジェクト<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType>プロパティ。  
  
-   現在の UI カルチャが明示的に設定しないと、現在のアプリケーション ドメインの既定のカルチャを定義していない場合、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティは、Windows によって暗黙的に設定`GetUserDefaultUILanguage`関数。 この関数は、によって、Multilingual User Interface (MUI)、これにより、既定の言語を設定するユーザーに提供されます。 UI 言語が、ユーザーが設定されていない場合の既定値はオペレーティング システムのリソースの言語は、システムにインストールされた言語です。  
  
 次の単純な"Hello world"の例では、現在の UI カルチャが明示的に設定します。 次の 3 つのカルチャのリソースが含まれています: 英語 (米国) または EN-US、フランス語 (フランス)、または FR-FR、やロシア語 (ロシア) RU-RU です。 Greetings.txt をという名前のテキスト ファイルでは、EN-US でリソースが含まれています。  
  
```  
HelloString=Hello world!  
```  
  
 Greetings.fr をという名前のテキスト ファイルに含まれる、FR-FR のリソースに入っています。  
  
```  
HelloString=Salut tout le monde!  
```  
  
 Greetings.ru をという名前のテキスト ファイルに含まれる RU-RU リソースに格納します。  
  
```  
HelloString=Всем привет!  
```  
  
 次の例では、(Visual Basic バージョンの Example.vb) または Example.cs c# バージョンのソース コードに示します。  
  
 [!code-csharp[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.currentculture/cs/example.cs#1)]
 [!code-vb[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.currentculture/vb/example.vb#1)]  
  
 この例をコンパイルするには、次のコマンドを含み、コマンド プロンプトから実行バッチ (.bat) ファイルを作成します。 C# を使用している場合は、指定`csc`の代わりに`vbc`と`Example.cs`の代わりに`Example.vb`します。  
  
```  
resgen Greetings.txt   
vbc Example.vb /resource:Greetings.resources  
  
resgen Greetings.fr-FR.txt  
Md fr-FR  
al /embed:Greetings.fr-FR.resources /culture:fr-FR /out:fr-FR\Example.resources.dll  
  
resgen Greetings.ru-RU.txt  
Md ru-RU  
al /embed:Greetings.ru-RU.resources /culture:ru-RU /out:ru-RU\Example.resources.dll  
```  
  
<a name="retrieving"></a>   
### <a name="retrieving-resources"></a>リソースの取得  
 呼び出す、<xref:System.Resources.ResourceManager.GetObject%28System.String%29>と<xref:System.Resources.ResourceManager.GetString%28System.String%29>特定のリソースにアクセスするメソッド。 呼び出すことも、<xref:System.Resources.ResourceManager.GetStream%28System.String%29>文字列以外のリソースをバイト配列として取得するメソッド。 既定では、リソースがローカライズされているアプリでこれらのメソッドを返しますの呼び出しを行ったスレッドの現在の UI カルチャで決定するカルチャのリソース。 前のセクションを参照してください。 [ResourceManager とカルチャ固有のリソース](#CultureSpecific)、スレッドの現在の UI カルチャを定義する方法の詳細についてはします。 リソース マネージャーは、現在のスレッド UI カルチャのリソースを見つけることができない場合、は、指定したリソースを取得するフォールバック プロセスが使用されます。 リソース マネージャーが、ローカライズされたリソースを見つけられない場合は、既定のカルチャのリソースが使用されます。 リソース フォールバック規則の詳細については、この記事の「リソース フォールバック プロセス」セクションを参照してください。 [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)します。  
  
> [!NOTE]
>  .Resources ファイルが指定されている場合、<xref:System.Resources.ResourceManager>クラスのコンス トラクターが見つからない場合、リソースを取得しようとすると、スロー、<xref:System.Resources.MissingManifestResourceException>または<xref:System.Resources.MissingSatelliteAssemblyException>例外。 例外に対処する方法については、次を参照してください。、 [MissingManifestResourceException の処理と MissingSatelliteAssemblyException 例外](#exception)このトピックで後述します。  
  
 次の例では、<xref:System.Resources.ResourceManager.GetString%2A>カルチャに固有のリソースを取得します。 英語 (en)、フランス語 (フランス) (FR-FR)、およびロシア語 (ロシア) (RU-RU) の .txt ファイルからコンパイルされたリソースのカルチャ。 例は、英語 (米国)、フランス語 (フランス)、ロシア語 (ロシア)、およびスウェーデン語 (スウェーデン) を現在のカルチャと現在の UI カルチャを変更します。 呼び出して、<xref:System.Resources.ResourceManager.GetString%2A>メソッドをおよび現在の日付と月が表示されますが、ローカライズされた文字列を取得します。 スウェーデン語 (スウェーデン) が現在の UI カルチャの場合を除き、適切なローカライズされた文字列が表示に注意してください。 スウェーデン語の言語リソースが利用できないため、アプリは代わりに既定のカルチャは英語のリソースを使用します。  
  
 例では、次の表に記載されたテキスト ベースのリソース ファイルが必要です。 という名前の 1 つの文字列リソースを持つ各`DateStart`します。  
  
|culture|ファイル名|リソース名|リソースの値|  
|-------------|---------------|-------------------|--------------------|  
|en-US|DateStrings.txt|`DateStart`|今日が|  
|fr-FR|DateStrings.fr ファイルに格納|`DateStart`|Aujourd'hui、c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 次の例では、(Visual Basic バージョンの ShowDate.vb) または ShowDate.cs c# バージョンのコードのソース コードに示します。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 この例をコンパイルするには、次のコマンドを含み、コマンド プロンプトから実行するバッチ ファイルを作成します。 C# を使用している場合は、指定`csc`の代わりに`vbc`と`showdate.cs`の代わりに`showdate.vb`します。  
  
```  
  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
  
```  
  
 現在の UI カルチャ以外の特定のカルチャのリソースを取得する 2 つの方法はあります。  
  
-   呼び出すことができます、 <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>、 <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>、または<xref:System.Resources.ResourceManager.GetStream%28System.String%2CSystem.Globalization.CultureInfo%29>特定カルチャのリソースを取得するメソッド。 ローカライズされたリソースが見つからない場合、リソース マネージャーは、適切なリソースを検索するリソース フォールバック プロセスを使用します。  
  
-   呼び出すことができます、<xref:System.Resources.ResourceManager.GetResourceSet%2A>メソッドを取得する、<xref:System.Resources.ResourceSet>特定のカルチャのリソースを表すオブジェクト。 メソッドの呼び出しで、ローカライズされたリソースを検索することがない場合、親カルチャのリソース マネージャーがプローブするかどうかや、かどうかだけにフォールバックの既定のカルチャのリソースを指定できます。 使用することができますし、<xref:System.Resources.ResourceSet>メソッド名、(そのカルチャのローカライズ版) のリソースにアクセスする、または、セット内のリソースを列挙します。  
  
<a name="exception"></a>   
### <a name="handling-missingmanifestresourceexception-and-missingsatelliteassemblyexception-exceptions"></a>MissingManifestResourceException および MissingSatelliteAssemblyException 例外の処理  
 特定のリソースを取得しようとするが、リソース マネージャーが見つからないことは、リソースとない既定のカルチャが定義されている、または既定のカルチャのリソースが存在することはできません、resource manager をスローする<xref:System.Resources.MissingManifestResourceException>例外場合、メイン アセンブリにリソースを検索するが必要ですが、<xref:System.Resources.MissingSatelliteAssemblyException>サテライト アセンブリにリソースを検索することが必要な場合。 など、リソース取得メソッドを呼び出すときに、例外がスローされたことに注意してください。<xref:System.Resources.ResourceManager.GetString%2A>または<xref:System.Resources.ResourceManager.GetObject%2A>、いないときにインスタンス化すると、<xref:System.Resources.ResourceManager>オブジェクト。  
  
 次の条件下では、通常、例外がスローされます。  
  
-   適切なリソース ファイルまたはサテライト アセンブリが存在しません。 リソース マネージャーには、アプリの既定のリソースをメイン アプリケーション アセンブリに埋め込むことが必要ですが、これらが存在しません。 場合、<xref:System.Resources.NeutralResourcesLanguageAttribute>属性は、アプリの既定のリソースがサテライト アセンブリに存在する、アセンブリが見つからないことを示します。 アプリをコンパイルするときに、リソースがメイン アセンブリに埋め込まれているか、必要に応じてサテライト アセンブリが生成され、適切にという名前を確認します。 その名前がフォームを実行する必要があります*appName*。 resources.dll、およびそれをカルチャが含まれているリソースを含む名前のディレクトリに配置する必要があります。  
  
-   アプリは、既定値または定義されたニュートラル カルチャがありません。 追加、<xref:System.Resources.NeutralResourcesLanguageAttribute>属性をソース コード ファイルまたはプロジェクトの情報ファイル (Visual Basic アプリの AssemblyInfo.vb) または c# アプリの AssemblyInfo.cs ファイル。  
  
-   `baseName`パラメーター、<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>コンス トラクターが .resources ファイルの名前を指定していません。 名前には、リソース ファイルの完全修飾名前空間がないファイル名拡張子を含める必要があります。 通常、Visual Studio で作成されるリソース ファイルは、名前空間の名前が作成され、コマンド プロンプトでコンパイルされたリソース ファイルはありません。 コンパイルし、次のユーティリティを実行して、埋め込みの .resources ファイルの名前を指定できます。 これは、メイン アセンブリまたはコマンド ライン パラメーターとしてのサテライト アセンブリの名前を指定するコンソール アプリです。 文字列として指定する必要がありますが表示されます、`baseName`パラメーター、リソース マネージャーでは、リソースを正しく特定できるようにします。  
  
     [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
     [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 アプリケーションの現在のカルチャを明示的に変更する場合も覚えておいてください、resource manager での値に基づいてリソース セットを取得する、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ、および not、<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>プロパティ。 通常、1 つの値を変更する場合変更する必要も、その他。  
  
<a name="versioning"></a>   
### <a name="resource-versioning"></a>リソースのバージョン管理  
 アプリの既定のリソースを含むメイン アセンブリはアプリのサテライト アセンブリは別であるために、サテライト アセンブリを再デプロイしなくても、メイン アセンブリの新しいバージョンをリリースできます。 使用する、<xref:System.Resources.SatelliteContractVersionAttribute>既存のサテライト アセンブリを使用して、メインのアセンブリの新しいバージョンでそれらを再デプロイがリソース マネージャーに指示する属性  
  
 サテライト アセンブリのバージョン管理サポートの詳細については、記事を参照してください。[のリソースの取得](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md)します。  
  
<a name="config"></a>   
### <a name="satelliteassemblies-configuration-file-node"></a>\<satelliteassemblies > 構成ファイルのノード  
 展開を行い、web サイト (HREF .exe ファイル) から実行される実行可能ファイルに対して、<xref:System.Resources.ResourceManager>オブジェクトは、アプリのパフォーマンスが低下することができます、web 経由でサテライト アセンブリをプローブ可能性があります。 パフォーマンスの問題を排除するために、アプリをデプロイしたサテライト アセンブリへのプローブを制限できます。 作成するを`<satelliteassemblies>`を指定し、アプリの特定のカルチャのセットを展開したアプリの構成ファイル内のノード、<xref:System.Resources.ResourceManager>オブジェクトはそのノードが表示されていない任意のカルチャのプローブしようとはしないでください。  
  
> [!NOTE]
>  作成に代わる、`<satelliteassemblies>`ノードは、使用する、 [ClickOnce 配置マニフェスト](https://msdn.microsoft.com/library/8457e615-e3b6-4990-8dcf-11bc590e4e9b)機能します。  
  
 アプリの構成ファイルで、次のようなセクションを作成します。  
  
```  
<?xml version ="1.0"?>  
<configuration>  
    <satelliteassemblies>  
        <assembly name="MainAssemblyName, Version=versionNumber, Culture=neutral, PublicKeyToken=null|yourPublicKeyToken">  
            <culture>cultureName1</culture>  
            <culture>cultureName2</culture>  
            <culture>cultureName3</culture>  
        </assembly>  
    </satelliteassemblies>  
</configuration>  
```  
  
 次のように、この構成情報を編集します。  
  
-   1 つ以上指定`<assembly>`ノードを展開すると、各メイン アセンブリの各ノードが完全修飾アセンブリ名を指定します。 代わりに、メイン アセンブリの名前を指定*MainAssemblyName*を指定し、 `Version`、 `PublicKeyToken`、および`Culture`属性をメイン アセンブリに対応する値。  
  
     `Version`属性は、アセンブリのバージョン番号を指定します。 たとえば、アセンブリの最初のリリースでは、バージョン番号は 1.0.0.0 可能性があります。  
  
     `PublicKeyToken`属性、キーワードを指定する`null`厳密な名前でアセンブリに署名していない場合は、アセンブリに署名した場合、公開キー トークンを指定します。  
  
     `Culture`属性、キーワードを指定する`neutral`メイン アセンブリを指定して、<xref:System.Resources.ResourceManager>クラスのみで表示されているカルチャを探すために、`<culture>`ノード。  
  
     完全修飾アセンブリ名の詳細については、記事を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)します。 厳密な名前付きアセンブリの詳細については、記事を参照してください。[の作成と using strong-named Assemblies](~/docs/framework/app-domains/create-and-use-strong-named-assemblies.md)します。  
  
-   1 つ以上指定`<culture>`"FR-FR"などの特定のカルチャ名、または"fr"などのニュートラル カルチャ名を持つノード。  
  
 下に表示されない任意のアセンブリにリソースが必要なかどうか、`<satelliteassemblies>`ノード、<xref:System.Resources.ResourceManager>クラスの標準のプローブ規則を使用するカルチャをプローブします。  
  
<a name="ws"></a>   
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  ただし、<xref:System.Resources.ResourceManager>クラスではサポートされて[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ、その用途をようお勧めできません。 このクラスを使用して開発する場合にのみ[!INCLUDE[net_portable](~/includes/net-portable-md.md)]で使用できるプロジェクト[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ。 リソースを取得する[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]、アプリを使用して、 [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182)クラスの代わりにします。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 、アプリ、<xref:System.Resources.ResourceManager>クラスは、パッケージ リソース インデックス (PRI) ファイルからリソースを取得します。 単一の PRI ファイル (アプリケーション パッケージの PRI ファイル) には、既定のカルチャおよびすべてのリソースが含まれています。 ローカライズ カルチャ。 MakePRI ユーティリティを使用して、XML リソース (.resw) 形式では、1 つまたは複数のリソース ファイルから PRI ファイルを作成します。 Visual Studio は、Visual Studio プロジェクトに含まれているリソースの作成および PRI ファイルを自動的にパッケージ化のプロセスを処理します。 .NET Framework を使用することができますし、<xref:System.Resources.ResourceManager>クラス ライブラリのアプリのリソースにアクセスします。  
  
 インスタンス化することができます、<xref:System.Resources.ResourceManager>オブジェクト、[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]デスクトップ アプリの場合と同じ方法でアプリ。  
  
 取得するリソースの名前を渡すことによって、特定のカルチャのリソースにアクセスすることができますし、<xref:System.Resources.ResourceManager.GetString%28System.String%29>メソッド。 既定では、このメソッドは、呼び出しを行ったスレッドの現在の UI カルチャで決定するカルチャのリソースを返します。 リソースの名前を渡すことによって、特定のカルチャのリソースを取得することも、<xref:System.Globalization.CultureInfo>がリソースを取得するカルチャを表すオブジェクトを<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>メソッド。 現在の UI カルチャまたは指定したカルチャのリソースが見つからない場合、resource manager は、適切なリソースを特定する UI 言語フォールバック リストを使用します。  
  
   
  
## Examples  
 次の例では、明示的なカルチャおよび暗黙の現在の UI カルチャを使用して、メイン アセンブリとサテライト アセンブリからの文字列リソースを取得する方法を示します。 詳細については、「ディレクトリの場所のサテライト アセンブリしないインストールで、グローバル アセンブリ キャッシュ」セクションを参照してください、[サテライト アセンブリの作成](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)トピック。  
  
 この例を実行します。  
  
1.  App ディレクトリでは、次のリソース文字列を含む rmc.txt という名前のファイルを作成します。  
  
    ```  
  
    day=Friday  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
2.  使用して、[リソース ファイル ジェネレーター](~/docs/framework/tools/resgen-exe-resource-file-generator.md) rmc.txt 入力ファイルから次のように、rmc.resources リソース ファイルを生成します。  
  
    ```  
    resgen rmc.txt  
    ```  
  
3.  アプリ ディレクトリのサブディレクトリを作成し、"ES-MX"という名前です。 これは、次の 3 つの手順で作成するサテライト アセンブリのカルチャ名です。  
  
4.  次のリソース文字列を含む ES-MX のディレクトリに rmc.es-MX.txt という名前のファイルを作成します。  
  
    ```  
  
    day=Viernes  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
5.  使用して、[リソース ファイル ジェネレーター](~/docs/framework/tools/resgen-exe-resource-file-generator.md) rmc.es MX.txt 入力ファイルから次のように、rmc.es MX.resources リソース ファイルを生成します。  
  
    ```  
    resgen rmc.es-MX.txt  
    ```  
  
6.  この例のファイル名が rmc.vb または rmc.cs のどちらであると仮定します。 次のソース コードをファイルにコピーします。 それをコンパイルし、メイン アセンブリのリソース ファイル、rmc.resources を実行可能アセンブリに埋め込みます。 Visual Basic コンパイラを使用している場合、構文です。  
  
    ```  
    vbc rmc.vb /resource:rmc.resources  
    ```  
  
     C# コンパイラの対応する構文です。  
  
    ```  
    csc /resource:rmc.resources rmc.cs  
    ```  
  
7.  使用して、[アセンブリ リンカー](~/docs/framework/tools/al-exe-assembly-linker.md)サテライト アセンブリを作成します。 アプリのベース名が rmc の場合は、サテライト アセンブリの名前は rmc.resources.dll である必要があります。 ES-MX のディレクトリにサテライト アセンブリを作成する必要があります。 ES-MX が現在のディレクトリの場合は、このコマンドを使用します。  
  
    ```  
    al /embed:rmc.es-MX.resources /c:es-MX /out:rmc.resources.dll   
    ```  
  
8.  取得して、埋め込まれたリソース文字列を表示する rmc.exe を実行します。  
  
 [!code-csharp[ResourceManager_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/ResourceManager_Class/cs/rmc.cs#1)]
 [!code-vb[ResourceManager_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ResourceManager_Class/vb/rmc.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <altmember cref="T:System.Globalization.CultureInfo" />
    <altmember cref="P:System.Globalization.CultureInfo.CurrentUICulture" />
    <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
    <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">アプリケーションのリソース</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ResourceManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ResourceManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを既定値で初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターは、独自のクラスから派生したを記述する場合にのみ役立ちます、<xref:System.Resources.ResourceManager>クラス。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (Type resourceSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type resourceSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resourceSource As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(Type ^ resourceSource);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : Type -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager resourceSource" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="resourceSource" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="resourceSource">リソース マネージャーが .resources ファイルを検索するために必要なすべての情報を取得する元となる種類。</param>
        <summary>指定した型オブジェクトの情報に基づいて、サテライト アセンブリでリソースを検索する <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>デスクトップ アプリ  
 リソース マネージャーを使用してデスクトップ アプリ、`resourceSource`パラメーターを次のように、特定のリソース ファイルを読み込めません。  
  
-   場合、<xref:System.Resources.NeutralResourcesLanguageAttribute>を示す既定のカルチャのリソースがサテライト アセンブリに配置をリソース マネージャーは、既定のカルチャのリソース ファイルをで指定された型と同じアセンブリで見つかったこと前提としています属性は使用されません。`resourceSource`パラメーター。  
  
-   リソース マネージャーは、既定のリソース ファイルがで指定された型と同じ基本名を持つことを想定しています、`resourceSource`パラメーター。  
  
-   リソース マネージャーは、既定値を使用します。<xref:System.Resources.ResourceSet>リソース ファイルを操作するクラス。  
  
 MyType を定義するアセンブリで MyCompany.MyProduct.MyType.resources をという名前の .resources ファイルのリソース マネージャーを検索など MyCompany.MyProduct.MyType という名前の型を指定します。  
  
 Visual Studio で、リソース デザイナーを自動的に生成コードを定義する、 `internal` (で C# の場合) または`Friend`(Visual Basic) では、クラスの名前は既定のカルチャの .resources ファイルの基本名と同じです。 これにより、インスタンス化すること、<xref:System.Resources.ResourceManager>として、リソースがある必要があります、クラスがコンパイラに表示されている限りために、リソースの名前に対応する名前の型のオブジェクトを取得することによって、特定のリソースのセットを結合、およびオブジェクトまぁ。 たとえば、Resource1 .resources ファイルの名前が場合、次のステートメントをインスタンス化、 <xref:System.Resources.ResourceManager> Resource1 をという名前の .resources ファイルを管理するオブジェクト。  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/ctor1.cs#2)]  
  
 Visual Studio を使用していない場合、その名前空間と名前は、既定の .resources ファイルのと同じメンバーを持たないクラスを作成することができます。 具体的な例を次に示します。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  ただし、<xref:System.Resources.ResourceManager>クラスではサポートされて[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ、その用途をようお勧めできません。 このクラスを使用して開発する場合にのみ[!INCLUDE[net_portable](~/includes/net-portable-md.md)]で使用できるプロジェクト[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ。 リソースを取得する[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]、アプリを使用して、 [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182)クラスの代わりにします。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ、<xref:System.Resources.ResourceManager>を使用して、`resourceSource`パラメーター、アセンブリ、基本名、およびリソース項目をアプリのパッケージ リソース インデックス (PRI) ファイル内に配置できる場所の名前空間を推論します。 たとえばで定義されている MyCompany.MyProduct.MyType という名前の型を指定`MyAssembly`、リソース マネージャーのリソース セット識別子が MyAssembly という名前の外観し、MyCompany.MyProduct.MyType そのリソース セット内のスコープを探します。 リソース マネージャーは、このスコープ内での既定のコンテキスト (現在のカルチャや現在のハイ コントラスト設定) の下にあるリソース項目を検索します。  
  
   
  
## Examples  
 次の例では、<xref:System.Resources.ResourceManager.%23ctor%28System.Type%29>インスタンスを作成するコンス トラクター、<xref:System.Resources.ResourceManager>オブジェクト。 英語 (en)、フランス語 (フランス) (FR-FR)、およびロシア語 (ロシア) (RU-RU) の .txt ファイルからコンパイルされたリソースのカルチャ。 例は、英語 (米国)、フランス語 (フランス)、ロシア語 (ロシア)、およびスウェーデン語 (スウェーデン) を現在のカルチャと現在の UI カルチャを変更します。 呼び出して、<xref:System.Resources.ResourceManager.GetString%28System.String%29>時間帯に依存している応答メッセージを表示するローカライズされた文字列を取得します。  
  
 例では、次の表に記載されている、3 つのテキスト ベースのリソース ファイルが必要です。 各ファイルには、という名前の文字列リソースが含まれています。 `Morning`、 `Afternoon`、および`Evening`します。  
  
|culture|ファイル名|リソース名|リソースの値|  
|-------------|---------------|-------------------|--------------------|  
|en-US|GreetingResources.txt|`Morning`|おはようございます|  
|en-US|GreetingResources.txt|`Afternoon`|こんにちは|  
|en-US|GreetingResources.txt|`Evening`|こんばんは|  
|fr-FR|GreetingResources.fr ファイルに格納|`Morning`|Bonjour|  
|fr-FR|GreetingResources.fr ファイルに格納|`Afternoon`|Bonjour|  
|fr-FR|GreetingResources.fr ファイルに格納|`Evening`|Bonsoir|  
|ru-RU|GreetingResources.ru ファイルに格納|`Morning`|ДОБРОЕ УТРО|  
|ru-RU|GreetingResources.ru ファイルに格納|`Afternoon`|ДОБРЫЙ ДЕНЬ|  
|ru-RU|GreetingResources.ru ファイルに格納|`Evening`|ДОБРЫЙ ВЕЧЕР|  
  
 次のバッチ ファイルを使用して、Visual Basic の例をコンパイルし、Greet.exe という名前の実行可能ファイルを作成することができます。 C# でコンパイルをするからコンパイラ名を変更`vbc`に`csc`とからのファイル拡張子`.vb`に`.cs`します。  
  
```  
  
resgen GreetingResources.txt  
vbc Greet.vb /resource: GreetingResources.resources  
  
md fr-FR  
resgen GreetingResources.fr-FR.txt  
al /out:fr-FR\Greet.resources.dll /culture:fr-FR /embed: GreetingResources.fr-FR.resources   
  
md ru-RU  
resgen GreetingResources.ru-RU.txt  
al /out:ru-RU\Greet.resources.dll /culture:ru-RU /embed: GreetingResources.ru-RU.resources  
  
```  
  
 次の例では、(Visual Basic バージョンの ShowDate.vb) または ShowDate.cs c# バージョンのコードのソース コードに示します。  
  
 [!code-csharp[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/greet.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/greet.vb#3)]  
  
 アプリのクラスを定義するだけでなく、名前付き`Example`、ソース コードは、名前の内部クラスを定義します`GreetingResources`、リソース ファイルの基本名と同じです。 正常にインスタンスを作成できるようになります、<xref:System.Resources.ResourceManager>オブジェクトを呼び出すことによって、<xref:System.Resources.ResourceManager.%23ctor%28System.Type%29>コンス トラクター。  
  
 出力が表示されますが、適切なローカライズされた文字列ことである場合、現在の UI カルチャがスウェーデン語 (スウェーデン) が場合を除き、通知は、英語の言語リソースを使用します。 定義されている、アプリが既定のカルチャのリソースを使用してスウェーデン語の言語リソースが利用できないため、<xref:System.Resources.NeutralResourcesLanguageAttribute>属性は、代わりにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceSource" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : string * System.Reflection.Assembly -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager (baseName, assembly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="baseName">拡張子はないが、完全修飾名前空間名を含んだ、リソース ファイルのルート名。 たとえば、"MyApplication.MyResource.en-US.resources" というリソース ファイルのルート名は "MyApplication.MyResource" です。</param>
        <param name="assembly">リソースのメイン アセンブリ。</param>
        <summary>指定したアセンブリ内で指定したルート名を持つファイルに含まれているリソースを検索する <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>デスクトップ アプリ  
 デスクトップ アプリ、サテライト アセンブリには、個々 のカルチャに固有のリソース ファイルを含める必要があり、メイン アセンブリには、既定のカルチャのリソース ファイルを含める必要があります。 サテライト アセンブリでは、そのアセンブリのマニフェストで指定された 1 つのカルチャのリソースを含むと見なされますされ、必要に応じて読み込まれます。  
  
> [!NOTE]
>  呼び出す必要がありますをアセンブリから取得するのではなく、直接の .resources ファイルからリソースを取得する、<xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A>メソッド代わりにインスタンス化する、<xref:System.Resources.ResourceManager>オブジェクト。  
  
 リソース ファイルがで識別される場合`baseName`内に見つかりません`assembly`、メソッドがインスタンス化、<xref:System.Resources.ResourceManager>オブジェクトが、特定のリソースを取得しようとすると、通常、例外がスロー<xref:System.Resources.MissingManifestResourceException>します。 例外の原因を診断する方法の詳細については、の「the MissingManifestResourceException 例外を処理する」セクションを参照してください、<xref:System.Resources.ResourceManager>クラスに関するトピック。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  ただし、<xref:System.Resources.ResourceManager>クラスではサポートされて[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ、その用途をようお勧めできません。 このクラスを使用して開発する場合にのみ[!INCLUDE[net_portable](~/includes/net-portable-md.md)]で使用できるプロジェクト[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ。 リソースを取得する[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]、アプリを使用して、 [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182)クラスの代わりにします。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ、リソース マネージャーの使用の簡易名、`assembly`アプリのパッケージ リソース インデックス (PRI) ファイルで一致するリソースを検索するパラメーターを設定します。 `baseName`リソース セット内のリソース項目を検索するパラメーターを使用します。 たとえば、PortableLibrary1.Resource1.de DE.resources のルート名は PortableLibrary1.Resource1 です。  
  
   
  
## Examples  
 次の例を示すためにローカライズされていない単純な"Hello World"アプリを使用して、<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>コンス トラクター。 ExampleResources.txt をという名前のテキスト ファイルの内容を次に示します。 アプリがコンパイルされると、リソースは、メイン アプリケーション アセンブリに埋め込まれます。  
  
```  
Greeting=Hello  
```  
  
 使用して、テキスト ファイルをバイナリ リソース ファイルに変換できる、コマンド プロンプトで、次のようにします。  
  
```  
resgen ExampleResources.txt  
```  
  
 次の例は、実行可能コードをインスタンス化する、<xref:System.Resources.ResourceManager>オブジェクトの名前を入力するように求めるし、あいさつ文が表示されます。  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/example.cs#1)]
 [!code-vb[System.Resources.ResourceManager.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/example.vb#1)]  
  
 Visual Basic では、次のコマンドを使用してコンパイルできます。  
  
```  
vbc Example.vb /resource:ExampleResources.resources  
```  
  
 または、以下を使用して c# ではコマンドします。  
  
```  
csc Example.cs /resource:ExampleResources.resources  
```  
  
 例にそのアセンブリで定義された型を渡すことによって、リソース ファイルを含むアセンブリへの参照を取得することに注意してください、`typeof`関数 (c#) または`GetType`(Visual Basic) で機能し、そのの値を取得する<xref:System.Type.Assembly%2A?displayProperty=nameWithType>プロパティ。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseName" /> パラメーターまたは <paramref name="assembly" /> パラメーターが <see langword="null" /> です。</exception>
        <block subset="none" type="overrides">
          <para>このコンス トラクターは、システム指定<see cref="T:System.Resources.ResourceSet" />実装します。 派生する必要があります、カスタム リソース ファイル形式を使用する、<see cref="T:System.Resources.ResourceSet" />クラスでオーバーライド、<see cref="M:System.Resources.ResourceSet.GetDefaultReader" />と<see cref="M:System.Resources.ResourceSet.GetDefaultWriter" />メソッド、およびパスを入力する、<see cref="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" />コンス トラクター。 カスタムを使用して<see cref="T:System.Resources.ResourceSet" />は制御するリソースのキャッシュ ポリシーまたは、独自のリソース ファイル形式をサポートしているが、一般に必要な役に立ちます。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly, Type ^ usingResourceSet);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : string * System.Reflection.Assembly * Type -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager (baseName, assembly, usingResourceSet)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
        <Parameter Name="usingResourceSet" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="baseName">拡張子はないが、完全修飾名前空間名を含んだ、リソース ファイルのルート名。 たとえば、"MyApplication.MyResource.en-US.resources" というリソース ファイルのルート名は "MyApplication.MyResource" です。</param>
        <param name="assembly">リソースのメイン アセンブリ。</param>
        <param name="usingResourceSet">使用するカスタム <see cref="T:System.Resources.ResourceSet" /> の種類。 <see langword="null" /> の場合は、既定のランタイム <see cref="T:System.Resources.ResourceSet" /> オブジェクトが使用されます。</param>
        <summary>指定した <see cref="T:System.Resources.ResourceSet" /> クラスを使用して、指定したアセンブリ内で指定したルート名を持つファイルに含まれるリソースを検索する <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サテライト アセンブリには、個々 のカルチャに固有のリソース ファイルを含める必要があり、メイン アセンブリには、既定のカルチャのリソース ファイルを含める必要があります。 サテライト アセンブリでは、そのアセンブリのマニフェストで指定された 1 つのカルチャのリソースを含むと見なされますされ、必要に応じて読み込まれます。  
  
> [!NOTE]
>  呼び出す必要がありますをアセンブリから取得するのではなく、直接の .resources ファイルからリソースを取得する、<xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A>メソッド代わりにインスタンス化する、<xref:System.Resources.ResourceManager>オブジェクト。  
  
 リソース ファイルがで識別される場合`baseName`内に見つかりません`assembly`、メソッドがインスタンス化、<xref:System.Resources.ResourceManager>オブジェクトが、特定のリソースを取得しようとすると、通常、例外がスロー<xref:System.Resources.MissingManifestResourceException>します。 例外の原因を診断する方法の詳細については、の「the MissingManifestResourceException 例外を処理する」セクションを参照してください、<xref:System.Resources.ResourceManager>クラスに関するトピック。  
  
> [!NOTE]
>  `usingResourceSet`パラメーターは、独自のリソース形式をサポートするために使用されは、一般的に`null`します。 異なるを受け取るコンス トラクター、<xref:System.Type>のみです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="usingResourceset" /> が <see cref="T:System.Resources.ResourceSet" /> の派生クラスではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseName" /> パラメーターまたは <paramref name="assembly" /> パラメーターが <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>このコンス トラクターでは、指定することができます、<see cref="T:System.Resources.ResourceSet" />実装します。 特定したくない場合<see cref="T:System.Resources.ResourceSet" />実装は、カスタム リソース ファイルの形式を使用するようにから派生する必要があります、<see cref="T:System.Resources.ResourceSet" />クラスでオーバーライド、<see cref="M:System.Resources.ResourceSet.GetDefaultReader" />と<see cref="M:System.Resources.ResourceSet.GetDefaultWriter" />メソッド、およびこのコンス トラクターにパスを入力します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BaseName">
      <MemberSignature Language="C#" Value="public virtual string BaseName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseName" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.BaseName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseName : string" Usage="System.Resources.ResourceManager.BaseName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Resources.ResourceManager" /> がリソースを検索するリソース ファイルのルート名を取得します。</summary>
        <value>
          <see cref="T:System.Resources.ResourceManager" /> がリソースを検索するリソース ファイルのルート名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.BaseName%2A>プロパティには、完全修飾名前空間の名前とそのカルチャまたはファイル名拡張子を除いたのリソース ファイルのルート リソース名が反映されます。 たとえば、アプリの既定のリソース ファイルの名前は`SampleApps.StringResources.resources`の値、<xref:System.Resources.ResourceManager.BaseName%2A>プロパティが"SampleApps.StringResources"。 アプリの既定のリソース ファイルの名前が場合`SampleApps.StringResources.en-US.resources`の値、サテライト アセンブリに埋め込まれていると、<xref:System.Resources.ResourceManager.BaseName%2A>プロパティが"SampleApps.StringResources"。  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager.BaseName%2A>を含めない限り、明示的に 1 つのファイルをコンパイルするときに、コンパイルされ、コマンドラインから埋め込みリソース ファイルのプロパティの値で名前空間の名前が含まれません。 一方で、<xref:System.Resources.ResourceManager.BaseName%2A>コンパイルされ、通常、Visual Studio 環境内で埋め込みリソース ファイルのプロパティの値には、既定の名前空間の名前にが含まれます。  
  
 <xref:System.Resources.ResourceManager.BaseName%2A>に渡された文字列と同じプロパティ値が、<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>または<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29>コンス トラクターをインスタンス化するときに、<xref:System.Resources.ResourceManager>インスタンス。  
  
   
  
## Examples  
 コンパイルし、次のユーティリティを実行して、埋め込みの .resources ファイルの名前を指定できます。 これは、メイン アセンブリまたはコマンド ライン パラメーターとしてのサテライト アセンブリの名前を指定するコンソール アプリです。 文字列として指定する必要がありますが表示されます、`baseName`のパラメーター、<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>または<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29>コンス トラクター、resource manager では、リソースを正しく特定できるようにします。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
 [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseNameField">
      <MemberSignature Language="C#" Value="protected string BaseNameField;" />
      <MemberSignature Language="ILAsm" Value=".field family string BaseNameField" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.BaseNameField" />
      <MemberSignature Language="VB.NET" Value="Protected BaseNameField As String " />
      <MemberSignature Language="C++ CLI" Value="protected: System::String ^ BaseNameField;" />
      <MemberSignature Language="F#" Value="val mutable BaseNameField : string" Usage="System.Resources.ResourceManager.BaseNameField" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Resources.ResourceManager" /> がリソースを検索するリソース ファイルのルート名を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.BaseNameField>フィールドはから派生した独自のクラスを記述する場合にのみ役立ちますが、<xref:System.Resources.ResourceManager>クラス。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateFileBasedResourceManager">
      <MemberSignature Language="C#" Value="public static System.Resources.ResourceManager CreateFileBasedResourceManager (string baseName, string resourceDir, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Resources.ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.CreateFileBasedResourceManager(System.String,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFileBasedResourceManager (baseName As String, resourceDir As String, usingResourceSet As Type) As ResourceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Resources::ResourceManager ^ CreateFileBasedResourceManager(System::String ^ baseName, System::String ^ resourceDir, Type ^ usingResourceSet);" />
      <MemberSignature Language="F#" Value="static member CreateFileBasedResourceManager : string * string * Type -&gt; System.Resources.ResourceManager" Usage="System.Resources.ResourceManager.CreateFileBasedResourceManager (baseName, resourceDir, usingResourceSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="resourceDir" Type="System.String" />
        <Parameter Name="usingResourceSet" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="baseName">リソースのルート名。 たとえば、"MyResource.en-US.resources" というリソース ファイルのルート名は "MyResource" です。</param>
        <param name="resourceDir">リソースを検索するディレクトリの名前。 <c>resourceDir</c> には、アプリケーション ディレクトリを基準とした相対パス、または絶対パスを指定できます。</param>
        <param name="usingResourceSet">使用するカスタム <see cref="T:System.Resources.ResourceSet" /> の種類。 <see langword="null" /> の場合は、既定のランタイム <see cref="T:System.Resources.ResourceSet" /> オブジェクトが使用されます。</param>
        <summary>リソースのアセンブリ マニフェストではなく特定のディレクトリを検索する <see cref="T:System.Resources.ResourceManager" /> オブジェクトを返します。</summary>
        <returns>リソースのアセンブリ マニフェストの代わりに指定されたディレクトリを検索する、リソース マネージャーの新しいインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アセンブリに埋め込まれていない .resources ファイルからリソースを取得するリソース マネージャーを返します。 これを使用することができます<xref:System.Resources.ResourceManager>ASP.NET ページのリソースを読み込むかをテストするオブジェクト、<xref:System.Resources.ResourceSet>実装します。  スタンドアロンの .resources ファイルからリソースを取得する例を参照してください、[のリソースの取得](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md)記事。  
  
 このメソッドを指定できます、<xref:System.Resources.ResourceSet>実装します。 特定したくない場合<xref:System.Resources.ResourceSet>実装では、カスタム リソース ファイル形式を使用することから派生する必要があります、<xref:System.Resources.ResourceSet>クラスでオーバーライド、<xref:System.Resources.ResourceSet.GetDefaultReader%2A>と<xref:System.Resources.ResourceSet.GetDefaultWriter%2A>メソッド、およびこのコンス トラクターにパスを入力します。  
  
> [!CAUTION]
>  によって明示的にリリースされるまで、リソースがロックされたままであるために、xcopy による配置では、ASP.NET アプリで、スタンドアロン .resources ファイルを使用して中断されます、<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>メソッド。 ASP.NET アプリケーションでリソースをデプロイする場合は、サテライト アセンブリに .resources ファイルをコンパイルします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseName" /> パラメーターまたは <paramref name="resourceDir" /> パラメーターが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="FallbackLocation">
      <MemberSignature Language="C#" Value="protected System.Resources.UltimateResourceFallbackLocation FallbackLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Resources.UltimateResourceFallbackLocation FallbackLocation" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.FallbackLocation" />
      <MemberSignature Language="VB.NET" Value="Protected Property FallbackLocation As UltimateResourceFallbackLocation" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Resources::UltimateResourceFallbackLocation FallbackLocation { System::Resources::UltimateResourceFallbackLocation get(); void set(System::Resources::UltimateResourceFallbackLocation value); };" />
      <MemberSignature Language="F#" Value="member this.FallbackLocation : System.Resources.UltimateResourceFallbackLocation with get, set" Usage="System.Resources.ResourceManager.FallbackLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.UltimateResourceFallbackLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既定のフォールバック リソースの取得元の場所を取得または設定します。</summary>
        <value>リソース マネージャーがフォールバック リソースを検索できる場所を指定する列挙値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.FallbackLocation%2A>プロパティは、独自のクラスから派生したを記述する場合にのみ役立ちますが、<xref:System.Resources.ResourceManager>クラス。  
  
 使用することができます、<xref:System.Resources.NeutralResourcesLanguageAttribute>アプリ用の既定のカルチャの検索場所、リソース マネージャーに通知する属性: (既定値) のメインのアセンブリまたはサテライト アセンブリ。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Resources.UltimateResourceFallbackLocation" />
        <altmember cref="T:System.Resources.NeutralResourcesLanguageAttribute" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
      </Docs>
    </Member>
    <Member MemberName="GetNeutralResourcesLanguage">
      <MemberSignature Language="C#" Value="protected static System.Globalization.CultureInfo GetNeutralResourcesLanguage (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Globalization.CultureInfo GetNeutralResourcesLanguage(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetNeutralResourcesLanguage(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetNeutralResourcesLanguage (a As Assembly) As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Globalization::CultureInfo ^ GetNeutralResourcesLanguage(System::Reflection::Assembly ^ a);" />
      <MemberSignature Language="F#" Value="static member GetNeutralResourcesLanguage : System.Reflection.Assembly -&gt; System.Globalization.CultureInfo" Usage="System.Resources.ResourceManager.GetNeutralResourcesLanguage a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="a">カルチャ固有の情報を返すアセンブリ。</param>
        <summary>指定したアセンブリで <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> 属性の値を取得して、メイン アセンブリの既定のリソースのカルチャ固有の情報を返します。</summary>
        <returns>見つかった場合は <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> 属性のカルチャ、それ以外の場合は、インバリアント カルチャ。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のカルチャの文字列以外の指定したリソースの値を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetObject : string -&gt; obj&#xA;override this.GetObject : string -&gt; obj" Usage="resourceManager.GetObject name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <summary>指定した文字列以外のリソースの値を返します。</summary>
        <returns>呼び出し元の現在のカルチャ用にローカライズされているリソースの値。 適切なリソース セットが存在するが、<paramref name="name" /> が見つからない場合、メソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetObject%2A>文字列以外のリソースを取得するメソッドを使用します。 などのプリミティブ データ型に属している値が含まれます<xref:System.Int32>または<xref:System.Double>、ビットマップ (など、<xref:System.Drawing.Bitmap?displayProperty=nameWithType>オブジェクト)、またはカスタム オブジェクトをシリアル化します。 通常、返されたオブジェクトをキャスト (c#) または (Visual Basic) で、適切な型のオブジェクトへの変換する必要があります。  
  
 定義されている現在のスレッドの UI カルチャの返されたリソースのローカライズ、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ。 リソースがそのカルチャのローカライズされていない場合、リソース マネージャーは適切なリソースの読み込みにフォールバック規則を使用します。 使用できるローカライズされたリソースのセットが見つからない場合、<xref:System.Resources.ResourceManager>既定のカルチャのリソースにフォールバックします。 既定のカルチャのリソース セットが見つからない場合、メソッドがスローされます、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリ内に存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 適切なリソースが設定という名前のリソースを見つけることができませんが、リソース マネージャーが読み込むことができる場合`name`、メソッドを返します`null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`リソースの名前を持つ大文字小文字が (既定値) または大文字小文字を区別します。  
  
> [!CAUTION]
>  このメソッドは、表示されているもの以外の例外をスローできます。 これが発生する理由の 1 つは、このメソッドを呼び出すメソッドが例外をスローするかどうかです。  たとえば、<xref:System.IO.FileLoadException>の配置またはサテライト アセンブリのインストール エラーが行われた場合、例外がスローされる<xref:System.Runtime.Serialization.SerializationException>型が逆シリアル化時に、ユーザー定義型がユーザー定義の例外をスローした場合、例外がスローされる可能性が。  
  
## <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 呼び出す場合、<xref:System.Resources.ResourceManager.GetObject%2A>メソッドを複数回、同じ`name`パラメーターでは、各呼び出しで同じオブジェクトへの参照を返すメソッドに依存しません。 これは、ため、<xref:System.Resources.ResourceManager.GetObject%2A>メソッドは、キャッシュで既存のリソース オブジェクトへの参照を返すか、リソースを再読み込みし、新しいリソース オブジェクトへの参照を返します。  
  
   
  
## Examples  
 次の例では、 <xref:System.Resources.ResourceManager.GetObject%28System.String%29> メソッドを使用して、カスタム オブジェクトを逆シリアル化します。 例では、UIElements.cs (場合は UIElements.vb Visual Basic を使用している場合) をという名前のソース コード ファイルが含まれていますという名前の次の構造を定義する`PersonTable`します。 この構造体は、ローカライズされたテーブル列名を表示する一般的なテーブル表示ルーチンでの使用を目的としています。 `PersonTable` 構造体は、 <xref:System.SerializableAttribute> 属性でマークされています。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#6](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example.cs#6)]
 [!code-vb[Conceptual.Resources.Retrieving#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#6)]  
  
 CreateResources.cs (Visual Basic の場合は CreateResources.vb) という名前のファイルに入っている次のコードは、UIResources.resx という名前の XML リソース ファイルを作成します。このリソース ファイルには、テーブルのタイトルに加えて、英語にローカライズされたアプリに関する情報を含む `PersonTable` オブジェクトが格納されます。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#7](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example1.cs#7)]
 [!code-vb[Conceptual.Resources.Retrieving#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#7)]  
  
 GetObject.cs (GetObject.vb) という名前のソース コード ファイルに含まれる次のコードは、リソースを取得し、コンソールに表示します。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#8](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example2.cs#8)]
 [!code-vb[Conceptual.Resources.Retrieving#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example2.vb#8)]  
  
 次のバッチ ファイルを実行することで、必要なリソース ファイルとアセンブリをビルドし、アプリケーションを実行することができます。 `/r` 構造体に関する情報にアクセスできるように、 `PersonTable` オプションを使用して Resgen.exe を指定し、UIElements.dll への参照を含める必要があります。 C# を使用している場合は、 `vbc` コンパイラ名を `csc`に置換し、 `.vb` 拡張子を `.cs`に置換します。  
  
```  
  
vbc /t:library UIElements.vb  
vbc CreateResources.vb /r:UIElements.dll  
CreateResources  
  
resgen UIResources.resx  /r:UIElements.dll  
vbc GetObject.vb /r:UIElements.dll /resource:UIResources.resources  
  
GetObject.exe  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるローカライズされたリソースのセットが見つからず、既定のカルチャ リソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String)" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetObject : string * System.Globalization.CultureInfo -&gt; obj&#xA;override this.GetObject : string * System.Globalization.CultureInfo -&gt; obj" Usage="resourceManager.GetObject (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <param name="culture">リソースのローカライズ対象のカルチャ。 リソースがこのカルチャにローカライズされていない場合、リソース マネージャーはフォールバック規則を使用して適切なリソースを探します。  
  
この値が <see langword="null" /> の場合、<see cref="P:System.Globalization.CultureInfo.CurrentUICulture" /> プロパティを使用して <see cref="T:System.Globalization.CultureInfo" /> オブジェクトが取得されます。</param>
        <summary>指定されたカルチャ用にローカライズされている指定された文字列以外のリソースの値を取得します。</summary>
        <returns>指定されたカルチャに合わせてローカライズされているリソースの値。 適切なリソース セットが存在するが、<paramref name="name" /> が見つからない場合、メソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>文字列以外のリソースを取得するメソッドを使用します。 などのプリミティブ データ型に属している値が含まれます<xref:System.Int32>または<xref:System.Double>、ビットマップ (など、<xref:System.Drawing.Bitmap?displayProperty=nameWithType>オブジェクト)、またはカスタム オブジェクトをシリアル化します。 通常、返されたオブジェクトをキャスト (c#) または (Visual Basic) で、適切な型のオブジェクトへの変換する必要があります。  
  
 指定されたカルチャ用に、返されたリソースがローカライズ`culture`、またはカルチャで指定されている、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ場合`culture`は`null`します。 リソースがそのカルチャのローカライズされていない場合、リソース マネージャーは適切なリソースの読み込みにフォールバック規則を使用します。 使用できるローカライズされたリソースのセットが見つからない場合、リソース マネージャーの既定のカルチャのリソースにフォールバックします。 既定のカルチャのリソース セットが見つからない場合、メソッドがスローされます、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリ内に存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 適切なリソースが設定という名前のリソースを見つけることができませんが、リソース マネージャーが読み込むことができる場合`name`、メソッドを返します`null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`リソースの名前を持つ大文字小文字が (既定値) または大文字小文字を区別します。  
  
> [!CAUTION]
>  このメソッドは、表示されているもの以外の例外をスローできます。 これが発生する理由の 1 つは、このメソッドを呼び出すメソッドが例外をスローするかどうかです。  たとえば、<xref:System.IO.FileLoadException>の配置またはサテライト アセンブリのインストール エラーが行われた場合、例外がスローされる<xref:System.Runtime.Serialization.SerializationException>型が逆シリアル化時に、ユーザー定義型がユーザー定義の例外をスローした場合、例外がスローされる可能性が。  
  
## <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 呼び出す場合、<xref:System.Resources.ResourceManager.GetObject%2A>メソッドを複数回、同じ`name`パラメーターでは、各呼び出しで同じオブジェクトへの参照を返すメソッドに依存しません。 これは、ため、<xref:System.Resources.ResourceManager.GetObject%2A>メソッドは、キャッシュで既存のリソース オブジェクトへの参照を返すか、リソースを再読み込みし、新しいリソース オブジェクトへの参照を返します。  
  
   
  
## Examples  
 次の例では、 <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドを使用して、カスタム オブジェクトを逆シリアル化します。 例では、NumberInfo.cs (NumberInfo.vb Visual Basic を使用している場合) をという名前のソース コード ファイルが含まれていますという名前の次の構造を定義する`Numbers`します。 この構造体がについて説明する英語以外には英語で 10 にカウントする単純な教育アプリで使用するためのものです。 なお、`Numbers`クラスには、<xref:System.SerializableAttribute>属性。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/numberinfo.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/numberinfo.vb#1)]  
  
 次のソース コードをファイルから名前付き CreateResources.cs (Visual Basic の場合は CreateResources.vb) は、既定の英語とフランス語、ポルトガル語、ロシア語の言語の XML リソース ファイルを作成します。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/createresources.cs#2)]
 [!code-vb[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/createresources.vb#2)]  
  
 リソースは、次のアプリは、現在の UI カルチャをフランス語 (フランス)、ポルトガル語 (ブラジル)、またはロシア語 (ロシア) に設定によって使用されます。 呼び出す、<xref:System.Resources.ResourceManager.GetObject%28System.String%29>を取得するメソッド、`Numbers`ローカライズされた数値を含むオブジェクトと<xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>を取得します、`Numbers`英語数字を含むオブジェクト。 現在の UI カルチャと英語の言語を使用して奇数の数値が表示されます。 ソース コード ファイルの名前は ShowNumbers.cs (ShowNumbers.vb)。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/shownumbers.cs#3)]
 [!code-vb[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/shownumbers.vb#3)]  
  
 ビルドの例では、Visual Basic バージョンを実行して、次のバッチ ファイルを使用できます。 C# を使用している場合は置き換えます`vbc`で`csc`と置換、`.vb`拡張機能を`.cs`します。  
  
```  
  
vbc /t:library NumberInfo.vb  
  
vbc CreateResources.vb /r:NumberInfo.dll  
CreateResources  
  
resgen NumberResources.resx /r:NumberInfo.dll  
  
resgen NumberResources.fr.resx /r:Numberinfo.dll  
Md fr  
al /embed:NumberResources.fr.resources /culture:fr /t:lib /out:fr\ShowNumbers.resources.dll  
  
resgen NumberResources.pt.resx  /r:Numberinfo.dll  
Md pt  
al /embed:NumberResources.pt.resources /culture:pt /t:lib /out:pt\ShowNumbers.resources.dll  
  
resgen NumberResources.ru.resx /r:Numberinfo.dll  
Md ru  
al /embed:NumberResources.ru.resources /culture:ru /t:lib /out:ru\ShowNumbers.resources.dll  
  
vbc ShowNumbers.vb /r:NumberInfo.dll /resource:NumberResources.resources  
ShowNumbers.exe  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからず、既定のカルチャ リソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <threadsafe>
          <see cref="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" />メソッドはスレッド セーフであります。</threadsafe>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
      </Docs>
    </Member>
    <Member MemberName="GetResourceFileName">
      <MemberSignature Language="C#" Value="protected virtual string GetResourceFileName (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetResourceFileName(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceFileName(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResourceFileName (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetResourceFileName(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetResourceFileName : System.Globalization.CultureInfo -&gt; string&#xA;override this.GetResourceFileName : System.Globalization.CultureInfo -&gt; string" Usage="resourceManager.GetResourceFileName culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">リソース ファイル名を構築する対象のカルチャ オブジェクト。</param>
        <summary>指定した <see cref="T:System.Globalization.CultureInfo" /> オブジェクトのリソース ファイルの名前を生成します。</summary>
        <returns>指定した <see cref="T:System.Globalization.CultureInfo" /> オブジェクトのリソース ファイルに使用できる名前。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetResourceFileName%2A>メソッドは、独自のクラスから派生したを記述する場合にのみ、<xref:System.Resources.ResourceManager>クラス。  
  
 このメソッドを使用して、<xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType>インバリアント カルチャ以外のすべてのカルチャのファイル名の一部としてプロパティ。 このメソッドは、アセンブリのマニフェストまたはタッチ、ディスクを検索しませんし、リソースのファイル名を作成する場合にのみ使用されます (に渡すに適した、<xref:System.Resources.ResourceReader>コンス トラクター) または blob のマニフェスト リソース名。  
  
 派生クラスが別の拡張機能など、検索するには、このメソッドをオーバーライドできます"。ResX"、またはリソース ファイルの名前付けするためのまったく異なるスキーム。 サテライト アセンブリ内のリソース ファイルの名前をカスタマイズし、サテライト アセンブリ自体の名前をカスタマイズするには、いないメソッドを使用できることに注意してください。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">.NET アプリケーションのグローバライズとローカライズ</related>
      </Docs>
    </Member>
    <Member MemberName="GetResourceSet">
      <MemberSignature Language="C#" Value="public virtual System.Resources.ResourceSet GetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Resources.ResourceSet GetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Resources::ResourceSet ^ GetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="F#" Value="abstract member GetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet&#xA;override this.GetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet" Usage="resourceManager.GetResourceSet (culture, createIfNotExists, tryParents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" />
        <Parameter Name="tryParents" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="culture">リソースが取得されるカルチャ。</param>
        <param name="createIfNotExists">リソース セットがまだ読み込まれていなければ読み込む場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="tryParents">リソース セットが見つからないときに、適切なリソースを読み込むためにリソース フォールバックを使用する場合は <see langword="true" />。リソース フォールバック プロセスをバイパスする場合は <see langword="false" />。</param>
        <summary>特定のカルチャのリソース セットを取得します。</summary>
        <returns>指定されたカルチャに設定されたリソース。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返されるリソース セットは、指定したカルチャにローカライズされたリソースを表します。 そのカルチャのリソースがローカライズされていない場合、`tryParents`は`true`、<xref:System.Resources.ResourceManager.GetResourceSet%2A>リソース フォールバック規則を使用して、適切なリソースを読み込めません。 場合`tryParents`は`false`、メソッドを返しますのカルチャに固有のリソース セットが見つからない`null`します。 リソース フォールバックの詳細については、「リソース フォールバック プロセス」セクションを参照して、 [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)記事。  
  
   
  
## Examples  
 次の例では、<xref:System.Resources.ResourceManager.GetResourceSet%2A>フランス語 (フランス) カルチャのカルチャに固有のリソースを取得します。 すべてのリソース セット内のリソースを列挙します。 実行可能ファイル ShowNumbers.exe という名前のソース コードが含まれています。 数値の名前を格納する次の 2 つのテキスト ファイルも含まれています。 まず、NumberResources.txt には、番号 1 から 10 まで英語での名前が含まれています。  
  
```  
  
one=one  
two=two  
three=three  
four=four  
five=five  
six=six  
seven=seven  
eight=eight  
nine=nine  
ten=ten  
  
```  
  
 2 つ目 NumberResources.fr ファイルに格納にはには、フランス語の言語で 4 つに 1 つの数字の名前が含まれています。  
  
```  
  
one=un  
two=deux  
three=trois  
four=quatre  
  
```  
  
 バッチ ファイルを使用して、リソース ファイルを生成し、英語の言語リソース ファイルを実行可能ファイルに埋め込む、フランス語の言語リソースのサテライト アセンブリを作成することができます。 Visual Baisc コンパイラを使用して、実行可能ファイルを生成するバッチ ファイルを次に示します。  
  
```  
  
resgen NumberResources.txt  
vbc shownumbers.vb /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
```  
  
 C# コンパイラでは、次のバッチ ファイルを使用できます。  
  
```  
  
resgen NumberResources.txt  
csc shownumbers.cs /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/cs/shownumbers.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/vb/shownumbers.vb#1)]  
  
 値を変更する場合、`createIfNotExists`引数`false`、メソッド呼び出しから制御`null`リソース マネージャーで、フランス語の言語リソースがまだロードされていないため、します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">
          <paramref name="tryParents" /> が <see langword="true" /> で、使用できるリソースのセットが見つからず、既定のカルチャ リソースもありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">.NET アプリケーションのグローバライズとローカライズ</related>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteContractVersion">
      <MemberSignature Language="C#" Value="protected static Version GetSatelliteContractVersion (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Version GetSatelliteContractVersion(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetSatelliteContractVersion(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetSatelliteContractVersion (a As Assembly) As Version" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static Version ^ GetSatelliteContractVersion(System::Reflection::Assembly ^ a);" />
      <MemberSignature Language="F#" Value="static member GetSatelliteContractVersion : System.Reflection.Assembly -&gt; Version" Usage="System.Resources.ResourceManager.GetSatelliteContractVersion a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="a">
          <see cref="T:System.Resources.SatelliteContractVersionAttribute" /> 属性を確認する対象のアセンブリ。</param>
        <summary>指定したアセンブリの <see cref="T:System.Resources.SatelliteContractVersionAttribute" /> 属性で指定されたバージョンを返します。</summary>
        <returns>指定したアセンブリのサテライト コントラクト バージョン。バージョンが見つからなかった場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サテライト アセンブリのバージョン管理の詳細については、次を参照してください。、<xref:System.Resources.SatelliteContractVersionAttribute>リファレンス トピック。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">アセンブリの <paramref name="a" /> で見つかった <see cref="T:System.Version" /> が無効です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="a" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStream">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したリソースからアンマネージ メモリ ストリーム オブジェクトを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetStream : string -&gt; System.IO.UnmanagedMemoryStream" Usage="resourceManager.GetStream name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">リソースの名前。</param>
        <summary>指定したリソースからアンマネージ メモリ ストリーム オブジェクトを返します。</summary>
        <returns>リソースを表すアンマネージ メモリ ストリーム オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetStream%2A>メソッドとして格納されているリソースの名前を受け取り、<xref:System.IO.MemoryStream>オブジェクトの値を取得、<xref:System.Object>リソース、および返します、<xref:System.IO.UnmanagedMemoryStream>オブジェクト。 オブジェクトに変換し、バイトのストリームを直接操作することが必要です。 このメソッドは主にパフォーマンス上の理由: リソースを取得するように、明示的なオブジェクトではなくバイト ストリームは、パフォーマンスを向上させることができます。  
  
 定義されている現在のスレッドの UI カルチャの返されたリソースのローカライズ、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ。 リソースがそのカルチャのローカライズされていない場合、リソース マネージャーは適切なリソースの読み込みにフォールバック規則を使用します。 使用できるローカライズされたリソースのセットが見つからない場合、<xref:System.Resources.ResourceManager>既定のカルチャのリソースにフォールバックします。 既定のカルチャのリソース セットが見つからない場合、メソッドがスローされます、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリ内に存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 適切なリソースが設定という名前のリソースを見つけることができませんが、リソース マネージャーが読み込むことができる場合`name`、メソッドを返します`null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`リソースの名前を持つ大文字小文字が (既定値) または大文字小文字を区別します。  
  
   
  
## Examples  
 次の例では、 <xref:System.Resources.ResourceManager.GetStream%28System.String%29> メソッドを使用して、アプリの開始スプラッシュ ウィンドウで使用されるビットマップを取得します。 次のソース コードという名前のファイルから CreateResources.cs (C# の場合) または CreateResources.vb (Visual Basic) にシリアル化されたイメージを含む AppResources.resx をという名前の .resx ファイルが生成されます。 この場合、画像は SplashScreen.jpg という名前のファイルから読み込まれます。ファイル名を変更して、独自の画像に置き換えることができます。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#4](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/createresources.cs#4)]
 [!code-vb[Conceptual.Resources.Retrieving#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/createresources.vb#4)]  
  
 次のコード (c#) の GetStream.cs をという名前のファイルまたは GetStream.vb (Visual Basic) のリソースを取得しでイメージを表示します、<xref:System.Windows.Forms.PictureBox?displayProperty=nameWithType>コントロール。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#5](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/getstream.cs#5)]
 [!code-vb[Conceptual.Resources.Retrieving#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/getstream.vb#5)]  
  
 次のバッチ ファイルを使用すると、C# の例をビルドできます。 Visual basic では、次のように変更します`csc`に`vbc`、からソース コード ファイルの拡張子を変更および`.cs`に`.vb`.。  
  
```  
  
csc CreateResources.cs  
CreateResources  
  
resgen AppResources.resx  
  
csc GetStream.cs /resource:AppResources.resources  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定されたリソースの値が <see cref="T:System.IO.MemoryStream" /> オブジェクトではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからず、既定のリソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String, culture As CultureInfo) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.GetStream : string * System.Globalization.CultureInfo -&gt; System.IO.UnmanagedMemoryStream" Usage="resourceManager.GetStream (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">リソースの名前。</param>
        <param name="culture">リソース検索に使用するカルチャを指定するオブジェクト。 <c>culture</c> が <see langword="null" /> の場合は、現在のスレッドのカルチャが使用されます。</param>
        <summary>指定したカルチャを使用し、指定したリソースからアンマネージ メモリ ストリーム オブジェクトを返します。</summary>
        <returns>リソースを表すアンマネージ メモリ ストリーム オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetStream%2A>メソッドとして格納されているリソースの名前を受け取り、<xref:System.IO.MemoryStream>オブジェクトの値を取得、<xref:System.Object>リソース、および返します、<xref:System.IO.UnmanagedMemoryStream>オブジェクト。 オブジェクトに変換し、バイトのストリームを直接操作することが必要です。 このメソッドは主にパフォーマンス上の理由: リソースを取得するように、明示的なオブジェクトではなくバイト ストリームは、パフォーマンスを向上させることができます。  
  
 指定されたカルチャ用に、返されたリソースがローカライズ`culture`、またはカルチャで指定されている、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ場合`culture`は`null`します。 リソースがそのカルチャのローカライズされていない場合、リソース マネージャーは適切なリソースの読み込みにフォールバック規則を使用します。 使用できるローカライズされたリソースのセットが見つからない場合、<xref:System.Resources.ResourceManager>既定のカルチャのリソースにフォールバックします。 既定のカルチャのリソース セットが見つからない場合、メソッドがスローされます、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリ内に存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 適切なリソースが設定という名前のリソースを見つけることができませんが、リソース マネージャーが読み込むことができる場合`name`、メソッドを返します`null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`リソースの名前を持つ大文字小文字が (既定値) または大文字小文字を区別します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定されたリソースの値が <see cref="T:System.IO.MemoryStream" /> オブジェクトではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからず、既定のリソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したカルチャまたは現在の UI カルチャの指定した文字列リソースを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetString : string -&gt; string&#xA;override this.GetString : string -&gt; string" Usage="resourceManager.GetString name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <summary>指定されている文字列リソースの値を返します。</summary>
        <returns>呼び出し元の現在の UI カルチャのためにローカライズされたリソースの値、または、リソース セットで <paramref name="name" /> が見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>デスクトップ アプリ  
 デスクトップ アプリは、返されるリソースが、現在のスレッドの UI カルチャのローカライズで定義されている、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ。 次の「リソース フォールバック プロセス」セクションに記載されている手順に従って、resource manager がプローブ リソースの場合は、そのカルチャのリソースがローカライズされておらず、、 [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)記事。 使用できるローカライズされたリソースのセットが見つからない場合、リソース マネージャーの既定のカルチャのリソースにフォールバックします。 メソッドがスローする場合は、リソース マネージャーは、既定のカルチャのリソース セットを読み込むことができません、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリ内に存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 適切なリソースが設定という名前のリソースを見つけることができませんが、リソース マネージャーが読み込むことができる場合`name`、メソッドを返します`null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`リソースの名前を持つ大文字小文字が (既定値) または大文字小文字を区別します。  
  
> [!CAUTION]
>  このメソッドは、表示されているもの以外の例外をスローできます。 これが発生する理由の 1 つは、このメソッドを呼び出すメソッドが例外をスローするかどうかです。  たとえば、<xref:System.IO.FileLoadException>の配置またはサテライト アセンブリのインストール エラーが行われた場合、例外がスローされる<xref:System.Runtime.Serialization.SerializationException>型が逆シリアル化時に、ユーザー定義型がユーザー定義の例外をスローした場合、例外がスローされる可能性が。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  ただし、<xref:System.Resources.ResourceManager>クラスではサポートされて[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ、その用途をようお勧めできません。 このクラスを使用して開発する場合にのみ[!INCLUDE[net_portable](~/includes/net-portable-md.md)]で使用できるプロジェクト[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ。 リソースを取得する[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]、アプリを使用して、 [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182)クラスの代わりにします。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ、<xref:System.Resources.ResourceManager.GetString%28System.String%29>メソッドの値を返します、`name`文字列リソース、呼び出し元の現在の UI カルチャ設定用にローカライズされています。 カルチャの一覧については、オペレーティング システムの推奨される UI 言語の一覧から派生します。 リソース マネージャーが一致しない場合`name`、メソッドを返します`null`します。  
  
   
  
## Examples  
 次の例では、<xref:System.Resources.ResourceManager.GetString%2A>カルチャに固有のリソースを取得します。 英語 (en)、フランス語 (フランス) (FR-FR)、およびロシア語 (ロシア) (RU-RU) の .txt ファイルからコンパイルされたリソースのカルチャ。 例は、英語 (米国)、フランス語 (フランス)、ロシア語 (ロシア)、およびスウェーデン語 (スウェーデン) を現在のカルチャと現在の UI カルチャを変更します。 呼び出して、<xref:System.Resources.ResourceManager.GetString%2A>メソッドをおよび現在の日付と月が表示されますが、ローカライズされた文字列を取得します。 スウェーデン語 (スウェーデン) が現在の UI カルチャの場合を除き、適切なローカライズされた文字列が表示に注意してください。 スウェーデン語の言語リソースが利用できないため、アプリは代わりに既定のカルチャは英語のリソースを使用します。 例では、次の表に記載されたテキスト ベースのリソース ファイルが必要です。 という名前の 1 つの文字列リソースを持つ各`DateStart`します。  
  
|culture|ファイル名|リソース名|リソースの値|  
|-------------|---------------|-------------------|--------------------|  
|en-US|DateStrings.txt|`DateStart`|今日が|  
|fr-FR|DateStrings.fr ファイルに格納|`DateStart`|Aujourd'hui、c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 次のバッチ ファイルを使用して、c# の例をコンパイルすることができます。 Visual Basic の場合は、 `csc` を `vbc`に変更し、さらにソース コード ファイルの拡張子を `.cs` から `.vb`に変更します。  
  
```  
resgen DateStrings.txt  
csc showdate.cs /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 次の例では、(Visual Basic バージョンの ShowDate.vb) または ShowDate.cs c# バージョンのソース コードに示します。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定されたリソースの値が文字列ではありません。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからず、既定のカルチャ用のリソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <threadsafe>
          <see cref="M:System.Resources.ResourceManager.GetString(System.String)" />メソッドはスレッド セーフであります。</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
        <related type="Article" href="https://msdn.microsoft.com/library/eca16922-1c46-4f68-aefe-e7a12283641f">サテライト アセンブリにリソースを取得します。</related>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetString : string * System.Globalization.CultureInfo -&gt; string&#xA;override this.GetString : string * System.Globalization.CultureInfo -&gt; string" Usage="resourceManager.GetString (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <param name="culture">リソースのローカライズ先のカルチャを表すオブジェクト。</param>
        <summary>指定したカルチャにローカライズされている文字列リソースの値を返します。</summary>
        <returns>指定されたカルチャのためにローカライズされたリソースの値、または、リソース セットで <paramref name="name" /> が見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>デスクトップ アプリ  
 デスクトップ アプリ場合`culture`は`null`、<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>メソッドから取得した現在の UI カルチャを使用して、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ。  
  
 返されるリソースがで指定されたカルチャのローカライズ、`culture`パラメーター。 リソースがローカライズされていない場合`culture`、リソースを次の「リソース フォールバック プロセス」セクションに記載されている手順に従って、リソース マネージャーは、プローブ、 [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)トピック。 使用できるリソースのセットが見つからない場合、リソース マネージャーの既定のカルチャのリソースにフォールバックします。 メソッドがスローする場合は、リソース マネージャーは、既定のカルチャのリソース セットを読み込むことができません、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリ内に存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 適切なリソースが設定という名前のリソースを見つけることができませんが、リソース マネージャーが読み込むことができる場合`name`、メソッドを返します`null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`リソースの名前を持つ大文字小文字が (既定値) または大文字小文字を区別します。  
  
> [!CAUTION]
>  このメソッドは、表示されているもの以外の例外をスローできます。 これが発生する理由の 1 つは、このメソッドを呼び出すメソッドが例外をスローするかどうかです。  たとえば、<xref:System.IO.FileLoadException>の配置またはサテライト アセンブリのインストール エラーが行われた場合、例外がスローされる<xref:System.Runtime.Serialization.SerializationException>型が逆シリアル化時に、ユーザー定義型がユーザー定義の例外をスローした場合、例外がスローされる可能性が。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  ただし、<xref:System.Resources.ResourceManager>クラスではサポートされて[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ、その用途をようお勧めできません。 このクラスを使用して開発する場合にのみ[!INCLUDE[net_portable](~/includes/net-portable-md.md)]で使用できるプロジェクト[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ。 リソースを取得する[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]、アプリを使用して、 [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182)クラスの代わりにします。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 、アプリ、<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>メソッドの値を返します、`name`文字列で指定されたカルチャのローカライズされたリソース、`culture`パラメーター。 リソースがローカライズされていない場合、`culture`全体を使用するカルチャ、ルックアップ[!INCLUDE[win8](~/includes/win8-md.md)]言語フォールバックのリスト、および既定のカルチャで検索した後を停止します。 リソース マネージャーが一致しない場合`name`、メソッドを返します`null`します。  
  
   
  
## Examples  
 次の例では、<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>カルチャに固有のリソースを取得します。 例の既定のカルチャが英語 (en) とフランス語 (フランス) (FR-FR)、ロシア語 (ロシア) (RU-RU) のサテライト アセンブリが含まれていますカルチャ。 例は、変更、現在のカルチャと UI カルチャを現在ロシア語 (ロシア) を呼び出す前に<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>します。 呼び出して、<xref:System.Resources.ResourceManager.GetString%2A>メソッドと<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッドを呼び出し<xref:System.Globalization.CultureInfo>各メソッドにフランス語 (フランス) とスウェーデン語 (スウェーデン) カルチャを表すオブジェクト。 出力では、月と日、月と同様に、その文字列のために表示、フランス語、<xref:System.Resources.ResourceManager.GetString%2A>メソッドは、フランス語の言語リソースを取得できません。 ただし、スウェーデン語 (スウェーデン) カルチャを使用したときに月と日、月の表示スウェーデン語では英語で入力して、その文字列が。 これは、します代わりに既定の英語カルチャのリソースを返すように、リソース マネージャーが、スウェーデン語のローカライズされたリソースを検出できないため。  
  
 例では、次の表に記載されたテキスト ベースのリソース ファイルが必要です。 という名前の 1 つの文字列リソースを持つ各`DateStart`します。  
  
|culture|ファイル名|リソース名|リソースの値|  
|-------------|---------------|-------------------|--------------------|  
|en-US|DateStrings.txt|`DateStart`|今日が|  
|fr-FR|DateStrings.fr ファイルに格納|`DateStart`|Aujourd'hui、c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 次のバッチ ファイルを使用して、Visual Basic の例をコンパイルすることができます。 C# でコンパイルする`vbc`に`csc`からソース コード ファイルの拡張子を変更および`.vb`に`.cs`。  
  
```  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 次の例では、(Visual Basic バージョンの ShowDate.vb) または ShowDate.cs c# バージョンのソース コードに示します。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate2.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定されたリソースの値が文字列ではありません。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからず、既定のカルチャ用のリソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <threadsafe>
          <see cref="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" />メソッドはスレッド セーフであります。</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
      </Docs>
    </Member>
    <Member MemberName="HeaderVersionNumber">
      <MemberSignature Language="C#" Value="public static readonly int HeaderVersionNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 HeaderVersionNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeaderVersionNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int HeaderVersionNumber;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeaderVersionNumber : int" Usage="System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Resources.ResourceManager" /> の現在の実装が解釈および作成できるリソース ファイル ヘッダーのバージョンを指定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreCase">
      <MemberSignature Language="C#" Value="public virtual bool IgnoreCase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreCase" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.IgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IgnoreCase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IgnoreCase { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreCase : bool with get, set" Usage="System.Resources.ResourceManager.IgnoreCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リソース マネージャーが <see cref="M:System.Resources.ResourceManager.GetString(System.String)" /> メソッドと <see cref="M:System.Resources.ResourceManager.GetObject(System.String)" /> メソッドで大文字と小文字を区別しないリソースの検索を許可しているかどうかを示す値を取得または設定します。</summary>
        <value>リソースの検索時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合の値、<xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティは`false`、「リソース」という名前のリソースが「リソース」という名前のリソースと同じです。 場合<xref:System.Resources.ResourceManager.IgnoreCase%2A>は`true`、「リソース」という名前のリソースは「リソース」という名前のリソースと同じです。 ただし、時に<xref:System.Resources.ResourceManager.IgnoreCase%2A>は`true`、<xref:System.Resources.ResourceManager.GetString%2A?displayProperty=nameWithType>と<xref:System.Resources.ResourceManager.GetObject%2A?displayProperty=nameWithType>メソッドは、インバリアント カルチャを使用して大文字の文字列比較を実行します。 利点は、これらのメソッドによって実行される大文字の文字列比較の結果が、カルチャに関係なくすべてのコンピューターで同じになることです。 欠点は、結果、すべてのカルチャの大文字小文字の規則と一致しないことです。  
  
 たとえば、トルコ語のアルファベットは、ドットで I の文字の 2 つのバージョンとドットのない 1 つがあります。 トルコ語では、文字 I (Unicode 0049) と見なされます ı (Unicode 0131) 別の文字の大文字バージョン。 文字 i (Unicode 0069) は、さらに別の文字 İ (Unicode 0130) の小文字のバージョンと見なされます。 大文字の文字列比較をこれらの大文字小文字の区別規則に従って文字 (Unicode 0069) を i と I (Unicode 0049) が"TR-TR"(七面鳥のトルコ語) のカルチャの失敗する必要があります。 ただし、インバリアント カルチャの大文字小文字の規則を使用して、比較が実行されるため、<xref:System.Resources.ResourceManager.IgnoreCase%2A>は`true`、この比較は成功します。  
  
> [!NOTE]
>  パフォーマンス上の理由は、常に、リソース名の大文字小文字が正しくを指定することをお勧めします。 設定<xref:System.Resources.ResourceManager.IgnoreCase%2A>に`true`ワーキング セットとパフォーマンスの大幅な低下の大幅な増加が発生することができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InternalGetResourceSet">
      <MemberSignature Language="C#" Value="protected virtual System.Resources.ResourceSet InternalGetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Resources.ResourceSet InternalGetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function InternalGetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Resources::ResourceSet ^ InternalGetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="F#" Value="abstract member InternalGetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet&#xA;override this.InternalGetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet" Usage="resourceManager.InternalGetResourceSet (culture, createIfNotExists, tryParents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" />
        <Parameter Name="tryParents" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="culture">検索対象のカルチャ オブジェクト。</param>
        <param name="createIfNotExists">リソース セットがまだ読み込まれていなければ読み込む場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="tryParents">リソース セットを読み込むことができないときに、親 <see cref="T:System.Globalization.CultureInfo" /> オブジェクトを確認する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>リソース セットを検索するための実装を提供します。</summary>
        <returns>指定されたリソース セット。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">メイン アセンブリに .resources ファイルが含まれていませんが、これはリソースの検索に必要です。</exception>
        <exception cref="T:System.ExecutionEngineException">ランタイムで、内部エラーが発生しました。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">
          <paramref name="culture" /> に関連付けられているサテライト アセンブリを配置できません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <block subset="none" type="overrides">
          <para>このメソッドは、リソースの設定、ありことは再帰的な再入を検索するために必要なすべての作業を完了します。 アセンブリとトリガーつまり、このメソッドを読み込む可能性があります、<see cref="E:System.AppDomain.AssemblyLoad" />にコールバックする、イベント、<see cref="T:System.Resources.ResourceManager" />オブジェクトを完全に初期化されていません。 過剰なロックを防ぐためにこのメソッドはスレッド セーフではありません。 <see cref="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />、 <see cref="M:System.Resources.ResourceManager.GetString(System.String)" />、および<see cref="M:System.Resources.ResourceManager.GetObject(System.String)" />メソッドは、必要なすべての同期を行います。</para>
        </block>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">.NET アプリケーションのグローバライズとローカライズ</related>
      </Docs>
    </Member>
    <Member MemberName="MagicNumber">
      <MemberSignature Language="C#" Value="public static readonly int MagicNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 MagicNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MagicNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MagicNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int MagicNumber;" />
      <MemberSignature Language="F#" Value=" staticval mutable MagicNumber : int" Usage="System.Resources.ResourceManager.MagicNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リソース ファイルを識別するために使用する番号を保持します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値は、0xBEEFCACE に設定されます。 システムの既定のファイル形式の最初の 4 バイトがリトル エンディアン形式の 32 ビット符号付き整数を含む (を参照してください<xref:System.Text.Encoding>)。  
  
 場合、<xref:System.Resources.ResourceManager.MagicNumber>が見つかると、それに続くバイトのバージョン番号になります、<xref:System.Resources.ResourceManager>と過去のこのヘッダーを取得するバイト数をスキップするかを示す番号が続くヘッダー。 次の番号は、のバージョンを示す、<xref:System.Resources.ResourceManager>バージョンについては後に、ヘッダーを作成します。  
  
 現在の実装のバージョン番号は、1 つです。 次のバイトは固定長の文字列の名前を含む、 <xref:System.Resources.IResourceReader>、このファイルの読み取りができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MainAssembly">
      <MemberSignature Language="C#" Value="protected System.Reflection.Assembly MainAssembly;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Reflection.Assembly MainAssembly" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MainAssembly" />
      <MemberSignature Language="VB.NET" Value="Protected MainAssembly As Assembly " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Reflection::Assembly ^ MainAssembly;" />
      <MemberSignature Language="F#" Value="val mutable MainAssembly : System.Reflection.Assembly" Usage="System.Resources.ResourceManager.MainAssembly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リソースを含むメイン アセンブリを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.MainAssembly>フィールドはから派生した独自のクラスを記述する場合にのみ役立ちますが、<xref:System.Resources.ResourceManager>クラス。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllResources">
      <MemberSignature Language="C#" Value="public virtual void ReleaseAllResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseAllResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.ReleaseAllResources" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReleaseAllResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseAllResources();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseAllResources : unit -&gt; unit&#xA;override this.ReleaseAllResources : unit -&gt; unit" Usage="resourceManager.ReleaseAllResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>リソース マネージャーに、すべての <see cref="T:System.Resources.ResourceSet" /> オブジェクトの <see cref="M:System.Resources.ResourceSet.Close" /> メソッドを呼び出し、すべてのリソースを解放するように指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、実行中のアプリのワーキング セットに縮小されます。 これで、将来のリソース検索<xref:System.Resources.ResourceManager>リソース マネージャーを検索する必要があるためにオブジェクトが最初の参照としてコストがかかるするリソースを再度読み込むとします。 これは、役立ちます、複雑なスレッド シナリオで、新しい<xref:System.Resources.ResourceManager>オブジェクトが適切な動作です。  
  
> [!NOTE]
>  .NET Framework バージョン 2.0 以降、<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>メソッドはスレッド セーフを<xref:System.Resources.ResourceManager.GetObject%2A>、 <xref:System.Resources.ResourceManager.GetString%2A>、および<xref:System.Resources.ResourceManager.GetStream%2A>操作。 この変更の利点は、リソースにアクセスする複数のスレッドのパフォーマンスの向上です。 ただし、呼び出した場合、<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>メソッド別のスレッドで同時に、リソースを取得中に 1 つのスレッドで、get 操作をスローできます、<xref:System.ObjectDisposedException>例外。  
  
 リソース マネージャーは完全にスコープ外に出るし、ガベージ コレクションが待機することがなく、確定的にリリースされる、現在のリソース マネージャーで作成したリソースの管理対象のインスタンスがない状況でこのメソッドを使用することもできます。  
  
> [!NOTE]
>  このメソッドを呼び出す場合、サテライト アセンブリはアンロードされません。 サテライト アセンブリをアンロードするには使用、<xref:System.AppDomain.Unload%2A>メソッド。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="ResourceSets">
      <MemberSignature Language="C#" Value="protected System.Collections.Hashtable ResourceSets;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Collections.Hashtable ResourceSets" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.ResourceSets" />
      <MemberSignature Language="VB.NET" Value="Protected ResourceSets As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Collections::Hashtable ^ ResourceSets;" />
      <MemberSignature Language="F#" Value="val mutable ResourceSets : System.Collections.Hashtable" Usage="System.Resources.ResourceManager.ResourceSets" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("call InternalGetResourceSet instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>カルチャから <see cref="T:System.Resources.ResourceSet" /> オブジェクトへの割り当てを返す <see cref="T:System.Collections.Hashtable" /> を格納します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResourceSetType">
      <MemberSignature Language="C#" Value="public virtual Type ResourceSetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ResourceSetType" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.ResourceSetType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ResourceSetType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ResourceSetType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ResourceSetType : Type" Usage="System.Resources.ResourceManager.ResourceSetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Resources.ResourceSet" /> オブジェクトの構築にリソース マネージャーが使用するリソース セット オブジェクトの型を取得します。</summary>
        <value>
          <see cref="T:System.Resources.ResourceSet" /> オブジェクトの構築にリソース マネージャーが使用するリソース セット オブジェクトの型。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>