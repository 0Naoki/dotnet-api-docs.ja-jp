<Type Name="IPlaybackControl" FullName="System.EnterpriseServices.IPlaybackControl">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f1d7e688218f9e4d155f0f11867ab1dd115b8742" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37655117" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IPlaybackControl" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IPlaybackControl" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.IPlaybackControl" />
  <TypeSignature Language="VB.NET" Value="Public Interface IPlaybackControl" />
  <TypeSignature Language="C++ CLI" Value="public interface class IPlaybackControl" />
  <TypeSignature Language="F#" Value="type IPlaybackControl = interface" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("51372AFD-CAE7-11CF-BE81-00AA00A2FA25")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.InterfaceType</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="29f5c-101">メッセージ キューの配信機構のサーバー側再生エラーおよびクライアント側エラーの異常処理において、キュー コンポーネント内で機能します。</span>
      <span class="sxs-lookup">
        <span data-stu-id="29f5c-101">Functions in Queued Components in the abnormal handling of server-side playback errors and client-side failures of the Message Queuing delivery mechanism.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="29f5c-102">両方を実装するコンポーネント、COM + カタログで定義されている例外クラス<xref:System.EnterpriseServices.IPlaybackControl>と、元のクラスのインターフェイス。</span><span class="sxs-lookup"><span data-stu-id="29f5c-102">The exception class defined for the component in the COM+ catalog implements both <xref:System.EnterpriseServices.IPlaybackControl> and the interface for the original class.</span></span> <span data-ttu-id="29f5c-103">元のクラス インターフェイスのメソッドの実装を使用して、クラス自体で障害が発生したメソッドの例外処理を実行できます。</span><span class="sxs-lookup"><span data-stu-id="29f5c-103">The method implementations of the original class interface are used to perform the exception handling for the failed methods in the class itself.</span></span> <span data-ttu-id="29f5c-104">後に呼び出される<xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A>または<xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A>を最初に呼び出されるメソッドの例外を処理します。</span><span class="sxs-lookup"><span data-stu-id="29f5c-104">They will be called after <xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A> or <xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A> to process exceptions for the method originally called.</span></span>  
  
 <span data-ttu-id="29f5c-105">メソッドを呼び出して、キュー コンポーネント プレーヤー<xref:System.EnterpriseServices.IPlaybackControl>を最終的な配置されている、または配信不能キューに配置するメッセージがある例外ハンドラー オブジェクトに通知します。</span><span class="sxs-lookup"><span data-stu-id="29f5c-105">The Queued Components Player calls the methods of <xref:System.EnterpriseServices.IPlaybackControl> to inform the exception-handler object that a message is about to be placed on the final resting or dead letter queue.</span></span> <span data-ttu-id="29f5c-106">キュー コンポーネント プレーヤーは、元のメソッド呼び出しで失敗した例外ハンドラー オブジェクトで、同じメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="29f5c-106">The Queued Components Player then calls the same method in the exception-handler object that had failed in the original method call.</span></span> <span data-ttu-id="29f5c-107">例外ハンドラー オブジェクトでは、問題の診断情報の収集など、オブジェクトまたはクライアントに、問題の通知メッセージを生成して、代わりをなど実装できます。</span><span class="sxs-lookup"><span data-stu-id="29f5c-107">The exception-handler object can implement an alternative, for example, by gathering problem diagnosis information or generating an object or message that informs the client of the problem.</span></span> <span data-ttu-id="29f5c-108">アプリケーションが実装していない場合<xref:System.EnterpriseServices.IPlaybackControl>、キュー コンポーネント プレーヤーのすべての再試行に達した場合、有害なメッセージが最終的な配置されている、または配信不能キューに配置されます。</span><span class="sxs-lookup"><span data-stu-id="29f5c-108">If the application does not implement <xref:System.EnterpriseServices.IPlaybackControl>, the poison message is placed on the final resting or dead letter queue when the Queued Components Player exhausts all retries.</span></span>  
  
 <span data-ttu-id="29f5c-109">有害メッセージは、サーバーまたはキュー システムの問題のため、何らかの理由で処理できないメッセージです。</span><span class="sxs-lookup"><span data-stu-id="29f5c-109">A poison message is a message that cannot be processed for some reason, perhaps because of a problem with the server or queuing system.</span></span> <span data-ttu-id="29f5c-110">トランザクションがロールバックされ、有害メッセージはキューの先頭にします。</span><span class="sxs-lookup"><span data-stu-id="29f5c-110">The transaction is rolled back, and the poison message goes to the top of the queue.</span></span> <span data-ttu-id="29f5c-111">メッセージが再度にデキューされると、同じ条件が発生します。</span><span class="sxs-lookup"><span data-stu-id="29f5c-111">When the message is dequeued again, the same condition occurs.</span></span> <span data-ttu-id="29f5c-112">このメッセージは、問題を修正するために何かがまで無限にループを続行できます。</span><span class="sxs-lookup"><span data-stu-id="29f5c-112">This message can continue looping indefinitely until something is done to correct the problem.</span></span> <span data-ttu-id="29f5c-113">キュー コンポーネント サービスは、一連の再試行を使用して、有害なメッセージを処理します。</span><span class="sxs-lookup"><span data-stu-id="29f5c-113">The Queued Components service handles the poison message by using a series of retries.</span></span> <span data-ttu-id="29f5c-114">いくつかの失敗した再試行の後、メッセージは、最後の静止キューに移動されます。</span><span class="sxs-lookup"><span data-stu-id="29f5c-114">After several unsuccessful retries, the message is moved to a final resting queue.</span></span> <span data-ttu-id="29f5c-115">有害メッセージ キューに置かれたコンポーネントのメッセージ移動ツールを使用して手動で移動するまでの静止キューに残ります。</span><span class="sxs-lookup"><span data-stu-id="29f5c-115">Poison messages remain in the resting queue until manually moved by using the Queued Components Message Mover tool.</span></span>  
  
 <span data-ttu-id="29f5c-116">有害メッセージのような状況も解決できるプログラムを使用して、<xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A>メソッドで、サーバー側コンポーネントの作成者の遅延アクティベーションを再生するすべての試行が失敗したことを通知します。</span><span class="sxs-lookup"><span data-stu-id="29f5c-116">The poison message situation can also be resolved programmatically, using the <xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A> method, which informs the server-side component author that all attempts to play back the deferred activation have failed.</span></span>  
  
 <span data-ttu-id="29f5c-117">有害メッセージを検出すると、問題の根本原因を迅速に解決できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="29f5c-117">If you discover a poison message, you might be able to solve the underlying cause of the problem quickly.</span></span> <span data-ttu-id="29f5c-118">たとえば、何らかの理由により、サーバーがオフラインで、サーバーをオンラインに戻すが開くことができます。</span><span class="sxs-lookup"><span data-stu-id="29f5c-118">For example, if the server was offline for some reason, you can bring the server back online.</span></span> <span data-ttu-id="29f5c-119">問題を迅速に解決することはできない場合、は、トランザクションが発生しなかったことを要求元に通知する別のトランザクションを自動的に生成できます。</span><span class="sxs-lookup"><span data-stu-id="29f5c-119">If you cannot solve the problem quickly, you can automatically generate another transaction that notifies the requestor that the transaction did not occur.</span></span> <span data-ttu-id="29f5c-120">リクエスターでは、既にコミットされているトランザクションの効果を反転する補正トランザクションを作成できます。</span><span class="sxs-lookup"><span data-stu-id="29f5c-120">The requestor can then make a compensating transaction that reverses the effect of a transaction that has already committed.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="FinalClientRetry">
      <MemberSignature Language="C#" Value="public void FinalClientRetry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FinalClientRetry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.IPlaybackControl.FinalClientRetry" />
      <MemberSignature Language="VB.NET" Value="Public Sub FinalClientRetry ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FinalClientRetry();" />
      <MemberSignature Language="F#" Value="abstract member FinalClientRetry : unit -&gt; unit" Usage="iPlaybackControl.FinalClientRetry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="29f5c-121">サーバーにメッセージを配信しようとするすべてのメッセージ キュー試行が拒否され、最終的にメッセージがクライアント側のトランザクション配信不能キューに置かれていることをクライアント側の例外処理コンポーネントに通知します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="29f5c-121">Informs the client-side exception-handling component that all Message Queuing attempts to deliver the message to the server were rejected, and the message ended up on the client-side Xact Dead Letter queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="29f5c-122">メッセージは、トランザクション配信不能キューに届いた、COM + は、この通知を配信するサーバー クラスに関連するクライアント側の例外ハンドラーを起動しようとします。</span><span class="sxs-lookup"><span data-stu-id="29f5c-122">As messages arrive in the Xact Dead Letter queue, COM+ attempts to invoke a client-side exception handler related to the server class to deliver this notification.</span></span> <span data-ttu-id="29f5c-123">これは最初の呼び出しによって<xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A>、例外ハンドラー オブジェクトで例外処理のバージョンの失敗したメソッドを呼び出してから。</span><span class="sxs-lookup"><span data-stu-id="29f5c-123">It does so by first calling <xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A>, then calling the exception-handling version of the failed method in the exception-handler object.</span></span> <span data-ttu-id="29f5c-124">この例外のメソッドは、エラーの記録、管理者にメール メッセージの送信またはクライアント側の補正アクション (以前のトランザクションの効果を反転) など、例外の操作を実行できます。</span><span class="sxs-lookup"><span data-stu-id="29f5c-124">This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction).</span></span> <span data-ttu-id="29f5c-125">例外のメソッドが成功しなかった場合メッセージはトランザクション配信不能キューに残ります。</span><span class="sxs-lookup"><span data-stu-id="29f5c-125">If the exception method is not successful, the message is left on the Xact Dead Letter queue.</span></span>  
  
 <span data-ttu-id="29f5c-126">トランザクション配信不能キューは、Microsoft メッセージ キュー (MSMQ) エクスプ ローラーで表示できます。</span><span class="sxs-lookup"><span data-stu-id="29f5c-126">The Xact Dead Letter queue can be viewed in the Microsoft Message Queue (MSMQ) Explorer.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FinalServerRetry">
      <MemberSignature Language="C#" Value="public void FinalServerRetry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FinalServerRetry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry" />
      <MemberSignature Language="VB.NET" Value="Public Sub FinalServerRetry ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FinalServerRetry();" />
      <MemberSignature Language="F#" Value="abstract member FinalServerRetry : unit -&gt; unit" Usage="iPlaybackControl.FinalServerRetry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="29f5c-127">サーバーへの遅延アクティベーションを再生しようとするすべての試行が失敗し、メッセージが最後の静止キューに移動されようとしていることをサーバー側の例外クラスの実装に通知します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="29f5c-127">Informs the server-side exception class implementation that all attempts to play back the deferred activation to the server have failed, and the message is about to be moved to its final resting queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="29f5c-128">メッセージは、トランザクション配信不能キューに到着、COM + は、この通知を配信するサーバー クラスに関連するサーバー側の例外ハンドラーを起動しようとします。</span><span class="sxs-lookup"><span data-stu-id="29f5c-128">As messages arrive on the Xact Dead Letter queue, COM+ attempts to invoke a server-side exception handler related to the server class to deliver this notification.</span></span> <span data-ttu-id="29f5c-129">これは最初の呼び出しによって<xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A>、例外処理のバージョンの障害が発生した例外ハンドラー オブジェクトでメソッドを呼び出してから。</span><span class="sxs-lookup"><span data-stu-id="29f5c-129">It does so by first calling <xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A>, then calling the exception handling version of the failed method in the exception handler object.</span></span> <span data-ttu-id="29f5c-130">この例外のメソッドは、エラーの記録、管理者にメール メッセージの送信またはクライアント側の補正アクション (以前のトランザクションの効果を反転) など、例外の操作を実行できます。</span><span class="sxs-lookup"><span data-stu-id="29f5c-130">This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction).</span></span> <span data-ttu-id="29f5c-131">サーバー オブジェクトは、このトランザクションを正常に完了するには、あらゆる努力をする必要があります。</span><span class="sxs-lookup"><span data-stu-id="29f5c-131">The server object should make every effort to complete this transaction successfully.</span></span> <span data-ttu-id="29f5c-132">それ以外の場合、メッセージを再処理するには、手動介入が必要です。</span><span class="sxs-lookup"><span data-stu-id="29f5c-132">Otherwise, manual intervention is required to reprocess the message.</span></span> <span data-ttu-id="29f5c-133">例外のメソッドが成功しなかった場合、メッセージは、最後の静止キューに移動されます。</span><span class="sxs-lookup"><span data-stu-id="29f5c-133">If the exception method is not successful, the message is moved to the final resting queue.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>